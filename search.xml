<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/undefined/%E5%BE%AE%E7%94%B5%E5%AD%90%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%9D%8A%20-%20%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h4 id="flexpaper-openOffice-SwfTools"><a href="#flexpaper-openOffice-SwfTools" class="headerlink" title="flexpaper + openOffice + SwfTools"></a>flexpaper + openOffice + SwfTools</h4><p>1.flexpaper 不支持中文路径，在fb编译器中二次编译之后不支持中文路径，采用数据库中英文路径与中文路径对应的方式解决。</p>
<p>2.在竞赛信息修改的时候，文件修改没有支持，后期加上</p>
<p>3.在系统设置里面加上每个设备的预约数量上限，以设备名称查找已预约设备数量。还有每个实验室的预约数量上限。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Spring%E6%8A%80%E6%9C%AF%E6%A0%88%E6%9E%84%E5%BB%BA%E5%89%8D%E5%90%8E%E5%8F%B0%E5%9B%A2%E8%B4%AD%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="Spring技术栈构建前后台团购网站"><a href="#Spring技术栈构建前后台团购网站" class="headerlink" title="Spring技术栈构建前后台团购网站"></a>Spring技术栈构建前后台团购网站</h2><h4 id="lombak插件"><a href="#lombak插件" class="headerlink" title="lombak插件"></a>lombak插件</h4><h4 id="分包发布（Web-Controller-Service-…）"><a href="#分包发布（Web-Controller-Service-…）" class="headerlink" title="分包发布（Web/Controller | Service/…）"></a>分包发布（Web/Controller | Service/…）</h4><h4 id="FreeMarker-Macro"><a href="#FreeMarker-Macro" class="headerlink" title="FreeMarker | Macro"></a>FreeMarker | Macro</h4><h4 id="Sitemesh"><a href="#Sitemesh" class="headerlink" title="Sitemesh"></a>Sitemesh</h4><h4 id="缓存（Redis）"><a href="#缓存（Redis）" class="headerlink" title="缓存（Redis）"></a>缓存（Redis）</h4><h4 id="Mybatis工具类"><a href="#Mybatis工具类" class="headerlink" title="Mybatis工具类"></a>Mybatis工具类</h4><h4 id="地区选择"><a href="#地区选择" class="headerlink" title="地区选择"></a>地区选择</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    <content><![CDATA[<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p>以太网前端有一个叫做前导码的部分（由0|1数字交替组合而成，表示一个以太网帧的开始）。</p>
<p>帧尾最后出现的是FCS，用它可以检测帧是否有损坏。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Java%20%E8%99%9A%E6%8B%9F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="Java-visulVM"><a href="#Java-visulVM" class="headerlink" title="Java visulVM"></a>Java visulVM</h2><p>这是一款Java自带的监控工具。</p>
<h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h2><p>[TOC]</p>
<h3 id="第十二章-Java内存模型与线程"><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h3><p>多任务处理的原因是因为CPU运算速度与计算机的存储、通信子系统的差距太大，大量的时间都花费在磁盘IO、网络通信以及数据库的访问上面。</p>
<p>衡量一个服务性能的高低好坏，每秒事务处理数（TPS）是最重要的指标之一，代表每秒内服务端平均能响应的请求总数。</p>
<h4 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h4><p>Java虚拟机规范中试图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p><strong>12.3.1 主内存与工作内存</strong><br></p>
<p>Java内存模型的主要目标就是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。</p>
<p><strong>12.3.2 内存间交互操作</strong><br></p>
<p>关于主内存与工作内存之间具体的交互协议，一个变量如何从主内存拷贝到工作内存，相反操作等，Java内存模型定义8种操作完成。</p>
<pre><code>1.lock（锁定）：作用于主内存变量。
2.unlock（解锁）：作用于主内存变量。
3.read（读取）：作用于主内存。
4.load（载入）：作用于工作内存变量。
...
</code></pre><p><strong>12.3.3 对于volatile型变量的特殊规则</strong><br></p>
<p>关键字volatile是Java虚拟机提供的最轻量级的同步机制，但是很多情况下程序员使用synchronized来进行同步。因为不理解的缘故。</p>
<p>当一个变量定义为volatile之后，其具备两种特性：</p>
<pre><code>1.保证此变量对所有线程的可见性，可见性表示当一个线程修改变量值的时候，其它线程立刻得知修改后的新值。
</code></pre><blockquote>
<p>提示：普通变量不能做到上面的，它需要通过主内存来完成。如果线程A修改一个普通变量的值，然后主内存进行回写，另外一个线程B在A完成回写之后再从主内存进行读取操作，新的变量才会对线程B可见。</p>
</blockquote>
<blockquote>
<p>提示：JMM实现让volatile修饰变量让其它内存立刻可见的思路在于：==当写一个volatile变量时，JMM会将该线程对应的工作内存中的共享变量值刷新到主内存中==，==当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量==。volatile变量正是通过这种写-读方式实现对其他线程可见（但其内存语义实现则是通过内存屏障）。</p>
</blockquote>
<blockquote>
<p>注意：volatitle变量在各个线程的工作内存中不存在一致性问题。Java里面运算不是原子操作，==导致volatitle变量的运算在并发下一样是不安全的==。</p>
</blockquote>
<pre><code>2.volatile禁止指令重排优化，由于 编译器和处理器 都能执行指令重排优化。普通变量仅仅能保证该方法在执行过程中得到正确的结果，但是不能保证程序代码的执行顺序。

如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。
总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。
</code></pre><blockquote>
<p>内存屏障(内存栅栏)：是一个CPU指令，作用有两个：1.保证特定操作的执行顺序。2.保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</p>
</blockquote>
<blockquote>
<p>提示：使用volatile的优势：在某些情况下，volatile同步机制的性能要优于锁（synchronized关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。volatile变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
</blockquote>
<blockquote>
<p>提示：指令重排序，指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应的电路单元处理，但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保证程序能得出正确的执行结果。</p>
</blockquote>
<p><strong>12.3.4 对于long和double型变量的特殊规则</strong><br></p>
<p>因为Java内存模型要求lock unlock read load assign use store write这8个操作都具有原子性，但是对于64位的数据类型（long和double）在模型中特定一条宽松的规定：允许虚拟机将没有被volatile修饰的 64位 数据的读写操作划分为 两次32位 的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定。</p>
<p>因为Java内存模型虽然允许不将long和double变量的读写实现成原子操作，但是允许虚拟机选择将这些操作实现为具有原子性的操作。</p>
<p><strong>12.3.5 原子性、可见性与有序性</strong><br></p>
<pre><code>1.原子性：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write；在synchronized块之间的操作也具备原子性。

2.可见性：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了volatile之外，Java还有synchronized和final关键字能实现可见性。

3.有序性：如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）。如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序现象和工作内存与主内存同步延迟）。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。
</code></pre><p><strong>12.3.6 先行发生原则</strong><br></p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>面是Java内存模型下一些天然的先行发生关系：</p>
<pre><code>程序次序规则

管程锁定规则

volatile变量规则

线程启动规则

线程终止规则

线程中断规则

对象终结规则

传递性
</code></pre><p>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
<h4 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h4><p><strong>12.4.1 线程的实现</strong><br></p>
<p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度。Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。</p>
<p>实现线程有三种方式：</p>
<pre><code>1.使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）。

2.使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）。

3.使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。）
</code></pre><p><strong>12.4.2 Java线程调度</strong><br></p>
<p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p>
<pre><code>1.协同式调度多线程系统：线程的执行时间由线程本身来控制，线程执行完之后要通过通知系统切换到另一个线程上。

    优势：实现简单。

2.抢占式线程调度：线程由系统来分配执行时间，线程的切换不由线程本身来决定。
</code></pre><p>Java线程优先级</p>
<pre><code>...
</code></pre><p><strong>12.4.3 状态转换</strong><br></p>
<p>Java语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。</p>
<h3 id="第十三章-线程安全与锁优化"><a href="#第十三章-线程安全与锁优化" class="headerlink" title="第十三章 线程安全与锁优化"></a>第十三章 线程安全与锁优化</h3><h4 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h4><h4 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h4><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
<p><strong>13.2.1 Java语言中的线程安全</strong><br></p>
<p>我们可以将Java语言中各种操作共享的数据分为5类：</p>
<pre><code>1.不可变：不可变带来的安全性是最简单和最纯粹的，如final的基本数据类型。如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如：String类的substring、replace方法。Number类型的大部分子类都符合不可变要求的类型，但是AtomicInteger和AtomicLong则并非不可变的。

2.绝对线程安全：Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。比如java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了。

3.相对线程安全：通常意义上所讲的线程安全就是相对相对线程安全，其需要保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要额外的保障措施，但对于特定顺序的连续调用需要额外的同步手段保证调用的正确性。

4.线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况。

5.线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java语言中很少出现。

    5.1 线程对立的例子：

        Thread类的suspend()方法和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程，如果并发进行的话无论调用是否进行同步，目标线程都会有死锁的风险。
</code></pre><p><strong>13.2.2 线程安全的实现方法</strong><br></p>
<p>虚拟机提供的同步和锁机制在线程安全中实现起到重要的作用。</p>
<pre><code>1.互斥同步（阻塞同步）

    同步：表示在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个或一些线程使用。

    互斥：是实现同步的一种手段，临界区 | 互斥量 | 信号量都是主要的互斥实现方法。
</code></pre><blockquote>
<p>提示：在Java中最基本的互斥同步手段就是 synchronized 关键字（该关键字经过编译之后生成了monitorenter和monitorexit两个字节码指令）。</p>
</blockquote>
<p>除了synchronized关键字之外，我们还能使用java.util.concurrent包的重入锁(ReentrantLock)来实现同步，在基本用法中，synchronized关键字和ReentrantLock很像。相比synchronized关键字ReentrantLock增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。</p>
<p>互斥同步属于一种悲观的并发策略，认为如果不做正确的同步措施就会发生问题，所以无论共享数据是否真的会出现竞争，其都要加锁。</p>
<pre><code>2.非阻塞同步

    互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略。

    随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步。

    Java并发包的整数原子类，其中的compareAndSet和getAndIncrement等方法都使用了Unsafe类的CAS操作。

3.无同步方案

    要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码。
</code></pre><h4 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h4><p><strong>13.3.1 自旋锁和自适应自旋</strong><br></p>
<p>互斥同步对性能最大的影响是阻塞的实现，挂起线程 和 恢复线程 的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。</p>
<p>另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<blockquote>
<p>提示：为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁。</p>
</blockquote>
<p>在JDK 1.6已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源。在JDK 1.6中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p><strong>13.3.2 锁消除</strong><br></p>
<p>锁清除表示虚拟机 即时编译器  在运行时对一些程序要求同步，但是被检测到不可能存在共享数据竞争的锁进行清除。</p>
<blockquote>
<p>提示：锁清除的判断依据来源于 逃逸分析 的数据支持(如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其它线程访问到，那就可以将它们当做栈上的数据处理，认为它们是线程私有化的，同步加锁自然无需进行)。</p>
</blockquote>
<p><strong>13.3.3 锁粗化</strong><br></p>
<p>原则上总是推荐将同步块的作用范围限制得尽量小，只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p><strong>13.3.4 轻量级锁</strong><br></p>
<p>它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot虚拟机的对象头分为两部分信息</p>
<pre><code>1.第1部分用于存储对象自身的运行时数据（如哈希码、GC分代年龄等），这部分称为mark word，是实现轻量级锁和偏向锁的关键。

2.第2部分用于存储指定方法区对象类型数据的指针。如果对象是数组，还会有一个部分存储数据的长度。
</code></pre><p><strong>13.3.5 偏向锁</strong><br></p>
<p>偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能（在没有实际竞争的情况下，还能够针对部分场景继续优化）。</p>
<p>如果不仅仅没有竞争，自始至终使用锁的线程都只有一个，那么维护轻量级锁都是浪费的。偏向锁的目的是：减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗，轻量级锁每次申请 | 释放锁都至少需要一次 CAS，但是偏向锁只有初始化时需要使用一次CAS。</p>
<p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下将整个同步都消除掉，连CAS操作都不做。</p>
<p>偏向锁表示会偏向第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其它线程获取，那持有偏向锁的线程将永远不需要再进行同步。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%B5%B0%E8%BF%91Java/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><p>[TOC]</p>
<h3 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h3><p>程序编译的结果从本地机器码转变为字节码。</p>
<blockquote>
<p>提示：实现语言无关性的基础仍然是虚拟机和字节码存储格式。Class文件中包含了Java虚拟机指令集和符号表以及若干其它辅助信息。</p>
</blockquote>
<h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p>将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p>
<h4 id="6-2-无关性基石"><a href="#6-2-无关性基石" class="headerlink" title="6.2 无关性基石"></a>6.2 无关性基石</h4><pre><code>1.Java刚诞生的口号：一次编写，到处运行（Write Once, Run Anywhere）。

2.实现虚拟机的语言无关性的基础是虚拟机和字节码存储格式，Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成Class文件，从而在虚拟机上运行。
</code></pre><h4 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3 Class类文件的结构"></a>6.3 Class类文件的结构</h4><blockquote>
<p>注意：任何一个Class文件都对应着唯一一个类或接口的定义信息。但相反地，类或接口并不一定都得定义在文件里（比如类或接口也可以通过类加载器直接生成）。</p>
</blockquote>
<p>Class文件是以一组8位字节为基础单位的二进制流，中间没有分隔符。</p>
<p>Class文件中字节序为Big-Endian，最高位字节在地址最低位、最低位字节在地址最高位<br>Class文件中只有2种数据类型：无符号数和表。</p>
<pre><code>1.无符号数：属于基本类型。

2.表：是由多个无符号数或者其它表作为数据项构成的复合数据类型。
</code></pre><blockquote>
<p>提示：无论是无符号数还是表，当需要描述同一类型但数量不定的多个线程时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式。这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
</blockquote>
<blockquote>
<p>提示：Class的结构被完全限定的，不能有任何违背官方规定的操作。</p>
</blockquote>
<p><strong>6.3.1 魔数和Class文件版本</strong><br></p>
<p>每个Class文件的头四个字节称为魔数，用于确定这个文件是否为一个能被虚拟机接受的Class文件。紧接着魔数的4个字节存储的是Class文件的版本号，分为次版本号和主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后的版本的Class文件。</p>
<p><strong>6.3.2 常量池</strong><br></p>
<p>常量池在主次版本之后，可以理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型。常量池的容量计数是从1开始的，0用于描述“不引用任何一个常量池项目”。</p>
<p>常量池中主要存放两大类常量：字面量和符号引用。</p>
<pre><code>1.字面量：接近Java的常量概念。如：文本字符串 | 声明为final的常量值等。

2.符号引用：符号则引用则属于编译原理方面概念。包括：

    2.1 类和接口的全限定名
    2.2 字段的名称和描述符
    2.3 方法的名称和描述符
</code></pre><p>常量池中每一项常量都是一个表，JDK1.7中一共有14种常量类型。</p>
<pre><code>...
</code></pre><p><strong>6.3.3 访问标志</strong><br>        </p>
<p>访问标志用于标示一些类或接口的访问信息，如Class是类还是接口，是否是public，是否定义完为abstract等。如果是类的话，是否被声明为final等。</p>
<p><strong>6.3.4 类索引、父类索引和接口索引集合</strong><br></p>
<p>这三项用于确定类的继承关系，类索引用于确定类的全限定名。父类索引用于确定类的父类的全限定名。接口索引集合用来描述类实现了哪些接口，并按照implements语句的顺序排列。</p>
<p><strong>6.3.5 字段表集合</strong><br></p>
<p>字段表用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量，但是不包括在方法内部声明的局部变量。</p>
<p>字段包括字段修饰符（用标志位描述，和类的访问标志类似），字段的简单名称，字段和方法的描述符以及属性表集合。</p>
<pre><code>1.简单名称是指没有类型和参数修饰的方法或者字段名称。

2.描述符用于描述字段的数据类型，方法的参数列表和返回值。

3.全限定名。如：类的全限定名
</code></pre><p>字段表集合不会列出从超类或父接口中继承而来的字段，但可能列出原本Java程序中不存在的字段，如：内部类指向外部类的实例的字段。</p>
<p><strong>6.3.6 方法表集合</strong><br></p>
<p>方法表集合和字段表集合类似，包括了方法的访问标志、名称索引、描述符索引和属性表集合<br>方法里的Java代码通过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p>
<p>如果父类的方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。但有可能会出现由编译器自动添加的方法，如类构造器“<clinit>”方法和实例构造器“<init>”方法。</init></clinit></p>
<p>Java语言中要重载一个方法，除了要有相同的简单名称之外，还要求必须有与原方法不同的特征签名。特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合。由于返回值不包含在特征签名中，所以Java语言里无法仅仅依靠返回值不同来对已有的方法进行重载。</p>
<p><strong>6.3.7 属性表集合</strong><br></p>
<p>属性表不要求具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略不认识的属性</p>
<p>1.Code属性</p>
<pre><code>Java程序方法体中的代码通过编译器编译成字节码指令后存储在Code属性内
max_stack代表了操作数栈深度的最大值，虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。
</code></pre><blockquote>
<p>提示：Slot是虚拟机为局部变量分配内存所使用的最小单位，局部变量表中的Slot可以重用<br>虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令。</p>
</blockquote>
<pre><code>通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。这样就实现了在任何实例方法里面都能通过this关键字访问到此方法所属的对象。

异常表是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。
</code></pre><p>2.Exceptions属性</p>
<pre><code>Exceptions属性的作用是列举出方法描述时在throws关键字后面列举的异常。
</code></pre><p>3.LineNumberTable属性</p>
<pre><code>用于描述Java源码行号和字节码行号(字节码的偏移量)之间的对应关系。
</code></pre><p>可以在Javac中分别使用-g:none和-g:lines来取消或要求生成这项信息；如果关闭，当抛出异常时，堆栈中将不会显示出错的行号。</p>
<p>4.LocalVariableTable属性</p>
<pre><code>描述栈帧中局部变量中的变量与Java源码中定义的变量之间的关系。
</code></pre><p>可以在Javac中分别使用-g:none和-g:vars来取消或要求生成这项信息。如果关闭，所有参数的名称都将消失，IDE将会使用诸如arg0、arg1之类的占位符代替原油的参数名。</p>
<p>5.ConstantValue属性</p>
<pre><code>用于通知虚拟机自动为静态变量赋值，只有类变量(被static关键字修饰的变量)才可以使用这项属性。
</code></pre><p>虚拟机对非static类型的变量的赋值是在实例构造器<init>方法中进行；而对于类变量则有2种方式，在类构造器<clinit>方法中或者使用ConstantValue属性。</clinit></init></p>
<blockquote>
<p>提示：ConstantValue属性值只能限于基本类型和String。</p>
</blockquote>
<p>6.Signure属性</p>
<pre><code>用于记录泛型签名中包含类型变量或参数化类型的类、接口、初始化方法或成员的泛型签名信息。
</code></pre><p>Java语言的泛型采用的是擦除法实现的伪泛型，在字节码(code属性)中，泛型信息编译(类型变量、参数化类型)之后都通通被擦除掉。</p>
<blockquote>
<p>提示：Java的反射API获取的泛型类型的最终数据源就是来自Signure属性。</p>
</blockquote>
<h4 id="6-4-字节码指令"><a href="#6-4-字节码指令" class="headerlink" title="6.4 字节码指令"></a>6.4 字节码指令</h4><p>Java采用面向操作数栈而不是寄存器的架构。</p>
<p>字节码指令集由于限制了虚拟机操作码的长度为一个字节，所以指令集的字节码总数不可能超过256条。</p>
<p>编译器在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型的数据，将boolean和char类型的数据零扩展为相应的int类型数据。</p>
<p>虚拟机规范规定在处理整型数据时，只有除法指令和求余指令中当出现除数为零时会导致虚拟机抛出ArithmeticException异常。</p>
<p>Java虚拟机在进行浮点数运算时会采用最接近数舍入模式，把浮点数转换整数时，Java虚拟机使用IEEE 754标准的向零舍入模式；多疑浮点数运算不能用于精确计算。</p>
<p>Java虚拟机处理浮点数运算时，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作没有明确的数学定义的话，将会使用NaN表示。所有使用NaN值作为操作数的算法操作，结果都会返回NaN。</p>
<p>在对long类型的数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较采用无信号比较方式。</p>
<p>Java虚拟机直接支持小范围类型向大范围类型的安全转换，比如int到float，而处理窄化类型转化可能会导致结果产生不同的正负号、不同数量级的情况，很可能会导致数值的精度丢失。</p>
<p>Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出的运行时异常<br>各种数据类型的比较最后都会转化为int类型的比较操作。</p>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，2种同步结构都是使用管程(Monitor)来支持。Java虚拟机的指令集中有 monitorenter 和 monitorexit 2条指令来支持synchronized关键字的语义。</p>
<h3 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h3><p>虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机最直接使用的Java类型的过程就是虚拟机的类加载机制。</p>
<h4 id="7-1-类加载特性"><a href="#7-1-类加载特性" class="headerlink" title="7.1 类加载特性"></a>7.1 类加载特性</h4><p>在Java中，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提高灵活性，Java中天生可以动态扩展语言特性就是依赖运行期动态加载和动态连接实现。</p>
<h4 id="7-2-类加载过程"><a href="#7-2-类加载过程" class="headerlink" title="7.2 类加载过程"></a>7.2 类加载过程</h4><p>类的加载过程，从类被加载到虚拟机内存开始，到卸载出内存为止，其整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。</p>
<p><strong>7.2.1 加载</strong><br></p>
<p>加载是类加载过程的一个阶段，在加载阶段需要完成：</p>
<pre><code>1.通过一个类的全限定名来获取定义此类的二进制字节流。

2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据接口。

3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
</code></pre><p><strong>7.2.2 验证</strong><br></p>
<p>验证是连接阶段的第一步，这一阶段的主要目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。</p>
<p>从整体上看，验证阶段大致上会完成4个阶段的校验工作：文件格式、元数据、字节码、符号引用。</p>
<p>1.文件格式验证</p>
<pre><code>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
</code></pre><p>可能包括的验证点：1.是否以魔数0xCAFEBABE开头。2.主次版本号是否在当前虚拟机处理范围之内。3.常量池的常量中是否有不被支持的常量类型。4.指向常量的各种索引值中是否有指向不存在常量或不符合类型的常量。5. …</p>
<p>2.元数据验证</p>
<pre><code>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。
</code></pre><p>可能包括验证点：1.这个类是否有父类。2.这个类的父类是否继承了不允许被继承的类。3. …</p>
<p>3.字节码验证</p>
<pre><code>该阶段的验证主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。在第二阶段对元数据信息中的数据类型做完检查之后，这个阶段将对类的方法进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
</code></pre><p>4.符号引用验证</p>
<pre><code>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。
</code></pre><p>可能验证的内容有：1.符号引用中通过字符串描述的全限定名是否能找到对应的类。2.在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段。…</p>
<p><strong>7.2.3 准备</strong><br></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值阶段，变量所使用的内存都将在方法区中进行分配。</p>
<blockquote>
<p>提示：此时进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将在对象实例化时随着对象一起分配在Java堆中。</p>
</blockquote>
<p><strong>7.2.4 解析</strong><br></p>
<p>该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用和直接引用的关联：</p>
<p>1.概念</p>
<pre><code>1. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

2. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。
</code></pre><blockquote>
<p>注意：虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前采取解析。</p>
</blockquote>
<p>2.对解析结果进行缓存</p>
<p>同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功。同样的，如果第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p>
<p>3.解析动作的目标</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限制符7类符号引用进行。前面四种引用的解析过程，对于后面三种，与JDK1.7新增的动态语言支持息息相关，由于java语言是一门静态类型语言，因此没有介绍invokedynamic指令的语义之前，没有办法将他们和现在的java语言对应上。</p>
<p><strong>7.2.5 初始化</strong><br></p>
<p>类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码（或者说是字节码）。</p>
<h4 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h4><p>类加载器，表示将“通过一个类的全限定名来获取描述此类的二进制字节流”动作放在Java虚拟机外面去实现，从而使得应用程序能够自己觉得如何获取所需要的类。</p>
<p><strong>7.4.1 类与类加载器</strong><br></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p>
<p><strong>7.4.2 类加载器</strong><br></p>
<p>从Java虚拟机的角度分为两种不同的类加载器：启动类加载器（Bootstrap ClassLoader）和其他类加载器。</p>
<pre><code>1.启动类加载器，使用C++语言实现，是虚拟机自身的一部分。

2.其余的类加载器都由Java语言实现，独立于虚拟机之外，并且全都继承自java.lang.ClassLoader类。（这里只限于HotSpot虚拟机）。
</code></pre><p>从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p>
<p>1.启动类加载器（Bootstrap ClassLoader）</p>
<p>这个类加载器负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</p>
<p>2.扩展类加载器（Extension ClassLoader）</p>
<p>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p>3.应用程序类加载器（Application ClassLoader）</p>
<p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>
<p><strong>7.4.3 双亲委派机制</strong><br></p>
<p>双亲委派机制模型：要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。</p>
<blockquote>
<p>双亲委派模型的工作过程：1.如果一个类加载器收到了类加载的请求，先将这个请求委派给父类加载器去完成（所以所有的加载请求最终都会传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</p>
</blockquote>
<p>使用双亲委派模型来组织类加载器之间的关系，显而易见的优势：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p><strong>7.4.4 破坏双亲委派模型</strong><br></p>
<p>1.第一次被破坏</p>
<p>1.第二次被破坏</p>
<p>1.第三次被破坏</p>
<h3 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h3><h4 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h4><p>==执行引擎是Java虚拟机最核心的组成部件之一==。虚拟机的执行引擎由自己实现，所以可以自行定制指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<p>从外观上看，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本节将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p>
<h4 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h4><p>栈帧是用于==支持虚拟机方法调用和方法执行的数据结构==，它是虚拟机运行时数据区中虚拟机栈的栈元素。</p>
<p>栈帧存储了方法的==局部变量表、操作数栈、动态连接和方法返回地址==等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<blockquote>
<p>提示：执行引擎运行所有字节码指令都只针对当前栈帧进行操作。</p>
</blockquote>
<p><strong>8.2.1 局部变量表</strong><br></p>
<p>局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表的容量以变量槽（Variable Slot）为最小单位。 一个Slot可以存放一个32位以内（boolean、byte、char、short、int、float、reference和returnAddress）的数据类型，reference类型表示一个对象实例的引用，returnAddress已经很少见了，可以忽略。</p>
<p>对于64位的数据类型（Java语言中明确的64位数据类型只有long和double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>虚拟机通过==索引定位的方式使用局部变量表==，索引值的范围从0开始至局部变量表最大的Slot数量。访问的是32位数据类型的变量，索引n就代表了使用第n个Slot,==如果是64位数据类型，就代表会同时使用n和n+1这两个Slot==。</p>
<p>为了节省栈帧空间，局部变量Slot可以重用，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。如果当前字节码PC计数器的值超出了某个变量的作用域，那么这个变量的Slot就可以交给其他变量使用。这样的设计会带来一些额外的副作用，比如：在某些情况下，Slot的复用会直接影响到系统的收集行为。</p>
<p><strong>8.2.2 操作数栈</strong><br></p>
<p>操作数栈又称为操作栈，它是一个后入先出栈。当一个方法执行开始时，这个方法的操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是 出栈/入栈操作。</p>
<p>在概念模型中，一个活动线程中两个栈帧是相互独立的。但大多数虚拟机实现都会做一些优化处理：让下一个栈帧的部分操作数栈与上一个栈帧的部分局部变量表重叠在一起，这样的好处是方法调用时可以共享一部分数据，而无须进行额外的参数复制传递。</p>
<p><strong>8.2.3 动态连接</strong><br></p>
<p>每个==栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用==，持有这个引用是为了支持方法调用过程中的动态连接；</p>
<p>字节码中方法调用指令是以常量池中的指向方法的符号引用为参数的，有一部分符号引用会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为 静态解析，另外一部分在每次的运行期间转化为直接引用，这部分称为动态连接。</p>
<p><strong>8.2.4 方法返回地址</strong><br></p>
<p>当一个方法执行之后，只有两种方式可以退出这个方法。</p>
<pre><code>1.执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。

2.另外一种是在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理（即本方法异常处理表中没有匹配的异常处理器），就会导致方法退出，这种退出方式称为异常完成出口。
</code></pre><blockquote>
<p>注意：这种退出方式不会给上层调用者产生任何返回值。</p>
</blockquote>
<p><code>无论采用何种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行</code>，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p>
<p>一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<p><strong>8.2.5 附加信息</strong><br></p>
<p>虚拟机规范允许虚拟机实现向栈帧中添加一些自定义的附加信息，例如与调试相关的信息等。</p>
<h4 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h4><p>方法调用并不等同于方法的执行，方法调用阶段唯一的任务就是确定被调用方法的版本(调用哪一个方法)，不涉及方法内部的具体运行过程，在程序运行时进行方法调用是最普遍频繁的操作。</p>
<blockquote>
<p>提示：Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。</p>
</blockquote>
<p><strong>8.3.1 解析</strong><br></p>
<p>“编译期可知，运行期不可变”的方法（静态方法和私有方法），在类加载的解析阶段，会将其符号引用转化为直接引用（入口地址）。这类方法的调用称为“解析（Resolution）”。</p>
<p>在Java虚拟机中提供了5条方法调用字节码指令：</p>
<pre><code>1.invokestatic:调用静态方法

2.invokespecial:调用实例构造器方法、私有方法、父类方法

3.invokevirtual:调用所有的虚方法

4.invokeinterface:调用接口方法，会在运行时在确定一个实现此接口的对象

5.invokedynamic:先在运行时动态解析出点限定符所引用的方法，然后再执行该方法，在此之前的4条调用命令的分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
</code></pre><p><strong>8.3.2 分派</strong><br></p>
<p>分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟中是如何实现的。</p>
<p>1.静态分派</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派发生在编译阶段。静态分派最典型的应用就是方法重载。</p>
<pre><code>package Demo.controller;

public class staticDispatch {
    static abstract class Human{}

    static class man extends Human{}

    static class woman extends Human{}

    public void sayhello(Human guy){
        System.out.println(&quot;human guy&quot;);
    }

    public void sayhello(man guy){
        System.out.println(&quot;man guy&quot;);
    }

    public void sayhello(woman guy){
        System.out.println(&quot;woman guy&quot;);
    }

    public static void main(String[] args) {
        Human man = new man();
        Human woman = new woman();
        staticDispatch staticDispatch = new staticDispatch();
        staticDispatch.sayhello(man);

        staticDispatch.sayhello(woman);
    }
}
</code></pre><blockquote>
<p>总结：Human man = new Man();其中的Human称为变量的静态类型，man称为变量的实际类型。那么两者的区别在于：静态类型在编译期可知，而实际类型到运行期才能确定。在重载时通过参数的静态类型而不是实际类型作为判定依据，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。</p>
</blockquote>
<p>所以选择了sayhello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p>
<p>2.动态分派</p>
<p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。最典型的应用就是方法重写。</p>
<p>3.单分派和多分派</p>
<p>方法的接收者、方法的参数都可以称为方法的宗量。根据分批基于多少种宗量，可以将分派划分为单分派和多分派。单分派是根据一个宗量对目标方法进行选择的，多分派是根据多于一个的宗量对目标方法进行选择的。</p>
<p>Java在进行静态分派时，选择目标方法要依据两点：一是变量的静态类型是哪个类型，二是方法参数是什么类型。因为要根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
<p>运行时阶段的动态分派过程，由于编译器已经确定了目标方法的签名（包括方法参数），运行时虚拟机只需要确定方法的接收者的实际类型，就可以分派。因为是根据一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<blockquote>
<p>注：到JDK1.7时，Java语言还是静态多分派、动态单分派的语言，未来有可能支持动态多分派。</p>
</blockquote>
<p>4.虚拟机动态分派的实现</p>
<p>由于动态分派是非常频繁的动作，而动态分派在方法版本选择过程中又需要在方法元数据中搜索合适的目标方法，虚拟机实现出于性能的考虑，通常不直接进行如此频繁的搜索，而是采用优化方法。</p>
<p>其中一种“稳定优化”手段是：在类的方法区中建立一个虚方法表（Virtual Method Table, 也称vtable, 与此对应，也存在接口方法表——Interface Method Table，也称itable）。使用虚方法表索引来代替元数据查找以提高性能。其原理与C++的虚函数表类似。</p>
<p>虚方法表中存放的是各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类中该方法相同，都指向父类的实现入口。虚方法表一般在类加载的连接阶段进行初始化。</p>
<p><strong>8.3.3 动态类型语言支持</strong><br></p>
<p>JDK新增加了invokedynamic指令来是实现“动态类型语言”。</p>
<p>静态语言和动态语言的区别：</p>
<pre><code>静态语言（强类型语言）： 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。  例如：C++、Java、Delphi、C#等。

动态语言（弱类型语言） ： 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。  例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

强类型定义语言 ： 强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。

弱类型定义语言 ： 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
</code></pre><h4 id="8-4-基于栈的字节码解释执行引擎"><a href="#8-4-基于栈的字节码解释执行引擎" class="headerlink" title="8.4 基于栈的字节码解释执行引擎"></a>8.4 基于栈的字节码解释执行引擎</h4><p>虚拟机如何调用方法的内容已经讲解完毕，现在我们来探讨虚拟机是如何执行方法中的字节码指令。</p>
<p><strong>8.4.1 解释执行</strong><br></p>
<p>Java语言经常被人们定位为“解释执行”语言，在Java初生的JDK1.0时代，这种定义还比较准确的，但当主流的虚拟机中都包含了即时编译后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出来了直接生成本地代码的编译器[如何GCJ（GNU Compiler for the Java）]，而C/C++也出现了通过解释器执行的版本（如CINT），这时候再笼统的说“解释执行”，对于整个Java语言来说就成了几乎没有任何意义的概念，只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。</p>
<p>Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译就是半独立实现的，</p>
<p><strong>8.4.2 基于栈的指令集和基于寄存器的指令集</strong><br></p>
<p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），依赖操作数栈进行工作。与之相对应的另一套常用的指令集架构是基于寄存器的指令集， 依赖寄存器进行工作。</p>
<p>基于栈的指令集主要的优点就是可移植，寄存器是由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。</p>
<p>栈架构的指令集还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单等。<br>栈架构指令集的主要缺点是执行速度相对来说会稍微慢一些。</p>
<h3 id="第九章-类加载及执行子系统的案例实战"><a href="#第九章-类加载及执行子系统的案例实战" class="headerlink" title="第九章 类加载及执行子系统的案例实战"></a>第九章 类加载及执行子系统的案例实战</h3><h4 id="9-1-Tomcat：正统的类加载架构"><a href="#9-1-Tomcat：正统的类加载架构" class="headerlink" title="9.1 Tomcat：正统的类加载架构"></a>9.1 Tomcat：正统的类加载架构</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>[toc]</p>
<p>在Java程序中，类型的加载、连接和初始化过程都是在程序运行期间完成的。提供了更大的灵活性，增加了更多的功能。</p>
<h3 id="Java-虚拟机与程序的生命周期"><a href="#Java-虚拟机与程序的生命周期" class="headerlink" title="Java 虚拟机与程序的生命周期"></a>Java 虚拟机与程序的生命周期</h3><p>在如下几种情况下，Java虚拟机将结束生命周期：</p>
<pre><code>1. 执行了System.exit()方法

2. 程序正常执行结束

3. 程序在执行过程中遇到异常或错误而异常终止

4. 由于操作系统出现错误而导致Java虚拟机进程终止
</code></pre><h3 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h3><pre><code>1. 加载：查找并加载类的二进制数据（就是将二进制形式的Java类型读入Java虚拟机中）

2. 连接：

    1. 验证：确保被加载的类的正确性

    2. 准备：为类的静态变量分配内存、并将其初始化为默认值（为类变量分配内存，设置默认值。但是到达初始化之前，类变量都没有初始化为真正的初始值。）

    3. 解析：将类中的符号引用转换为直接引用（解析过程是在类型的常量池中寻找类、接口、字段和方法的符号引用，将这些符号引用替换为直接引用的过程。）

3. 初始化：为类的静态变量赋予正确的初始值（为类的变量赋予正确的初始值）

    类的初始化步骤：

        1. 假如这个类还没有被加载和连接，那就先进行加载和连接

        2. 假如类存在直接父类，并且这个父类还没有被初始化，那么就先初始化直接父类

        3. 假如类中存在初始化语句，那就依次执行这些初始化语句

4. 类的实例化：

    1. 为新的对象分配内存
    2. 为实例变量赋予默认值
    3. 为实例变量赋予正确初始值。

    Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为&lt;init&gt;。针对源程序中每一个类的构造方法，Java编译器都产生一个&lt;init&gt;方法。
</code></pre><h4 id="Java对类的使用方式"><a href="#Java对类的使用方式" class="headerlink" title="Java对类的使用方式"></a>Java对类的使用方式</h4><p>Java程序对类的使用方式有两种：主动使用与被动使用。所有Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才 初始化 它们。</p>
<pre><code>1. 主动使用

    1. 创建类的实例
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值
    3. 调用类的静态方法
    4. 反射
    5. 初始化一个类的子类
    6. Java虚拟机启动时被标明为启动类的类
    7. 动态语言支持
</code></pre><blockquote>
<p>提示：调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
</blockquote>
<pre><code>2. 被动使用

    除了上面的七种主动使用方式之外，其它方式不会导致类被初始化
</code></pre><blockquote>
<p>提示：所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化它们。</p>
</blockquote>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类的加载指将类.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范没有说明Class对象位于哪里，hospot将其放在方法区内）封装类在方法区内的数据结构。</p>
<p>类的加载的最终产品是位于内存中的Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<blockquote>
<p>类加载器是用来将类加载到Java虚拟机中，在jdk1.2之后采用双亲委托机制，该机制能够更好的保证Java平台的安全。在此机制中，出Java虚拟机自带的根类加载器之外，其余的类加载器都有且只有一个父类加载器。当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，如果父类加载器能加载，则由父类加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p>
</blockquote>
<h5 id="加载-class文件方式"><a href="#加载-class文件方式" class="headerlink" title="加载.class文件方式"></a>加载.class文件方式</h5><pre><code>1. 从本地系统中直接加载

2. 通过网路下载.class文件

3. 从zip等归档文件中加载

4. 将Java源文件动态编译为.class文件

...
</code></pre><blockquote>
<p>提示：对于静态字段来说，只要直接定义了该字段的类才会被初始化。当一个类在初始化时，要求其父类全部都已经初始化完成。</p>
</blockquote>
<pre><code>-XX:+TraceClassLoading：用于追踪类的加载信息并打印出来。

-XX:+&lt;option&gt;，表示开启option选项
-XX:-&lt;option&gt;，表示关闭option选项
-XX:&lt;option&gt;=&lt;value&gt;，表示将option选项值设置为value
</code></pre><p>由上面的命令可以在控制台得到即使static中没有被初始化，但是在Java中已经被加载出来过的。</p>
<p>常量在编译阶段会被存入到调用这个常量方法所在类的常量池中。本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</p>
<blockquote>
<p>提示：助记符：</p>
</blockquote>
<blockquote>
<blockquote>
<p>ldc表示将int，float或是String类型的常量值从常量池中推送至栈顶。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>bipush表示将单字节（-128-127）的常量推送至栈顶。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>sipush表示将一个短整型的常量值（-32768-32767）推送至栈顶。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>iconst_1表示将int类型1推送至栈顶。（iconst_1 - iconst_5）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>anewarry表示创建一个引用类型的（如类、接口、数组）数组，并将其引用值压入栈顶</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>newarray表示创建一个指定的原始类型（如int float char等）的数组，并将其引用值压入栈顶。</p>
</blockquote>
</blockquote>
<p>当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，会导致这个被初始化。</p>
<p>对于数组实例来说，其类型是由JVM在运行期间动态生成的，表示 [运行类的类型 这种形式。动态生成的类型，其父类类型是Object。对于数组来说，JavaDoc经常将构成数组的元素的Component，实际就是数组降低一个维度后的类型。</p>
<blockquote>
<p>提示：当一个数组类的类型是原生类型时，表示该类的类加载器是没有的（null）。</p>
</blockquote>
<p>当一个接口在初始化时，并不要求其父接口都完成初始化。只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。</p>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ol>
<li>在初始化一个类时，并不会先初始化它所实现的接口。</li>
<li>在初始化一个接口时，并不会先初始化它的父接口。</li>
</ol>
<p>所以一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时才会导致该接口的初始化。</p>
<h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><p>只有当程序访问的 静态变量 或 静态方法 确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。</p>
<p>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<h4 id="两种类型的类加载器"><a href="#两种类型的类加载器" class="headerlink" title="两种类型的类加载器"></a>两种类型的类加载器</h4><p>类加载器并不需要等到某个类被“首次主动使用”时在加载它。</p>
<p>1.JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误。（LinkageError错误）。2. 如果这个类一直没有被使用，那么类加载器就不会报错错误。</p>
<p>在类被加载之后，就进入连接阶段，该阶段是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p>
<blockquote>
<p>类的验证内容：1. 类文件的结构检查。 2. 语义检查。 3. 字节码检查。 4. 二进制兼容性验证。</p>
</blockquote>
<h5 id="1-Java虚拟机自带的加载器"><a href="#1-Java虚拟机自带的加载器" class="headerlink" title="1. Java虚拟机自带的加载器"></a>1. Java虚拟机自带的加载器</h5><p>由上到下的类加载器：</p>
<pre><code>1. 根类加载器（Bootstrap）

    该加载器没有父加载器，它负责加载虚拟机的核心类库，如：java.lnag.*等。根类加载器从系统属性 sun.boot.class.path 所指定的目录中加载类库。该加载器的实现依赖底层操作系统，是虚拟机实现的一部分，并没有继承java.lang.ClassLoader类。

        $JAVA_HOME中jre/lib/rt.jar里所有的.class，是由c++实现，不是classloader的子类。

2. 扩展类加载器（Extension）

    它的父加载器是根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库。或者从jdk的安装目录的 jre\lib\ext子目录（扩展目录）下加载类库。如果用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载。该加载器是java.lang.ClassLoader类的子类。

        负责加载Java平台的扩展功能的jar包。包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。

3. 系统（应用）类加载器（System）

    或称为应用类加载器，它的父加载器是扩展类加载器。它从环境变量 classpath或者系统属性 java.class.path 所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。该加载器是 java.lang.ClassLoader 类的子类。

        负责加载classpath中指定的jar包及目录中class。
</code></pre><h5 id="2-用户自定义的类加载器"><a href="#2-用户自定义的类加载器" class="headerlink" title="2. 用户自定义的类加载器"></a>2. 用户自定义的类加载器</h5><pre><code>1. java.lang.ClassLoader的子类

    所有用户自定义的类加载器都应该继承该类。

2. 用户可以定制类的加载方式
</code></pre><h5 id="当前类加载器（Current-ClassLoader）"><a href="#当前类加载器（Current-ClassLoader）" class="headerlink" title="当前类加载器（Current ClassLoader）"></a>当前类加载器（Current ClassLoader）</h5><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其它类（指的是所依赖的类），如果ClassX引用了ClassY，那么ClassX的类加载器就会去加载ClassY（前提是ClassY尚未被加载）。</p>
<h5 id="线程上下文加载器（Context-ClassLoader）"><a href="#线程上下文加载器（Context-ClassLoader）" class="headerlink" title="线程上下文加载器（Context ClassLoader）"></a>线程上下文加载器（Context ClassLoader）</h5><p>线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器。</p>
<p>如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类和资源。</p>
<h5 id="线程上下文类加载器的重要性"><a href="#线程上下文类加载器的重要性" class="headerlink" title="线程上下文类加载器的重要性"></a>线程上下文类加载器的重要性</h5><pre><code>SPI（Service Provider Interface） - 服务提供接口
</code></pre><p>父ClassLoader可以使用当前线程Thread.currentThread().getContextLoader()所指定的ClassLoader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其它没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。</p>
<blockquote>
<p>提示：线程上下文类加载器就是当前线程的Current ClassLoader。</p>
</blockquote>
<p>在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的，而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包（厂商提供），Java的启动类加载器是不会加载其它来源的jar的，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>
<blockquote>
<p>提示：线程上下文类加载器的一般使用模式（获取-使用-还原）。</p>
</blockquote>
<pre><code>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

try{
    Thread.currentThread().setContextClassLoader(targetTccl);
    myMethod();
}finally{
    Thread.currentThread().setContextClassLoader(classLoader);
}
</code></pre><p>在myMethod里面则调用了Thread.currentThread().getContextClassLoader()，获取当前线程的上下文类加载器做某些事情。</p>
<p>如果一个类由类加载器A加载，那这个类的依赖类也是由相同的类加载器加载的（如果该依赖类之前没有被加载过的话）。</p>
<blockquote>
<p>提示：ContextClassLoader的作用就是为了破坏Java的类加载委托机制。</p>
</blockquote>
<p>当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。</p>
<h4 id="类加载器的双亲委托机制"><a href="#类加载器的双亲委托机制" class="headerlink" title="类加载器的双亲委托机制"></a>类加载器的双亲委托机制</h4><p>在双亲委托机制中，各个加载器按照父子关系形成了树形结构（逻辑意义上的树形结构），除了根类加载器之外，其余的类加载器都有且只有一个父加载器。</p>
<pre><code>1. 自底向上检查类是否已经加载

2. 自顶向下尝试加载类

public Test16(String classLoaderName) {
    super();//将系统类加载器当做该类加载器的父加载器
    this.classLoaderName = classLoaderName;
}

public Test16(ClassLoader parent, String classLoaderName) {
    super(parent);//显示指定该类加载器的父加载器
    this.classLoaderName = classLoaderName;
}
</code></pre><p>如果有一个类加载器能够成功加载到我们的Test类，那么称此类加载器是定义类加载器，而所有能够成功返回Class对象引用的类加载器（包括定义类加载器）都称为初始类加载器。</p>
<h5 id="类加载器双亲委托模型的优点"><a href="#类加载器双亲委托模型的优点" class="headerlink" title="类加载器双亲委托模型的优点"></a>类加载器双亲委托模型的优点</h5><pre><code>1. 可以确保Java核心类库的类型安全：所有的Java应用都至少会引用java.lang.Object类，也就是在运行期，java.lang.Object这个类会被加载到Java虚拟机中。如果这个加载过程是由Java应用自己的类加载器所完成，那么很可能就会在JVM中存在很多版本的java.lang.Object类，而且这些类之间还是不兼容的，互相不可见的（正是命名空间在发挥作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了Java应用所使用的都是同一个版本的Java核心类库，它们之间是相互兼容的。

2. 可以确保Java核心类库所提供的类不会被自定义的类所替代。

3. 不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要不同的类加载器来加载它们即可。不同的类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。
</code></pre><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成的。</p>
<p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</p>
<p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p>
<h5 id="关于命名空间的说明"><a href="#关于命名空间的说明" class="headerlink" title="关于命名空间的说明"></a>关于命名空间的说明</h5><pre><code>1. 子加载器所加载的类能够访问父加载器所加载的类。

2. 父加载器所加载的类无法访问子加载器所加载的类。
</code></pre><h5 id="不同类加载器命名空间关系"><a href="#不同类加载器命名空间关系" class="headerlink" title="不同类加载器命名空间关系"></a>不同类加载器命名空间关系</h5><p>同一个命名空间内的类是相互可见的，子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类。如：系统类加载器加载的类能看见根类加载器加载的类。</p>
<p>由父加载器加载的类不能看见子加载器加载的类。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类互相不可见。</p>
<p>在运行期，一个Java类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器（defining loader）所共同决定的。如果同样名字（即相同的完全限定名）的类是由两个不同的加载器所加载的，那么这些类就是不同的，即便.class文件的字节码完全一样，并且从相同的位置加载。</p>
<p>内建于JVM中的启动类加载器会加载 java.lang.ClassLoader以及其它的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫作启动类加载器（Bootstrap）。</p>
<blockquote>
<p>提示：启动类加载器并不是Java类，而其它的加载器则都是Java类。启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。所有类加载器（除了启动类加载器）都被实现为Java类，不过，总归要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。</p>
</blockquote>
<h4 id="获得ClassLoader的途径"><a href="#获得ClassLoader的途径" class="headerlink" title="获得ClassLoader的途径"></a>获得ClassLoader的途径</h4><ol>
<li>获取当前类的ClassLoader -&gt; clazz.getClassLoader();</li>
<li>获取当前线程上下文的ClassLoader -&gt; Thread.currentThread().getContextClassLoader();</li>
<li>获取系统的ClassLoader -&gt; ClassLoader.getSystemClassLoader();</li>
<li>获取调用者的ClassLoader -&gt; DriverManager.getCallerClassLoader();</li>
</ol>
<h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>当类被加载、连接和初始化后，它的生命周期开始，当代表该类的class对象不再被引用，即不可触及时，class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。</p>
<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>
<p>由Java虚拟机自带的类加载器所加载的类在虚拟机的生命周期中，始终不会被卸载。而由用户自定义的类加载器可以被卸载。</p>
<h4 id="Laucher-加载类加载器"><a href="#Laucher-加载类加载器" class="headerlink" title="Laucher 加载类加载器"></a>Laucher 加载类加载器</h4><p>源码分析</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h2><p>[TOC]</p>
<h3 id="第10章-早期（编译器）优化"><a href="#第10章-早期（编译器）优化" class="headerlink" title="第10章 早期（编译器）优化"></a>第10章 早期（编译器）优化</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>javac 这类编译器对代码的运行效率没有任何优化措施。</p>
<h4 id="Javac-编译器"><a href="#Javac-编译器" class="headerlink" title="Javac 编译器"></a>Javac 编译器</h4><p>它本身是一个Java语言编写的程序。</p>
<h3 id="第11章-晚期（运行期）优化"><a href="#第11章-晚期（运行期）优化" class="headerlink" title="第11章 晚期（运行期）优化"></a>第11章 晚期（运行期）优化</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>即时编译器（JIT编译器），不是虚拟机必需的部分，Java虚拟机规范</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC14%E7%AB%A0%20Spring%20MVC%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第14章-Spring-MVC工作机制和设计模式"><a href="#第14章-Spring-MVC工作机制和设计模式" class="headerlink" title="第14章 Spring MVC工作机制和设计模式"></a>第14章 Spring MVC工作机制和设计模式</h2><p>[TOC]</p>
<h3 id="Spring-MVC总体设计"><a href="#Spring-MVC总体设计" class="headerlink" title="Spring MVC总体设计"></a>Spring MVC总体设计</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20Tomcat%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第十一章-Tomcat的系统架构与设计模式"><a href="#第十一章-Tomcat的系统架构与设计模式" class="headerlink" title="第十一章 Tomcat的系统架构与设计模式"></a>第十一章 Tomcat的系统架构与设计模式</h2><p>[TOC]</p>
<h3 id="11-1-Tomcat总体设计"><a href="#11-1-Tomcat总体设计" class="headerlink" title="11.1 Tomcat总体设计"></a>11.1 Tomcat总体设计</h3><h3 id="11-2-Tomcat中设计模式"><a href="#11-2-Tomcat中设计模式" class="headerlink" title="11.2 Tomcat中设计模式"></a>11.2 Tomcat中设计模式</h3><h4 id="11-2-1-门面设计模式"><a href="#11-2-1-门面设计模式" class="headerlink" title="11.2.1 门面设计模式"></a>11.2.1 门面设计模式</h4><p>门面设计模式，将一个东西封装成一个门面好与人家更容易的进行交流，如同一个国家的外交部一样。这重模式主要用在一个大型系统中有多个子系统时，这时有多个子系统肯定需要进行通信。但此时不能将每个子系统的内部数据过多的暴露给其它系统，否则没有必要设计子系统，所以此时通过设计门面。</p>
<blockquote>
<p>提示：门面模式是隔离数据的一种方式。</p>
</blockquote>
<h4 id="12-2-2-观察者设计模式"><a href="#12-2-2-观察者设计模式" class="headerlink" title="12.2.2 观察者设计模式"></a>12.2.2 观察者设计模式</h4><p>或称发布-订阅模式，也就是事件监听机制，通常在某个时间发生的前后会触发某一操作。观察者设计模式通常包含这几个角色：</p>
<pre><code>1. Subject抽象主题：负责所有观察者的引用，同时定义主要的事件操作。

2. ConcreteSubject具体主题：实现抽象主题定义的所有接口，当自己发生变化时会通知所有观察者。

3. Observer观察者：监听主题发生变化的操作接口。
</code></pre><h4 id="12-2-3-命令设计模式"><a href="#12-2-3-命令设计模式" class="headerlink" title="12.2.3 命令设计模式"></a>12.2.3 命令设计模式</h4><p>该模式主要作用是封装命令，将发出命令的责任和执行命令的责任分开，是功能的分工。不同模块可以对同一命令做出不同的解释。</p>
<pre><code>1. Client 创建一个命令，并决定接受者

2. Command 命令接口，定义一个抽象方法

3. ConcreteCommand 具体命令，负责调用接受者相应操作

4. Invoker 请求者，负责调用命令对象执行请求

5. Receiver 接受者，负责具体实施和执行一次请求
</code></pre><h4 id="12-2-4-责任链模式"><a href="#12-2-4-责任链模式" class="headerlink" title="12.2.4 责任链模式"></a>12.2.4 责任链模式</h4><p>责任链模式就是很多对象有每个对象对其下家的引用而连接起来形成一条链，请求在这条链上传递，直到链上的某个对象处理此请求，或链上的每个对象都可以处理此请求，直到对象都处理完。这样可以不影响客户端而能够在链上增加任意的处理节点。责任链包含的角色：</p>
<pre><code>1. Handler（抽象处理者） 定义一个处理请求的接口

2. ConcreteHandler（具体处理者） 处理请求的具体类
</code></pre>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<h2 id="第十章-深入理解Cookie和Session"><a href="#第十章-深入理解Cookie和Session" class="headerlink" title="第十章 深入理解Cookie和Session"></a>第十章 深入理解Cookie和Session</h2><p>[TOC]</p>
<p>Session和Cookie的作用都是为了保持访问用户与后端服务器的交互状态。</p>
<p>Cookie在传递信息时，随着Cookie个数的增多和访问量的增加，它占用的网络带宽也很大。</p>
<p>Session不容易在多台服务器之间共享。</p>
<h3 id="10-1-Cookie"><a href="#10-1-Cookie" class="headerlink" title="10.1 Cookie"></a>10.1 Cookie</h3><p>Cookie可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多无疑增加客户端与服务器的数据传输量。</p>
<h4 id="10-1-1-Cookie属性项"><a href="#10-1-1-Cookie属性项" class="headerlink" title="10.1.1 Cookie属性项"></a>10.1.1 Cookie属性项</h4><p>常用的属性：SetCookie</p>
<h4 id="10-1-2-Cookie工作"><a href="#10-1-2-Cookie工作" class="headerlink" title="10.1.2 Cookie工作"></a>10.1.2 Cookie工作</h4><h4 id="10-1-3-Cookie限制"><a href="#10-1-3-Cookie限制" class="headerlink" title="10.1.3 Cookie限制"></a>10.1.3 Cookie限制</h4><p>Cookie只是HTTP协议头中的一个字段，虽然HTPP协议本身没有对这个字段有多少限制，但是Cookie最终还是存储在浏览器里，所以不同的浏览器会对Cookie的大小和数量有限制。</p>
<h3 id="10-2-Session"><a href="#10-2-Session" class="headerlink" title="10.2 Session"></a>10.2 Session</h3><p>同一客户端每次和服务端交互时，不需要每次都传回所有Cookie值，而是传回一个ID，这个ID时客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。该ID通常是NAME为JSESIONID的一个Cookie。</p>
<h4 id="10-2-1-Session-与-Cookie"><a href="#10-2-1-Session-与-Cookie" class="headerlink" title="10.2.1 Session 与 Cookie"></a>10.2.1 Session 与 Cookie</h4><p>Session基于Cookie来工作</p>
<pre><code>1. 
</code></pre><h3 id="10-3-Cookie安全问题"><a href="#10-3-Cookie安全问题" class="headerlink" title="10.3 Cookie安全问题"></a>10.3 Cookie安全问题</h3><pre><code>1. Cookie

    Cookie通常情况下是将所有要保存的数据通过HTTP协议的头部从客户端传递到服务器，又从服务端传回客户端，所有的数据都存储在客户端的浏览器中，所以这些Cookie数据都能够被访问到。

2. Session

    Session将数据保存在服务器，所以Session更适合存储用户隐私和重要数据。
</code></pre><h3 id="10-4-分布式Session框架"><a href="#10-4-分布式Session框架" class="headerlink" title="10.4 分布式Session框架"></a>10.4 分布式Session框架</h3><h4 id="10-4-1-Cookie的限制"><a href="#10-4-1-Cookie的限制" class="headerlink" title="10.4.1 Cookie的限制"></a>10.4.1 Cookie的限制</h4><pre><code>1. 客户端cookie存储限制 不同浏览器中cookie存储个数的限制

2. cookie管理混乱

    因为如果每个应用系统都有自己管理的应用cookie，将会导致混乱。但由于通常应用系统都在同一个域名下，cookie又有存储限制，所以没有统一管理很容易出现cookie超出限制的混乱。

3. 安全
</code></pre><h4 id="10-4-2-Session的优势"><a href="#10-4-2-Session的优势" class="headerlink" title="10.4.2 Session的优势"></a>10.4.2 Session的优势</h4><pre><code>1. Session配置的统一管理

2. Cookie使用的监控和统一规范管理

3. Session存储的多元化

4. Session配置的动态修改

5. Session加密key的定期修改

6. 充分的容灾机制，保持框架的使用稳定性

...

9. 跨域名Session和cookie如何共享，现在一个网站可能存在多个域名，所以跨域问题需要解决
</code></pre><h3 id="10-5-Cookie压缩"><a href="#10-5-Cookie压缩" class="headerlink" title="10.5 Cookie压缩"></a>10.5 Cookie压缩</h3><h3 id="10-6-表单重复提交问题"><a href="#10-6-表单重复提交问题" class="headerlink" title="10.6 表单重复提交问题"></a>10.6 表单重复提交问题</h3><p>能够防止表单重复提交，就需要标识用户的每一个访问请求，使得每一次访问对服务器来说都是唯一确定的。</p>
<p>这里为了标识用户的每次访问请求，可以在用户请求一个表单域时增加一个隐藏表单项，这个表单项的值每次都是唯一的token。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20Lock%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="第四章-Lock的使用"><a href="#第四章-Lock的使用" class="headerlink" title="第四章 Lock的使用"></a>第四章 Lock的使用</h2><h3 id="4-1-使用ReentrantLock类"><a href="#4-1-使用ReentrantLock类" class="headerlink" title="4.1 使用ReentrantLock类"></a>4.1 使用ReentrantLock类</h3><p>与synchronize关键字类似，能够实现线程之间同步互斥，同时扩展功能使得其更加强大。</p>
<h4 id="4-1-1-ReentrantLock-实现同步"><a href="#4-1-1-ReentrantLock-实现同步" class="headerlink" title="4.1.1 ReentrantLock 实现同步"></a>4.1.1 ReentrantLock 实现同步</h4><blockquote>
<p>提示：当前线程在运行完之后将进行锁释放，其它线程才可以继续执行。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：调用ReentrantLock对象的lock()方法获取锁，调用unlock()方法释放锁。</p>
</blockquote>
</blockquote>
<p>调用了 lock.lock() 程序的线程就持有了“对象监视器”，其它线程只有等待锁被释放时再次争抢。效果和使用synchronize关键字一样，线程之间还是顺序执行的。</p>
<h4 id="4-1-3-使用Condition实现等待-通知"><a href="#4-1-3-使用Condition实现等待-通知" class="headerlink" title="4.1.3 使用Condition实现等待/通知"></a>4.1.3 使用Condition实现等待/通知</h4><p>由于关键字 synchronized 与wait()和notify()方法/notifyAll()方法相结合可以实现等待/通知模式，类ReentrantLock也可以实现同样的功能，但是需要借助 Condition 对象。</p>
<p>Condition 有更好的灵活性，可以实现多路通知功能，表示在一个Lock对象里面可以创建多个Condition（对象监视器）实例，线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度上更加灵活。</p>
<blockquote>
<p>提示：synchronized 相当于整个Lock对象中只有一个单一的Condition对象，所有的线程都注册在它一个对象上。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：必须在condition.await()方法调用之前调用 lock.lock()方法获取同步监视器。</p>
</blockquote>
</blockquote>
<h4 id="4-1-4-正确使用Condition实现等待-通知"><a href="#4-1-4-正确使用Condition实现等待-通知" class="headerlink" title="4.1.4 正确使用Condition实现等待/通知"></a>4.1.4 正确使用Condition实现等待/通知</h4><pre><code>1.Object类中的 wait() 方法相当于 Condition类中的await()方法。

2.Object类中的 wait(long timeout) 方法相当于 Condition类中的await(long time, TimeUnit unit)方法。

3.Object类中的 notify()方法相当于 Condition类中的signal()方法。

4.Object类中的 notifyAll()方法相当于 Condition类中的 signalAll()方法。
</code></pre><h4 id="4-1-5-实现多个Condition通知部分线程"><a href="#4-1-5-实现多个Condition通知部分线程" class="headerlink" title="4.1.5 实现多个Condition通知部分线程"></a>4.1.5 实现多个Condition通知部分线程</h4><p>使用 ReentrantLock 对象可以唤醒指定种类的线程，这是控制部分线程行为的有效方式。</p>
<h3 id="4-2-使用-ReentrantReadWriteLock-类"><a href="#4-2-使用-ReentrantReadWriteLock-类" class="headerlink" title="4.2 使用 ReentrantReadWriteLock 类"></a>4.2 使用 ReentrantReadWriteLock 类</h3><p>类 ReentrantLock 具有完全互斥排它的效果，即同一时间只有一个线程在执行 ReentrantLock.lock()方法后面的任务。虽然保证实例变量的安全性，但效率低下。</p>
<p>读写锁 ReentrantReadWriteLock 表示两个锁，一个读锁（共享锁），一个写锁（排它锁）。即表示多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。</p>
<blockquote>
<p>提示：多个线程可以同时进行读取操作，但是同一时刻只允许一个线程进行写入操作。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在读读共享中，使用 lock.readLock() 读锁可以提高程序运行效率，允许多个线程同时执行 lock() 方法后面的程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在写写互斥中，使用 lock.writeLock() 的效果就是同一时间只允许一个线程执行 lock() 方法后面的代码。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在读写互斥中，使用 lock.writeLock() | lock.readLock() 的效果就是同一时间只允许一个线程执行 lock() 方法后面的代码。</p>
</blockquote>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8Timer/</url>
    <content><![CDATA[<h2 id="第五章-定时器Timer"><a href="#第五章-定时器Timer" class="headerlink" title="第五章 定时器Timer"></a>第五章 定时器Timer</h2><p>[TOC]</p>
<h3 id="5-1-定时器Timer的使用"><a href="#5-1-定时器Timer的使用" class="headerlink" title="5.1 定时器Timer的使用"></a>5.1 定时器Timer的使用</h3><p>在JDK库中Timer类主要负责计划任务的功能，即在指定的时间开始执行某一任务。Timer类的作用就是设置计划任务，但是封装任务的类却是TimerTask类。</p>
<h4 id="5-1-1-方法schedule-TimerTask-task-Date-time-测试"><a href="#5-1-1-方法schedule-TimerTask-task-Date-time-测试" class="headerlink" title="5.1.1 方法schedule(TimerTask task, Date time)测试"></a>5.1.1 方法schedule(TimerTask task, Date time)测试</h4><h5 id="1-在未来执行的效果"><a href="#1-在未来执行的效果" class="headerlink" title="1. 在未来执行的效果"></a>1. 在未来执行的效果</h5>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%8B%BE%E9%81%97%E5%A2%9E%E8%A1%A5/</url>
    <content><![CDATA[<h2 id="第七章-拾遗增补"><a href="#第七章-拾遗增补" class="headerlink" title="第七章 拾遗增补"></a>第七章 拾遗增补</h2><p>[TOC]</p>
<h3 id="7-4-SimpleDateFormat非线程安全"><a href="#7-4-SimpleDateFormat非线程安全" class="headerlink" title="7.4 SimpleDateFormat非线程安全"></a>7.4 SimpleDateFormat非线程安全</h3><p>类SimpleDateFormat主要负责日期的转换与格式化，但是在多线程环境中使用此类容易造成数据转换和处理的不准确，因为此类是非线程安全的。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="第五章-基础构建模块"><a href="#第五章-基础构建模块" class="headerlink" title="第五章 基础构建模块"></a>第五章 基础构建模块</h2><h3 id="5-1-同步容器类"><a href="#5-1-同步容器类" class="headerlink" title="5.1 同步容器类"></a>5.1 同步容器类</h3><p>同步容器类包括Vector | Hashtable。它们实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能够访问容器的状态。</p>
<h4 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1.1"></a>5.1.1</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Spring%E6%BA%90%E7%A0%81%20-%20Spring%20IoC%E5%AE%B9%E5%99%A8%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Spring源码-Spring-IoC容器加载过程"><a href="#Spring源码-Spring-IoC容器加载过程" class="headerlink" title="Spring源码 - Spring IoC容器加载过程"></a>Spring源码 - Spring IoC容器加载过程</h2><p>Spring IoC容器的加载过程是：1.资源文件定位。2.解析。3.注册。4.实例化。</p>
<pre><code>1.资源文件定位：该过程是在ApplicationContext的实现类里完成，因为ApplicationContext接口继承ResourcePatternResolver接口，该接口继承 ResourceLoader 接口，ResourceLoader 中的getResource()方法可以将外部资源读取为Resource类。
</code></pre><p>…</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Spring%20%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Spring-源码解析"><a href="#Spring-源码解析" class="headerlink" title="Spring 源码解析"></a>Spring 源码解析</h1><p><img src="/images/1.jpg" alt=""></p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p> (Inversion of Control):控制反转</p>
<p>控制：资源的获取方式</p>
<p>​    主动式：（要什么资源自给创建即可）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">​	BookServlet&#123;</span><br><span class="line"></span><br><span class="line">​	BookService bs = <span class="keyword">new</span> BookService()； </span><br><span class="line"></span><br><span class="line">​	AirPlane ap = <span class="keyword">new</span> AirPlane();<span class="comment">//复杂对象的创建是一个比较庞大的工程 </span></span><br><span class="line"></span><br><span class="line">​	&#125;</span><br></pre></td></tr></table></figure>
<p>被动式：资源的获取不是我们自己创建，而是交给容器来管理，创建和设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BookServlet&#123;</span><br><span class="line">    BookService bs ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bs.checkout();<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器：管理所有得组件（有功能的类），假设BookServlet受容器管理，BookService也是受容器管理的；</p>
<p>那么容器可以自动探查出那些组件（类）需要用到另一个组件，容器帮我们创建BookService对象，并赋值。</p>
<p>==容器：主动获取变为自动接收。==    </p>
<h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>（Dependency Injection）依赖注入：</p>
<p>​    容器可以知道那个组件（类）运行的时候，需要另一个类（组件）；容器通过反射的方式，将容器中准备好的BookService对象注入（利用反射给对象赋值）到BookServlet之中，</p>
<p>​    <strong>只要容器管理的组件，都能使用容器强大的功能；</strong></p>
<h2 id="Helloword（通过各种方式给容器中注册对象）"><a href="#Helloword（通过各种方式给容器中注册对象）" class="headerlink" title="Helloword（通过各种方式给容器中注册对象）"></a>Helloword（通过各种方式给容器中注册对象）</h2><p>以前都是自己New对象，现在所有对象交给容器来创建；==给容器注册组件==</p>
<p>框架编写流程：</p>
<h3 id="1）、导包"><a href="#1）、导包" class="headerlink" title="1）、导包"></a>1）、导包</h3><p>​    核心容器：</p>
<p>​    beans，context，core，expression，</p>
<p>​    日志包：</p>
<p>​    commons-logging </p>
<h3 id="2）、写配置"><a href="#2）、写配置" class="headerlink" title="2）、写配置"></a>2）、写配置</h3><p>​    spring的配置文件中，集合了spring的IOC容器管理的所有组件（会员清单）；</p>
<p>​    创建一个 Spring Bean Configuration的配置文件</p>
<p>​    一个Bean标签可以注册一个组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> ：要写注册的全类名</span></span><br><span class="line">id: 这个对象的唯一标示</span><br><span class="line">property标签：为属性赋值</span><br><span class="line">name：属性名</span><br><span class="line">val：属性值</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取属性</span></span><br><span class="line"><span class="comment">//ApplicationContext IOC 容器</span></span><br><span class="line">ApplicationContext ioc = <span class="keyword">new</span> ClassPathXMlApplicationContext(<span class="string">"ioc.xml"</span>);</span><br><span class="line">getbean 获取</span><br></pre></td></tr></table></figure>
<h3 id="3）、测试"><a href="#3）、测试" class="headerlink" title="3）、测试"></a>3）、测试</h3><h2 id="Resource-和-Autowried-的区别与联系"><a href="#Resource-和-Autowried-的区别与联系" class="headerlink" title="Resource 和  Autowried 的区别与联系"></a>Resource 和  Autowried 的区别与联系</h2><h3 id="联系："><a href="#联系：" class="headerlink" title="联系："></a>联系：</h3><p> 都是用来装配Bean的注解。都可以写在字段上,或写在setter方法上。</p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><h4 id="Autowried："><a href="#Autowried：" class="headerlink" title="Autowried："></a>Autowried：</h4><p>默认情况下要求对象必须存在, 它要求依赖对象必须存在. 若允许null值, 可以设置它的==required为false.==（默认为true）</p>
<p><strong>默认按照类型进行装配注入. 如果想按照名称进行装配的话, 需要与Qualifer注解搭配使用.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowried</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"admin"</span>) <span class="comment">//按照名称装配</span></span><br><span class="line"><span class="keyword">private</span> AdminDAO adminDAO;</span><br></pre></td></tr></table></figure>
<p><strong>Autowried更加强大，==它是Spring提供的注解==。</strong></p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource:"></a>Resource:</h4><p><strong>默认按照名称来装配注入, 只有找不到与名称匹配的bean才会按照类型来注入.</strong></p>
<h5 id="Resource-的装配顺序"><a href="#Resource-的装配顺序" class="headerlink" title="Resource 的装配顺序"></a>Resource 的装配顺序</h5><ul>
<li>如果同时指定了name属性和type属性, 那么Spring将从容器中找唯一匹配的bean进行装配, 找不到则抛出异常</li>
<li>如果指定了name属性值, 则从容器中查找名称匹配的bean进行装配, 找不到则抛出异常</li>
<li>如果指定了type属性值, 则从容器中查找类型匹配的唯一的bean进行装配, ==找不到或者找到多个都会抛出异常==</li>
<li>如果都不指定, 则会自动按照byName方式进行装配, 如果没有匹配, 则回退一个按照类型进行匹配, 如果匹配则自动装配</li>
</ul>
<p>@Rescource ：扩展性更强，即使更换另外一个框架，他也可以用。</p>
<h3 id="IOC-总结："><a href="#IOC-总结：" class="headerlink" title="IOC 总结："></a>IOC 总结：</h3><ol>
<li>ioc是一个容器，帮我们管理所有组件</li>
<li>依赖注入：@Autowired：自动赋值</li>
<li>某个组件要使用Spring提供的更多（IOC,AOP），==必须注册到容器中。== </li>
</ol>
<p>体会：</p>
<pre><code>1. 容器启动，默认会创建所有单实例Bean
2. autowired 自动装配，是从容器中找到这些符合要求的bean
3. ioc.getBean(); 也是从容器中找到这个bean
4. 容器中包括了所有的Bean
5. 调试Spring 的源码 看看容器到底是什么。==其实就是一个map==
6. 这个map保存好了所有创建好的bean，并提供外界获取的功能。。。
7. 探索一下单实例bean到保存在了那个map中。源码部分
</code></pre><p>如何看框架源码：</p>
<pre><code>1. 从HelloWord 开始 Debug 模式
2. 翻译方法名
3. 放行这个方法，观察控制台，以及变量的变化
4. 看方法上面的注释。
</code></pre><p>==起名一定要规范，注释一定要清楚==</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>​    AOP：面向切面编程，指在程序运行期间，将<strong>某段代码</strong>==动态的切入==到指定方法的<strong>指定位置</strong>进行运行的这种编程方式，称为面向切面编程</p>
<p>​    场景：计算器运行计算方法的时候，进行日志记录</p>
<p>加日志记录：</p>
<p>​    1）、直接编写在方法内部，不推荐，修改特别麻烦</p>
<p>​        日志记录：系统的辅助功能</p>
<p>​        业务逻辑：主要功能</p>
<p>​        耦合</p>
<p>​    2）、我们希望的是：</p>
<p>​        业务逻辑：（核心功能）；日志模块；在核心功能运行时，自己动态的加上。</p>
<p>​        运行的时候，日志功能可以自动加上</p>
<p>Spring动态代理难：Spring实现了AOP功能，底层就是动态代理：</p>
<p>​    可以利用Spring一句代码都不写的去创建动态代理：</p>
<p>​        实现简单，而且没有强制要求对象那个必须实现接口。</p>
<p>​        将<strong>某段代码</strong>==动态的切入==到指定方法的<strong>指定位置</strong>进行运行的这种编程方式（Spring简化了面向切面编程）</p>
<h4 id="五个注解通知"><a href="#五个注解通知" class="headerlink" title="五个注解通知"></a>五个注解通知</h4><ol>
<li><p>@Before 在目标方法之前运行。      <strong>前置通知</strong></p>
</li>
<li><p>@After 在目标方法之后运行             <strong>后置通知</strong></p>
</li>
<li><p>@AfterReturning：在目标方法正常返回之后运行     <strong>返回通知</strong></p>
</li>
<li><p>@AfterThrowing：在目标方法抛出异常之后运行       <strong>异常通知</strong></p>
</li>
<li><p>@Around  ： ==<strong>环绕通知</strong>==</p>
<p>执行顺序：</p>
<p>​    <strong>正常执行：@Before(前置) –&gt; @After（后置）–&gt;@AfterReturning（正常返回）</strong></p>
<p>​    <strong>异常执行：@Before(前置) –&gt; @After（后置）–&gt;@AfterThrowing（方法异常）</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    method.invoke(obj,args);</span><br><span class="line">    <span class="comment">//返回通知</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">&#125;</span><br><span class="line">Spring中最强大的通知</span><br><span class="line">四合一通知：环绕通知</span><br><span class="line">	环绕通知中有一个参数，ProceedingJoinPoint pjp</span><br><span class="line">	<span class="comment">//利用反射调用方法，就等同于method.invoke(obj,args);</span></span><br><span class="line">	pjp.proceed(args); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">myAround</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    Object args = pjp.getArgs();</span><br><span class="line">    <span class="comment">//获取方法名</span></span><br><span class="line">    String name = pjp.getSignature().getName();</span><br><span class="line">    Object proceed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//前置通知@Before</span></span><br><span class="line">        System.out.println(<span class="string">"【环绕前置通知】【"</span>+name+<span class="string">"方法开始了】"</span>);</span><br><span class="line">	<span class="comment">//利用反射调用方法，就等同于method.invoke(obj,args);</span></span><br><span class="line">        </span><br><span class="line">        proeed = pjp.proceed(args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回通知@AfterReturning</span></span><br><span class="line">        System.out.println(<span class="string">"【环绕返回通知】【"</span>+name+<span class="string">"方法返回，返回值"</span>+proceed+<span class="string">"】"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    	<span class="comment">//异常通知@AfterThrowing</span></span><br><span class="line">        System.out.println(<span class="string">"【环绕异常通知】【"</span>+name+<span class="string">"方法出现异常,异常信息为：】"</span>+e+<span class="string">"】"</span>);</span><br><span class="line">        <span class="comment">//为了能让外界感知到这个异常我们一定将异常抛出去</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【环绕后置通知】【"</span>+name+<span class="string">"方法结束了】"</span>);</span><br><span class="line">   		 <span class="comment">//后置通知@After</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射调用的返回值也一定返回出去</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==环绕通知是<strong>优先</strong>于普通通知执行的！！！==<br>执行顺序： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">​	【普通前置】</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">​	环绕前置</span><br><span class="line"></span><br><span class="line">​	环绕执行，目标方法执行</span><br><span class="line"></span><br><span class="line">​	环绕返回</span><br><span class="line"></span><br><span class="line">​	&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">​	环绕异常(一定要抛出去)</span><br><span class="line"></span><br><span class="line">​	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">​	环绕返回</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​	【普通后置】</span><br><span class="line"></span><br><span class="line">​	【普通方法返回/异常】</span><br></pre></td></tr></table></figure>
<p>新的顺序：</p>
<p>​    ==环绕前置—–普通前置—-目标方法执行——环绕正常返回/出现环绕异常——环绕后置—-普通后置—–普通返回或者异常==</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><h5 id="​JDK代理："><a href="#​JDK代理：" class="headerlink" title="​JDK代理："></a>​JDK代理：</h5><p>java代理类的实现主要靠<code>Proxy</code>类和<code>InvocationHandler</code>接口来实现。</p>
<ol>
<li>通过<code>Proxy.getProxyClass()</code>方法生成代理类的class文件并加载。（具体生成步骤见 源码中<code>ProxyClassFactory.apply()</code>） </li>
<li>获取这个class的构造器，传入代理类的逻辑实现类<code>InvocationHandler</code>作为构造函数参数，实例化class获得代理类对象。 </li>
<li>调用代理类对象的对应方法</li>
</ol>
<h5 id="CGlib代理："><a href="#CGlib代理：" class="headerlink" title="CGlib代理："></a>CGlib代理：</h5><h2 id="Spring-源码核心"><a href="#Spring-源码核心" class="headerlink" title="Spring 源码核心"></a>Spring 源码核心</h2><h3 id="AOP源码核心："><a href="#AOP源码核心：" class="headerlink" title="AOP源码核心："></a>AOP源码核心：</h3><p>​    AOP源码：就是动态代理，套动态代理，【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么】</p>
<h4 id="1-什么是EnableAspectJAutoProxy"><a href="#1-什么是EnableAspectJAutoProxy" class="headerlink" title="1.什么是EnableAspectJAutoProxy"></a>1.什么是EnableAspectJAutoProxy</h4><p>​    1.@Import(AspectJAutoProxyRegistrar.class)：给容器中导入这个类，AspectJAutoProxyRegistrar</p>
<p>​        利用AspectJAutoProxyRegistrar 给容器中自定义注册bean</p>
<p>​        internalAutoProxyCreator = AnnotationAwareAspectJAutoProxyCreator</p>
<p>​    给容器中注册一个AnnotationAwareAspectJAutoProxyCreator</p>
<h4 id="2-AnnotationAwareAspectJAutoProxyCreator"><a href="#2-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="2.AnnotationAwareAspectJAutoProxyCreator"></a>2.AnnotationAwareAspectJAutoProxyCreator</h4><p>​    AnnotationAwareAspectJAutoProxyCreator</p>
<p>​        -》父类：AspectJAwareAdvisorAutoProxyCreator</p>
<p>​            -》父类：AbstractAdvisorAutoProxyCreator</p>
<p>​                -》父类：AbstractAutoProxyCreator</p>
<p>​                        implements SmartInstantiationAwareBeanPostProcessor，, BeanFactoryAware</p>
<p>​                        关注后置处理器（在bean初始化完成前后做的事情）、自动装配BeanFactory</p>
<p>​    AbstractAutoProxyCreator.setBeanFactory(BeanFactory beanFactory)</p>
<p>​    AbstractAutoProxyCreator.中有后置处理器</p>
<h4 id="3-流程"><a href="#3-流程" class="headerlink" title="3.流程"></a>3.流程</h4><p>​    1）传入配置类，创建IOC容器</p>
<p>​    2）注册配置类，调用refresh（），刷新容器</p>
<p>​    3）registerBeanPostProcessors（beanFactory）；注册bean的后置处理器来方便拦截bean的创建</p>
<p>​        1.先获取IOC容器中已经定义的需要的创建对象的所有BeanPostProcessor</p>
<p>​        2.给容器中加入别的BeanPostProcessor</p>
<p>​        3.优先注册实现了PriorityOrdered 接口的BeanPostProcessor</p>
<p>​        4.再给容器中注册了实现了Ordered接口的BeanPostProcessor</p>
<p>​        5.注册没有实现优先级接口的BeanPostProcessor</p>
<p>​        6.注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器之中</p>
<p>​            创建 internalAutoProxyCreator 的 </p>
<p>​                BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 </p>
<p>​            1）创建Bean的实例</p>
<p>​            2）populateBean，给Bean的属性赋值</p>
<p>​            3）initializeBean 初始化Bean</p>
<p>​        还有很多 实在是看不懂了</p>
<h4 id="AOP源码总结："><a href="#AOP源码总结：" class="headerlink" title="AOP源码总结："></a>AOP源码总结：</h4><ol>
<li><p>@EnableAspectJAutoProxy 开启AOP功能</p>
</li>
<li><p>EnableAspectJAutoProxy  会给容器中注册一个AnnotationAwareAspectJAutoProxyCreator</p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator 是一个后置处理器</p>
</li>
<li><p>容器的创建流程</p>
<pre><code> 1.    registerBeanPostProcessors() 注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象
    2.    finishBeanFactoryInitialization() 初始化剩下的单实例bean
1. 创建业务逻辑组件和切面组件
2. AnnotationAwareAspectJAutoProxyCreator 拦截组件的创建过程
3. 组件创建完成之后，判断组件是否需要增强
   1. 是，切面的通知方法，包装成增强器（Advisor）；给业务逻辑组件创建一个代理对象（Cglib）。
</code></pre></li>
<li><p>执行目标方法：</p>
<pre><code>1. 代理对象执行目标方法
     2. CglibAopProxy.intercept();
         1. 得到目标方法的拦截器链，（增强器包装成拦截器MethodInterceptor）
             2. 利用拦截器的链式机制，一次进入每一个拦截器进行执行
</code></pre><ol start="3">
<li><p>效果：</p>
<p>​    正常执行：前置通知——》目标方法——》后置通知——》返回通知</p>
<p>​    异常执行：前置通知——》目标方法——》后置通知——》异常通知</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LogAspectProxy&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="meta">@Before</span></span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        	BAspectProxy&#123;</span><br><span class="line">       			 <span class="meta">@Before</span></span><br><span class="line">       			 method.invoke(obj,args);</span><br><span class="line">                 <span class="meta">@AfterReturning</span></span><br><span class="line">                <span class="comment">//..........</span></span><br><span class="line">                <span class="comment">//修改了返回值</span></span><br><span class="line">        	&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@AfterReturning</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="meta">@AfterThrowing</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="meta">@After</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个切面的环绕通知，==不会影响第二个切面==。但是如果第二个切面==修改了返回值，第一个切面感知到的返回值就不同了==。</strong></p>
<h3 id="IOC源码核心！！！："><a href="#IOC源码核心！！！：" class="headerlink" title="IOC源码核心！！！："></a>IOC源码核心！！！：</h3><p>IOC：</p>
<pre><code>1. IOC是一个容器?用什么装的？
2. 默认容器启动时，创建所有单实例对象
3. 我们可以直接从容器中获取到这个对象
</code></pre><p>SpringIOC：</p>
<pre><code>1. IOC容器的启动过程，启动期间都做了什么（**什么时候创建了单实例bean**）
2. IOC是如何创建这些单实例bean,并且是如何管理的？
3. 这些单实例bean都保存在了哪里？
</code></pre><p>思路：</p>
<p>​    从HelloWord开始，调试每个方法的作用!!</p>
<h4 id="1-ClassPathXmlApplicationContext-构造器！"><a href="#1-ClassPathXmlApplicationContext-构造器！" class="headerlink" title="1.ClassPathXmlApplicationContext 构造器！"></a>1.ClassPathXmlApplicationContext 构造器！</h4><p>ApplicationContext ioc = new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>==this(new String[] {configLocation}, true, null);==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">//对象创建，所有单实例bean创建完成</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Refresh（）方法："><a href="#2-Refresh（）方法：" class="headerlink" title="2.Refresh（）方法："></a>2.Refresh（）方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">       <span class="comment">//同步锁保证IOC容器只会被创建一次</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// 准备容器刷新</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 准备了一个Bean工厂，并解析XML文件，将所有的配置信息保存起来</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 准备Bean工厂</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">		</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//注册Bean工厂的后置处理器</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//初始化消息源，支持国际化功能</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 初始化事件转换器</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">               <span class="comment">//初始化其他的  beans 在我们的子类中   留给子类重写用的</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">               <span class="comment">//注册一些监听器 </span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//***********************************************</span></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">//初始化所有单实例bean的地方</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//***********************************************</span></span><br><span class="line">               </span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">						<span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-finishBeanFactoryInitialization-beanFactory-实现"><a href="#3-finishBeanFactoryInitialization-beanFactory-实现" class="headerlink" title="3.finishBeanFactoryInitialization(beanFactory)实现;"></a>3.finishBeanFactoryInitialization(beanFactory)实现;</h4><p>​    ==AbstractApplicationContext== 类下面的 ；Bean工厂；创建bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">	<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">	<span class="comment">//***********************************************</span></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">       <span class="comment">//初始化所有单实例bean的地方</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">       <span class="comment">//***********************************************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-preInstantiateSingletons方法"><a href="#4-preInstantiateSingletons方法" class="headerlink" title="4.preInstantiateSingletons方法"></a>4.preInstantiateSingletons方法</h4><p>​    ==DefaultListableBeanFactory==类下面的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">		<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    </span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//***********************************************</span></span><br><span class="line">    	<span class="comment">//拿到所有的要创建的bean的名称</span></span><br><span class="line">		List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    	<span class="comment">//按顺序创建bean</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="comment">//根据bean的id 获取到bean的定义信息</span></span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">//判断创建非抽象的的，单实例的，非懒加载的</span></span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">                <span class="comment">//判断是否是一个实现了Factory接口的bean</span></span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">						<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">						<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">						<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">							isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">											((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">									getAccessControlContext());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">									((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">							getBean(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//创建bean的细节</span></span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">				<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getBean-beanName-创建bean的细节"><a href="#getBean-beanName-创建bean的细节" class="headerlink" title="getBean(beanName);创建bean的细节"></a>getBean(beanName);创建bean的细节</h4><p>其实都是调用了==<strong>doGetBean(name, null, null, false)</strong>==方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doGetBean-name-null-null-false-幕后主谋"><a href="#doGetBean-name-null-null-false-幕后主谋" class="headerlink" title="doGetBean(name, null, null, false);幕后主谋"></a>doGetBean(name, null, null, false);幕后主谋</h4><p><img src="images/1.png" alt=""></p>
<p><img src="images/2.png" alt=""></p>
<ul>
<li style="list-style: none"><input type="checkbox"> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  	<span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">  			@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  </span><br><span class="line">  		<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  		Object bean;</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">      <span class="comment">//先从已经注册的所有单实例bean中找，看有没有那个bean 第一次创建是没有的</span></span><br><span class="line">  		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  					logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">  							<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">  				&#125;</span><br><span class="line">  				<span class="keyword">else</span> &#123;</span><br><span class="line">  					logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">  		&#125;</span><br><span class="line">  </span><br><span class="line">  		<span class="keyword">else</span> &#123;</span><br><span class="line">  			<span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">  			<span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">  			<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">  			&#125;</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">  			BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">  			<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">  				<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">  				String nameToLookup = originalBeanName(name);</span><br><span class="line">  				<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">  					<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">  							nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">  				&#125;</span><br><span class="line">  				<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">  					<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">  					<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">  				&#125;</span><br><span class="line">  				<span class="keyword">else</span> &#123;</span><br><span class="line">  					<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">  					<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">//标志这个bean已经被创建了</span></span><br><span class="line">  			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">  				markBeanAsCreated(beanName);</span><br><span class="line">  			&#125;</span><br><span class="line">  </span><br><span class="line">  			<span class="keyword">try</span> &#123;</span><br><span class="line">  				<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">  				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">  </span><br><span class="line">  				<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">//拿到创建当前bean之前所依赖的，需要提前创建的bean   depend-on属性  </span></span><br><span class="line">            <span class="comment">//如果有就循环创建</span></span><br><span class="line">  				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">  				<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">  					<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">  						<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">  							<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">  									<span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">  						&#125;</span><br><span class="line">  						registerDependentBean(dep, beanName);</span><br><span class="line">  						<span class="keyword">try</span> &#123;</span><br><span class="line">  							getBean(dep);</span><br><span class="line">  						&#125;</span><br><span class="line">  						<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">  							<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">  									<span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">  						&#125;</span><br><span class="line">  					&#125;</span><br><span class="line">  				&#125;</span><br><span class="line">  </span><br><span class="line">  				<span class="comment">// Create bean instance.创建bean实例</span></span><br><span class="line">  				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">  						<span class="keyword">try</span> &#123;</span><br><span class="line">  							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">  						&#125;</span><br><span class="line">  						<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">  							<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">  							<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">  							<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">  							destroySingleton(beanName);</span><br><span class="line">  							<span class="keyword">throw</span> ex;</span><br><span class="line">  						&#125;</span><br><span class="line">  					&#125;);</span><br><span class="line">  					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">  				&#125;</span><br><span class="line">  </span><br><span class="line">  				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">  					<span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">  					Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">  					<span class="keyword">try</span> &#123;</span><br><span class="line">  						beforePrototypeCreation(beanName);</span><br><span class="line">  						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">  					&#125;</span><br><span class="line">  					<span class="keyword">finally</span> &#123;</span><br><span class="line">  						afterPrototypeCreation(beanName);</span><br><span class="line">  					&#125;</span><br><span class="line">  					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">  				&#125;</span><br><span class="line">  </span><br><span class="line">  				<span class="keyword">else</span> &#123;</span><br><span class="line">  					String scopeName = mbd.getScope();</span><br><span class="line">  					<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">  					<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">  						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">  					&#125;</span><br><span class="line">  					<span class="keyword">try</span> &#123;</span><br><span class="line">  						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">  							beforePrototypeCreation(beanName);</span><br><span class="line">  							<span class="keyword">try</span> &#123;</span><br><span class="line">  								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">  							&#125;</span><br><span class="line">  							<span class="keyword">finally</span> &#123;</span><br><span class="line">  								afterPrototypeCreation(beanName);</span><br><span class="line">  							&#125;</span><br><span class="line">  						&#125;);</span><br><span class="line">  						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">  					&#125;</span><br><span class="line">  					<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">  						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">  								<span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">  								<span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">  								ex);</span><br><span class="line">  					&#125;</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">  				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">  				<span class="keyword">throw</span> ex;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  		<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">  			<span class="keyword">try</span> &#123;</span><br><span class="line">  				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">  				<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">  					<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">  				&#125;</span><br><span class="line">  				<span class="keyword">return</span> convertedBean;</span><br><span class="line">  			&#125;</span><br><span class="line">  			<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">  				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  					logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">  							ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">  				&#125;</span><br><span class="line">  				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> (T) bean;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-getSingleton方法"><a href="#5-getSingleton方法" class="headerlink" title="5.getSingleton方法"></a>5.getSingleton方法</h4><p><strong>==DefaultSingletonBeanRegistry==</strong>类下面的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance</span></span><br><span class="line"><span class="comment">	按照名字和 实例 缓存所有对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//先从一个地方将这个bean get出来</span></span><br><span class="line">			Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">							<span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line">							<span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				<span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//bean 创建 （千呼万唤始出来） 创建完成后调用添加单实例</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">					<span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">							ex.addRelatedCause(suppressedException);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    <span class="comment">//添加创建的bean</span></span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> singletonObject;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-addSingleton"><a href="#6-addSingleton" class="headerlink" title="6.addSingleton"></a>6.addSingleton</h4><p>==添加进map（ConcurrentHashMap）==</p>
<p>IOC:容器之一，保存单实例bean的地方</p>
<p>==DefaultSingletonBeanRegistry—-singletonObjects==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">		<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">		<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">		<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IOC流程源码总结！！！！！！！："><a href="#IOC流程源码总结！！！！！！！：" class="headerlink" title="IOC流程源码总结！！！！！！！："></a>IOC流程源码总结！！！！！！！：</h3><p>1）、ClassPathXmlApplicationContext 构造器   调用 Refresh()方法</p>
<p>2）、 Refresh()方法：</p>
<pre><code>1. 加上同步锁保证IOC容器只会被创建一次
2. 准备了一个Bean工厂，并解析XML文件，将所有的配置信息保存起来
3. 注册Bean工厂的后置处理器，初始化消息源，（支持国际化功能），
4. 初始化一些事件转换器，注册一些监听器 
5. 初始化其他的  beans 在我们的子类中   留给子类重写用的 方法 **onRefresh();**
6.   ==finishBeanFactoryInitialization(beanFactory);  初始化单实例的地方。==
</code></pre><p>3）、finishBeanFactoryInitialization(beanFactory) 方法</p>
<pre><code>1. AbstractApplicationContext 类下面的 ；Bean工厂；创建bean
2. 调用 beanFactory.preInstantiateSingletons();  初始化所有单实例bean的地方
</code></pre><p>4）、==preInstantiateSingletons();==</p>
<pre><code>1. 拿到所有的要创建的bean的名称
2. 按顺序创建bean (for each循环)
3. 根据bean的id 获取到bean的定义信息
4. 判断创建非抽象的的，单实例的，非懒加载的
5. 创建bean的细节 （getBean方法）
</code></pre><p>5）、==getBean方法==</p>
<ol>
<li>调用 doGetBean(name, null, null, false);</li>
</ol>
<p>6）、==doGetBean==方法</p>
<pre><code>1. 先从已经注册的所有单实例bean中找，看有没有那个bean ==第一次创建是没有的==
2. 判断拿到创建当前bean之前所依赖的，需要提前创建的bean   depend-on属性  （如果有就循环创建）
3.  调用：getSingleton（创建单实例bean）
</code></pre><p>7）、==getSingleton==方法</p>
<pre><code>1. 先从容器将这个 bean  get出来（第一次创建没有）
2. bean 创建 （千呼万唤始出来） 创建完成后调用添加单实例
3. 添加创建的bean，addSingleton方法
</code></pre><p>8）、==addSingleton==方法</p>
<pre><code>1. 用synchronized 加锁 将所有的对象添加进容器（singletonObjects）
         2. 单实例容器其实就是一个ConcurrentHashMap（256）
</code></pre><p>==getBean总结：==</p>
<ul>
<li><strong>转换 BeanName</strong></li>
<li><strong>从缓存中加载实例</strong></li>
<li><strong>实例化 Bean</strong></li>
<li><strong>检测依赖</strong></li>
<li><strong>创建 Bean</strong></li>
<li><strong>添加到 IOC 容器中</strong></li>
</ul>
<hr>
<p>面试题：</p>
<h3 id="BeanFactory和ApplicationContext-的区别："><a href="#BeanFactory和ApplicationContext-的区别：" class="headerlink" title="BeanFactory和ApplicationContext 的区别："></a>BeanFactory和ApplicationContext 的区别：</h3><ul>
<li><p>ApplicationContext 是 BeanFactory的子接口；</p>
</li>
<li><p>BeanFactory ：bean工厂接口，负责创建bean实例；容器里面的保存的所有单例bean其实是一个map，也是Spring 最底层的接口</p>
</li>
<li><p>ApplicationContext：是容器接口；更多的负责容器功能的实现；（可以基于BeanFactory创建好的对象之上完成强大的容器） 容器可以从map中获取这些bean，并且 aop，DI，实在ApplicationContext接口下的这些类里面。</p>
</li>
<li><p>==BeanFactory ：是Spring 最底层的接口； ApplicationContext：是留给我们程序员使用的IOC容器接口；ApplicationContext 是 BeanFactory 的子接口。==</p>
</li>
<li><p>==Spring里面最大模式是工厂模式。==</p>
<p><code>&lt;bean class=&quot;&quot;&gt;&lt;/bean&gt;</code>  <strong>类似于使用说明书</strong></p>
<p>BeanFactory：bean工厂；工厂模式。帮用户创建bean。</p>
</li>
</ul>
<h3 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h3><ul>
<li>singleton:默认作用域，容器里拥有唯一的Bean实例</li>
<li>prototype：针对每一个getBean请求，容器都会创建一个Bean实例</li>
<li>request：每个HTTP请求一个</li>
<li>session：每个session创建一个Bean</li>
<li>globalSession：每个全局的HTTP Session 创建一个Bean实例</li>
</ul>
<h3 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h3><p><strong>Bean的完整生命周期从 spring 容器开始实例化 bean 开始，到销毁。可以从三点来理解</strong></p>
<ul>
<li><p>1、 bean自身的方法：包括构造方法、 set 方法、 init-method 指定的方法、 destroy-method 指定的方法</p>
</li>
<li><p>2、 Bean级生命周期接口方法：如 BeanNameAware 、 BeanFactoryAware 等这些接口方法由 bean类实现。</p>
</li>
<li><p>3、 容器级生命周期接口方法：有InstantiationAware<strong>BeanPostProcessor</strong> 、 BeanPostProcessor 等。一般称为<strong>后置处理器</strong>。<strong>他们一般不由bean 本身实现，独立存在，注册到 spring 容器中</strong>。 Spring 通过接口反射预先知道，当 spring 容器创建任何 bean 时，这些后处理器都会发生作用。</p>
</li>
</ul>
<h3 id="Spring的传播机制"><a href="#Spring的传播机制" class="headerlink" title="==Spring的传播机制=="></a>==Spring的传播机制==</h3><ul>
<li>1.如果当前没有事务，就新建一个事务；如果已存在一个事务，就加入到这个事务中。</li>
<li>2.支持当前事务，如果当前没有事务，以非事务方式执行。</li>
<li>3.使用当前事务，如果当前没有事务，则抛出异常。</li>
<li>4.新建事务，如果当前存在事务，则把当前事务挂起。</li>
<li>5.以非事务方式执行，如果当前存在事务，则把当前事务挂起。</li>
<li>6.以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>7.如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 1. 类似的操作。</li>
</ul>
<h3 id="Servlet如何处理多个请求访问？"><a href="#Servlet如何处理多个请求访问？" class="headerlink" title="Servlet如何处理多个请求访问？"></a>Servlet如何处理多个请求访问？</h3><ul>
<li><p>Servlet容器默认是采用单实例多线程的方式处理多个请求的：</p>
</li>
<li><p>1.当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化(只存在一个Servlet实例)；</p>
</li>
<li><p>2.容器初始化Servlet主要就是读取配置文件（可以通过servlet.xml的设置线程池中线程数目，初始化线程池通过web.xml,初始 化每个参数值等等。</p>
</li>
<li><p>3.当请求到达时，Servlet容器通过调度线程(Dispatchaer Thread) 调度它管理下线程池中等待执行的线程（Worker Thread）给请求者；</p>
</li>
<li><p>4.线程执行Servlet的service方法；</p>
</li>
<li><p>5.请求结束，放回线程池，等待被调用；</p>
</li>
</ul>
<p>（注意：避免使用实例变量（成员变量），因为如果存在成员变量，可能发生多线程同时访问该资源时，都来操作它，照成数据的不一致，因此产生线程安全问题）</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h4><pre><code>1. 在cmd中输入命令查看被占用端口号进程号

    netstat -ano|findstr 端口号

2. 然后将进程号停掉

    taskkill /f /t /im 查询到的端口号对应的进程号
</code></pre>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC21%E7%AB%A0%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="第21章-总结"><a href="#第21章-总结" class="headerlink" title="第21章 总结"></a>第21章 总结</h1><h2 id="21-1-SpringMVC-原理总结"><a href="#21-1-SpringMVC-原理总结" class="headerlink" title="21.1 SpringMVC 原理总结"></a>21.1 SpringMVC 原理总结</h2><p>SpringMVC本质是一个Servlet，Servlet的运行需要一个Servlet容器。这里以Tomcat为例分析Servlet容器的结构和原理。Tomcat可以分为：连接器和容器。连接器，用于处理网络连接相关的事情。如：Socket连接、request封装、连接线程池维护等。容器，用于存放编写的网站程序。</p>
<p>Java提供两个Servlet的实现类：GenericServlet和HttpServlet。GenericServlet主要做了三件事：1.实现ServletConfig接口，使得可以直接调用ServletConfig中的方法。2.提供无参init()方法。3.提供log()方法。HttpServlet主要做了两件事：1.将ServletRequest和ServletResponse转换为HttpServletRequest和HttpServletResponse。2.根据Http请求(get/post等)将请求路由到7个不同的处理方法。如常见的doGet()方法和doPost()方法。</p>
<p>SpringMVC提供三个层次的Servlet：HttpServletBean | FrameworkServlet | DispatcherServlet 。HttpServletBean 用于将Servlet中配置的参数设置到相应的属性。FrameworkServlet 初始化SpringMVC中所使用的WebApplicationContext。DispatcherServlet 具体处理9大组件的初始化。</p>
<h4 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h4><p>FrameworkServlet在SpringMVC处理请求的作用：1.首先将所有类型请求转发到processRequest()方法。2.然后在processRequest()方法中做了三件事：2.1 调用doService()模板方法具体处理请求。2.2 将当前请求的LocaleContext和ServletRequestAttribute在处理请求前设置到LocaleContextHolder和RequestContextHolder，并在处理完成之后恢复。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC11%E7%AB%A0%20%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="第11章-SpringMVC组件分析"><a href="#第11章-SpringMVC组件分析" class="headerlink" title="第11章 SpringMVC组件分析"></a>第11章 SpringMVC组件分析</h1><h2 id="11-1-HandlerMapping"><a href="#11-1-HandlerMapping" class="headerlink" title="11.1 HandlerMapping"></a>11.1 HandlerMapping</h2><p>它的作用是根据request找到相应的处理器Handler和Interceptors。在HandlerMapping接口中只有一个方法：HandlerExceptionChain getHandler(HttpServletRequest request); </p>
<h2 id="11-2-HandlerAdapter"><a href="#11-2-HandlerAdapter" class="headerlink" title="11.2 HandlerAdapter"></a>11.2 HandlerAdapter</h2><p>HandlerAdapter理解为干活的人。在它里面有三个方法：1.supports(Object handler)，判断是否可以使用某个Handler。2.handle()方法是用来具体使用Handler干活。3.getLastModified()方法是获取最后一个修改的时间。</p>
<h2 id="11-3-HandlerExceptionResolver"><a href="#11-3-HandlerExceptionResolver" class="headerlink" title="11.3 HandlerExceptionResolver"></a>11.3 HandlerExceptionResolver</h2><p>在SpringMVC中专门处理异常情况的。此组件的作用是根据异常设置ModelAndView，然后交给render()方法进行渲染。render负责将ModelAndView渲染成页面。该组件HandlerExceptionResolver结构中只有一个方法，只需要从异常中解析出ModelAndView。</p>
<h2 id="11-4-ViewResolver"><a href="#11-4-ViewResolver" class="headerlink" title="11.4 ViewResolver"></a>11.4 ViewResolver</h2><p>该组件是将String类型视图名和Locale解析成View类型的视图。ViewResolver接口只有一个方法：View resolveViewName(String viewName, Locale locale);</p>
<p>最常使用的UrlBasedViewResolver系列解析器都是针对单一视图类型进行解析，比如：InternalResourceViewResolver只针对jsp类型视图。FreeMarkerViewResolver只针对FreeMarker视图。</p>
<h2 id="11-5-RequestToViewNameTranslator"><a href="#11-5-RequestToViewNameTranslator" class="headerlink" title="11.5 RequestToViewNameTranslator"></a>11.5 RequestToViewNameTranslator</h2><h2 id="11-6-LocaleResolver"><a href="#11-6-LocaleResolver" class="headerlink" title="11.6 LocaleResolver"></a>11.6 LocaleResolver</h2><p>在解析视图的时候需要两个参数：视图名和Locale。视图名是处理器返回的。Locale是LocaleResolver从request中解析出来的locale。locale表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。该接口中主要有两个方法：Locale resolveLocale(HttpServletRequest request); setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale); </p>
<h2 id="11-7-ThemeResolver"><a href="#11-7-ThemeResolver" class="headerlink" title="11.7 ThemeResolver"></a>11.7 ThemeResolver</h2><p>该组件是用来解析主题。</p>
<h2 id="11-8-MultipartResolver"><a href="#11-8-MultipartResolver" class="headerlink" title="11.8 MultipartResolver"></a>11.8 MultipartResolver</h2><p>该组件用于处理上传请求，处理方法是将普通的request包装成MultipartHttpServletRequest。该组件中有三个方法：1.isMultipart(HttpServletRequest request)：判断是否是上传请求。2.MultipartHttpServletRequest resolveMultipart(HttpServletRequest request)：将request包装成MultipartHttpServletRequest。3.cleanupMultipart(MultipartHttpServletRequest request)：清理上传过程中产生的临时资源。</p>
<h2 id="11-9-FlashMapManager"><a href="#11-9-FlashMapManager" class="headerlink" title="11.9 FlashMapManager"></a>11.9 FlashMapManager</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC3%E7%AB%A0%20Spring%20AOP%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="第3章-Spring-AOP的实现"><a href="#第3章-Spring-AOP的实现" class="headerlink" title="第3章 Spring AOP的实现"></a>第3章 Spring AOP的实现</h2><p>[toc]</p>
<h3 id="3-1-AOP概念"><a href="#3-1-AOP概念" class="headerlink" title="3.1 AOP概念"></a>3.1 AOP概念</h3><h4 id="3-1-2-Advice通知"><a href="#3-1-2-Advice通知" class="headerlink" title="3.1.2 Advice通知"></a>3.1.2 Advice通知</h4><p>Advice（通知）定义在连接点做什么，为切面增强提供织入接口。在Spring AOP中主要描述Spring AOP围绕方法调用而注入的切面行为。</p>
<p>在BeforeAdvice的继承关系中，定义了为待增强的目标方法设置的前置增强接口MethodBeforeAdvice，使用这个前置接口需要实现一个回调函数：</p>
<pre><code>void before(Method method, Object[] args, Object target) throws Throwable;
</code></pre><p>在AfterReturning-Advice接口中定义了接口方法：</p>
<pre><code>void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable;
</code></pre><p>在对于ThrowsAdvice，并没有指定需要实现的接口方法，它在抛出异常时被回调，这个回调是AOP使用反射机制来完成的。</p>
<h4 id="3-1-3-PointCut切点"><a href="#3-1-3-PointCut切点" class="headerlink" title="3.1.3 PointCut切点"></a>3.1.3 PointCut切点</h4><p>切点决定Advice通知应该作用于哪个连接点，即通过pointcut来定义需要增强方法的集合，这些集合可以选择按照一定的规则来完成。</p>
<p>在Pointcut的基本接口定义中可以看到，需要返回一个MethodMatcher。对于Point的匹配判断功能，具体是由这个返回的MethodMatcher来完成的，也就是说，由这个MethodMatcher来判断是否需要对当前方法调用进行增强，或者是否需要对当前调用方法应用配置好的Advice通知。</p>
<p>在JdkRegexpMethodPointcut的基类 StaticMethodMatcherPointcut的实现中可以看到，设置MethodMatcher为StaticMethodMatcher，同时JdkRegexpMethodPointcut也是这个MethodMatcher的子类。</p>
<p>在Pointcut的类继承关系中，MethodMatcher对象实际上是可以被配置成JdkRegexpMethodPointcut来完成方法的匹配判断的。在JdkRegexpMethodPointcut中，可以看到一个matches方法，这个matches方法是MethodMatcher定义的接口方法。在JdkRegexpMethodPointcut的实现中，这个matches方法就是使用正则表达式来对方法名进行匹配的地方。</p>
<p> 在JdkDynamicAopProxy的invoke方法中触发了对matches方法的调用。</p>
<h4 id="3-1-4-Advisor通知器"><a href="#3-1-4-Advisor通知器" class="headerlink" title="3.1.4 Advisor通知器"></a>3.1.4 Advisor通知器</h4><p>将切面切面增强设计（Advice）与切点（pointcut）结合起来的方法就是Advisor。通过Advisor可以定义应该使用哪个通知并在哪个关注点使用它。</p>
<p>在DefaultPointcutAdvisor中，有两个属性，分别是advice和pointcut。通过这两个属性，可以分别配置Advice和Pointcut。</p>
<h3 id="3-2-Spring-AOP-的设计与实现"><a href="#3-2-Spring-AOP-的设计与实现" class="headerlink" title="3.2 Spring AOP 的设计与实现"></a>3.2 Spring AOP 的设计与实现</h3><h4 id="3-2-1-JVM动态代理实现"><a href="#3-2-1-JVM动态代理实现" class="headerlink" title="3.2.1 JVM动态代理实现"></a>3.2.1 JVM动态代理实现</h4><p>在Spring AOP实现中，使用的核心技术是动态代理，而这种动态代理实际上是JDK的一个特性（在JDK 1.3以上的版本里，实现了动态代理模式）。通过JDK的动态代理特性，可以为任意Java对象创建代理对象，对于具体使用来说，这个特性是通过Java Reflection API来完成的。</p>
<p>JDK中已经实现了Proxy模式，在基于Java虚拟机设计应用程序时，只需要直接使用这个特性就可以了。具体来说，可以在Java的reflection包中看到Proxy对象，这个对象生成后，所起的作用就类似于Proxy模式中的Proxy对象。在使用时，还需要为代理对象（Proxy）设计一个回调方法，这个回调方法起到的作用是，在其中加入了作为代理需要额外处理的动作。在JDK中实现，需要实现下面所示的InvocationHandler接口：</p>
<pre><code>public interface InvocationHandler {

    public Object invoke(Object proxy, Method m, Object[] args) throws Throwable;

}
</code></pre><p>invoke方法的第一个参数是代理对象实例，第二个参数是Method方法对象，代表的是当前Proxy被调用的方法，最后一个参数是被调用的方法中的参数。</p>
<p>Proxy类中invoke()方法在反射的基础上加载类里面的方法。Proxy.newInstance()方法生成具体Proxy对象时将InvocationHandler设置到参数里面便可。</p>
<h4 id="3-2-2-Spring-AOP设计分析"><a href="#3-2-2-Spring-AOP设计分析" class="headerlink" title="3.2.2 Spring AOP设计分析"></a>3.2.2 Spring AOP设计分析</h4><p>Spring AOP的核心技术是JDK动态代理技术。以动态代理技术为基础，设计出了一系列AOP的横切实现，比如前置通知、返回通知、异常通知等。同时，Spring AOP还提供了一系列的Pointcut来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关的Pointcut方法来实现切入需求。</p>
<p>在Spring AOP中，虽然对于AOP的使用者来说，只需要配置相关的Bean定义即可，但仔细分析Spring AOP的内部设计可以看到，为了让AOP起作用，需要完成一系列过程，比如，需要为目标对象建立代理对象，这个代理对象可以通过使用JDK的Proxy来完成，也可以通过第三方的类生成器cglib来完成。然后，还需要启动代理对象的拦截器来完成各种横切面的织入，这一系列的织入设计是通过一系列Adapter来实现的。通过一系列Adapter的设计，可以把AOP的横切面设计和Proxy模式有机地结合起来，从而实现在AOP中定义好的各种织入方式。</p>
<h3 id="3-3-建立AopProxy代理对象"><a href="#3-3-建立AopProxy代理对象" class="headerlink" title="3.3 建立AopProxy代理对象"></a>3.3 建立AopProxy代理对象</h3><h4 id="3-3-1-设计原理"><a href="#3-3-1-设计原理" class="headerlink" title="3.3.1 设计原理"></a>3.3.1 设计原理</h4><p>在Spring AOP中，一个重要的部分是代理对象的生成，对于Spring应用，可以看到，是通过配置和调用Spring的ProxyFactoryBean来完成此任务的。在ProxyFactoryBean中，封装了主要代理对象的生成过程。在这个生成过程中，可以使用JDK的Proxy和CGLIB两种方式。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5376408-42bda1e019e97d1a.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="继承关系"></p>
<p>在这个类继承关系中，AspectPxoxyFactory、ProxyFactory和ProxyFactoryBean，都在同一个类的继承体系下，都是ProxyConfig、AdvicedSupport 和ProxyCreatorSupport的子类。</p>
<blockquote>
<p>共同基类ProxyConfig为ProxyFactoryBean这样的子类提供了配置属性。</p>
</blockquote>
<blockquote>
<blockquote>
<p>基类AdvisedSupport的实现中，封装了AOP对通知后台通知器的相关操作，这些操作对于不同的AOP的代理对象的生成都是一样的，但对于具体的AOP代理对象的创建，AdvisedSupport把它交给它的子类们去完成</p>
</blockquote>
</blockquote>
<blockquote>
<p>ProxyCreatorSupport，可以将它看成是其子类创建AOP代理对象的一个辅助类。</p>
</blockquote>
<p>在通过继承基类的功能实现，具体的AOP代理对象的生成，根据不同的需要，分别由ProxyFactoryBean、AspectJProxyFactory后台ProxyFactory来完成。</p>
<blockquote>
<p>提示：如果应用需要使用AspectJ AOP，AspectJProxyFactory起到集成Spring和AspectJ的作用。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：对于使用Spring AOP的应用，ProxyFactoryBean（可在IoC容器中完成声明式配置）和ProxyFactory（需要编程式使用Spring AOP）都提供了AOP功能的封装。</p>
</blockquote>
</blockquote>
<h4 id="3-3-2-配置ProxyFactoryBean"><a href="#3-3-2-配置ProxyFactoryBean" class="headerlink" title="3.3.2 配置ProxyFactoryBean"></a>3.3.2 配置ProxyFactoryBean</h4><p>在基于XML配置Spring的Bean时，往往需要一系列的配置步骤来使用ProxyFactoryBean和AOP。</p>
<pre><code>1. 定义使用的通知器Advisor，该通知器应该作为一个Bean来定义。该通知器的实现定义了需要对目标对象进行增强的切面行为，即Advice通知。

2. （配置AOP，封装AOP功能的主要类）定义ProxyFactoryBean，将它作为另一个Bean来定义，它是封装AOP功能的主要类。

    2.1 AOP代理接口

    2.2 AOP切面增强的对象

    2.3 代理拦截器，配置通知器的名称（通知器在AOP代理的配置下通过使用代理对象的拦截器机制发挥作用）

3. 定义target属性，作为target属性注入的Bean，在需要AOP通知器中的切面应用来增强的对象。
</code></pre><h5 id="1-配置-ProxyFactoryBean-分析Spring-AOP实现原理"><a href="#1-配置-ProxyFactoryBean-分析Spring-AOP实现原理" class="headerlink" title="1. 配置 ProxyFactoryBean 分析Spring AOP实现原理"></a>1. 配置 ProxyFactoryBean 分析Spring AOP实现原理</h5><p>ProxyFactoryBean是在 Spring IoC 环境中创建AOP应用的底层方法，是一个非常灵活的创建AOP应用的底层方法，Spring通过其完成对AOP使用的封装。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5376408-48158ac92e37feee.png?imageMogr2/auto-orient/strip|imageView2/2/w/650/format/webp" alt="配置ProxyFactoryBean"></p>
<h4 id="3-3-3-ProxyFactoryBean生成AopProxy代理对象"><a href="#3-3-3-ProxyFactoryBean生成AopProxy代理对象" class="headerlink" title="3.3.3 ProxyFactoryBean生成AopProxy代理对象"></a>3.3.3 ProxyFactoryBean生成AopProxy代理对象</h4><p>我们知道通过 ProxyFactoryBean 来配置目标对象和切面行为。该 ProxyFactoryBean 是一个 FactoryBean。在ProxyFactoryBean中通过interceptorNames属性（通知器将切面行为Advice应用到目标对象中）来配置已经定义好的通知器 Advisor 。</p>
<p>在 ProxyFactoryBean 中需要为 target目标对象 生成 Proxy 代理对象，从而为AOP横切面的编织做好准备工作。</p>
<pre><code>initializeAdvisorChain()：初始化通知器链,通知器链中封装了一系列从配置中读取的拦截器,为代理对象的生成做好准备。 

getSingletonInstance()：生成Singleton类型的Proxy 。

DefaultAopProxyFactory ：AopProxy接口类,AopProxy有两个子类实现,一个是JdkDynamicAopProxy,一个是CglibProxyFactory 。
</code></pre><p>从FactoryBean中获取对象是以getObject方法作为入口完成的，ProxyFactoryBean实现中的getObject()方法，是FactoryBean需要实现的接口。对ProxyFactoryBean来说，需要对目标对象增加的增强处理，都通过了getObject方法进行了封装，这些增强处理是为AOP功能的实现提供服务的。getObject的实现清单如下。getObect()方法首先对通知器进行了初始化，通知器封装了一系列的拦截器，这些拦截器都要从配置文件中获取，然后为代理对象的生成做好准备。在生成代理对象时，因为Spring中有singleton类型和prototype类型这两种不同的bean，所有要对代理对象进行一个区分。</p>
<p>为Proxy代理对象配置Advisor链是在initializeAdvisorChain方法中实现的。这个初始化的工作发生在应用第一次通过ProxyFactoryBean去获取代理对象的时候。在完成这个初始化之后，接着读取配置中出现的所有通知器，这个取得通知器的过程也比较简单，把通知器的名字交给容器的getBean方法就可以了，这是通过对IOC容器实现的一个回调完成的。然后把从IOC容器中取得的通知器加入到拦截器链中，这个动作是由addAdvisorOnChainCreation方法来实现的。</p>
<p>接着在getObject()方法中，将会执行getSingletonInstance()方法，该方法主要是生成代理对象并封装对target目标对象的调用（即加入拦截器）。具体的生成过程是，首先读取ProxyFactoryBean中的配置，为生成代理对象做好必要的准备，比如设置代理的方法接口调用等。Spring通过AopProxy类来具体生成代理对象。对于getSingletonInstance()方法中代理对象的生成过程。</p>
<p>Spring利用AopProxy接口类把AOP代理对象的实现与框架其他部分有效隔离开来。AopProxy接口有两个子类实现，一个Cglib2AopProxy，另一个是JdkDynamicProxy。 具体代理对象的生成是在ProxyFactoryBean的基类AdvisedSupport中实现，借助AopProxyFactory完成，这个对象要么从JDK中生成，要么借助CGLIB获得。</p>
<p>AOP Proxy的生成的两种方式（JDK或CGLIB提供的Proxy特性）。如果目标对象是接口类使用JDK来生成，否则Spring会使用CGLIB来生成目标的代理对象。</p>
<p>在AopProxy代理对象的生成过程中，首先要从AdviseSupport对象中取得配置的目标对象，AOP完成的是切面应用对目标应用对象的增强。如果这里没有配置目标对象会直接抛出异常。一般而言，默认方式是使用JDK来产生AopProxy代理对象，但如果配置的目标对象不是接口类的实现，会使用CGLIB来产生AopProxy代理对象；在使用CGLIB来产生AopProxy代理对象时，因为CGLIB是第三方类库，本身不在JDK基类库中，所有需要在classPath中正确配置，以便能够加载和利用。在Spring中，使用JDK和CGLIB来生成AopProxy代理对象的工作，是由JdkDynamicAopProxy和CglibProxyFactory来完成。</p>
<h4 id="3-3-4-JDK生成AopProxy代理对象"><a href="#3-3-4-JDK生成AopProxy代理对象" class="headerlink" title="3.3.4 JDK生成AopProxy代理对象"></a>3.3.4 JDK生成AopProxy代理对象</h4><p>newProxyInstance方法:需要指明3个参数（类装载器,代理接口,Proxy回调方法所在的对象,这个对象要实现InvocationHandler接口）。InvocationHandler接口:类装载器,代理接口,Proxy回调方法所在的对象,这个对象要实现InvocationHandler接口。反射类接口,定义了invoke方法,提供代理对象的回调入口。</p>
<h4 id="3-3-5-CGLIB生成AopProxy代理对象"><a href="#3-3-5-CGLIB生成AopProxy代理对象" class="headerlink" title="3.3.5 CGLIB生成AopProxy代理对象"></a>3.3.5 CGLIB生成AopProxy代理对象</h4><p>配置Enhancer对象,通过Enhancer对象的callback回调设置生成代理对象。其中通过设置DynamicAdvisedInterceptor拦截器来完成AOP功能的。</p>
<h3 id="3-4-Spring-AOP拦截器调用的实现"><a href="#3-4-Spring-AOP拦截器调用的实现" class="headerlink" title="3.4 Spring AOP拦截器调用的实现"></a>3.4 Spring AOP拦截器调用的实现</h3><h4 id="3-4-1-设计原理"><a href="#3-4-1-设计原理" class="headerlink" title="3.4.1 设计原理"></a>3.4.1 设计原理</h4><p>在Spring AOP通过JDK的Proxy方式或CGLIB方式生成代理对象的时候，相关的拦截器已经 配置到 代理对象中去了，拦截器在代理对象中起作用是通过对这些方法的回调来完成的。</p>
<p>如果使用JDK的Proxy来生成代理对象，那么需要InvocationHandler来设置拦截器回调，而如果使用CGLIB来生成代理对象，通过DynamicAdvisedInterceptor来完成回调。</p>
<h4 id="3-4-2-JdkDynamicAopProxy的invoke拦截"><a href="#3-4-2-JdkDynamicAopProxy的invoke拦截" class="headerlink" title="3.4.2 JdkDynamicAopProxy的invoke拦截"></a>3.4.2 JdkDynamicAopProxy的invoke拦截</h4><p>在 JdkDynamicAopProxy 生成代理对象时，它的AopProxy代理对象生成调用。</p>
<pre><code>Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);

- this 表示InvocationHandler对象，InvocationHandler是JDK定义反射类的一个接口，这个接口定义了invoke方法，此方法为回调方法。
</code></pre><p>通过invoke()方法的具体实现，来完成对目标对象方法调用的拦截器或者功能增强工作。在这个方法中，包含一个完整的拦截器链对目标对象的拦截过程，比如获取拦截器链中的拦截器进行配置，逐个运行拦截器链里的拦截器增强，知道最后的目标对象方法的运行。</p>
<h4 id="3-4-3-CglibAopProxy的intercept拦截器"><a href="#3-4-3-CglibAopProxy的intercept拦截器" class="headerlink" title="3.4.3 CglibAopProxy的intercept拦截器"></a>3.4.3 CglibAopProxy的intercept拦截器</h4><h4 id="3-3-4-目标方法的调用"><a href="#3-3-4-目标方法的调用" class="headerlink" title="3.3.4 目标方法的调用"></a>3.3.4 目标方法的调用</h4><p>如果没有拦截器会对目标对象方法直接调用。对于JDKDynamicAopProxy代理对象是通过AopUtils使用反射机制实现的。在这个调用方法中首先得到调用方法的反射对象，然后使用invoke启动对方法反射对象的调用。</p>
<p>使用Cglib2AopProxy的代理对象，其目标对象的调用是通过CGLIB的MethodProxy对象直接完成。</p>
<pre><code>retVal=methodProxy.invoke(target,args);
</code></pre><h4 id="3-4-5-AOP拦截器的调用"><a href="#3-4-5-AOP拦截器的调用" class="headerlink" title="3.4.5 AOP拦截器的调用"></a>3.4.5 AOP拦截器的调用</h4><p>在AOP如何完成对目标的增强时，这些都是封装在AOP拦截器链中，由具体的拦截器完成。</p>
<p>无论是使用JDKDynamicAopProxy还是使用CglibAopProxy创建代理对象最终对AOP拦截链的调用都是在ReflectiveMethodInvocation中通过proceed方法实现的。</p>
<p>在proceed方法中逐个运行拦截器的拦截方法。在运行拦截器的拦截方法之前需要对代理方法完成一个匹配，通过这个匹配判断来决定拦截器是否满足切面增强的要求。</p>
<h4 id="3-4-6-配置通知器"><a href="#3-4-6-配置通知器" class="headerlink" title="3.4.6 配置通知器"></a>3.4.6 配置通知器</h4><p>在AopProxy代理对象拦截回调过程之前，我们先回到 ReflectionMethodInvocation 类的 proceed() 方法，在这个方法里，可以看到得到了配置的 interceptorOrInterceptionAdvice 。</p>
<pre><code>Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
</code></pre><p>interceptorOrInterceptionAdvice是获得的拦截器，它通过拦截器机制对目标对象进行增强。这个拦截器来自interceptorsAndDynamicMethodMatchers。</p>
<p>具体来说上面的interceptorOrInterceptionAdvice是interceptorsAndDynamicMathers持有的List中的一个元素。</p>
<h4 id="3-4-7-Advice通知的实现"><a href="#3-4-7-Advice通知的实现" class="headerlink" title="3.4.7 Advice通知的实现"></a>3.4.7 Advice通知的实现</h4><p>AopProxy代理对象生成时，其拦截器也一并生成。</p>
<p>在为AopProxy配置拦截器的实现中，有一个取得拦截器配置过程，这个过程由DefaultAvisorChainFactory实现的，而这个工厂类负责生成拦截器链，在它的getInterceptorsAndDynamicInterceptionAdvice方法中，有一个适配器的注册过程，通过配置Spring预先设计好的拦截器，Spring加入了它对Aop实现的处理。</p>
<p>为详细了解这个过程，先从DefaultAdvisorChainFactory的实现开始，通过以下代码可以看到，在DefaultAdvisorChainFactory实现中，首先构造了一个GlobalAdvisorAdapterRegistry单件，然后对配置的Advisor通知器进行逐个遍历，这些通知链都是配置在interceptorNames中的，从getInterceptorsAndDynamicInterceptionAdvice传递进来的advised参数对象中，可以方便的取得配置的通知器，有了这些通知器，接着就是一个由 GlobalAdvisorAdapterRegistry来完成的拦截器的适配和注册。</p>
<p>GlobalAdvisorAdapterRegistry 的 getInterceptors() 方法为AOP的实现做出了很大的贡献，这个方法封装着 advice 织入实现的入口，我们先从 GlobalAdvisorAdapterRegistry 的实现入手，它基本起一个适配器的作用，但同时也是单例模式。</p>
<p>我们知道在DefaultAdvisorAdapterRegistry中，设置了一系列的adapter适配器，这是这些适配器的实现，为Spring的advice提供了编织能力。</p>
<p>Adapter的具体作用：</p>
<pre><code>1. 调用adapter的support方法，通过这个方法来判断取得的advice属于什么类型的advice通知，从而根据不同的advice类型来注册不同的AdviceInterceptor，也就是前面我们看到的拦截器。

2. 这些AdviceInterceptor都是Spring AOP框架设计好的，是为实现不同的advice功能提供服务的。有了这些AdviceInterceptor，可以方便的使用由Spring提供的各种不同的advice来设计AOP应用。也就是说，正是这些AdviceInterceptor最终实现了advice通知在AopProxy对象中的织入功能。

3. 在DefaultAdvisorRegistry的getInterceptors调用中，从MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdaper这几个通知适配器的名字上可以看出和Advice一一对应，在这里，他们作为适配器被加入到adapter的List中，他们都是实现AdvisorAdapter接口的同一层次的类，只是各自承担着不同的适配的任务，一对一的服务于不同的advice实现。
</code></pre><p>Spring AOP为了实现advice的织入，设计了特定拦截器对这些功能进行了封装。虽然应用不会直接用到这些拦截器，但却是advice发挥作用不可缺少的准备。</p>
<h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><p>在通过ProxyFactoryBean实现AOP整个过程中，它的实现首先需要对 目标对象以及拦截器 进行正确的配置，以便 AopProxy代理对象 正确产生。（这些配置可以通过配置 ProxyFactoryBean 的属性来完成或通过编程式地使用ProxyFactory来实现）。</p>
<blockquote>
<p>提示：通过 ProxyFactory 类，我们可以控制哪些方面需要被织入到代理中去。</p>
</blockquote>
<p>在生成AopProxy代理对象的时候，Spring AOP专门设计了AopProxy代理对象的生产工厂（AopProxyFactory）来生产AopProxy代理对象。默认使用的生产工厂（DefaultAopProxyFactory - 该生产工厂定义了AopProxy代理对象的生成策略（JDK或CGLIB））。而最终的AopProxy对象的产生则交给JdkDynamicAopProxy和Cglib2AopProxy这两个具体的工厂来完成。</p>
<blockquote>
<p>提示：我们可以看到 ProxyFactory 内部将生成代理对象的过程转交给一个 DefaultAopProxyFactory 对象来完成。后者又根据程序中的设置将其转交给一个 Cglib2AopProxy 或者 JdkDynamicAopProxy 来完成。</p>
</blockquote>
<p>在得到AopProxy代理对象后，在代理的接口方法被调用执行的时候，在AopProxy暴露代理的方法被调用的时候，前面定义的Proxy机制就起作用。Proxy对象暴露的方法调用时，并不是直接运行目标对象中的方法。而是首先会触发对这些方法调用进行拦截，这些拦截对目标调用的增强提供了工作空间。</p>
<p>拦截过程在JDK的Proxy代理对象中，通过invoke()方法来完成，该方法是虚拟机触发的一个回调。在CGLIB的Proxy代理对象中，拦截是由设置好的回调callback()方法来完成的。</p>
<blockquote>
<p>提示：在有了上面的拦截器的作用，才会有AOP切面的大作用。</p>
</blockquote>
<p>在ProxyFactoryBean的回调中，首先会根据配置来对拦截器是否与当前的调用方法相匹配进行判断。</p>
<h4 id="声明式的Spring-AOP编程"><a href="#声明式的Spring-AOP编程" class="headerlink" title="声明式的Spring AOP编程"></a>声明式的Spring AOP编程</h4><p>首先看一下声明式的 Spring AOP 编程，在 ProxyFactoryBean 中，它的 AOP 实现需要依赖 JDK 或者 CGLIB 提供的 Proxy 特性。从 FactoryBean 中取得对象，是用 getObject() 方法作为入口完成的。</p>
<p>在 getObject() 方法中， Spring 使用这个 AopProxy 接口把 AOP 代理对象的实现与框架的其他部分有效地分离。 AopProxy 接口有两个子类实现，一个时 cglib2AopProxy ，另一个是 JdkDynamicProxy 。</p>
<p>创建 AopProxy 的过程是在 AopProxyFactory 中进行的，在 Spring 中， AopProxyFactory 使用的是 DefaultAopProxyFactory 。这个被使用的 DefaultAopProxyFactory ，作为 AopProxy 的创建工厂对象。有了这个 AopProxyFactory 对象以后，我们再到 DefaultAopProxyFactory 中看一下 AopProxy 是怎样生成的。</p>
<p>关于 AopProxy 代理对象的生产，需要考虑使用哪种生成方法，如果目标对象是接口类，那么适合使用 JDK 来生成代理对象，否则 Spring 会使用 CGLIB 来生成目标对象的代理对象。为了满足不同的代理对象生成的要求， DefaultAopProxyFactory 作为 AopProxy 的生产工厂，可以根据不同的需要生成两种 AopProxy 对象。</p>
<p>这样就分别得到了 JdkDynamicAopProxy 对象和 Cglib2AopProxy 对象，剩下的问题就是分别在两个产生代理对象的类中生成除代理对象。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC2%E7%AB%A0%20Spring%20IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="第2章-Spring-Framework的核心-IoC容器的实现"><a href="#第2章-Spring-Framework的核心-IoC容器的实现" class="headerlink" title="第2章 Spring Framework的核心 - IoC容器的实现"></a>第2章 Spring Framework的核心 - IoC容器的实现</h2><p>[TOC]</p>
<h3 id="2-1-Spring-IOC容器概述"><a href="#2-1-Spring-IOC容器概述" class="headerlink" title="2.1 Spring IOC容器概述"></a>2.1 Spring IOC容器概述</h3><h4 id="2-1-1-IOC容器依赖反转模式"><a href="#2-1-1-IOC容器依赖反转模式" class="headerlink" title="2.1.1 IOC容器依赖反转模式"></a>2.1.1 IOC容器依赖反转模式</h4><p>通过将对象的依赖注入交给框架或IOC容器来完成。它可以在对象生成或初始化时直接将数据注入到对象中，或可以通过将对象引用注入到对象数据域中的方式来注入对方法调用的依赖。IOC容器进行对象关系的管理，并由IOC容器完成对象的注入。</p>
<h4 id="2-1-2-Spring-IOC的应用场景"><a href="#2-1-2-Spring-IOC的应用场景" class="headerlink" title="2.1.2 Spring IOC的应用场景"></a>2.1.2 Spring IOC的应用场景</h4><p>在Spring中，Spring IoC提供了基本的JavaBean容器，通过IoC模式管理以来关系，并通过依赖注入和AOP切面增强了为JavaBean这样的POJO对象赋予事务管理、生命周期管理等基本功能。</p>
<h3 id="2-2-IoC容器系列的设计与实现-BeanFactory-ApplicationContext"><a href="#2-2-IoC容器系列的设计与实现-BeanFactory-ApplicationContext" class="headerlink" title="2.2 IoC容器系列的设计与实现 BeanFactory | ApplicationContext"></a>2.2 IoC容器系列的设计与实现 BeanFactory | ApplicationContext</h3><p>在SpringIoC容器的设计中，主要有两个容器系列：1.实现BeanFactory接口的简单容器系列，实现容器的基本功能。2.ApplicationContext应用上下文，在BeanFactory的基础上增添了功能，它作为容器的高级形态存在。扩展了BeanFactory。</p>
<p>BeanFactory与ApplicationContext都是容器的具体表现形式。BeanFactory体现了Spring为提供给用户使用的IOC容器所设定的最基本的功能规范。在Spring提供IOC容器基本定义基础上，Spring通过定义BeanDefinition来管理基于Spring的应用中各种对象以及他们之间的相互依赖关系。</p>
<p>BeanDefinition抽象了我们对Bean的定义，是让容器起作用的主要数据类型。对Ioc容器而言，BeanDefinition就是对反转依赖模式管理的对象的依赖关系的数据抽象。如：容器里面装的水。</p>
<p>AbstractApplicationContext 是整个容器的核心处理类，是真正的Spring容器的执行者，在内部使用了模板方法。</p>
<h4 id="2-2-2-Spring-Ioc容器设计"><a href="#2-2-2-Spring-Ioc容器设计" class="headerlink" title="2.2.2 Spring Ioc容器设计"></a>2.2.2 Spring Ioc容器设计</h4><p>从BeanFactory到HierarchicalBeanFactory，再到ConfigurableBeanFactory，这是一条主要的Beanfactory设计路径，该路径定义了基本的IoC容器的规范。而第二条接口设计主线是以ApplicationContext为主的接口设计。</p>
<h5 id="1-BeanFactory应用场景"><a href="#1-BeanFactory应用场景" class="headerlink" title="1. BeanFactory应用场景"></a>1. BeanFactory应用场景</h5><p>BeanFactory提供最基本的IOc容器功能。其只是一个接口类，没有给出容器的具体实现。而其它的各种类(DefaultListableBeanFactory/XmlBeanFactory/ApplicationContext)等都可以看做是容器附加某种功能的具体实现。</p>
<blockquote>
<p>提示：FactoryBean 与 BeanFactory</p>
</blockquote>
<blockquote>
<blockquote>
<p>通过转移字符&amp;来得到FactoryBean本身，用来区分通过容器来获取FactoryBean产生的对象和获FactoryBean本身。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>FactoryBean 和 BeanFactory ，前面是factory，是ioc容器或对象工厂。后者是bean，在spring中，所有的bean都是由BeanFactory（IOC容器）进行管理的。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：FactoryBean不是简单的Bean，是一个能够产生或者修饰对象生成的工厂Bean，它的实现和设计模式中的工厂模式类似。</p>
</blockquote>
<h5 id="2-BeanFactory容器的设计原理"><a href="#2-BeanFactory容器的设计原理" class="headerlink" title="2. BeanFactory容器的设计原理"></a>2. BeanFactory容器的设计原理</h5><p>DefaultListableBeanFactory包含了基本IoC容器所具有的的重要功能，作为Spring中的默认的功能完整的IoC容器来使用。</p>
<p>XmlBeanFactory继承DefaultListableBeanFactory，除了具备基本的功能之外，还具备读取以XML文件定义的BeanDefinition的能力。</p>
<p>XML文件是由XmlBeanFactory初始化的XmlBeanDefinitionReader来处理以XML方式定义的BeanDefinition。构造XmlBeanFactory这个IoC容器需要Resource类给出BeanDefinition的信息来源。Resource是Spring用来封装I/O操作的类，例如ClassPathResource(“*.xml”)等。</p>
<p>XmlBeanFactory 是一个与XML相关的BeanFacotory，也就是说它是一个读取以XML文件方式定义的BeanDefinition的IOC容器。</p>
<p>在使用IOC容器的几个步骤：</p>
<pre><code>1. 创建IOC配置文件的抽象资源，抽象资源包括BeanDefinition的定义信息。

2. 创建一个BeanFactory，这里使用DefaultListableBeanFactory。

3. 创建一个载入BeanDefinition的读取器，如XmlBeanDefinitionReader来载入XML文件形式的BeanDefinition，通过一个回调配置给BeanFactory。

4. 从定义好的资源位置读入配置信息。在完成载入和注册Bean之后，需要的ioc容器建立起来，此时可以直接使用ioc容器。
</code></pre><h5 id="3-ApplicationContext应用场景"><a href="#3-ApplicationContext应用场景" class="headerlink" title="3. ApplicationContext应用场景"></a>3. ApplicationContext应用场景</h5><p>ApplicationContext在已有IOC容器基本功能基础上提供附加功能，使得其更方便使用。</p>
<pre><code>1. 支持不同信息源，ApplicationContext扩展了MessageSource接口。支持国际化实现。

2. 访问资源，体现在ResourceLoader和Resource支持上。可从不同地方获取Bean定义的资源。

3. 支持应用事件。继承了接口ApplicationEventPublisher，从而在上下文中引入了事件机制。这些事件和Bean 的生命周期的结合为Bean 的管理提供了便利。

4. 在ApplicationContext 中提供的附加服务。这些服务使得基本的 IoC 容器的基本功能更加丰富。
</code></pre><p>在经过上面的种种讨论我们清楚在应用开发的过程中使用ApplicationContext作为IOC容器的基本形式。</p>
<h5 id="4-ApplicationContext容器设计原理"><a href="#4-ApplicationContext容器设计原理" class="headerlink" title="4. ApplicationContext容器设计原理"></a>4. ApplicationContext容器设计原理</h5><p>在ApplicationContext的容器中，常以 FileSystemXmlApplicationContext 来说明 ApplicationContext 容器的设计原理。</p>
<p>ApplicationContext 主要功能在FileSystemXmlApplicationContext 的基类AbstractXmlApplicationContext中已经实现了，在FileSystemXmlApplicationContext 中，作为一个具体的应用上下文，只需要实现和它自身设计相关的2个功能。</p>
<p>第1个功能，如果应用直接使用FileSystemXmlApplicationContext ，对于实例化这个应用上下文的支持，同时启动IoC容器的refresh()过程。</p>
<p>第2个功能，与FileSystemXmlApplicationContext 设计具体相关的功能，这部分与怎样从文件系统中加载XML的bean定义资源有关。</p>
<h3 id="2-3-Ioc容器初始化过程"><a href="#2-3-Ioc容器初始化过程" class="headerlink" title="2.3 Ioc容器初始化过程"></a>2.3 Ioc容器初始化过程</h3><p>IOc容器的初始化是由refresh()方法来启动的，该方法标志ioc容器的正式启动。该方法包括BeanDefinition的Resource定位、载入和注册三个基本过程。</p>
<blockquote>
<p>提示：Spring 把这三个过程分开，并使用不同的模块来完成，从而方便自己定义IoC 容器的初始化过程。</p>
</blockquote>
<pre><code>1. BeanDefinition的Resource定位过程。Resource定位表示BeanDefinition的资源定位过程，它是由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一接口。对于BeanDefinition 的存在形式，可以是文件系统中的通过FileSystemResource 来进行抽象；类路径中定义的Bean 信息可以通过ClassPathResource 来进行抽象。这个定位过程类似于容器寻找数据的过程。

2. BeanDefinition的载入。载入过程是将用户定义好的Bean表示成IOC容器内部的数据结构，该容器内部的数据结构是BeanDefinition。BeanDefinition 实际上就是POJO 对象在IoC 容器中的抽象，通过这个BeanDefinition 定义的数据结构，使IoC 容器能够方便地管理Bean。

3. BeanDefinition的注册。注册过程是通过BeanDefinitionRegistry 接口的实现来完成的。注册过程把载入过程中解析得到BeanDefinition 向IoC 容器进行注册。在IoC 容器内部将BeanDefinition 注入到一个HashMap 中去，IoC 容器就是通过这个HashMap 来持有这些Bean 数据的。
</code></pre><blockquote>
<p>提示：上面的IOC初始化过程不包括Bean依赖注入的实现。在Spring IoC 的设计中，Bean 定义的载入 和 依赖注入是两个独立的过程。依赖注入一般发生在第一个通过getBean() 向容器中获取Bean 的时候，也并不全是这样，例如某个Bean 设置了lazyinit 属性，那么Bean 的依赖注入在其初始化的过程中就已经完成了，而不需要等到整个容器初始化完成之后，第一次使用getBean()才会触发。</p>
</blockquote>
<h4 id="2-3-1-BeanDefinition的Resource定位过程"><a href="#2-3-1-BeanDefinition的Resource定位过程" class="headerlink" title="2.3.1 BeanDefinition的Resource定位过程"></a>2.3.1 BeanDefinition的Resource定位过程</h4><p>在以编程的方式使用 DefaultListableBeanFactory 时，首先定义一个Resource来定位容器使用的BeanDefinition。使用ClassPathResource，意味着Spring会在类路径中去寻找以文件形式存在的BeanDefinition信息 。</p>
<pre><code>ClassPathResource res = new ClassPathResource(&quot;beans.xml&quot;);
</code></pre><blockquote>
<p>提示：这里定义的Resource并不能由DefaultListableBeanFactory直接使用，Spring通过BeanDefinitionReader来对这些信息进行处理。</p>
</blockquote>
<p>我们回到常用的ApplicationContext上，如：FileSystemXmlApplicationContext、ClassPathXmlApplicationContext、XmlWebApplicationContext等。简单地从这些类的名字上分析，可以清楚地看到它们可以提供哪些不同的Resource读入功能。</p>
<blockquote>
<p>提示：我们可以清楚的知道，对BeanDefinition 资源定位的过程，是由refresh() 方法触发的，refresh() 方法的调用是在FileSystemXmlApplicationContext 的构造函数中启动的。</p>
</blockquote>
<p>在BeanDefinition 定位完成基础上，就可通过返回的Resource 对象进行BeanDefinition 载入。在完成定位过程后，为BeanDefinition 的载入创造了I/O 操作的条件，但具体的数据还没有开始读入，读入将在BeanDefinition的载入和解析中完成。</p>
<h4 id="2-3-2-BeanDefinition的载入和解析"><a href="#2-3-2-BeanDefinition的载入和解析" class="headerlink" title="2.3.2 BeanDefinition的载入和解析"></a>2.3.2 BeanDefinition的载入和解析</h4><p>在完成BeanDefinition的Resource定位的后，便可进行BeanDefinition信息的载入过程。该过程相当于把定义的BeanDefinition在IoC容器中转化成一个Spring内部表示的数据结构的过程。IoC容器对Bean的管理和依赖注入功能的实现，是通过对其持有的BeanDefinition进行各种相关操作来完成的。这些BeanDefinition数据在IoC容器中通过一个HashMap来保持和维护。</p>
<p>将定义的BeanDefinition在ioc容器中转换成一个Spring内部表示的数据结构的过程。Ioc容器对Bean管理和依赖注入的实现是通过对其持有的BeanDefinition进行各种相关操作完成的。</p>
<p>从DefaultListableBeanFactory的设计入手来看IoC容器是怎样完成BeanDefinition载入的。先回到IoC容器的初始化入口refresh（）方法。该方法最初是在FileSystemXmlApplicationContext的构造函数中被调用的，它的调用标志着容器初始化的开始，这些初始化对象就BeanDefinition数据，初始化入口函数：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5376408-ee4228c6fcf9aadd.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="启动BeanDefinition的载入"></p>
<p>于容器的启动来说，refresh()方法是一个很重要的方法。该方法在AbstractApplicationContext类（是FileSystemXmlApplicationContext的基类）中找到，它详细描述了整个ApplicationContext的初始化过程。如：BeanFactory的更新、MessageSource和PostProcessor的注册。</p>
<pre><code>refresh()方法在ioc容器中执行的过程：

    1. 子类启动refreshBeanFactory()

    2. 设置BeanFactory的后置处理

    ...
</code></pre><p>读入器的配置，可以在FileSystemXmlApplicationContext 的基类AbstractRefreshableApplicationContext 中的refreshBeanFactory() 方法的实现中查看。refreshBeanFactory() 方法被FileSystemXmlApplicationContext 构造函数中的refresh() 方法所调用。在该方法中，通过createBeanFactory() 创建一个DefaultListableBeanFactory 的IoC 容器供ApplicationContext 使用。同时，还启动了loadBeanDefinitions() 来载入BeanDefinition。</p>
<p>调用的loadBeanDefinitions(Resource res)方法在AbstractBeanDefinitionReader类里是没有实现的，具体的实现在XmlBeanDefinitionReader中。在读取器中，需要得到封装了对XML文件的I/O操作的代表XML文件的Resource，读取器可以在打开I/O流后得到XML的文件对象。有了这个文件对象以后，就可按照Spring的Bean定义规则来对这个XML的文档树进行解析了，该解析是交给BeanDefinitionParserDelegate来完成的。</p>
<p>在完成资源的载入后，需要将载入的BeanDefinition进行解析并转化为IoC容器内部数据结构,这个过程在registerBeanDefinitions()成，具体是由BeanDefinitionsDocumentReader来完成。</p>
<h5 id="BeanDefinition-的载入"><a href="#BeanDefinition-的载入" class="headerlink" title="BeanDefinition 的载入"></a>BeanDefinition 的载入</h5><p>首先，通过调用XML的解析器得到document对象。</p>
<p>然后，按照Spring的Bean规则进行解析。按照Spring的Bean规则进行解析的过程是在默认设置好的DefaultBeanDefinitionDocumentReader中实现的。DefaultBeanDefinitionDocumentReader的创建是在后面的方法中完成的，然后再完成BeanDefinition的处理，处理的结果由BeanDefinitionHolder对象持有。这个BeanDefinitionHolder除了持有BeanDefinition对象外，还持有其他与BeanDefinition的使用相关的信息，比如Bean的名字、别名集合等。这个BeanDefinitionHolder的生成是通过对Document文档树的内容进行解析来完成的，可看到该解析过程是由BeanDefinitionParserDelegate实现的（processBeanDefinition方法中实现）的，同时这个解析是与Spring对BeanDefinition的配置规则紧密相关的。</p>
<blockquote>
<p>提示：具体的BeanDefinition的解析是在BeanDefinitionParserDelegate中完成的。</p>
</blockquote>
<p>在上面过程中介绍了对Bean元素进行解析的过程，也就是BeanDefinition依据XML的定义被创建的过程。这个BeanDefinition可以看成是对定义的抽象。这个数据对象中封装的数据大多都是与定义相关的，也有很多就是我们在定义Bean时看到的那些Spring标记，比如常见的init-method、destroy-method、factory-method等。</p>
<p>beanClass、description、lazyInit这些属性都是在配置bean时经常碰到的，都集中在BeanDefinition。通过解析以后，便可对BeanDefinition元素进行处理，在这个过程中可以看到对Bean定义的相关处理，比如对元素attribute值的处理，对元素属性值的处理，对构造函数设置的处理，等等。</p>
<h4 id="2-3-3-BeanDefinition在ioc容器中的注册"><a href="#2-3-3-BeanDefinition在ioc容器中的注册" class="headerlink" title="2.3.3 BeanDefinition在ioc容器中的注册"></a>2.3.3 BeanDefinition在ioc容器中的注册</h4><p>BeanDefinition在IoC容器中载入和解析的过程完成以后，用户定义的BeanDefinition信息已经在IoC容器内建立起了自己的数据结构以及相应的数据表示，但此时这些数据还不能供IoC容器直接使用，需要在IoC容器中对这些BeanDefinition数据进行注册。在DefaultListableBeanFactory中，是通过一个HashMap来持有载入的BeanDefinition的，这个HashMap的定义在DefaultListableBeanFactory中可以看到，如下所示。</p>
<pre><code>private final Map beanDefinitionMap = new  ConcurrentHashMap();
</code></pre><p>将解析得到的BeanDefinition向IoC容器中的beanDefinitionMap注册的过程是在载入BeanDefinition完成后进行的。</p>
<p>在DefaultListableBeanFactory中实现了BeanDefinitionRegistry的接口，该接口的实现完成BeanDefinition向容器的注册。注册过程就是把解析得到的BeanDefinition设置到 hashMap中去。需要注意的是，如果遇到同名的BeanDefinition，进行处理的时候需要依据allowBeanDefinitionOverriding的配置来完成。</p>
<p>完成了BeanDefinition的注册，就完成了IoC容器的初始化过程。此时，在使用的IoC容器DefaultListableBeanFactory中已经建立了整个Bean的配置信息，而且这些BeanDefinition已经可以被容器使用了，它们都在beanDefinitionMap里被检索和使用。容器的作用就是对这些信息进行处理和维护。</p>
<blockquote>
<p>总结：初始化过程主要工作是在ioc容器中建立BeanDefinition数据映射。</p>
</blockquote>
<h3 id="2-4-ioc容器的依赖注入"><a href="#2-4-ioc容器的依赖注入" class="headerlink" title="2.4 ioc容器的依赖注入"></a>2.4 ioc容器的依赖注入</h3><p>初始化过程主要工作是在ioc容器中建立BeanDefinition数据映射。</p>
<p>当前IoC容器已经载入了用户定义的Bean信息，我们注意到用户第一次向IoC容器索要Bean时，即调用getBean（）的接口定义，触发依赖注入。</p>
<p>在BeanDefinition信息中通过控制 lazy-init 属性来让容器完成对Bean的预实例化。它是在初始化过程中完成的。</p>
<p>重点来说，getBean是依赖注入的起点，之后会调用createBean。在这个过程中，Bean对象会依据BeanDefinition定义的要求生成。在AbstractAutowireCapableBeanFactory中实现了这个createBean，createBean不但生成了需要的Bean，还对Bean初始化进行了处理，比如实现了在BeanDefinition中的init-method属性定义，Bean后置处理器等。</p>
<p>与依赖注入关系特别密切的方法有createBeanInstance()和populateBean()。在createBeanInstance()中生成了Bean所包含的Java对象，这个对象的生成有很多种不同的方式，可以通过工厂方法生成，也可以通过容器的autowire特性生成，这些生成方式都是由相关的BeanDefinition来指定的。</p>
<p>IoC容器中，要了解怎样使用cglib来生成Bean对象，需要看一下SimpleInstantiationStrategy类。这个Strategy是Spring用来生成Bean对象的默认类，它提供了两种实例化Java对象的方法，一种是通过BeanUtils，它使用了JDK的反射功能，一种是通过前面提到的CGLIB来生成，使用SimpleInstantiationStrategy生成Java对象。</p>
<p>在实例化Bean对象生成的基础上，怎样把这些Bean对象的依赖关系设置好，完成整个依赖注入过程。这个过程涉及对各种Bean对象的属性的处理过程（即依赖关系处理的过程），这些依赖关系处理的依据就是已经解析得到的BeanDefinition。这个过程涉及到 populateBean() 方法。</p>
<p>通过使用BeanDefinitionResolver来对BeanDefinition进行解析，然后注入到property中。下面到BeanDefinitionValueResolver中去看一下解析过程的实现。</p>
<p>这两种属性的注入都调用了resolveValueIfNecessary，这个方法包含了所有对注入类型的处理。</p>
<p>在完成这个解析过程后，已经为依赖注入准备好了条件，这是真正把Bean对象设置到它所依赖的另一个Bean的属性中去的地方，其中处理的属性是各种各样的。依赖注入的发生是在BeanWrapper的setPropertyValues中实现的，具体的完成却是在BeanWrapper的子类BeanWrapperImpl中实现的。</p>
<p>在Bean的创建和对象依赖注入的过程中，需要依据BeanDefinition中的信息来递归地完成依赖注入。从上面的几个递归过程中可以看到，这些递归都是以getBean()方法为入口的。一个递归是在上下文体系中查找需要的Bean和创建Bean的递归调用。另一个递归是在依赖注入时，通过递归调用容器的getBean()方法，得到当前Bean的依赖Bean，同时也触发对依赖Bean的创建和注入。在对Bean的属性进行依赖注入时，解析的过程也是一个递归的过程。这样根据依赖关系，一层一层地完成Bean的创建和注入，直到最后完成当前Bean的创建。有了这个顶层Bean的创建和对它的属性依赖注入的完成，意味着和当前Bean相关的整个依赖链的注入也完成了。</p>
<p>在Bean创建和依赖注入完成以后，在IoC容器中建立起一系列依靠依赖关系联系起来的Bean，这个Bean已经不是简单的Java对象了。该Bean系列以及Bean之间的依赖关系建立完成以后，通过IoC容器的相关接口方法，就可以非常方便地供上层应用使用了。</p>
<h3 id="2-5-容器的其它特性的设计与实现"><a href="#2-5-容器的其它特性的设计与实现" class="headerlink" title="2.5 容器的其它特性的设计与实现"></a>2.5 容器的其它特性的设计与实现</h3><h4 id="2-5-1-ApplicationContext和Bean的初始化和销毁"><a href="#2-5-1-ApplicationContext和Bean的初始化和销毁" class="headerlink" title="2.5.1 ApplicationContext和Bean的初始化和销毁"></a>2.5.1 ApplicationContext和Bean的初始化和销毁</h4><ol>
<li>初始化</li>
</ol>
<p>对于BeanFactory，特别是ApplicationContext，容器自身也有一个初始化和销毁关闭的过程。容器的实现是通过ioc管理Bean的生命周期来实现的。Ioc容器的Bean生命周期。</p>
<p>在调用Bean初始化方法之前会调用一系列aware接口实现，将相关的BeanName、BeanClassLoader以及BeanFactory注入到Bean中。           </p>
<p>对 ApplicationContext 启动 的过程是在AbstractApplicationContext中实现的。在使用应用上下文时需要做一些准备工作，这些准备工作在prepareBeanFactory（）方法中实现。在这个方法中，为容器配置了ClassLoader、PropertyEditor和BeanPostProcessor等，从而为容器的启动做好了必要的准备工作。</p>
<p>在容器要关闭时，也需要完成一系列的工作，这些工作在doClose( )方法中完成。在这个方法中，先发出容器关闭的信号，然后将Bean逐个关闭，最后关闭容器自身。</p>
<p>在容器的初始化和销毁的设计与实现过程中需要区分Bean的初始化和销毁过程。Spring IoC容器提供了相关的功能，可以让应用定制Bean的初始化和销毁过程。容器的实现是通过IoC管理Bean的生命周期来实现的。Spring IoC容器在对Bean的生命周期进行管理时提供了Bean生命周期各个时间点的回调。在分析Bean初始化和销毁过程的设计之前，简要介绍一下IoC容器中的Bean生命周期。</p>
<pre><code>1. Bean实例的创建。

2. 为Bean实例设置属性

3. 调用Bean的初始化方法

4. 应用可以通过Ioc容器使用Bean

5. 当容器关闭时，调用Bean的销毁方法
</code></pre><p>Bean的初始化方法调用是在initializeBean()方法实现的。</p>
<p>在调用Bean的初始化方法之前，会调用一系列的aware接口实现，把相关的BeanName、BeanClassLoader，以及BeanFactoy注入到Bean中去。接着会看到对invokeInitMethods的调用，这时还会看到启动afterPropertiesSet的过程，当然，这需要Bean实现InitializingBean的接口，对应的初始化处理可以在InitializingBean接口的afterPropertiesSet方法中实现，这里同样是对Bean的一个回调。</p>
<p>最后，还会看到判断Bean是否配置有initMethod，如果有，那么通过invokeCustomInitMethod方法来直接调用，最终完成Bean的初始化。</p>
<p>在这个对initMethod的调用中，可以看到首先需要得到Bean定义的initMethod，然后通过JDK的反射机制得到Method对象，直接调用在Bean定义中声明的初始化方法。</p>
<ol start="2">
<li>销毁</li>
</ol>
<p>我们可以看到对Bean的销毁过程，首先对postProcessBeforeDestruction进行调用，然后调用Bean的destroy方法，最后是对Bean的自定义销毁方法的调用，整个过程和前面的初始化过程很类似。</p>
<h4 id="2-5-2-lazy-init属性和预实例化"><a href="#2-5-2-lazy-init属性和预实例化" class="headerlink" title="2.5.2 lazy-init属性和预实例化"></a>2.5.2 lazy-init属性和预实例化</h4><p>在IOC容器初始化过程中，主语的工作是对BeanDefinition的定位、载入、解析和注册。此时依赖注入并没有发生，依赖注入发生在应用第一次向容器索要 Bean 时。向容器索要Bean是通过getBean()方法的调用完成的。该getBean是容器提供Bean服务的最基本的接口。</p>
<h4 id="2-5-3-FactoryBean的实现"><a href="#2-5-3-FactoryBean的实现" class="headerlink" title="2.5.3 FactoryBean的实现"></a>2.5.3 FactoryBean的实现</h4><p>FactoryBean为应用生成需要的对象，这些对象往往是经过特殊处理的，如ProxyFactoryBean这样的特殊Bean。FactoryBean的生产特性是在getBean中起作用的，看下面的调用：</p>
<pre><code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
</code></pre><p>在getObjectForBeanInstance的实现方法中可以看到在FactoryBean中常见的getObject方法的接口。FactoryBean类似于AbstractFactory抽象工厂，getObjectForBeanInstance()方法类似于createProduceA()这样的生产接口，具体的FactoryBean实现如：TransactionProxyBean就是具体的工厂实现。</p>
<h4 id="2-5-4-BeanPostProcessor的实现"><a href="#2-5-4-BeanPostProcessor的实现" class="headerlink" title="2.5.4 BeanPostProcessor的实现"></a>2.5.4 BeanPostProcessor的实现</h4><p>BeanPostProcessor是使用IoC容器时经常会遇到的一个特性，这个Bean的后置处理器是一个监听器，它可以监听容器触发的事件。将它向IoC容器注册后，容器中管理的Bean具备了接收IoC容器事件回调的能力。BeanPostProcessor的使用非常简单，只需要通过设计一个具体的后置处理器来实现。同时，这个具体的后置处理器需要实现接口类BeanPostProcessor，然后设置到XML的Bean配置文件中。这个BeanPostProcessor是一个接口类，它有两个接口方法，一个是postProcessBeforeInitialization，在Bean初始化前提供回调入口；一个是postProcessAfterInitialization，在Bean的初始化后提供回调入口，这两个回调的触发都是和容器管理Bean的生命周期相关的。这两个回调方法的参数都是一样的，分别是Bean的实例化对象和Bean的名字。</p>
<p>postProcessBeforeInitialization是在populateBean完成之后被调用的。从BeanPostProcessor中的一个回调接口入手，对另一个回调接口postProcessAfterInitialization方法的调用，实际上也是在同一个地方封装完成的，这个地方就是populateBean方法中的initializeBean调用。在前面对IoC的依赖注入进行分析时，对这个populateBean有过分析，这个方法实际上完成了Bean的依赖注入。在容器中建立Bean的依赖关系，是容器功能实现的一个很重要的部分。</p>
<p>在initializeBean方法中，需要使用Bean的名字，完成依赖注入以后的Bean对象，以及这个Bean对应的BeanDefinition。在这些输入的帮助下，完成Bean的初始化工作，这些工作包括为类型是BeanNameAware的Bean设置Bean的名字，类型是BeanClassLoaderAware的Bean设置类装载器，类型是BeanFactoryAware的Bean设置自身所在的IoC容器以供回调使用，当然，还有对postProcessBeforeInitialization/postProcessAfterInitialization的回调和初始化属性init-method的处理等。经过这一系列的初始化处理之后，得到的结果就是可以正常使用的由IoC容器托管的Bean了。</p>
<h4 id="2-5-5-autowiring（自动依赖装配）的实现"><a href="#2-5-5-autowiring（自动依赖装配）的实现" class="headerlink" title="2.5.5 autowiring（自动依赖装配）的实现"></a>2.5.5 autowiring（自动依赖装配）的实现</h4><p>在之前我们一直是通过 BeanDefinition 的属性值和构造函数以显式的方式对Bean的依赖关系进行管理的。在Spring IoC容器中还提供了自动依赖装配的方式。在自动装配中，不需要对Bean属性做显式的依赖关系声明，只需要配置好autowiring属性，IoC容器会根据这个属性的配置，使用反射自动查找属性的类型或者名字，然后基于属性的类型或名字来自动匹配IoC容器中的Bean，从而自动地完成依赖注入。</p>
<p>autowiring属性是在对Bean属性进行依赖注入时起作用。对autowirng属性进行处理，从而完成对Bean属性的自动依赖装配，是在populateBean中实现的。对属性autowiring的处理是populateBean处理过程的一个部分。在populateBean的实现中，在处理一般的Bean之前，先对autowiring属性进行处理。如果当前的Bean配置了autowire_by_name和autowire_by_type属性，那么调用相应的autowireByName方法和autowireByType方法。例如，对于autowire_by_name，它首先通过反射机制从当前Bean中得到需要注入的属性名，然后使用这个属性名向容器申请与之同名的Bean，这样实际又触发了另一个Bean的生成和依赖注入的过程。</p>
<p> 在对autowiring类型做了一些简单的逻辑判断以后，通过调用autowireByName和autowireByType来完成自动依赖装配。</p>
<p> 对autowireByName来说，它首先需要得到当前Bean的属性名，这些属性名已经在BeanWrapper和BeanDefinition中封装好了，然后是对这一系列属性名进行匹配的过程。在匹配的过程中，因为已经有了属性的名字，所以可以直接使用属性名作为Bean名字向容器索取Bean，这个getBean会触发当前Bean的依赖Bean的依赖注入，从而得到属性对应的依赖Bean。在执行完这个getBean后，把这个依赖Bean注入到当前Bean的属性中去，这样就完成了通过这个依赖属性名自动完成依赖注入的过程。autowireByType的实现和autowireByName的实现过程是非常类似的。</p>
<h4 id="2-5-6-Bean的依赖检查"><a href="#2-5-6-Bean的依赖检查" class="headerlink" title="2.5.6 Bean的依赖检查"></a>2.5.6 Bean的依赖检查</h4><p>在一般情况下，Bean的依赖注入是在应用第一次向容器索取Bean的时候发生，在这个时候，不能保证注入一定能够成功，如果需要重新检查这些依赖关系的有效性，会是一件很繁琐的事情。为了解决这样的问题，在Spring IoC容器中，设计了一个依赖检查特性，通过它，Spring可以帮助应用检查是否所有的属性都已经被正确设置。在具体使用的时候，应用只需要在Bean定义中设置dependency-check属性来指定依赖检查模式即可，这里可以将属性设置为none、simple、object、all四种模式，默认的模式是none。</p>
<h4 id="2-5-7-Bean对IoC容器的感知"><a href="#2-5-7-Bean对IoC容器的感知" class="headerlink" title="2.5.7 Bean对IoC容器的感知"></a>2.5.7 Bean对IoC容器的感知</h4><p>容器管理的Bean一般不需要了解容器的状态和直接使用容器，但在某些情况下，是需要在Bean中直接对IoC容器进行操作的，这时候，就需要在Bean中设定对容器的感知。Spring IoC容器也提供了该功能，它是通过特定的aware接口来完成的。aware接口有以下这些：</p>
<pre><code>BeanNameAware ，可以在Bean中得到它在IoC容器中的Bean实例名称。

BeanFactoryAware，可以在Bean中得到Bean所在的IoC容器，从而直接在Bean中使用IoC容器的服务。

ApplicationContextAware，可以在Bean中得到Bean所在的应用上下文，从而直接在Bean中使用应用上下文的服务。

MessageSourceAware，在Bean中可以得到消息源。

ApplicationEventPublisherAware，在Bean中可以得到应用上下文的事件发布器，从而可以在Bean中发布应用上下文的事件。

ResourceLoaderAware，在Bean中可以得到ResourceLoader，从而在Bean中使用ResourceLoader加载外部对应的Resource资源。
</code></pre><p>在设置Bean的属性之后，调用初始化回调方法之前，Spring会调用aware接口中的setter方法。以ApplicationContextAware为例，分析对应的设计和实现。这个接口定义得很简单。</p>
<p>这里只有一个方法setApplicationContext(ApplicationContext applicationContext)，它是一个回调函数，在Bean中通过实现这个函数，可以在容器回调该aware接口方法时使注入的applicationContext引用在Bean中保存下来，供Bean需要使用ApplicationContext的基本服务时使用。这个对setApplicationContext方法的回调是由容器自动完成的。可以看到，一个ApplicationContextAwareProcessor作为BeanPostProcessor的实现，对一系列的aware回调进行了调用，比如对ResourceLoaderAware接口的调用，对ApplicationEventPublisherAware接口的调用，以及对MessageSourceAware和ApplicationContextAware的接口调用等。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="第5章-数据库操作组件的实现"><a href="#第5章-数据库操作组件的实现" class="headerlink" title="第5章 数据库操作组件的实现"></a>第5章 数据库操作组件的实现</h2><p>[toc]</p>
<p>### </p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/FastDFS/</url>
    <content><![CDATA[<h2 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>开源轻量级分布式文件系统，对文件进行管理。（文件存储、文件同步、文件访问（上传/下载））。</p>
<p>FastDFS是一个开源的轻量级分布式文件系统，它解决了大数据量存储和负载均衡等问题，特别适合以中小文件（建议范围：4KB-500MB）为载体的在线服务。</p>
<h4 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h4><p>分布式文件存储系统主要分为3部分。</p>
<pre><code>1. 文件存储系统(保存文件)

2. 文件容灾系统(相互备份)

3. 文件访问调度仲裁系统(调配资源，决定存储位置)

    优点(极大扩展能力，高可用性，弹性存储)

    缺点(系统复杂度高，需要更多硬件资源)
</code></pre><p><a href="http://www.ityouknow.com/springboot/2018/01/16/spring-boot-fastdfs." target="_blank" rel="noopener">SpringBoot集成FastDFS</a></p>
<pre><code>1. 基于客户端/服务器的文件存储系统
</code></pre>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%20-%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>结构型模式旨在通过改变程序结构来达到解耦的目的，使得程序更容易维护和扩展。</p>
<p>代理模式是做方法增强的。</p>
<p>适配器模式是将狗包装成鸭用来做适配器接口的。</p>
<p>桥接模式是做解耦的。</p>
<p>装饰者模式是装饰类或增强类场景的。</p>
<p>外观模式是调用者不需要关心实例化过程，直接调用需要的方法就行的。</p>
<p>组合模式用于描述具有层次结构的数据。</p>
<p>享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%20-%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/UML/</url>
    <content><![CDATA[<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><h4 id="UML-聚合关系与组合关系"><a href="#UML-聚合关系与组合关系" class="headerlink" title="UML - 聚合关系与组合关系"></a>UML - 聚合关系与组合关系</h4><ul>
<li>聚合关系：空心菱形-箭头，是整体和局部的概念。菱形这一边可以理解为一个盘子，盛东西。</li>
<li>组合关系：实心菱形-箭头，是同时存在生命周期的关系，如：鸟和翅膀。</li>
</ul>
<h4 id="UML-依赖关系与关联关系"><a href="#UML-依赖关系与关联关系" class="headerlink" title="UML - 依赖关系与关联关系"></a>UML - 依赖关系与关联关系</h4><ul>
<li>依赖关系：虚线，若有若无的，在需要的时候调用依赖的对象。如：动物类里面依赖温度和水对象。</li>
<li>关联关系：实线箭头，实打实的关系，表示一个对象里面包括另外一个对象。如：企鹅对象里面包括气候这个对象类。</li>
</ul>
<h4 id="UMML-实现和继承"><a href="#UMML-实现和继承" class="headerlink" title="UMML - 实现和继承"></a>UMML - 实现和继承</h4><ul>
<li>实现，实线空心箭头，</li>
<li>继承，虚线空心箭头，</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/IDEA%20%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%20%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>IDEA阅读源码 类图结构</p>
<pre><code>1.快捷键 ctrl + alt + shift + u

2.选择 java class diagrams

3. ...
</code></pre>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="设计模式-工厂方法源码解析"><a href="#设计模式-工厂方法源码解析" class="headerlink" title="设计模式 - 工厂方法源码解析"></a>设计模式 - 工厂方法源码解析</h2><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><pre><code>Collection（VideoFactory） -? ArrayList（JavaVideoFactory） -&gt; Iterator&lt;E&gt;方法（Video抽象类）-&gt; Itr()（实现的具体产品JavaVideo | PythonVideo）
</code></pre><h4 id="URLStreamHandlerFactory-解决URL协议扩展use"><a href="#URLStreamHandlerFactory-解决URL协议扩展use" class="headerlink" title="URLStreamHandlerFactory (解决URL协议扩展use)"></a>URLStreamHandlerFactory (解决URL协议扩展use)</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%20-%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="抽象工厂模式-源码分析"><a href="#抽象工厂模式-源码分析" class="headerlink" title="抽象工厂模式 - 源码分析"></a>抽象工厂模式 - 源码分析</h2><h4 id="Connection-java-mysql-Connection"><a href="#Connection-java-mysql-Connection" class="headerlink" title="Connection (java.mysql.Connection)"></a>Connection (java.mysql.Connection)</h4><h4 id="Statement-java-mysql-Statement"><a href="#Statement-java-mysql-Statement" class="headerlink" title="Statement (java.mysql.Statement)"></a>Statement (java.mysql.Statement)</h4><h4 id="SqlSessionFactory-mybatis"><a href="#SqlSessionFactory-mybatis" class="headerlink" title="SqlSessionFactory (mybatis)"></a>SqlSessionFactory (mybatis)</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%20-%20JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="建造者模式-JDK源码解析"><a href="#建造者模式-JDK源码解析" class="headerlink" title="建造者模式 - JDK源码解析"></a>建造者模式 - JDK源码解析</h2><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><h4 id="BeanDefinitionBuilder"><a href="#BeanDefinitionBuilder" class="headerlink" title="BeanDefinitionBuilder"></a>BeanDefinitionBuilder</h4><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><pre><code>1.数据访问对象接口：定义了在一个模型对象上要执行的标准操作
2.数据访问对象实体类：实现上面的接口。该类从数据源获取数据，数据源可以是数据库或者xml以及其它的存储机制。
3.模型对象/数值对象：简单的POJO，包括get/set方法来存储通过DAO类检索到的数据。
</code></pre>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式用于从客户端到服务器一次性传递带有多个属性的数据。</p>
<pre><code>1.业务对象：为传输对象填充数据的业务服务。
2.传输对象：简单的POJO
3.客户端：客户端可以发送请求或发送传输对象到业务对象。
</code></pre><h4 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h4><p><strong>1.创建传输对象</strong><br></p>
<pre><code>public class StudentVO {
   private String name;
   private int rollNo;

   StudentVO(String name, int rollNo){
      this.name = name;
      this.rollNo = rollNo;
   }

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

   public int getRollNo() {
      return rollNo;
   }

   public void setRollNo(int rollNo) {
      this.rollNo = rollNo;
   }
}
</code></pre><p><strong>2.创建业务对象</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class StudentBO {

   //列表是当作一个数据库
   List&lt;StudentVO&gt; students;

   public StudentBO(){
      students = new ArrayList&lt;StudentVO&gt;();
      StudentVO student1 = new StudentVO(&quot;Robert&quot;,0);
      StudentVO student2 = new StudentVO(&quot;John&quot;,1);
      students.add(student1);
      students.add(student2);    
   }
   public void deleteStudent(StudentVO student) {
      students.remove(student.getRollNo());
      System.out.println(&quot;Student: Roll No &quot; 
      + student.getRollNo() +&quot;, deleted from database&quot;);
   }

   //从数据库中检索学生名单
   public List&lt;StudentVO&gt; getAllStudents() {
      return students;
   }

   public StudentVO getStudent(int rollNo) {
      return students.get(rollNo);
   }

   public void updateStudent(StudentVO student) {
      students.get(student.getRollNo()).setName(student.getName());
      System.out.println(&quot;Student: Roll No &quot; 
      + student.getRollNo() +&quot;, updated in the database&quot;);
   }
}
</code></pre><p><strong>3.使用 StudentBO 来演示传输对象设计模式</strong><br></p>
<pre><code>public class TransferObjectPatternDemo {
   public static void main(String[] args) {
      StudentBO studentBusinessObject = new StudentBO();

      //输出所有的学生
      for (StudentVO student : studentBusinessObject.getAllStudents()) {
         System.out.println(&quot;Student: [RollNo : &quot;
         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);
      }

      //更新学生
      StudentVO student =studentBusinessObject.getAllStudents().get(0);
      student.setName(&quot;Michael&quot;);
      studentBusinessObject.updateStudent(student);

      //获取学生
      studentBusinessObject.getStudent(0);
      System.out.println(&quot;Student: [RollNo : &quot;
      +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);
   }
}
</code></pre>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20MVC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Java%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p>
<h4 id="1-垃圾回收机制的算法"><a href="#1-垃圾回收机制的算法" class="headerlink" title="1.垃圾回收机制的算法"></a>1.垃圾回收机制的算法</h4><p>不管是何种算法，都需要实现两件基本的事情：1.发现无用的信息对象。2.回收无用对象占用的内存空间。</p>
<p><strong>1.引用计数器</strong><br></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Java%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<h4 id="Java-7-新增的Objects类"><a href="#Java-7-新增的Objects类" class="headerlink" title="Java 7 新增的Objects类"></a>Java 7 新增的Objects类</h4><p>Java为工具类的命名习惯是添加一个字母s，如操作数组的Arrays，操作集合的工具类Collections。然后操作对象的工具类便是Objects。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/Java%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6%20-%20LinkedHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Java容器框架-LinkedHashMap源码分析"><a href="#Java容器框架-LinkedHashMap源码分析" class="headerlink" title="Java容器框架 - LinkedHashMap源码分析"></a>Java容器框架 - LinkedHashMap源码分析</h2><p>[TOC]</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>LinkedHashMap继承自HashMap</p>
]]></content>
  </entry>
  <entry>
    <title>Cookie 和 Session</title>
    <url>/undefined/Cookie%20%E5%92%8C%20Session/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h2><p>[TOC]</p>
<p>Cookie是客户端技术 Session是服务器端技术。</p>
<p>API:</p>
<blockquote>
<ul>
<li><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/http/Cookie.html" target="_blank" rel="noopener">javax.servlet.http:Class Cookie</a></li>
<li><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/http/HttpSession.html" target="_blank" rel="noopener">javax.servlet.http:Interface HttpSession</a></li>
</ul>
</blockquote>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><blockquote>
<p>注意：这里是一些细节</p>
</blockquote>
<ul>
<li>一个cookie只能标识一种信息，至少含有标识该信息的名称和值</li>
<li>浏览器一般只允许存放300个cookie，每个站点最多存放20个，每个cookie大小限制为4KB</li>
<li>默认是会话级别cookie(存储于浏览器内存)，浏览器进程关闭则删除。有效期通过<code>maxAge</code>设置，存于硬盘，0表示删除</li>
<li>删除cookie时，path必须一致，否则不会删除</li>
</ul>
<hr>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>session对象由服务器创建,一个浏览器(会话)独占一个session对象</p>
<p>session对象由服务器创建生命周期</p>
<ul>
<li>创建：调用<code>request</code>对象的<code>getSession</code>方法后才会创建session对象;<code>getSession(false)</code>只获取，不创建</li>
<li>销毁：默认30分钟没人使用则自动销毁。失效时间可在<code>web.xml</code>的<code>&lt;session-config&gt;</code>标签中使用<code>&lt;session-timeout&gt;</code>，单位分钟；也可调用<code>session</code>对象的<code>invalidate</code>方法销毁</li>
</ul>
<hr>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>session基于cookie实现，将<code>JSESSIONID</code>写回浏览器，这个cookie(<code>JSESSIONID</code>)默认没设置有效期,关浏览器即销毁。可以自行回写<code>JSESSIONID</code>覆盖原cookie值</p>
<p>示例代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line">    String sessionid = session.getId();</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,sessionid);</span><br><span class="line">    cookie.setPath(<span class="string">"/s1"</span>);</span><br><span class="line">    cookie.setMaxAge(<span class="number">30</span>*<span class="number">60</span>);</span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><ul>
<li>用户登录</li>
<li>防止表单重复提交</li>
<li>一次性验证码的校验</li>
</ul>
<p><strong>小Tips</strong></p>
<ul>
<li>一般大型网站不用session,使用cookie,减小服务器压力</li>
<li>若浏览器禁用cookie,需使用url自带sessionid，相关方法:<code>encodeURL</code>和<code>encodeRedirectURL</code></li>
<li>禁止表单重复提交：在javascript或者服务器实现。javascript防不死，用户可通过修改js、自建表单提交，刷新页面，后退等方法重复提交；服务器实现是给每个表单一个随机表单号</li>
<li>生成表单号使用“令牌发生器”，为保证唯一性(减小重复概率)，使用单例。</li>
<li>base64编码，三字节变四字节，每6位变8位(一字节)，高位补零，每字节最大值为63，故得名。</li>
<li>md5，常用于保存密码(可能为防止破解会加随机数)，校验数据完整性</li>
</ul>
<p>防止表单重复提交之令牌例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/1/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenProcessor</span> </span>&#123;<span class="comment">//令牌</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.构造方法私有</span></span><br><span class="line"><span class="comment">     * 2.自己创建一个</span></span><br><span class="line"><span class="comment">     * 3.对外暴露一个方法，允许获取上面创建的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TokenProcessor</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> TokenProcessor instance = <span class="keyword">new</span> TokenProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TokenProcessor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">genetateToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String token = System.currentTimeMillis()+<span class="keyword">new</span> Random().nextInt()+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest md =  MessageDigest.getInstance(<span class="string">"md5"</span>);</span><br><span class="line">            <span class="keyword">byte</span> [] md5 =  md.digest(token.getBytes());</span><br><span class="line">            <span class="comment">//base64编码</span></span><br><span class="line">            BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">            <span class="keyword">return</span> encoder.encode(md5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三个域对象"><a href="#三个域对象" class="headerlink" title="三个域对象"></a>三个域对象</h2><ul>
<li>Session</li>
<li>Request</li>
<li>ServletContext</li>
</ul>
<p>容器选用经验：</p>
<ul>
<li>数据显示完了就没用了，则选用Request</li>
<li>数据除了显示外，稍后还会用，则选用Session</li>
<li>数据除了显示外，不仅稍后会用，还会给别人用，则选用<code>ServletContext</code></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Cookie 和 Session</category>
      </categories>
      <tags>
        <tag>Cookie 和 Session</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassPathXmlApplicationContext</title>
    <url>/undefined/ClassPathXmlApplicationContext/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><blockquote>
<p>提示：ResourceLoader表示一种加载资源的方式，是策略模式的实现。</p>
</blockquote>
<pre><code>//构造器(部分)
public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException {
    super(parent);
    this.setConfigLocations(configLocations);
    if (refresh) {
        this.refresh();
    }
}
</code></pre><p>父类构造器(AbstractApplicationContext)</p>
<pre><code>public AbstractApplicationContext() {
    this.logger = LogFactory.getLog(this.getClass());
    this.id = ObjectUtils.identityToString(this);
    this.displayName = ObjectUtils.identityToString(this);
    this.beanFactoryPostProcessors = new ArrayList();
    this.active = new AtomicBoolean();
    this.closed = new AtomicBoolean();
    this.startupShutdownMonitor = new Object();
    this.applicationListeners = new LinkedHashSet();
    this.resourcePatternResolver = this.getResourcePatternResolver();
}

public AbstractApplicationContext(ApplicationContext parent) {
    this();
    this.setParent(parent);
}

protected ResourcePatternResolver getResourcePatternResolver() {
    return new PathMatchingResourcePatternResolver(this);
}
</code></pre>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/undefined/Git/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-git-rebase"><a href="#1-git-rebase" class="headerlink" title="1.git rebase"></a>1.git rebase</h2><p>git合并代码主要有两种方式：</p>
<pre><code>1.merge处理，这是我们比较能理解的方式。
2.rebase处理，中文此处翻译为衍合过程。
</code></pre><h2 id="2-git-update-index-–assume-unchanged-PATH"><a href="#2-git-update-index-–assume-unchanged-PATH" class="headerlink" title="2.git update-index –assume-unchanged PATH"></a>2.git update-index –assume-unchanged PATH</h2><p>表示手动设置不要检查特定文件的更改情况。</p>
<blockquote>
<p>注意：另外git提供了另外一种exclude的方式来完成同样的事情，不同的是.gitignore这个文件本身会提交到版本库中去。用来保存公共的需要排除的文件。.git/info/exclude设置的是我们自己本地需要排除的文件。这不会影响到别人，也不会提交到版本库中去。</p>
</blockquote>
<pre><code>$ git update-index --assume-unchanged /path/to/file   #忽略跟踪

$ git update-index --no-assume-unchanged /path/to/file  #恢复跟踪
</code></pre><h2 id="3-Git工作流程"><a href="#3-Git工作流程" class="headerlink" title="3.Git工作流程"></a>3.Git工作流程</h2><pre><code>git -
    commit -a 将workspace程序提交到local repository
    add (-u) 将workspace程序提交到index(暂存区)
    commit 将index程序提交到local repository
    push 将local repository程序推到remote repository

    pull/rebase 将remote repository程序拉到workspace
    fetch 将remote repository程序拉到local repository

    checkout head 将local repository到workspace
    checkout 将index到workspace
    diff head 将local到workspace
    diff 将index到workspace
</code></pre><blockquote>
<p>注：</p>
</blockquote>
<h2 id="4-git命令"><a href="#4-git命令" class="headerlink" title="4.git命令"></a>4.git命令</h2><h4 id="4-1-创建与合并分支"><a href="#4-1-创建与合并分支" class="headerlink" title="4.1 创建与合并分支"></a>4.1 创建与合并分支</h4><pre><code>1.git branch 查看当前分支
2.git checkout -b &lt;name&gt; 创建并切换到dev分支
3.git checkout &lt;name&gt; 切换分支
3.git merge dev 将dev分支合并到master，当然首先需要切换回到master分支

4.git merge 该命令表示合并指定分支到当前分支

5.git branch -d &lt;name&gt; 删除分支
</code></pre><h4 id="4-2-解决冲突"><a href="#4-2-解决冲突" class="headerlink" title="4.2 解决冲突"></a>4.2 解决冲突</h4><p>如果两个分支上的程序出现冲突，即就是两个分支上的程序都被改动之后，那么在两者合并的过程中就会产生冲突。</p>
<pre><code>1.git status 了解冲突的文件
</code></pre><blockquote>
<p>注意：在git无法自动合并分支的时候，首先应该解决冲突，然后再提交合并。</p>
</blockquote>
<pre><code>2.git log --graph 该命令可以看到分支合并图
</code></pre><h4 id="4-3-分支管理策略"><a href="#4-3-分支管理策略" class="headerlink" title="4.3 分支管理策略"></a>4.3 分支管理策略</h4><pre><code>1.git merge --no-ff &lt;name&gt; 该命令表示禁用fast forward 快速合并 分支
</code></pre><blockquote>
<p>提示：分支策略，在实际开发过程中，按照几个基本原则进行管理，平时不在master分支上干活，这分支是用来发布新版本。</p>
</blockquote>
<h4 id="4-4-多人协作"><a href="#4-4-多人协作" class="headerlink" title="4.4 多人协作"></a>4.4 多人协作</h4><pre><code>1.git remote -v 查看远程库信息
2.git push origin &lt;name&gt; 从本地推送分支，推送失败 git pull 抓取远程的新提交

3.git branch --set-upstream branch-name origin/branch-name 建立本地分支和远程分支的关联
</code></pre><h4 id="4-5-标签管理"><a href="#4-5-标签管理" class="headerlink" title="4.5 标签管理"></a>4.5 标签管理</h4><pre><code>1.命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id
2.命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息
3.命令git tag可以查看所有标签

4.命令git push origin &lt;tagname&gt;可以推送一个本地标签
5.命令git push origin --tags可以推送全部未推送过的本地标签
6.命令git tag -d &lt;tagname&gt;可以删除一个本地标签
7.命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签
</code></pre><h4 id="4-6-自定义git"><a href="#4-6-自定义git" class="headerlink" title="4.6 自定义git"></a>4.6 自定义git</h4><pre><code>如果想要忽略到一些文件的时候，可以在.gitignore文件中填写，同时该文件可以被版本管理。
</code></pre><hr>
<h2 id="不上传LocalController-java和local文件夹文件"><a href="#不上传LocalController-java和local文件夹文件" class="headerlink" title="不上传LocalController.java和local文件夹文件"></a>不上传LocalController.java和local文件夹文件</h2><pre><code>1.找到 E:\projects\WebOA\.git\info 路径
2.修改该路径下的语句：

    # git ls-files --others --exclude-from=.git/info/exclude
    # Lines that start with &apos;#&apos; are comments.
    # For a project mostly in C, the following would be a good set of
    # exclude patterns (uncomment them if you want to use them):
    # *.[oa]
    # *~
    src/main/java/cn/edu/xidian/see/controller/LocalController.java
    src/main/webapp/WEB-INF/views/local/*
</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON 和 ProtoBuf序列化</title>
    <url>/undefined/JSON%20%E5%92%8C%20ProtoBuf%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="JSON-和-ProtoBuf序列化"><a href="#JSON-和-ProtoBuf序列化" class="headerlink" title="JSON 和 ProtoBuf序列化"></a>JSON 和 ProtoBuf序列化</h2><p>[TOC]</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>在开发远程过程调用（RPC）程序时候，会涉及到对象的序列化与反序列化问题。如：Person对象从客户端通过TCP方式发送到服务器端。（因为TCP协议只能发送字节流，所以需要应用层将Person对象序列化成字节流）。</p>
<blockquote>
<p>注意：在使用JSON或者ProtoBuf时，需要保证ByteBuf二进制包是完整的二进制包。不能是半包或粘包。</p>
</blockquote>
<h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><p>多个发送端的输入ByteBuf粘在一起的时候称之为粘包。</p>
<h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><p>一个输入的ByteBuf被拆开读取，读取到一个破碎的包，这种情况下被称之为半包。</p>
<h4 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h4><p>基于上面的粘包和半包的情况，可以在Netty中根据自定义协议，将读取到的进程缓冲区ByteBuf在应用层进行二次拼装，重新组装应用层数据包。这一过程被称之为拆包。</p>
<p>这里主要有两种方式实现这一过程：</p>
<pre><code>1. 自定义解码器分包器：基于ByteToMessgeDecoder或者ReplayingDecoder，定义自己的进程缓冲区分包器。

2. 使用Netty内置的解码器。（如：LengthFieldBasedFrameDecoder自定义分隔符数据包解码器，对缓冲区ByteBuf进行正确的分包）。
</code></pre><h3 id="JSON-协议通信"><a href="#JSON-协议通信" class="headerlink" title="JSON 协议通信"></a>JSON 协议通信</h3><h4 id="JSON-序列化通用类"><a href="#JSON-序列化通用类" class="headerlink" title="JSON 序列化通用类"></a>JSON 序列化通用类</h4><pre><code>1. 阿里的FastJson

2. 谷歌的Gson

3. 开源社区的 Jackson
</code></pre><p>一般是Gson库与阿里的FastJson两者的结合使用。JSON序列化时，使用Gson库。反序列化时，阿里的FastJson库。</p>
<h3 id="ProtoBuf-协议通信"><a href="#ProtoBuf-协议通信" class="headerlink" title="ProtoBuf 协议通信"></a>ProtoBuf 协议通信</h3><p>ProtoBuf是谷歌的一种数据交换的格式，是一套类似于JSON或者XML的数据传输格式和规范。用于不同应用或进程之间的通信。</p>
<p>ProtoBuf的编码过程：</p>
<pre><code>1. 使用预先定义的Message数据结构将实际的传输数据进行打包

2. 编码成二进制流进行传输或存储
</code></pre><p>更加的适用于高性能、快速响应的场景。因为其是二进制数据格式，数据序列化之后，更加的适合在网络中进行传输。</p>
]]></content>
      <categories>
        <category>JSON 和 ProtoBuf序列化</category>
      </categories>
      <tags>
        <tag>JSON 和 ProtoBuf序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/JDK%208%20%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h2 id="Collectors-源码"><a href="#Collectors-源码" class="headerlink" title="Collectors 源码"></a>Collectors 源码</h2><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy()"></a>groupingBy()</h3><h3 id="groupingByConcurrent"><a href="#groupingByConcurrent" class="headerlink" title="groupingByConcurrent()"></a>groupingByConcurrent()</h3><h3 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy()"></a>partitioningBy()</h3><h2 id="Stream-源码"><a href="#Stream-源码" class="headerlink" title="Stream 源码"></a>Stream 源码</h2><p>在Stream中提供了三个原生的流（IntStream | LongStream | DoubleStream）是为了避免不必要的装箱和拆箱操作。</p>
<p>集合主要关注的是对于数据的管理和存储，而流主要关注的是对元素之间的计算。</p>
<p>stream pipeline（流管道）可以看做是对于流源的一种查询，除非该流被显示的设计成可以并发修改的。</p>
<p>流只能被操作一次。否则会抛出异常。然有些流操作会返回接收者，不是新的流对象。</p>
<p>流对于是并行或串行可以通过方法（sequential() - 串行 | parallel() - 并行）来进行修改。还可以通过isParallel()方法查询该流是否是并行的。</p>
<h3 id="AutoCloseable"><a href="#AutoCloseable" class="headerlink" title="AutoCloseable"></a>AutoCloseable</h3><p>在该接口中只提供一个close()方法，在实现该接口之后的应用会自动关闭。</p>
<h3 id="BaseStream"><a href="#BaseStream" class="headerlink" title="BaseStream"></a>BaseStream</h3><h4 id="Spliterator-spliterator"><a href="#Spliterator-spliterator" class="headerlink" title="Spliterator spliterator()"></a>Spliterator<t> spliterator()</t></h4><p>该方法被称为分割迭代器（类似于Iterator），是流的一个终止操作。迭代流中的元素。</p>
<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h4><p>返回迭代器，对流中的数据进行迭代。</p>
<h4 id="S-sequential"><a href="#S-sequential" class="headerlink" title="S sequential()"></a>S sequential()</h4><h4 id="S-parallel"><a href="#S-parallel" class="headerlink" title="S parallel()"></a>S parallel()</h4><h4 id="S-onClose-Runnable-closeHandler"><a href="#S-onClose-Runnable-closeHandler" class="headerlink" title="S onClose(Runnable closeHandler)"></a>S onClose(Runnable closeHandler)</h4><p>关闭处理器方法，流中的close()方法被调用的时候，该处理器才会被调用，调用的顺序是按照添加的顺序从先到后调用。</p>
<h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>该方法是重写AutoCloseable接口中的方法。</p>
<blockquote>
<p>提示：CopyAndReadArrayList 是将底层的数据重新复制一份，在新的复制的一份数据上进行操作。其适用的场景是读多写少的场景。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM性能调优</title>
    <url>/undefined/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%20-%20%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h2><p>[TOC]</p>
<h3 id="系统常用诊断工具"><a href="#系统常用诊断工具" class="headerlink" title="系统常用诊断工具"></a>系统常用诊断工具</h3><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>可以快速查看服务器的负载情况，该命令返回的是系统的平均负载，包括各个分钟之内的任务平均数量，包括正在运行的任务以及可以运行但正在等待某个处理器空闲的任务。</p>
<h4 id="dmesag-tail"><a href="#dmesag-tail" class="headerlink" title="dmesag | tail"></a>dmesag | tail</h4><p>该命令输出系统日志的最后10行。</p>
<h4 id="vmstat-l"><a href="#vmstat-l" class="headerlink" title="vmstat l"></a>vmstat l</h4><p>vmstat是实时性能检测工具，可以展现给定时间间隔服务器的状态值，包括服务器的CPU使用率、内存使用、虚拟内存交换情况、IO读写情况等。</p>
<h4 id="mpstat-P-ALL-l"><a href="#mpstat-P-ALL-l" class="headerlink" title="mpstat -P ALL l"></a>mpstat -P ALL l</h4><p>该命令显示每个cpu的使用情况。</p>
<h4 id="free-m"><a href="#free-m" class="headerlink" title="free -m"></a>free -m</h4><p>查看内存的使用情况，-m表示按照兆字节显示</p>
<h4 id="sar-n-DEV-l"><a href="#sar-n-DEV-l" class="headerlink" title="sar -n DEV l"></a>sar -n DEV l</h4><p>sar命令主要用来查看网络设备的吞吐率。可以以此判断网络设备是否饱和。</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>该命令包含了系统全局的很多指标信息，包括系统负载情况、系统内存使用情况、系统CPU使用情况。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="CPU分析"><a href="#CPU分析" class="headerlink" title="CPU分析"></a>CPU分析</h4><p>在CPU繁忙的时候造成的性能问题主要原因有以下几个。</p>
<pre><code>1. 线程中有无限空循环、无阻塞、正则匹配或者单纯的计算

2. 发生了频繁的GC

3. 多线程的上下文切换
</code></pre><h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><pre><code>1. 堆外内存


2. 堆内内存，通常这部分内存性能相关的有如下几个方面

    1. 创建的对象，一般存储在堆中，需要控制好对象的数量和大小，尤其大对象容易进入老年代。

    2. 全局集合，通常全局集合的生命周期比较长，因此需要注意。

    3. 缓存，缓存选用的数据结构不同会在很大程度上影响内存的大小和GC。

    4. ClassLoader，主要动态加载类容易造成永久代内存不足。

    5. 多线程，线程分配会占用本地内存，过多线程会造成内存的不足。

    上面的各个情况的使用不当会造成：

        1. 频繁的GC（stop the world）使得应用响应变慢

        2. OOM，直接造成内存溢出错误使得程序退出。OOM的情况分为：

            1. heap space：堆内存不足

            2. PermGen space：永久代内存不足

            3. Native thread：本地线程没有足够内存分配

    排查堆内存常见工具是jmap

        1. 查看JVM内存使用状况：jmap -heap &lt;pid&gt;

        2. 查看JVM内存存活的对象：jmap -histo:live &lt;pid&gt;

        3. 将heap里所有对象都dump下来，无论对象是死还是活：jmap -dump:format=b,file=xxx.hprof &lt;pid&gt;

        4. 先做一次FULL GC，然后再dump，只包括仍然存活的对象信息：jump -dump:format=b,live,file=xxx.hprof &lt;pid&gt;
</code></pre><h3 id="IO分析"><a href="#IO分析" class="headerlink" title="IO分析"></a>IO分析</h3><h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><p>可以使用系统工具pidstat、iostat、vmstat来查看IO状况。</p>
<p>导致IO性能差的原因有如下几个：</p>
<pre><code>1. 大量的随机读写操作

2. 设备慢

3. 文件太大
</code></pre><h4 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h4><p>查看网络IO状况一般使用netstat工具。</p>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><h4 id="CPU调优"><a href="#CPU调优" class="headerlink" title="CPU调优"></a>CPU调优</h4><pre><code>1. 不要存在一直运行的线程，可以使用sleep休眠一段时间

2. 轮询的时候可以使用wait/notify机制

3. 避免循环、正则表达式匹配、计算过多，序列化/反序列化等

4. 避免频繁GC，尤其是FULL GC

在多线程情况下：

    1. 多线程使用的时候，减少线程数量和线程的切换，使用线程池

    2. 多线程对于锁的竞争可以考虑减少锁的粒度（ReentrantLock）等。
</code></pre><h4 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h4><p>内存调优主要是对JVM调优的调优。</p>
<pre><code>1. 合理设置各个代的大小，避免新生代设置过小（不够用，经常Minor GC并进入老年代）以及过大（会产生碎片），同样避免Survivor设置过大和过小。

    1. 新生代大小选择，响应时间优先的应用，尽可能设大，直到接近系统的最低响应时间限制。在这种情况下，新生代回收发生GC的频率是最低的。同时，也能够减少到达老年代的对象。吞吐量优先的应用，也应尽可能的设置大些，因为对响应时间没有要求，垃圾回收可以并行进行。

    2. 老年代大小选择，响应时间优先的应用，老年代一般都是使用并发回收器。所以大小设置需要小心。

2. 选择合适的GC策略

3. 老年代优先使用Parallel GC（-XX:+UseParallel[Old]GC），可以保证最大的吞吐量。由于CMS会产生碎片，确实有必要才改成CMS或G1。

4. 
</code></pre><h4 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h4><p>JVM的参数配置在很大程度上影响Java应用的性能。</p>
<h5 id="启动参数配置"><a href="#启动参数配置" class="headerlink" title="启动参数配置"></a>启动参数配置</h5><pre><code>1. java -XX:+PrintCommandLineFlags 通过该参数来查看所有可以设置的参数及其默认值，或者在程序启动的时候加：-XX:+PrintCommandLineFlags 查看与默认值不同的启动参数。或查看所有启动参数：-XX:PrintFlagsFinal。
</code></pre><blockquote>
<p>提示：jinfo -flags [pid] 查看目前启动使用的有效参数。 jinfo -flag [fileName] [pid] 查看对应参数的值</p>
</blockquote>
<h5 id="动态设置参数"><a href="#动态设置参数" class="headerlink" title="动态设置参数"></a>动态设置参数</h5><p>在Java应用启动之后发现是GC造成的性能问题，但启动的时候没有加入打印GC的参数，动态参数可以解决这个问题。</p>
<pre><code>jinfo -flag [-/+][flagName] [pid] 启动或禁用某个参数

jinfo -flag [flagName=value] [pid] 设置某个参数的值
</code></pre><p>对于上面的GC问题，可以使用命令打开HeapDump并设置dump路径。</p>
<pre><code>jinfo -flag +HeapDumpBeforeFullGC [pid]

jinfo -flag +HeapDumpAfterFullGC [pid]

jinfo -flag +HeapDumpPath=/... [pid]
</code></pre><p>同样地，可以动态关闭</p>
<pre><code>jinfo -flag -HeapDumpBeforeFullGC [pid]

jinfo -flag -HeapDumpAfterFullGC [pid]
</code></pre><h5 id="verbose-gc-XX-PrintGCDetails"><a href="#verbose-gc-XX-PrintGCDetails" class="headerlink" title="-verbose:gc | -XX:+PrintGCDetails"></a>-verbose:gc | -XX:+PrintGCDetails</h5><p>很多GC推荐设置都同时设置这两个参数，其实只要打开了 -XX:+PrintGCDetails，前面选项也会被同时打开，无需重复设置。</p>
<h5 id="XX-DisableExplicitGC"><a href="#XX-DisableExplicitGC" class="headerlink" title="-XX:+DisableExplicitGC"></a>-XX:+DisableExplicitGC</h5><p>该参数的作用使得 system.gc变为空调用，很多推荐设置里面都建议开启该参数。</p>
<p>….</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/undefined/JSP/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP：Java Server Pages，一种动态web资源的开发技术</p>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/jspapi/index.html" target="_blank" rel="noopener">JSP 2.3 API - Apache Tomcat 8.0.30</a></p>
</blockquote>
<h2 id="调用和运行原理"><a href="#调用和运行原理" class="headerlink" title="调用和运行原理"></a>调用和运行原理</h2><p>JSP本质是一个servlet.</p>
<p>每个JSP页面在第一次被访问时，WEB容器会把请求交给JSP引擎(即一个JAVA程序)处理。JSP引擎先将JSP翻译成一个<code>_jspServlet</code>(实质也是一个servlet)，然后按照servlet的调用方式进行调用。</p>
<ul>
<li>服务器会将jsp先翻译成servlet，这个servlet位于tomcat服务器<code>work</code>目录，这jsp类的父类是<code>org.apache.jasper.runtime.HttpJspBase</code>,这个<code>HttpJspBase</code>类继承自<code>HttpServlet</code></li>
<li>向服务器发请求会调用servlet的service方法;同样地，访问jsp会调用这个JSP类的<code>_jspService</code>方法。</li>
<li>JSP中的标签语言会在<code>_jspService</code>方法中通过<code>out.write()</code>写出来；JSP中的Java代码会原封不动的搬到<code>_jspService</code>方法中。</li>
<li>在<code>_jspService</code>方法中提前准备好了一些对象供JSP调用，如：<code>out,page,application,request,response</code>等等。</li>
<li>由于第一次访问时会翻译成servlet，所以第一次访问较慢。</li>
</ul>
<p>下面以<code>demo1.jsp</code>为例，展示对应的类<code>%CATALINA_HOME%\work\Catalina\localhost\hello\org\apache\jsp\demo1_jsp.java</code>中的部分代码<br><a id="more"></a><br>示例1:<code>demo1.jsp</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;demo1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">当前时间时：</span><br><span class="line">&lt;%</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    out.write(date.toGMTString());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>示例2：<code>_jspService</code>方法中代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;html&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;head&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"    &lt;title&gt;demo1&lt;/title&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;/head&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;body&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"当前时间时：\r\n"</span>);</span><br><span class="line"></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">out.write(date.toGMTString());</span><br><span class="line"></span><br><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;/body&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;/html&gt;\r\n"</span>);</span><br></pre></td></tr></table></figure>
<p>示例3:<code>_jspService</code>方法中一些定义的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h2><ul>
<li><strong>JSP模板元素</strong>:JSP页面中的HTML内容。定义了网页的基本骨架，即结构和外观。</li>
<li><strong>JSP表达式</strong>:用于将程序数据输出到客户端。如，<code>&lt;%=变量或表达式 %&gt;</code>脚本表达式(无分号)，用于输出数据。</li>
<li><strong>JSP脚本片段</strong>:用于在JSP页面中编写多行java代码,严格遵循java语法。一个JSP页面可有多个脚本片段，它们可以相互访问(和放在一对<code>&lt;% %&gt;</code>中一样),单个片段可不完整。</li>
<li><strong>JSP声明</strong>:JSP中代码默认翻译到servlet的service方法中，而JSP声明中的代码被翻译到<code>_jspService</code>方法外。语法：<code>&lt;%! java代码 %&gt;</code>。</li>
<li><strong>JSP注释</strong>:格式<code>&lt;%-- 注释  --%&gt;</code>，注释的内容不会发给浏览器。</li>
<li><strong>JSP指令</strong>:是为JSP引擎设计的，定义了三个指令:page指令，include指令，taglib指令。语法:<code>&lt;%@ 指令 属性名=&quot;值&quot; %&gt;</code>。<ul>
<li>page指令:定义各种属性，作用于整个JSP页面。</li>
<li>include指令:用于包含JSP文件(页头、页脚)。属于静态包含(编译时包含)，它包含的所有JSP会编译成一个servlet。</li>
<li>taglib指令:用于在JSP页面导入标签库。</li>
</ul>
</li>
<li><strong>JSP标签</strong>:也称为jsp Action元素，用于在jsp页面中提供业务逻辑功能，避免在jsp页面中直接写java代码而难以维护</li>
<li><strong>JSP内置对象</strong>:九大隐式对象，<code>request,response,session,application,config,page,exception,out,pageContext</code></li>
</ul>
<hr>
<p>关于上述语法的一些说明</p>
<p>page指令语法：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page</span><br><span class="line">[ language=<span class="string">"java"</span> ]</span><br><span class="line">[ extends=<span class="string">"package.class"</span> ]</span><br><span class="line">[ <span class="keyword">import</span>=<span class="string">"&#123;package.class | package.*&#125;, ..."</span> ]</span><br><span class="line">[ session=<span class="string">"true | false"</span> ]</span><br><span class="line">[ buffer=<span class="string">"none | 8kb | sizekb"</span> ]</span><br><span class="line">[ autoFlush=<span class="string">"true | false"</span> ]</span><br><span class="line">[ isThreadSafe=<span class="string">"true | false"</span> ]</span><br><span class="line">[ info=<span class="string">"text"</span> ]</span><br><span class="line">[ errorPage=<span class="string">"relativeURL"</span> ]</span><br><span class="line">[ contentType=<span class="string">"mimeType [ ;charset=characterSet ]"</span> | <span class="string">"text/html ; charset=ISO-8859-1"</span> ]</span><br><span class="line">[ isErrorPage=<span class="string">"true | false"</span> ]</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>errorPage</code>:错误提示页面。也可在<code>web.xml</code>的<code>&lt;error-page&gt;</code>标签配置，异常处理页面。在page指令设置的优先级高于在<code>web.xml</code>配置。</li>
<li><code>pageEncoding</code>:JSP引擎以何种码表翻译JSP,该值需和JSP文件的保存编码一致，且若要在浏览器正确显示，还要和<code>contentType</code>一致。</li>
</ul>
<p>动态包含(运行时包含):<code>request.getRequestDispatcher(&quot;/public/head.jsp&quot;).include(request,response)</code>,涉及到的jsp会生成单独的servlet，即有多个servlet，在浏览器访问时包含。静态包含性能优于动态包含</p>
<p>JSP常用标签</p>
<ul>
<li><code>&lt;jsp:include&gt;</code>:pageContext.include(),动态包含</li>
<li><code>&lt;jsp:forward&gt;</code></li>
<li><code>&lt;jsp:param&gt;</code></li>
</ul>
<hr>
<h2 id="九大隐式对象"><a href="#九大隐式对象" class="headerlink" title="九大隐式对象"></a>九大隐式对象</h2><p>JSP引擎在调用JSP对应的<code>_jspServlet</code>时，会传递和创建9个web开发相关的对象供使用。后两者(<code>out</code>和<code>pageContext</code>)为JSP独有</p>
<ul>
<li>request</li>
<li>response</li>
<li>session</li>
<li>application</li>
<li>config</li>
<li>page</li>
<li>exception</li>
<li>out</li>
<li>pageContext</li>
</ul>
<h3 id="out隐式对象"><a href="#out隐式对象" class="headerlink" title="out隐式对象"></a>out隐式对象</h3><p><strong>out隐式对象</strong>:用于向客户端发送文本数据。通过调用<code>pageContext</code>对象的<code>getOut</code>方法返回，类型为<code>JspWriter</code>，作用和<code>ServletResponse.getWriter</code>返回的<code>PrintWriter</code>对象相似。</p>
<p><code>JspWriter</code>相当于自带缓存功能的<code>PrintWriter</code>,设置page指令的buffer属性课调整缓存大小。满足如下条件之一，out对象才调用<code>ServletResponse.getWriter</code>方法，并通过返回的<code>PrintWriter</code>对象将out对象的缓冲区的内容真正写入到servlet引擎提供的缓冲区中：</p>
<ul>
<li>设置page指令的buffer属性关闭的out对象的缓存功能</li>
<li>out对象的缓冲区已满</li>
<li>整个JSP页面结束</li>
</ul>
<p>例子：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    out.write(<span class="string">"out.write&lt;br/&gt;"</span>);</span><br><span class="line">	response.getWriter().write(<span class="string">"response.getWriter.write&lt;br/&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.getWriter.write</span><br><span class="line">out.write</span><br></pre></td></tr></table></figure>
<p>可见，由于out有缓冲，所以后显示。</p>
<h3 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h3><p><strong>pageContext对象</strong>:是JSP技术中最重要的一个对象，它代表JSP页面的运行环境</p>
<ul>
<li>封装了对其他8大隐式对象的引用(主要用于自定义标签开发)</li>
<li>自身是一个域对象，可用来保存数据(page域存的东西只能在页面范围内拿得出来)</li>
<li>封装了web开发中的一些常用操作(提供管理所有域的入口)，如：引入和跳转其他资源、检索其他域对象中的属性等</li>
</ul>
<p>Class PageContext的API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/jspapi/index.html?javax/servlet/jsp/PageContext.html" target="_blank" rel="noopener">javax.servlet.jsp:Class PageContext</a></p>
</blockquote>
<p>Java Web 中的四个域:</p>
<ul>
<li>application域:应用程序范围,servletContext,对应的常量<code>PageContext.APPLICATION_SCOPE</code></li>
<li>session域:会话范围,session,对应的常量<code>PageContext.SESSION_SCOPE</code></li>
<li>resquet域:请求范围,request,对应的常量<code>PageContext.REQUEST_SCOPE</code></li>
<li>page域:页面范围,pageContext,对应的常量<code>PageContext.PAGE_SCOPE</code></li>
</ul>
<p><strong><code>findAttribute(java.lang.String name)</code></strong>查找各个域中的属性，是<code>PageContext</code>从父类<code>javax.servlet.jsp.JspContext</code>继承的，实现了父类的抽象方法。会<strong>依次</strong>从<code>page,request,session,application</code>域中寻找相应的属性，找到为止。</p>
<h2 id="JSP映射和查错"><a href="#JSP映射和查错" class="headerlink" title="JSP映射和查错"></a>JSP映射和查错</h2><h4 id="JSP映射"><a href="#JSP映射" class="headerlink" title="JSP映射"></a>JSP映射</h4><p>在<code>webxml</code>的<code>&lt;servlet&gt;</code>标签中加<code>&lt;jsp-file&gt;</code>标签，其他的和servlet映射一样。</p>
<p><strong>1.查找jsp页面中的错误</strong><br></p>
<ul>
<li>JSP页面中的语法格式有问题，导致不能翻译成servlet源文件，JSP引擎将提示这类错误在JSP页面中的位置以及相关信息</li>
<li>JSP页面中的语法格式没有问题，但翻译承德servlet源文件出现java语法问题导致源文件编译不通过，JSP引擎将提示这类错误在JSP页面中的位置以及相关信息</li>
<li>JSP页面翻译成的servlet程序运行时出现异常，这和普通java程序运行时错误完全一样，java虚拟机将提示错误在servlet源文件中的位置以及相关信息</li>
</ul>
<h2 id="JSP与JavaBean"><a href="#JSP与JavaBean" class="headerlink" title="JSP与JavaBean"></a>JSP与JavaBean</h2><p>JavaBean是一个遵循特定写法的java类，JavaBean常用于封装数据，具有如下热点：</p>
<ul>
<li>该java类必须有一个无参的构造函数</li>
<li>属性必须私有化</li>
<li>私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。</li>
</ul>
<p>JSP中提供了三个关于JavaBean的标签：</p>
<ul>
<li><code>&lt;jsp:useBean&gt;</code>:用于在JSP页面中查找或实例化一个JavaBean组件</li>
<li><code>&lt;jsp:setProperty&gt;</code>:用于在JSP页面中设置一个JavaBean组件的属性</li>
<li><code>&lt;jsp:getProperty&gt;</code>:用于在JSP页面中获取一个JavaBean组件的属性</li>
</ul>
<blockquote>
<p>提示：一些细节</p>
</blockquote>
<ul>
<li><code>&lt;jsp:useBean&gt;</code>标签的标签体只在实例化bean时才执行</li>
<li><code>&lt;jsp:setProperty&gt;</code>可用请求参数给bean属性赋值，支持8种基本数据类型的转换(把客户机提交的字符串转成相应的8种基本类型赋到bean的属性上)</li>
<li>在标签中将<code>property=&quot;*&quot;</code>，用所有请求参数为bean赋值，请求参数名称和bean属性名称必须要一致</li>
<li>如果JavaBean实例对象的某个属性值为null,那么使用<code>&lt;jsp:getProperty&gt;</code>标签输出结果为<strong>“null”字符串</strong></li>
</ul>
]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存区域与内存溢出异常</title>
    <url>/undefined/JVM%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h2><h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h3><p><img src="images/16.png" alt=""></p>
<pre><code>线程共享：方法区，堆

线程私有：虚拟机栈，本地方法栈，程序计数器
</code></pre><h4 id="1-程序计数器（线程私有）"><a href="#1-程序计数器（线程私有）" class="headerlink" title="1.程序计数器（线程私有）"></a>1.程序计数器（线程私有）</h4><pre><code>可以看做是当前线程所执行的字节码的==行号指示器==。

==选取下一条需要执行的的字节码指令==，基础功能都需要依赖这个计数器来完成。
</code></pre><h4 id="2-Java虚拟机栈（线程私有的）"><a href="#2-Java虚拟机栈（线程私有的）" class="headerlink" title="2.Java虚拟机栈（线程私有的）"></a>2.Java虚拟机栈（线程私有的）</h4><pre><code>**虚拟机栈描述的是Java方法执行的内存模型**

每一个方法在执行的时候都会创建一个栈帧，每一个方法从调用直至执行完成的过程，就对应着==一个栈帧在虚拟机栈中的出栈入栈的过程==。

局部变量表：

    其中存放了编译期可知的各种**基本数据类型**（八大基本数据类型），**对象引用**（它不同于对象本身，可能是一个指向对象**起始地址**的引用指针，也可能是指向一个**代表对象的句柄**或者其他与此对象**相关的位置信息**）和 **returnAddress类型**（指向了一条字节码指令的地址）

==其中64位长度的long 和 double类型会占用两个局部变量空间==其余只占一个
</code></pre><h4 id="3-本地方法栈（线程私有）"><a href="#3-本地方法栈（线程私有）" class="headerlink" title="3.本地方法栈（线程私有）"></a>3.本地方法栈（线程私有）</h4><pre><code>本地方法栈是为虚拟机使用到的是Native方法服务。
</code></pre><h4 id="4-Java堆（线程共享）"><a href="#4-Java堆（线程共享）" class="headerlink" title="4.Java堆（线程共享）"></a>4.Java堆（线程共享）</h4><pre><code>Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块区域，==在虚拟机启动时创建==

其唯一目的就是：==存放对象实例，几乎所有的对象实例都在这里分配内存==，所有的对象实例以及数组都要在堆上分配内存。

Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。Java堆还可以细分为==新生代和老年代==

Java堆中还可以划分指出**多个线程私有的分配缓冲区**（TLAB）

Java堆可以存储在物理上不连续的内存空间之中
</code></pre><h4 id="5-方法区（线程共享）"><a href="#5-方法区（线程共享）" class="headerlink" title="5.方法区（线程共享）"></a>5.方法区（线程共享）</h4><pre><code>用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。

 用于存储已被虚拟机加载的类信息，常量，静态变量，

方法区可以选择不实现垃圾收集，他的**内存回收目标主要是针对常量池的回收和对类型的卸载！**
</code></pre><h4 id="6-运行时常量（方法区的一部分）"><a href="#6-运行时常量（方法区的一部分）" class="headerlink" title="6.运行时常量（方法区的一部分）"></a>6.运行时常量（方法区的一部分）</h4><pre><code>用于**存放编译期生成的字面量和符号引用**，这部分内容在**类加载**后进入方法区的运行时常量池中存放。

**运行期间也可能将新的常量放入池中**， 例如：String 类中的intern（）方法。
</code></pre><h4 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h4><pre><code> 他可以使用Native函数库直接分配堆外内存。然后通过一个存储在Java堆中的DirectByteBuffer对象**作为这块内存的引用**来进行操作

这样做避免了在Java堆中和Native堆中**来回复制数据**
</code></pre><h3 id="2-HotSpot虚拟机对象探秘："><a href="#2-HotSpot虚拟机对象探秘：" class="headerlink" title="2.HotSpot虚拟机对象探秘："></a>2.HotSpot虚拟机对象探秘：</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="==对象的创建=="></a>==对象的创建==</h4><pre><code>1. 虚拟机再碰到一条 new 指令的时候，先去检查这个指令的参数在常量池中**能否定位到一个类的引用**，并检查这个类**是否被加载**，解析和初始化。如果**没有**那么先**执行相应的类加载**过程

2. 在类加载检查通过之后，那么虚拟机将为对象分配空间。

3. ==指针碰撞==：假设堆是绝对规整的，所有用过的内存放在一边，空闲的内存放在一边，**中间放着一个指针作为分界点的指示器**，那么分配对象仅仅就是将这个指针往空闲的那边挪动一段大小和对象相等的距离。这种分配方式称为指针碰撞。**往空闲的空间挪动称为指针碰撞**

4. ==空闲列表==：假设内存不是规整的，空闲区域和内存区间相互交错。此时虚拟机必须维护一个表，**记录那些内存块是可以使用的**，再分配的时候从列表中找出一段足够大的空间划分给对象实例，并更新列表上的记录。这种分配方式称为空闲列表。**在空闲的区间挑选一块**

5.  使用哪种分配方式**取决于垃圾收集器是否带有压缩整理**的功能。
</code></pre><h4 id="如何解决创建对象是的线程安全问题"><a href="#如何解决创建对象是的线程安全问题" class="headerlink" title="如何解决创建对象是的线程安全问题"></a>如何解决创建对象是的线程安全问题</h4><pre><code>**方案一：**

    对分配内存空间的动作进行同步处理——实际上采用**CAS加上失败重试**的方式。

**方案二：**

    把内存分配的动作按照不同的线程划分在不同的空间上进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲（TLAB）**，那个线程需要分配内存，就在那个线程的TLAB上分配。**只有在TLAB用完并重新分配新的TLAB是才需要同步锁定。**

 6. 在内存分配完成之后，虚拟机要将分配到的内存空间都**初始化**为==零值==（保证了不赋初值可以直接使用）
 7. 给对象头赋值：虚拟机对对象进行必要的设置，那个类的，如何找到类的元数据信息，Hash码，对象的GC分代年龄等信息。==存储在对象头之中！！==
 8. 最后执行 init 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算产生出来。
</code></pre><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><pre><code>对象在内存中存储的布局可以分为三块区域：**对象头，实例数据，和对齐填充。**

**对象头信息**：

    1）、用于存储对象自身的运行时数据。哈希吗，GC分代信息等。

    2）、类型指针，（==系统通过这个指针来确定是哪个类的实例==），如果是一个数组，那么在对象头中还会存储这个对象的数组长度。

**实例数据部分**：

    1）、是对象真正存储的有效信息。

    2）、无论是父类继承下来的还是子类中自己定义的都需要记录起来。

**对齐填充**：

    1）、对齐填充并不是必须存在的。也没有什么特别的含义

    2）、仅仅起着对齐的作用。（要求必须是8的倍数，如果实例数据不够8位，则会使用对齐填充来进行对齐补充）
</code></pre><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><pre><code>前提：Java程序需要通过==栈上面的reference数据来操作堆==上面的具体对象

句柄访问：Java堆中将会划分出一块内存作为句柄池，句柄中包含了对象的实例数据与类型数据各自的具体位置信息。

直接指针：reference中存储的直接就是对象的地址。

好处：

**句柄访问**：使用句柄最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄之中的实例数据指针，而reference不需要改变。

**直接地址**：速度更快，节省了一次指针定位的时间开销（本书是使用直接地址的）
</code></pre><h4 id="内存溢出异常（OutOfMeMoryError）"><a href="#内存溢出异常（OutOfMeMoryError）" class="headerlink" title="内存溢出异常（OutOfMeMoryError）"></a>内存溢出异常（OutOfMeMoryError）</h4><pre><code>==除了程序计数器之外==别的其他几个运行时内存区域都有发生内存溢出的情况。
</code></pre><h5 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h5><pre><code>Java堆用于存储对象，只要**不断地创建对象，并且避免垃圾回收清除这些对象**，那么在对象数量达到**最大堆的容量限制**之后就会发生内存溢出异常。
</code></pre><h5 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h5><ul>
<li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，则会抛出StackOverflowError异常</p>
</li>
<li><p>如果虚拟机在扩展栈的时候无法申请到足够的内存空间，则会抛出OutOfMomeryError异常</p>
<p>实验表明在单个线程之下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，都会抛出StackOverflowError异常</p>
<p>如果不断建立线程，倒是可以发生内存溢出异常，在这种情况下每个线程的栈分配的内存越大，反而更加容易产生内存溢出异常。</p>
<p>如果是建立过多线程，从而出现的内存溢出异常，可以通过减少最大堆和栈的容量来换取更多的线程。</p>
</li>
</ul>
<h5 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h5><pre><code>使用**intern**方法 无限放入常量。

产生大量的类去填满方法区
</code></pre><h5 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h5><h2 id="垃圾收集器和内存分配策略"><a href="#垃圾收集器和内存分配策略" class="headerlink" title="垃圾收集器和内存分配策略"></a>垃圾收集器和内存分配策略</h2><p>前言：Java和C++之间存在一堵由==内存动态分配和垃圾收集技术==围成的高墙，墙外面的人想进来，墙里面的人却想出去。</p>
<h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><ul>
<li>那些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<h4 id="3-2对象已死吗？"><a href="#3-2对象已死吗？" class="headerlink" title="3.2对象已死吗？"></a>3.2对象已死吗？</h4><h5 id="3-2-1引用计数算法"><a href="#3-2-1引用计数算法" class="headerlink" title="3.2.1引用计数算法"></a>3.2.1引用计数算法</h5><p>​    概念：给对象添加一个引用计数器，每当有一个地方引用他的时候，计数器的值就加一，当引用失效的时候，计数器就减一，<strong>任何时候计数器为零的对象就是不可能再被使用的</strong>。</p>
<h5 id="3-2-2可达性分析法"><a href="#3-2-2可达性分析法" class="headerlink" title="3.2.2可达性分析法"></a>3.2.2可达性分析法</h5><p>​    一句话，就是把对象挂在了GC Roots之上，如果没有挂上就回收。即使他们之间或许有关联，只要没有挂在GC Roots之上，就需要回收。</p>
<p>​    <img src="images/17.png" alt=""></p>
<p>如图：对象 5和6 即使他们彼此有关联，但是没有挂在GC Roots之上，所以被判断为是可以回收的对象。</p>
<h5 id="3-2-3再谈引用"><a href="#3-2-3再谈引用" class="headerlink" title="3.2.3再谈引用"></a>3.2.3再谈引用</h5><h5 id="3-2-4生存还是死亡"><a href="#3-2-4生存还是死亡" class="headerlink" title="3.2.4生存还是死亡"></a>3.2.4生存还是死亡</h5><p>​    可达性分析算法判断为可以回收的对象只是判了缓刑。</p>
<p>​    两次标记过程：</p>
<p>​        第一次：可达性分析法判断之后没有与GC Roots 相连接的引用链，那么将会进行第一次标记，并且进行一次筛选。如果这个对象被判定为需要执行finalize()方法，那么这个对象将会被放在 <strong>F - Queue</strong>的队列之中。</p>
<p>​        第二次：GC 将会对F-Queue之中的对象进行第二次小规模的标记，还没有逃脱那么将会回收。</p>
<h5 id="3-2-5回收方法区"><a href="#3-2-5回收方法区" class="headerlink" title="3.2.5回收方法区"></a>3.2.5回收方法区</h5><p>​    1）、回收废弃的常量</p>
<p>​        例如:String</p>
<p>​    2)、回收无用的类：</p>
<p>​        满足如下三个条件：</p>
<ul>
<li>该类的所有实例都已经被回收了。    </li>
<li>加载该类的ClassLoader已经被回收</li>
<li>改类的java.lang.class 对象没有在任何地方被引用，<strong>无法通过反射访问该类的方法</strong>。 </li>
</ul>
<h4 id="3-3垃圾收集算法："><a href="#3-3垃圾收集算法：" class="headerlink" title="==3.3垃圾收集算法：=="></a>==3.3垃圾收集算法：==</h4><h5 id="3-3-1标记—清除算法"><a href="#3-3-1标记—清除算法" class="headerlink" title="3.3.1标记—清除算法"></a>3.3.1标记—清除算法</h5><p>​    首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。（<strong>先标记后清除</strong>）</p>
<p>​    两个不足：</p>
<p>​        1）、效率不高，标记和清除两个过程的效率都不高。</p>
<p>​        2）、空间问题，会产生大量的不连续的空间碎片。（再分配大对象时没有地方分配，提前触发GC）</p>
<p>​    <img src="images/18.jpg" alt=""></p>
<h5 id="3-3-2复制算法"><a href="#3-3-2复制算法" class="headerlink" title="3.3.2复制算法"></a>3.3.2复制算法</h5><p>​    很简单：将内存分为大小相等的<strong>两块</strong>，每次<strong>只用一块</strong>，当这<strong>一块的内存用完了</strong>，直接把这一块上面存活的对象，<strong>复制到第二块</strong>之上。再把<strong>第一块直接清除掉</strong>。（可以避免内存碎片）</p>
<p>​    代价：每次只是用一半，太高了。</p>
<p>​    改良：因为新生代中的对象98%都是”<strong>朝生夕死</strong>“，所以可以将内存分为一块<strong>较大的Eden</strong>，和<strong>两块较小的Survivor</strong>空间。</p>
<p>​    Eden ： Survivor = 8 ： 1</p>
<p>​    每次回收的时候，将Eden 和 一块Survivor 中还存活的对象，一次性的复制到另一块Survivor之中。这样只会浪费10%，但是无法保证每一次只有不多于10%的对象存活，因此还需要<strong>内存担保</strong>。</p>
<p><img src="images/19.png" alt=""></p>
<p><img src="images/20.png" alt=""></p>
<h5 id="3-3-3-标记—整理算法"><a href="#3-3-3-标记—整理算法" class="headerlink" title="3.3.3 标记—整理算法"></a>3.3.3 标记—整理算法</h5><p>​    复制算法在对象存活率过高的时候，需要进行较多的复制操作，效率将会变得更低。</p>
<p>​    更关键的是，万一100%的对象都存活了，怎么办？</p>
<p>​    标记整理算法：    </p>
<p>​        先标记，<strong>在移动整理一下</strong>。就没有内存碎片了。</p>
<p>​    <img src="images/21.png" alt=""></p>
<p>​    <img src="images/22.png" alt=""></p>
<h5 id="3-3-4分代收集算法"><a href="#3-3-4分代收集算法" class="headerlink" title="3.3.4分代收集算法"></a>3.3.4分代收集算法</h5><p>​    新生代：每次都有大量的对象死去，只有<strong>少量存活</strong>，所以采用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>​    老年代：<strong>对象存活率高，</strong>没有额外的空间进行空间担保，采用标记—清除，或者采用标记—整理算法。</p>
<h4 id="3-4HotSpot的算法实现"><a href="#3-4HotSpot的算法实现" class="headerlink" title="3.4HotSpot的算法实现"></a>3.4HotSpot的算法实现</h4><ol>
<li><p>通过可达性分析算法——是否有到达GC Roots的引用链来判断，对象是否可以被回收。</p>
</li>
<li><p>对象之间的引用在类的成员变量初始化以及类的方法中都会出现，如果<strong>逐个遍历，会消耗很多时间</strong>。</p>
</li>
<li><p>使用一组<strong>OopMap来记录对象在栈中的引用地址</strong>，这样，HotSpot就可以<strong>快速</strong>找到GC Roots的对象集合。</p>
</li>
<li><p>另外，如果在进行判断分析的时候，有<strong>新的引用产生怎么办</strong>呢？</p>
<p>​    这就要求在虚拟机执行垃圾收集的时候，需要将<strong>所有虚拟机暂停</strong>（“Stop the world”），以保持快照的<strong>一致性</strong>。</p>
<p>但是如果积攒了比较多的对象集中进行分析，那么这个暂停的时间就会比较长，一次收集的时间就会比较多。</p>
<p>如果通过<strong>增加垃圾收集频次，减少每次垃圾收集分析工作量，那么垃圾收集占用总的时间也不少</strong>。</p>
</li>
<li><p>安全点：由于为每一条指令都生成OopMap需要大量的空间，所以只再特定的位置记录这些信息，这些位置成为安全点。</p>
</li>
<li><p>长时间执行的的最明显特征是指令序列复用，方法调用啊，循环跳转，异常跳转等。</p>
</li>
<li><p>另外，虚拟机有两种中断方式。</p>
<ol>
<li><p>抢先式中断：由虚拟机发起，所有线程全部中断，不在安全点上的线程，恢复运行至安全点上。</p>
</li>
<li><p>主动式中断：由线程去轮询是否中断的标志位，发现标识为真时，就自己将线程暂停挂起。</p>
</li>
</ol>
</li>
<li><p>安全区域：专门用来处理当进行垃圾收集的时候，没有分配CPU时间的程序，比如线程处于<strong>Sleep状态</strong>，<strong>Blocked状态</strong>，这些线程没办法响应JVM的暂停要求，对于这种状况，单独设置了一个安全区域</p>
</li>
<li><p>基本思路：</p>
<ol>
<li><p>当线程执行到安全区域中的代码时，标识自己进入了安全区域。</p>
</li>
<li><p>当线程准备离开安全区域的时候，检查垃圾收集是否完成，如果结束了，线程继续执行；如果没结束，就等到结束之后再离开安全区域。</p>
</li>
</ol>
</li>
</ol>
<h4 id="3-5垃圾收集器："><a href="#3-5垃圾收集器：" class="headerlink" title="3.5垃圾收集器："></a>3.5垃圾收集器：</h4><h5 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS(Concurrent Mark Sweep)"></a>CMS(Concurrent Mark Sweep)</h5><p>​    并发标记清除收集器：以获取最短回收停顿时间为目标的收集器。</p>
<p><strong>应用场景</strong>：希望系统停顿时间最短，已给用户较好的的体验。</p>
<p>运作过程：</p>
<ul>
<li>初始标记：仅仅是标记一下GC Roots 能直接关联的对象，速度很快</li>
<li>并发标记：就是进行GC Roots Tracing（示踪）的过程</li>
<li>重新标记：重新标记阶段就是为了修正并发标记期间因为<strong>用户程序继续运行</strong>而<strong>导致标记产生变动</strong>的那一部分对象的标记记录，这个阶段的停顿时间一般会比<strong>初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong></li>
<li>并发清除：</li>
</ul>
<p>优点：==并发收集，低停顿==         </p>
<p>原因：由于在整个过程中最耗时的<strong>并发标记和并发清除</strong>过程收集器程序都可以和<strong>用户线程一起工作</strong>，所以总体来说，CMS收集器的内存回收过程是与用户线程<strong>一起并发执行</strong>的</p>
<p>三大缺点：</p>
<pre><code>1. CMS收集器对CPU资源非常敏感    在**并发阶段他会占用一部分线程**，从而**导致应用程序变慢**，**总的吞吐量会降低。**
2. CMS处理器无法处理浮动垃圾 伴随着程序运行，自然会产生一些**新的垃圾（在标记过后）**，CMS无法再本次收集中清除，这个称为浮动垃圾。
3. 标记清除算法的缺点。（内存碎片的浪费）
</code></pre><h5 id="G1（G-First）"><a href="#G1（G-First）" class="headerlink" title="G1（G First）"></a>G1（G First）</h5><p>​    G1 收集器是面向服务端应用的垃圾收集器。G1具备如下的特点：</p>
<ol>
<li>并发和并行：G1能充分利用CPU、<strong>多核环境下的硬件优势</strong>，<strong>使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间</strong>。部分其他收集器原本需要停顿<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内</li>
</ol>
<p>运作过程：</p>
<p>​1、初始标记；2、并发标记；3、最终标记；4、筛选回收</p>
<p>​    上面几个步骤的运作过程和CMS有很多相似之处。</p>
<p>​    初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，</p>
<p>​    并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。</p>
<p>​    最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记<strong>产生变动的那一部分标记</strong>记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。</p>
<p>​    最后在筛选回收阶段首先对各个Region的<strong>回收价值和成本进行排序</strong>，根据用户所<strong>期望的GC停顿时间</strong>来制定回收计划</p>
<h2 id="第七章：类加载机制"><a href="#第七章：类加载机制" class="headerlink" title="第七章：类加载机制"></a>第七章：类加载机制</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将静态存储结构转换为方法区的运行时数据结构</li>
<li>生成一个java.lang.class 对象，作为这个类的访问入口</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>其实就是检查加载的 class 的正确性和安全性 </p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为类变量分配存储空间以及设置类变量初始值（附默认值）</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>JVM 将常量池内的符号引用转换为直接引用</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行类变量的赋值  以及静态代码块</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="images/23.png" alt=""></p>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>​    由<code>C++</code>语言实现（针对<code>HotSpot</code>）,负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录或<code>-Xbootclasspath</code>参数指定的路径中的类库加载到内存中</p>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>​    负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</p>
<h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><p>​    负责加载用户类路径（<code>classpath</code>）上的指定类库</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="实现自己的类加载器"><a href="#实现自己的类加载器" class="headerlink" title="实现自己的类加载器"></a>实现自己的类加载器</h5><pre><code>1. 继承ClassLOader这个类
2. 实现 findClass 这个方法
3. 在findClass 这个方法中调用 defineClass 这个方法即可
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String path;</span><br><span class="line">	<span class="keyword">private</span> String classLoaderName;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path, String classLoaderName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.path = path;</span><br><span class="line">		<span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用于寻找类文件</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">		<span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用于加载类文件</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">		name = path + name + <span class="string">".class"</span>;</span><br><span class="line">		InputStream in = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">			out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			<span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				out.close();</span><br><span class="line">				in.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> out.toByteArray();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双亲委派模型的工作机制"><a href="#双亲委派模型的工作机制" class="headerlink" title="双亲委派模型的工作机制"></a>双亲委派模型的工作机制</h4><p>​    <strong>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即<code>ClassNotFoundException</code>），子加载器才会尝试自己去加载。</strong></p>
<h3 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h3><pre><code>1. 保证了安全性。黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。！
2. **防止两份相同的字节码文件加入到内存中占用内存资源**
</code></pre><h3 id="ClassLoader-和-Class-forName-的区别"><a href="#ClassLoader-和-Class-forName-的区别" class="headerlink" title="ClassLoader 和 Class.forName 的区别"></a>ClassLoader 和 Class.forName 的区别</h3><h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h4><p>Class.forName 会去加载并初始化这个类</p>
<p>其实他是调用了 forName 这个方法  里面的是否要初始化 为true 所以说他是<strong>完成了整个类加载过程</strong></p>
<p>==<strong>所以静态代码块会被执行</strong>==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在连接MySQL 数据库时 必须使用 Class.forName 才能完成对驱动的注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>ClassLoader 只是完成了对这个类的加载过程，并没有进行初始化操作</p>
<p><strong>在Spring IOC 中多见。用于懒加载，加快了初始化部署速度。留到实际使用是才去加载。</strong></p>
<h2 id="JVM-其他问题"><a href="#JVM-其他问题" class="headerlink" title="JVM 其他问题"></a>JVM 其他问题</h2><h3 id="可以作为GCroot的对象："><a href="#可以作为GCroot的对象：" class="headerlink" title="可以作为GCroot的对象："></a>可以作为GCroot的对象：</h3><ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中的Native方法引用的对象</li>
</ol>
<h3 id="JVM参数："><a href="#JVM参数：" class="headerlink" title="JVM参数："></a>JVM参数：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms</span><br><span class="line">-Xmx</span><br><span class="line">-Xss</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h4><p>​    <strong>标配参数：</strong></p>
<p>​            java -version</p>
<p>​            java -help</p>
<p>​    <strong>X参数（了解）：</strong></p>
<p>​            java -Xint  解释执行</p>
<p>​            java -Xcomp    第一次使用就编译成本地代码</p>
<p>​            java -Xmixed 混合模式</p>
<p>​    <strong>XX参数：</strong></p>
<p>​            <strong>Boolean 类型：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">公式：</span><br><span class="line">	-XX: + 或者 - 某个属性值</span><br><span class="line">	+ ： 表示开启</span><br><span class="line">	- ： 表示关闭</span><br><span class="line"><span class="keyword">case</span>： 是否打印GC收集细节：</span><br><span class="line"><span class="number">1</span>. 运行程序</span><br><span class="line"><span class="number">2</span>. 添加JVM参数  -XX：+PrintGCDetails</span><br><span class="line"><span class="number">3</span>. jps -l 获取进程编号</span><br><span class="line"><span class="number">4</span>. jinfo -flag PrintGCDetails 进程编号 </span><br><span class="line">	查看是否开启</span><br></pre></td></tr></table></figure>
<p>​            <strong>KV设值类型：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">公式：</span><br><span class="line">	-XX:属性key=属性值value</span><br><span class="line"><span class="keyword">case</span>：</span><br><span class="line">	-XX：MetaspaceSize=<span class="number">128</span>m （元空间大小）</span><br><span class="line">	-XX：MaxTenuringThreshold=<span class="number">15</span> （晋升老年代GC次数）</span><br></pre></td></tr></table></figure>
<h4 id="查看参数"><a href="#查看参数" class="headerlink" title="查看参数"></a><strong>查看参数</strong></h4><p><strong>一。正在运行的程序的参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. jps -l 获取进程id</span><br><span class="line"><span class="number">2</span>. jinfo -flags id</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>​    -Xms：</p>
<p>​        等价于 ： -XX：InitialHeapSize</p>
<p>​    -Xmx：</p>
<p>​        等价于： -XX：MaxHeapSize</p>
<p><strong>二。初始参数：</strong></p>
<p> java -XX:+PrintFlagsInitial</p>
<p>:=      人为修改了参数</p>
<p>=         初始参数</p>
<p><strong>三：最终参数</strong></p>
<p> java -XX:+PrintFlagsFinal</p>
<p>​    运行java命令的同时打印出参数</p>
<p><strong>四：查看究竟用那个GC收集器</strong></p>
<p>​    java -XX:+PrintCommandLineFlags -version</p>
<p><img src="images/3.png" alt=""></p>
<h4 id="JVM常用基本配置参数"><a href="#JVM常用基本配置参数" class="headerlink" title="JVM常用基本配置参数"></a>JVM常用基本配置参数</h4><p>-Xms 初始堆内存</p>
<p>-Xmx 最大堆内存</p>
<h4 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms 初始堆大小内存</span><br><span class="line">-Xmx 最大堆分配内存</span><br><span class="line">-Xss 设置单个线程的大小 一般为 <span class="number">521</span>K—<span class="number">1024</span>K （<span class="number">0</span> 代表 使用默认值）</span><br><span class="line">	等价于：-XX：ThreadStackSize</span><br><span class="line">-Xmn 设置年轻代大小</span><br><span class="line">-XX:MetaspaceSize 设置元空间大小</span><br><span class="line">-XX:SurvivorRatio 设置新生代老年代的比例 </span><br><span class="line">	例<span class="number">1</span>：-XX:SurvivorRatio=<span class="number">4</span>   <span class="number">4</span>:<span class="number">1</span>：<span class="number">1</span> （默认 <span class="number">8</span>:<span class="number">1</span>:<span class="number">1</span>）</span><br><span class="line">-XX:MaxTenuringThreshold 设置垃圾最大年龄 （必须 <span class="number">0</span>-<span class="number">15</span>之间 不然会报错）</span><br></pre></td></tr></table></figure>
<h4 id="GC日志信息："><a href="#GC日志信息：" class="headerlink" title="GC日志信息："></a>GC日志信息：</h4><p><img src="images/4.png" alt=""></p>
<h2 id="四大引用："><a href="#四大引用：" class="headerlink" title="四大引用："></a>四大引用：</h2><h3 id="强引用："><a href="#强引用：" class="headerlink" title="强引用："></a>强引用：</h3><p>​    当内存不足时，JVM开始垃圾回收，对于强引用的对象，就算是==出现了OOM也不会对该对象进行回收==，死都不回收！</p>
<p>​    强引用是我们最常见的普通对象引用。只要强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态。是不可能被垃圾回收机制回收的，==即使该对象也后都不会被用到，JVM也不会回收==，<strong>==因此强引用是造成Java内存泄露的主要原因之一==</strong></p>
<p>​    对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者是显式的将相应的强引用赋值为null，一般就可以被垃圾收集了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强<span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">new</span> Object(); <span class="comment">//这样的定义默认是强引用</span></span><br><span class="line">		Object o2 = o1; <span class="comment">//o2 引用赋值</span></span><br><span class="line">		o1 = <span class="keyword">null</span>; <span class="comment">//o1 置空</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.out.println(o2);  <span class="comment">//照样可以打印出结果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>​    ==内存足够的前提下不收，内存不够了就收了你！== <strong>java.lang.SoftReference</strong> 类来实现，可以让对象豁免一些垃圾收集！！</p>
<p>​    <strong>软引用通常在对内存敏感的程序之中，比如高速缓存就有用到软引用</strong>，内存够用的时候就保留，不够用就回收！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 软<span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="comment">//内存够用的情况下</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRef_Memory_enough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">		SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(o1);</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(softReference.get());</span><br><span class="line">		</span><br><span class="line">		o1 = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(softReference.get());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//内存不够用</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 故意产生大对象并配置小的内存，让他内存不够用了导致OOM，看软引用的回收情况</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRef_Memory_NotEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">		SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(o1);</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(softReference.get());</span><br><span class="line">		</span><br><span class="line">		o1 = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2000</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(o1);</span><br><span class="line">			<span class="comment">//这个 打印不出来了</span></span><br><span class="line">			System.out.println(softReference.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//softRef_Memory_enough();</span></span><br><span class="line">		softRef_Memory_NotEnough();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>​    ==只要发生GC一定回收，不管JVM内存是否充足==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 弱<span class="title">Demo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">		WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(o1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(weakReference.get());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"============="</span>);</span><br><span class="line">		</span><br><span class="line">		o1 = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(weakReference.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出： 内存足够</span><br><span class="line">java.lang.Object@<span class="number">15</span>db9742</span><br><span class="line">java.lang.Object@<span class="number">15</span>db9742</span><br><span class="line">=============</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h3 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h3><p>​    假设有一个应用需求读取大量的本地图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 如果每次读取图片都从硬盘读取则会严重影响性能</span><br><span class="line">* 如果一次性加载到内存中又可能造成内存溢出</span><br></pre></td></tr></table></figure>
<p>设计思路是：用一个HashMap 来保存图片的路径和相应图片对象的关联之间的映射关系，在内存不足的情况下，JVM会自动回收这些缓存图片的对象所占用的空间，从而有效的避免了OOM的问题！</p>
<p>==Map&lt;String, SoftRefence<bitmap>&gt; images = new HashMap&lt;&gt;();==</bitmap></p>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>==只要发生GC就回收==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        myHashMap();</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        myWeakHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Integer key1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value1 = <span class="string">"HashMap"</span>;</span><br><span class="line">        map.put(key1, value1);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key1 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key2 = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">        String value2 = <span class="string">"HashMap-WeakHashMap"</span>;</span><br><span class="line">        weakHashMap.put(key2, value2);</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        key2 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>=HashMap&#125;</span><br><span class="line">&#123;<span class="number">1</span>=HashMap&#125;</span><br><span class="line">&#123;<span class="number">1</span>=HashMap&#125;</span><br><span class="line">===================</span><br><span class="line">&#123;<span class="number">2</span>=HashMap-WeakHashMap&#125;</span><br><span class="line">&#123;<span class="number">2</span>=HashMap-WeakHashMap&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p>​    虚引用需要<strong>java.lang.ref.PhantomReference</strong>类来实现。</p>
<pre><code>顾名思义，就是==形同虚设==，与其他几种引用都不同，虚引用并不会决定对象的生命周期。

==如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收==，==**它不能单独使用,也不能通过它访问对象，虚引用必须和引用队列(ReferenceQueue)联合使用**==

虚引用的主要作用是**跟踪对象被垃圾回收的状态**。**仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。**

**PhantomReference的get方法总是返回null,**   **因此无法访问对应的引用对象**。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。

==换句话说，设置虛引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理==。Java技术允许使用finalize()方法在垃圾收集器==将对象从内存中清除出去之前做必要的清理工作==。 ==类似于Spring中的后置通知==。
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 虚<span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">		ReferenceQueue&lt;Object&gt; referentQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line">		PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(o1, referentQueue);</span><br><span class="line">		</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(phantomReference.get());</span><br><span class="line">		System.out.println(referentQueue.poll());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"===============GC之前====================="</span>);</span><br><span class="line">		o1 = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">		System.out.println(phantomReference.get());</span><br><span class="line">		System.out.println(referentQueue.poll());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">java.lang.Object@<span class="number">7852e922</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.ref.PhantomReference@<span class="number">4e25154f</span></span><br></pre></td></tr></table></figure>
<h3 id="强软弱虚总结："><a href="#强软弱虚总结：" class="headerlink" title="强软弱虚总结："></a>强软弱虚总结：</h3><p>​    <img src="images/5.png" alt=""></p>
<p>==软引用和虚引用再被回收后，会放入引用队列中，便于后续处理==</p>
<h2 id="对OOM的认识："><a href="#对OOM的认识：" class="headerlink" title="==对OOM的认识：=="></a>==对OOM的认识：==</h2><h3 id="StackOverflow："><a href="#StackOverflow：" class="headerlink" title="StackOverflow："></a>StackOverflow：</h3><p>栈内存不够</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStackOverflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        myStackOverflow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myStackOverflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myStackOverflow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HeapSpace"><a href="#HeapSpace" class="headerlink" title="HeapSpace"></a>HeapSpace</h3><p>堆内存不够</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpace</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置参数 -Xms10m -Xmx10m</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">80</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GC-Overhead"><a href="#GC-Overhead" class="headerlink" title="GC Overhead"></a>GC Overhead</h3><p>​    GC回收时间过长时会抛OutOfMemroyError.过长的定义是，==超过98%的时间用来做GC并且回收了不到2%的堆内存====连续多次GC都只回收了不到2%的极端情况下才会抛出==。</p>
<p>​    <strong>假如不抛出GC overhead limit 错误会发生什么情况呢?<em>那就是GC清理的这么点内存很快会再次填满，迫使GC再次执行，这样就形成恶性循环，</em> CPU使用率一 直是100%， 而GC却没有任何成果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCOverHead</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置参数 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m（最大直接内存大小）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(String.valueOf(++i).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line">            System.out.println(<span class="string">"I = "</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Direct-Buffer（直接内存溢出）"><a href="#Direct-Buffer（直接内存溢出）" class="headerlink" title="Direct  Buffer（直接内存溢出）"></a>Direct  Buffer（直接内存溢出）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment">    NIO 里面的</span></span><br><span class="line"><span class="comment"> *  ByteBuffer.allocate(); 第一种方式是分配 JVM 堆内存，属于 GC 管辖，需要拷贝到直接内存速度慢</span></span><br><span class="line"><span class="comment"> *  ByteBuffer.allocateDirect(); 第二种方式分配本地 OS 内存，不属于GC管辖，不需要拷贝速度快。									性能更好，但是不断地分配本地内存，而堆内存很少使用，</span></span><br><span class="line"><span class="comment"> 								  JVM 不会进行 GC，就会爆出 OOM， 程序直接崩溃</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 小纸人</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-02 1:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查看直接内存大小</span></span><br><span class="line">        System.out.println((VM.maxDirectMemory() / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span> ) + <span class="string">"MB"</span>);</span><br><span class="line">        ByteBuffer.allocateDirect(<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unable-to-create-new-native-thread-无法创建更多线程"><a href="#unable-to-create-new-native-thread-无法创建更多线程" class="headerlink" title="unable to create new native thread(无法创建更多线程)"></a>unable to create new native thread(无法创建更多线程)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> *  你的应用创建了太多的线程， linux 默认一个 应用程序 最多创建 1024个线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 小纸人</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-02 1:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//暂停一会线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(Integer.MAX_VALUE); &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM 参数 ：</span></span><br><span class="line"><span class="comment"> *  -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> *  Java 8 之后使用了 元空间Metaspace 代替了 永久代</span></span><br><span class="line"><span class="comment"> *  主要存放 ：</span></span><br><span class="line"><span class="comment"> *      虚拟机加载的类信息</span></span><br><span class="line"><span class="comment"> *      常量池</span></span><br><span class="line"><span class="comment"> *      静态变量</span></span><br><span class="line"><span class="comment"> *  模拟 Metaspace 空间溢出，不停的生成类往 Metaspace 里面灌</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 小纸人</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-02 1:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> methodProxy.invoke(o,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                enhancer.create();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"多少次后发生了异常："</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM性能调优</title>
    <url>/undefined/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h2><p>[TOC]</p>
<h3 id="JDK-8-新特性"><a href="#JDK-8-新特性" class="headerlink" title="JDK 8 新特性"></a>JDK 8 新特性</h3><h4 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h4><p>Java 8 使用两个新概念扩展了接口的含义，默认方法和静态方法。默认方法，让开发人员可以在不破坏二进制兼容的前提下，往现存接口中添加新的方法（不强制那些实现了该接口的类也同时实现该新方法）。</p>
<h4 id="Nashorn-JavaScript-引擎"><a href="#Nashorn-JavaScript-引擎" class="headerlink" title="Nashorn JavaScript 引擎"></a>Nashorn JavaScript 引擎</h4><p>在JDK 8 中采用了Metaspace(JEP 122)代替持久带(PermGen space)。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
<h4 id="Visual-VM-插件"><a href="#Visual-VM-插件" class="headerlink" title="Visual VM 插件"></a>Visual VM 插件</h4><h4 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h4><h4 id="vmstat-命令"><a href="#vmstat-命令" class="headerlink" title="vmstat 命令"></a>vmstat 命令</h4>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合遍历</title>
    <url>/undefined/Java%20List%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-List集合遍历的几种方式"><a href="#Java-List集合遍历的几种方式" class="headerlink" title="Java List集合遍历的几种方式"></a>Java List集合遍历的几种方式</h2><h4 id="1-for循环遍历"><a href="#1-for循环遍历" class="headerlink" title="1.for循环遍历"></a>1.for循环遍历</h4><pre><code>//在这里新建一个List集合
List&lt;Teacher&gt; teacherLists = new ArrayList&lt;Teacher&gt;();
//然后遍历集合
for (int i = 0; i &lt; teacherList.size(); i++){
    Teacher teacher = teacherList.get(i);
    if (teacher != null){
        teacherLists.add(teacher);
        }
    model.addAttribute(&quot;teacherList&quot;,teacherLists);
}
</code></pre><h4 id="2-for循环-迭代器"><a href="#2-for循环-迭代器" class="headerlink" title="2.for循环(迭代器)"></a>2.for循环(迭代器)</h4><pre><code>for (Iterator iterators = teacherList.iterator();iterators.hasNext();){
    Teacher teacher = (Teacher) iterators.next();
    String tname = teacher.getName();
    model.addAttribute(&quot;teacherList&quot;,tname);
}
</code></pre><h4 id="3-for循环-数组"><a href="#3-for循环-数组" class="headerlink" title="3.for循环(数组)"></a>3.for循环(数组)</h4><pre><code>for (int i=0; i &lt; teacherList.size(); i++){
    String[] arr = new String[teacherList.size()];
    for (int j = 0; j &lt; teacherList.size(); j++){
        arr[i] = teacherList.get(j).getName();
        model.addAttribute(&quot;teacherList&quot;,arr[i]);
    }
    //model.addAttribute(&quot;teacherList&quot;,teacherList.get(i));
}
//model.addAttribute(&quot;teacherList&quot;,teacherList);
</code></pre><h4 id="4-F-E"><a href="#4-F-E" class="headerlink" title="4.F-E"></a>4.F-E</h4><p>在前端输出的时候，如果输出的是List集合，那么输出之后，还需要转换成具体的输出，比如：teacherList.getName()，teacherList.getOffice等。然后在之前加上&lt;#list&gt;标签能遍历所有的元素。</p>
<pre><code>&lt;#list teacherList as teacher&gt;
    &lt;tr&gt;
        &lt;td&gt;${teacher.getStaffno()}&lt;/td&gt;
        &lt;td&gt;${teacher.getName()}&lt;/td&gt;
        &lt;td&gt;${teacher.getOffice()}&lt;/td&gt;
    &lt;/tr&gt;
&lt;/#list&gt;
</code></pre><hr>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/undefined/Java%20NIO/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在实现NIO的客户端时，首先调用静态工厂方法 SocketChannel.open() 创建新的 java.nio.channels.SocketChannel对象。方法参数是 java.net.SocketAddress 对象，指示要连接的主机和端口。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><pre><code>1. 位置（postion）

2. 容量（capacity）

3. 限量（limit）

4. 标记（mark）
</code></pre><h4 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h4><h5 id="1-分配"><a href="#1-分配" class="headerlink" title="1. 分配"></a>1. 分配</h5><p>allocate()方法只返回一个有指定固定容量的新缓冲区，是一个kg能偶缓冲区。</p>
<h5 id="2-直接分配"><a href="#2-直接分配" class="headerlink" title="2. 直接分配"></a>2. 直接分配</h5><p>ByteBuffer类有另外一个allocateDirect()方法，该方法不为缓冲区创建后备数组。VM会对以太网卡、核心内存或其它位置的缓冲区使用直接内存访问，以此实现直接分配的ByteBuffer。</p>
<h5 id="3-包装"><a href="#3-包装" class="headerlink" title="3. 包装"></a>3. 包装</h5><p>如果已经有要输出的数据数组，一般要用缓冲区进行包装，而不是分配一个新的缓冲区，然后一次一部分的复制到这个缓冲区。</p>
<pre><code>byte[] data = &quot;hello world&quot;.getBytes(&quot;utf-8&quot;);
ByteBuffer buffer1 = ByteBuffer.wrap(data);

char[] text = &quot;some text&quot;.toCharArray();
CharBuffer buffer2 = ByteBuffer.wrap(text);
</code></pre><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>SocketChannel类可以读写TCP Socket。数据必须编码到ByteBuffer对象中完成读/写。每个SocketChannel都与一个Socket对象相关联，该Socket对象可用于高级配置，不过一般默认选项便可正常运行。</p>
<pre><code>//该方法创立连接将阻塞，即在连接建立或抛出异常之间，该方法不会返回
1. public static SocketChannel open(SocketAddress address) throws IOException;

//该方法创建初始未连接方法，以后需要connect()方法进行连接
2. public static SocketChannel open() throws IOException;
</code></pre><h4 id="1-读取"><a href="#1-读取" class="headerlink" title="1. 读取"></a>1. 读取</h4><p>在读取SokcetChannel内容时需要创建一个ByteBuffer，通道可以在ByteBuffer中存储数据，然后将该buffer传给read()方法。</p>
<blockquote>
<p>提示：1. 散布（scatter），表示能从一个源填充多个缓冲区。</p>
</blockquote>
<h4 id="2-写入"><a href="#2-写入" class="headerlink" title="2. 写入"></a>2. 写入</h4><p>Socket通道提供读写方法，一般情况下它们是全双工的。在想写入数据时，只需要填充一个ByteBuffer，然后将其回绕传给某个写入方法，该方法将数据复制到，输出时将缓冲区排空。</p>
<blockquote>
<p>提示：2. 聚集（gather），表示将多个缓冲区的数据写入到一个Socket中。</p>
</blockquote>
<h4 id="3-关闭"><a href="#3-关闭" class="headerlink" title="3. 关闭"></a>3. 关闭</h4><p>在用完通道之后需要关闭，释放它可能使用的端口和其它资源。close()方法。</p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>该类只有一个目的就是接受入站连接，我们无法读取、写入或连接ServerSocketChannel。其支持的唯一操作便是接受一个新的入站连接。accept() | close() 方法。</p>
<pre><code>//该方法只是创建这个对象
1. ServerSocketChannel server = ServerSocketChannel.open();

//该方法创建ServerSocket
2. ServerSocket socket = server.socket();

//Java 7中ServerSocketChannel有自己的bind()方法
</code></pre><h4 id="1-接受连接"><a href="#1-接受连接" class="headerlink" title="1. 接受连接"></a>1. 接受连接</h4><p>accept()方法监听入站连接请求。该方法可以在阻塞和非阻塞模式下操作。</p>
<h3 id="Selector类"><a href="#Selector类" class="headerlink" title="Selector类"></a>Selector类</h3><pre><code>1. 调用静态工厂方法 Selector.open() 来创建新的选择器。

2. 向选择器增加通道，Selector类没有增加通道的方法。register()方法在SelectableChannel类中声明。

    //参数1表示通道要向哪个选择器注册
    //参数2是SelectionKey类中的命名常量，标识通道所注册的操作
    public final SelectionKey register(Selector sel, int ops);

3. 当知道有通道已经准备好处理时，可以使用selectedkey()方法获取就绪通道。

    public abstract Set&lt;SelectionKey&gt; selectedKeys();
</code></pre><h3 id="SelectionKey-类"><a href="#SelectionKey-类" class="headerlink" title="SelectionKey 类"></a>SelectionKey 类</h3><p>SelectionKey类相当于通道的指针，一般会存储该通道的连接状态。</p>
]]></content>
      <categories>
        <category>Java NIO</category>
      </categories>
      <tags>
        <tag>Java NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理</title>
    <url>/undefined/Java%20%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是实现AOP编程的核心与关键技术。代理是一种设计模式，其目的是为其他对象提供一个代理以控制对某个对象的访问，代理类负责为委托类预处理消息，过滤消息并转发消息以及进行消息被委托类执行后的后续处理。为了保持行为的一致性，代理类与委托类通常情况下实现相同的接口。</p>
<pre><code>1.静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，也就是说在程序运行前代理类的.class文件就已经存在。
2.动态代理：在程序运行时运用反射机制动态创建生成。
</code></pre><h4 id="1-动态代理"><a href="#1-动态代理" class="headerlink" title="1.动态代理"></a>1.动态代理</h4><ul>
<li>JVM可以在运行期动态生成类的字节码，该类往往被用作动态代理类。</li>
<li>JVM生成的动态类必须实现一个或多个接口，所以这种只能用作具有相同接口的目标类的代理。</li>
<li>CGLIB库可以动态生成一个类的子类，一个类的子类也可作为该类的代理，这个可用来为没有实现接口的类生成动态代理类。</li>
<li>代理类可在调用目标方法之前、之后、前后、以及处理目标方法异常的catch块中添加系统功能代码。</li>
</ul>
<p>1.创建动态类API：</p>
<pre><code>java.lang.reflect:Class Proxy java.lang.reflect:Interface InvocationHandler
</code></pre><p>2.查看代理类方法列表信息：</p>
<pre><code>package com.iot.proxy;

import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.Collection;

/**
 * Created by brian on 2015/12/27.
 */
public class ProxyTest {
    public static void main(String[] args) throws Exception {
        Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);
        System.out.println(clazzProxy1);
        printConstructors(clazzProxy1);
        printMethods(clazzProxy1);

    }

    /**
     * 打印构造方法列表
     * @param clazz
     */
    public static void printConstructors(Class clazz){
        System.out.println(&quot;-------------constructors list-------------&quot;);
        Constructor[] constructors = clazz.getConstructors();
        System.out.print(getExecutableList(constructors));
    }

    /**
     * 打印成员方法列表
     * @param clazz
     */
    public static void printMethods(Class clazz) {
        System.out.println(&quot;-------------methods list-------------&quot;);
        Method[] methods = clazz.getMethods();
        System.out.print(getExecutableList(methods));
    }

    /**
     * 获取要打印的列表数据
     * 每行一个方法,按照func(arg1,arg2)的格式
     * @param executables
     * @return
     */
    public static String getExecutableList(Executable[] executables){
        StringBuilder stringBuilder = new StringBuilder();
        for (Executable executable : executables) {
            String name = executable.getName();
            stringBuilder.append(name);
            stringBuilder.append(&quot;(&quot;);
            Class[] clazzParams = executable.getParameterTypes();
            for (Class clazzParam : clazzParams) {
                stringBuilder.append(clazzParam.getName()).append(&quot;,&quot;);
            }
            if (clazzParams != null &amp;&amp; clazzParams.length != 0) {
                stringBuilder.deleteCharAt(stringBuilder.length() - 1);
            }
            stringBuilder.append(&quot;)\n&quot;);
        }
        return stringBuilder.toString();
    }


}
</code></pre><p>output：</p>
<pre><code>class com.sun.proxy.$Proxy0
-------------constructors list-------------
com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)
-------------methods list-------------
add(java.lang.Object)
remove(java.lang.Object)
equals(java.lang.Object)
toString()
hashCode()
clear()
contains(java.lang.Object)
isEmpty()
iterator()
size()
toArray([Ljava.lang.Object;)
toArray()
spliterator()
addAll(java.util.Collection)
stream()
forEach(java.util.function.Consumer)
containsAll(java.util.Collection)
removeAll(java.util.Collection)
removeIf(java.util.function.Predicate)
retainAll(java.util.Collection)
parallelStream()
isProxyClass(java.lang.Class)
getInvocationHandler(java.lang.Object)
getProxyClass(java.lang.ClassLoader,[Ljava.lang.Class;)
newProxyInstance(java.lang.ClassLoader,[Ljava.lang.Class;,java.lang.reflect.InvocationHandler)
wait()
wait(long,int)
wait(long)
getClass()
notify()
notifyAll()
</code></pre><p>3.创建实例对象</p>
<pre><code>/**
 * 测试创建实例对象
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
private static void createProxyInstance( ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    /**
     * 方法1：先创建代理类，再使用反射创建实例对象
     */
    Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);
    Constructor constructor = clazzProxy1.getConstructor(InvocationHandler.class);
    Collection proxy1 = (Collection) constructor.newInstance(new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            return null;
        }
    });

    /**
     * 方法2：直接使用newProxyInstance方法创建实例对象
     */
    Collection proxy2 = (Collection)Proxy.newProxyInstance(
            Collection.class.getClassLoader(),
            new Class[]{Collection.class},
            new InvocationHandler() {
                ArrayList target = new ArrayList();
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            //ArrayList targetTmp = new ArrayList();
            System.out.println(&quot;before invoke method: &quot;+method.getName());
            return method.invoke(target,args);

        }
    });

    proxy2.add(&quot;aaa&quot;);
    proxy2.add(&quot;bbb&quot;);
    System.out.println(proxy2.size());
    System.out.println(proxy2);
    System.out.println(proxy2.getClass().getName());

}
</code></pre><p>output：</p>
<pre><code>before invoke method: add
before invoke method: add
before invoke method: size
2
before invoke method: toString
[aaa, bbb]
com.sun.proxy.$Proxy0
</code></pre><p>上述代码相关说明:</p>
<pre><code>1.若将method.invoke(target,args);改为method.invoke(proxy,args);会出现死循环

2.从输出结果可知，每次调用代理类的方法，实际都是调用invoke方法

3.若将method.invoke(target,args);改为method.invoke(targetTmp,args);，则proxy2.size()为0。因为每次调用invoke方法时，targetTmp为新的局部变量

4.Object类只有的hashCode, equals, or toString方法会被交到InvocationHandler，其他方法自己有实现，不交给handler,所以最后打印结果为com.sun.proxy.$Proxy0而不是Collection
</code></pre><h4 id="3-InvocationHandler对象的运行原理"><a href="#3-InvocationHandler对象的运行原理" class="headerlink" title="3.InvocationHandler对象的运行原理"></a>3.InvocationHandler对象的运行原理</h4><p>InvocationHandler接口只有一个invoke方法，每次调用代理类的方法，即调用了InvocationHandler对象的invoke方法</p>
<p>invoke方法涉及三个要素：</p>
<pre><code>代理对象
代理对象调用的方法
方法接受的参数
</code></pre><blockquote>
<p>注：Object类的hashCode,equals,toString方法交给invoke,其他的Object类的方法，Proxy有自己的实现。</p>
</blockquote>
<h4 id="4-动态代理的工作原理"><a href="#4-动态代理的工作原理" class="headerlink" title="4.动态代理的工作原理"></a>4.动态代理的工作原理</h4><p>代理类创建时需要传入一个InvocationHandler对象，client调用代理类，代理类的相应方法调用InvocationHandler的的invoke方法，InvocationHandler的的invoke方法(可在其中加入日志记录、时间统计等附加功能)再找目标类的相应方法。</p>
<h4 id="5-面向切面编程"><a href="#5-面向切面编程" class="headerlink" title="5.面向切面编程"></a>5.面向切面编程</h4><p>把切面的代码以对象的形式传递给InvocationHandler的的invoke方法，invoke方法中执行该对象的方法就执行了切面的代码。</p>
<blockquote>
<p>所以需要传递两个参数：</p>
</blockquote>
<pre><code>1.目标(Object target) 
2.通知(自定义的adviser类)
</code></pre><p>1.定义Advice接口</p>
<pre><code>public interface Advice {
    void beforeMethod(Method method);
    void aftereMethod(Method method);
}
</code></pre><p>2.一个实现Advice接口的类MyAdvice,用于打印执行方法前和执行后的时间</p>
<pre><code>import java.lang.reflect.Method;

public class MyAdvice implements Advice{
    long beginTime = 0 ;
    @Override
    public void beforeMethod(Method method) {
        System.out.println(method.getName()+&quot; before at &quot;+beginTime);
        beginTime = System.currentTimeMillis();
    }

    @Override
    public void aftereMethod(Method method) {
        long endTime = System.currentTimeMillis();
        System.out.println(method.getName()+&quot; cost total &quot;+ (endTime-beginTime));
    }
}
</code></pre><p>3.定义一个getProxy方法创建实例对象,接收两个参数:目标和通知</p>
<pre><code>private static Object getProxy(final Object target,final Advice advice){
    Object proxy = Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    advice.beforeMethod(method);
                    Object retVal = method.invoke(target,args);
                    advice.aftereMethod(method);
                    return retVal;
                }
            }
    );
    return proxy;
}
</code></pre><p>4.调用：</p>
<pre><code>Collection proxy3 = (Collection) getProxy(new ArrayList(),new MyAdvice());
proxy3.add(&quot;111&quot;);
proxy3.add(&quot;222&quot;);
System.out.println(proxy3.size());
</code></pre><p>output:</p>
<pre><code>add before at 0
add cost total 0
add before at 1454433980839
add cost total 0
size before at 1454433980839
size cost total 0
2
</code></pre>]]></content>
      <categories>
        <category>Java代理</category>
      </categories>
      <tags>
        <tag>Java代理</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/undefined/Java%20%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射表示将类的属性和方法映射成相应的类。Java反射机制表示在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象都能够调用它的任意一个方法，这种动态获取的信息以及动态调用对象的方法功能是反射。</p>
<p>在java.lang.reflect包下有三个类：Field类 | Method类 | Constructor类，三者分别描述了一个类的域 | 方法 | 构造函数。三个类都有一个getName()方法。Field类有一个getType()方法，返回一个Class类型对象。三个类都有一个getModifiers()方法，返回一个整数，(0|1)描述方法所使用的修饰符。</p>
<blockquote>
<p>Java反射框架提供的功能</p>
</blockquote>
<pre><code>1.在运行时判断任意一个对象所属的类
2.在运行时构造任意一个类的对象
3.在运行时判断任意一个类所具有的成员变量和方法(通过反射甚至可以调用private方法)
4.在运行时调用任意一个对象的方法
5.注意上面的所有情况都是在运行时，而不是在编译时
</code></pre><h3 id="Class类和Object类"><a href="#Class类和Object类" class="headerlink" title="Class类和Object类"></a>Class类和Object类</h3><pre><code>1.Class是一个类，一个描述类的类，封装描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性。
2.对象经过反射后可以得到的属性：某类的数据成员变量名、方法、构造器，某个类实现的接口。
3.一个Class对象包含了特定某个类的有关信息。
4.Class对象只能由系统建立对象
5.一个类在JVM中只有一个Class实例。
</code></pre><h4 id="1-反射的基本使用"><a href="#1-反射的基本使用" class="headerlink" title="1.反射的基本使用"></a>1.反射的基本使用</h4><p>1.获取Class类的三种方法：</p>
<ul>
<li>类名.class</li>
<li>对象名.getClass()</li>
<li>Class.forName(“加载的类名”)</li>
</ul>
<p>2.判断是否是某个类的实例：</p>
<pre><code>通过 instanceof 关键字判断是否是某个类的实例
</code></pre><p>2.实现流程：</p>
<pre><code>1.使用上面的Class类获取方法获取特定的Class类，即该类对应的字节码。
2.调用Class对象的getConstructor(Class&lt;?&gt;... parameterTypes)获取构造方法对象
3.调用是构造方法类Constructor的newInstance(Object... initargs)方法新建对象
4.调用Class对象的getMethod(String name, Class&lt;?&gt;... parameterTypes)获取方法对象
5.调用方法对象类Method的invoke(Object obj, Object... args)方法，调用对象上相应方法
</code></pre><blockquote>
<p>注意：使用方法的参数唯一标识一个方法。依据：方法的重载。</p>
</blockquote>
<h4 id="2-枚举类成员"><a href="#2-枚举类成员" class="headerlink" title="2.枚举类成员"></a>2.枚举类成员</h4><pre><code>//案例：打印一个类的所有方法

...
Class&lt;?&gt; c1 = Class.forName(className);
while(c1 != null){
    for(Method m : c1.getDeclaredMethods()){
        System.out.println(
            Modifier.toString(m.getModifiers())+&quot;&quot;+ 
            m.getReturnType().getCanonicalName()+&quot;&quot;+
            m.getName()+
            Arrays.toString(m.getParameters())
        );

    }
    c1 = c1.getSuperclass();
}
</code></pre><h4 id="3-对象的检查"><a href="#3-对象的检查" class="headerlink" title="3.对象的检查"></a>3.对象的检查</h4><blockquote>
<p>注意：在使用私有的Field和Method对象之前，我们必须让它们是可以访问的。调用 setAccessible(true) 方法可以为反射 解锁 方法或域访问限制。但模块系统或者安全管理器会阻止请求，并以这种方式保护对象不被访问。所以在这种情况下可以调用  trySetAccessible() 方法，如果域或者方法是不可以被访问的，则该方法返回false。</p>
</blockquote>
<h4 id="4-方法的调用"><a href="#4-方法的调用" class="headerlink" title="4.方法的调用"></a>4.方法的调用</h4><blockquote>
<p>注意：即使 clone() 方法是所有数组类型的公有方法，当有描述数组类的Class对象上调用getMethod()方法时，返回的方法数字也不包含 clone() 方法。</p>
</blockquote>
<h4 id="5-对象的构造"><a href="#5-对象的构造" class="headerlink" title="5.对象的构造"></a>5.对象的构造</h4><p>如果我们需要构造对象，需要先找到 Constructor 对象，然后调用它的 newInstance() 方法。</p>
<pre><code>Constructor const = c1.getConstructor(int.class);
Object obj = const.newInstance(42);
</code></pre><h4 id="2-数组的反射"><a href="#2-数组的反射" class="headerlink" title="2.数组的反射"></a>2.数组的反射</h4><pre><code>public class ReflectTest {
    public static void main(String[] args) {
        int [] a1 = new int[]{1,2,3};
        int [] a2 = new int[5];
        int [][] a3 = new int[2][3];
        System.out.println(a1.getClass() == a2.getClass());//true
        System.out.println(a1.getClass());//class [I
        System.out.println(a3.getClass());//class [[I
        System.out.println(a1.getClass().getSuperclass() == a3.getClass().getSuperclass());//true
        System.out.println(a2.getClass().getSuperclass());//class java.lang.Object

        //下句编译不通过：Error:(15, 42) java: 不可比较的类型: java.lang.Class&lt;capture#1, 共 ? extends int[]&gt;和java.lang.Class&lt;capture#2, 共 ? extends int[][]&gt;
        //System.out.println(a1.getClass() == a3.getClass());

        Object []b3 = a3;//通过
        //下句编译不通过   Error:(17, 24) java: 不兼容的类型: int[]无法转换为java.lang.Object[]
        //Object [] b1 = a1;

        String s1 = &quot;abc&quot;;
        System.out.println(Arrays.asList(a1));//[[I@1540e19d]
        System.out.println(Arrays.asList(s1));//[abc]
    }
}

output：
    true
    class [I
    class [[I
    true
    class java.lang.Object
    [[I@1540e19d]
    [abc]
</code></pre><blockquote>
<p>注意：上面的例子说明，1.对于元素同类型的数组，同维数组，它们的class一样。2.当数组不同维时，它们的class不一样。3.当不同维时，父类都是Object，所以得到的结果都一样。4.基本类型一维数组不能直接转换为Object[]。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：HashCode与内存泄漏问题：1.hashcode一旦确定就不要变，否则容易出错。2.如果对象equals之后返回true，则它们的hashcode值相同。3.但是如果equals方法返回false，不一定表示两者的hashcode值不同。</p>
</blockquote>
</blockquote>
<h4 id="3-配置文件的加载"><a href="#3-配置文件的加载" class="headerlink" title="3.配置文件的加载"></a>3.配置文件的加载</h4><ul>
<li><p>类加载器加载只读配置文件<br>类名.class.getClassLoader().getResourceAsStream(str);</p>
</li>
<li><p>类名.class.getResourceAsStream(str);是指还是调用类加载器。</p>
</li>
</ul>
<pre><code>//源码
public InputStream getResourceAsStream(String name) {
    name = resolveName(name);
    ClassLoader cl = getClassLoader0();
    if (cl==null) {
        // A system class.
        return ClassLoader.getSystemResourceAsStream(name);
    }
    return cl.getResourceAsStream(name);
}
</code></pre><blockquote>
<p>注意：参数str的写法：1.不加斜杠，相对路径：str=”config.properties”; 2.加斜杠，从classpath的根路径找：str=”cn/edu/pku/config.properties”;</p>
</blockquote>
<h4 id="4-内省-Instropector-和JavaBean"><a href="#4-内省-Instropector-和JavaBean" class="headerlink" title="4.内省(Instropector)和JavaBean"></a>4.内省(Instropector)和JavaBean</h4><p>我们使用JavaBean获取属性值的流程大致是：变大写-&gt;补前缀-&gt;获取方法。</p>
<ul>
<li>1.使用内省操作<br></li>
</ul>
<p>简单实现： 使用java.beans.PropertyDescriptor类</p>
<p>麻烦实现: 使用java.beans.Introspector类,遍历getBeanInfo方法的返回值</p>
<p><strong>JavaBean必须有一个不带参数的构造函数</strong></p>
<ul>
<li>使用BeanUtils工具包</li>
</ul>
<pre><code>1.字符串和整数转换(对比(PropertyUtils)
2.属性级联操作
3.操作map
</code></pre><hr>
<h2 id="Method类-java-lang-reflect-Method"><a href="#Method类-java-lang-reflect-Method" class="headerlink" title="Method类 java.lang.reflect.Method"></a>Method类 java.lang.reflect.Method</h2><p>Method类位于java.lang.reflect.Method包下，在Java反射中Method类描述的是类的方法信息。在Method类的实例描述了方法的全部信息(如：方法修饰符、方法名称、参数列表等)。</p>
<h4 id="1-获取Method类对象"><a href="#1-获取Method类对象" class="headerlink" title="1.获取Method类对象"></a>1.获取Method类对象</h4><pre><code>1.getMethods() 获取类的public方法

2.getMethod(String name, Class[] params) 获取类的特定方法，name参数指定方法的名称，params参数指定方法的参数类型

3.getDeclaredMethods() 获取类中所有的方法(public protected default private)

4.getDeclaredMethod(String name, Class[] params) 获得类的特定方法,name参数指定方法的名字,params参数指定方法的参数类型
</code></pre><h4 id="2-Method类常用方法"><a href="#2-Method类常用方法" class="headerlink" title="2.Method类常用方法"></a>2.Method类常用方法</h4><pre><code>public class MethodTest{
    public static void main(String[] args){
        //1.获取操作类的所对应的Class对象
        Class&lt;?&gt; class = Class.forName(&quot;com.xidian.edu.cn.entity.User&quot;);
        //2.使用该类的class对象生成实例
        Object obj = class.newInstance();

        //3.使用方法
        Method addMethod = class.getMethod(&quot;addResult&quot;, new Class[]{int.class});
        ...

    }
}
</code></pre><blockquote>
<p>注意：Method类的invoke(Object object, Object args[]) 方法作用是：<code>调用该对象描述的方法，传递给定的参数，返回被调用方法的返回值。如果是静态方法，则将null传递给object。</code>接收的参数必须是对象，如果参数为基本类型数据，必须转换为包装类型的对象。invoke()方法的返回值总是对象。如果实际被调用的方法的返回类型是基本类型数据，那么invoke()方法会把它转换为相应的包装类型的对象，再将其返回。</p>
</blockquote>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Proxy 类可以在运行时创建实现了给定接口或者接口集的新类。代理类包括了特定接口所要求的所有方法，并且这些方法在Object类中定义的。调用处理器：是一个实现了InvocationHandler 接口的类对象。InvocationHandler 接口只有一个方法：</p>
<pre><code>Object invoke(Object proxy, Method method, Object[] args)
</code></pre><p>创建一个代理对象使用 Proxy 类的 newProxyInstance() 方法。该方法有三个参数：1.类加载器。2.Class对象数组。3.调用处理器。</p>
]]></content>
      <categories>
        <category>反射</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Runnable接口和Callable接口的区别</title>
    <url>/undefined/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a>Runnable接口和Callable接口的区别</h2><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已。Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<blockquote>
<p>提示：这里Callable+Future/FutureTask可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全表示程序在多线程下执行和在单线程下执行永远都能获得一样的结果，那么程序就是线程安全的。</p>
<h4 id="线程安全级别"><a href="#线程安全级别" class="headerlink" title="线程安全级别"></a>线程安全级别</h4><pre><code>1.不可变 final类型的类，任何线程都不能改变它们的值，除非新建一个。

2.绝对线程安全 

...
</code></pre><h2 id="在两线程之间共享数据"><a href="#在两线程之间共享数据" class="headerlink" title="在两线程之间共享数据"></a>在两线程之间共享数据</h2><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。</p>
<h2 id="sleep-方法与wait-方法"><a href="#sleep-方法与wait-方法" class="headerlink" title="sleep()方法与wait()方法"></a>sleep()方法与wait()方法</h2><p>sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。</p>
<h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><pre><code>1.通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。

2.解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。
</code></pre><h2 id="ThreadLocal作用"><a href="#ThreadLocal作用" class="headerlink" title="ThreadLocal作用"></a>ThreadLocal作用</h2><p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h4 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1.乐观锁"></a>1.乐观锁</h4><p>乐观锁表示对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>
<h4 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2.悲观锁"></a>2.悲观锁</h4><p>悲观锁表示对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因为每次对资源的操作都会持有一个独占的锁，就像synchronized。不管其它，直接上锁操作资源。</p>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/undefined/Java%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%96%87%E6%9C%ACIO/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="字符串和文本I-O"><a href="#字符串和文本I-O" class="headerlink" title="字符串和文本I/O"></a>字符串和文本I/O</h2><pre><code>1.字符串的比较
    警告：如果使用像&gt; &gt;= &lt; &lt;=这样的比较运算符比较两个字符串，就会发生语法错误。替代的方法是：s1.compareTo(s2)来进行比较。

    注意：如果两个字符串相等，equals方法返回true；如果它们不等，方法返回false。compareTo()方法会根据一个字符串是否等于、大于或小于另一个字符串而返回0、正整数或负整数。

    警告：length()方法是String的一个方法，但它是数组对象的一个属性，所以要获取字符串s中的字符个数，必须使用 s.length() 而要获取数组a中的元素个数，必须使用s.length。
</code></pre><blockquote>
<p>提示：数组提供length属性来获取数组的长度，String提供了length()方法来计算字符串的长度。此外，Java中还有一个计算对象大小的方法size()方法，该方法是针对泛型集合而言，用于查看泛型中有多少个元素。</p>
</blockquote>
<pre><code>2.文件类File
    File类特意提供了一种抽象，这种抽象表示以不依赖机器的方式处理很多文件和路径名依赖机器的复杂问题。

    注意：在windows中目录的分隔符是(\)，但是在Java中，反斜杠是一个特殊的字符，需要转义写成(\\)。

    注意：构建一个File实例并不会在机器上创建一个文件。不管文件是否存在，都可以创建任意文件名的File实例。我们可以调用File实例上的exists()方法判断文件是否存在。

3.文件的输入输出

    File对象封装了文件或路径的属性，但是这一File对象不包括创建文件以及向/从文件读/写数据的方法。为了完成I/O操作，我们需要使用恰当的Java I/O类创建对象。

        1.PrintWriter 写数据
            该类可以用来创建一个文件，并向文本文件中写入数据。
            注意：如果文件不存在，那么会调用PrintWriter的构造方法创建一个新的文件。如果文件已经存在，那么文件当前内容会被抛弃。

        2.使用Scanner读取数据
            java.util.Scanner类用来从控制台读取字符串和基本类型数值。为了能够从键盘读取，需要为System.in创建一个Scanner。
            注意：new Scanner(String) 为给定的字符串创建一个Scanner。为创建Scanner从文件中读取数据，需要使用构造方法 new File(filename) 利用 java.io.File 类创建File类的一个实例。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.字符串是封装在String类中的对象，要创建一个字符串，可以使用11种构造方法之一，也可以使用字符串直接量进行简洁初始化。
2.String 对象是不可变的，它的内容不能改变。
3.可以调用字符串的length()方法获取它的长度，使用charAt(index)方法从字符串中提取特定下标位置的字符，使用indexOf()方法和lastIndexOf()方法找出一个字符串中的某个字符或者某个子串。
4.substring()方法从字符串中提取子串
5.
</code></pre><hr>
<h4 id="1-序列流SequenceInputStream"><a href="#1-序列流SequenceInputStream" class="headerlink" title="1.序列流SequenceInputStream"></a>1.序列流SequenceInputStream</h4><p>序列流表示对多个流进行合并，表示其它输入流的逻辑串联。</p>
<p>案例1：合并两个流</p>
<pre><code>private static void testSequenceInputStream() throws IOException {
    FileInputStream fis1 = new FileInputStream(&quot;c:\\a.txt&quot;);
    FileInputStream fis2 = new FileInputStream(&quot;c:\\b.txt&quot;);

    SequenceInputStream s1 = new SequenceInputStream(fis1,fis2);
    int len = 0;
    byte[] byt = new byte[1024];

    FileOutputStream fos = new FileOutputStream(&quot;c:\\c.txt&quot;);
    while((len = s1.read(byt)) != -1) {
        fos.write(byt,0,len);
    }
    s1.close();
}
</code></pre><p>案例2：将mp3歌曲文件进行切割合并</p>
<pre><code>public class Demo{
    public static void main(String[] args) throws IOException {
        split(new File(&quot;c:\\a.mp3&quot;),10,new File(&quot;c:\\&quot;));
        System.out.println(&quot;切割完&quot;);

        LinkedHashSet&lt;InputStream&gt; hs = new LinkedHashSet&lt;InputStream&gt;();
        hs.add(new FileInputStream(new File(&quot;c:\\part.1.mp3&quot;)));
        hs.add(new FileInputStream(new File(&quot;c:\\part.2.mp3&quot;)));
        hs.add(new FileInputStream(new File(&quot;c:\\part.3.mp3&quot;)));
        hs.add(new FileInputStream(new File(&quot;c:\\part.4.mp3&quot;)));
        merage(hs, new File(&quot;c:\\merage.mp3&quot;));
        System.out.println(&quot;合并完毕&quot;);
    }

    //合并文件函数
    private static void merage(LinkedHashSet&lt;InputStream&gt; hs, File dest) throws IOException {
        final Iterator&lt;InputStream&gt; it = hs.iterator();
        FileOutputStream fos = new FileOutputStream(dest);
        SequenceInputStream seq = new SequenceInputStream(
                new Enumeration&lt;InputStream&gt;() {
                    @Override
                    public boolean hasMoreElements() {
                        return it.hasNext();
                    }
                    @Override
                    public InputStream nextElement() {
                        return it.next();
                    }
                });
        byte[] byt = new byte[1024 * 1024];
        int len = 0;
        while ((len = seq.read(byt)) != -1) {
            fos.write(byt, 0, len);
        }
        seq.close();
        fos.close();
}

//切割文件，切割之后保存路径
private static void split(File src, int count, File dir) throws IOException {
    FileInputStream fis = new FileInputStream(src);
    FileOutputStream fos = null;
    byte[] byt = new byte[1024 * 1024];
    int len = 0;

    for (int i = 1; i &lt;= count; i++) {
        len = fis.read(byt);
        if (len != -1) {
            fos = new FileOutputStream(dir + &quot;part.&quot; + i + &quot;.mp3&quot;);
            fos.write(byt, 0, len);
        }
        // fos.close();
    }
    fis.close();
    }
}
</code></pre><h4 id="2-打印流"><a href="#2-打印流" class="headerlink" title="2.打印流"></a>2.打印流</h4><pre><code>1.PrintStream 是一个字节打印流，System.out对应的类型就是PrintStream。

public static void main(String[] args){
    PrintStream ps = System.out;
    //普通write()方法只有调用flush()方法或者close()方法才会在控制台显示。
    ...
}
</code></pre><blockquote>
<p>注意：打印流的三种方法。1.void print(数据类型 变量) 2.println(数据类型 变量) 3.printf(String format,Object… args)</p>
</blockquote>
<pre><code>2.PrintWriter 是一个字符打印流，构造函数可以接收四种类型的值。

1.字符串路径
2.File对象
3.OutputStream
4.Writer
</code></pre><h4 id="3-操作数组的流对象-ByteArrayInputStream-ByteArrayOutputStream"><a href="#3-操作数组的流对象-ByteArrayInputStream-ByteArrayOutputStream" class="headerlink" title="3.操作数组的流对象(ByteArrayInputStream/ByteArrayOutputStream)"></a>3.操作数组的流对象(ByteArrayInputStream/ByteArrayOutputStream)</h4><p><strong>1.操作字节数组</strong><br></p>
<pre><code>public static void testByteArrayInputStream() throws Exception {
    InputStream in = new ByteArrayInputStream(new bytep[] {65,66,67});
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    for(int b = -1; (b = in.read()) != -1;){
        out.write(b);
    }
    in.close();
    out.close();
    System.out.println(Arrays.toString(out.toByteArray()));
    System.out.println(out);
}
</code></pre><p><strong>2.操作字符数组</strong><br></p>
<pre><code>public static void testCharArrayReader() throws Exception {
    CharArrayReader reader = new CharArrayReader(new char[] {&apos;A&apos;,&apos;b&apos;,&apos;c&apos;});
    CharArrayWriter writer = new CharArrayWriter();
    for(int b = -1; (b = reader.reade() != -1);){
        writer.write(b);
    }
    reader.close();
    writer.close();
    System.out.println(writer.toCharArray());
}
</code></pre><hr>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之美</title>
    <url>/undefined/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java并发编程之美"><a href="#Java并发编程之美" class="headerlink" title="Java并发编程之美"></a>Java并发编程之美</h2><p>[TOC]</p>
<h3 id="第1章-基础"><a href="#第1章-基础" class="headerlink" title="第1章 基础"></a>第1章 基础</h3><h3 id="第2章-基础扩展"><a href="#第2章-基础扩展" class="headerlink" title="第2章 基础扩展"></a>第2章 基础扩展</h3><h3 id="第3章-Java并发包ThreadLocalRandom类原理剖析"><a href="#第3章-Java并发包ThreadLocalRandom类原理剖析" class="headerlink" title="第3章 Java并发包ThreadLocalRandom类原理剖析"></a>第3章 Java并发包ThreadLocalRandom类原理剖析</h3><p>该类是JUC包下新增的随机数生成器，弥补Random类在多线程下的缺陷。</p>
<h4 id="3-1-Random类的局限性"><a href="#3-1-Random类的局限性" class="headerlink" title="3.1 Random类的局限性"></a>3.1 Random类的局限性</h4><p>每个Random实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。</p>
<p>在多线程环境下使用单个Random实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，会降低并发性能。</p>
<h4 id="3-2-ThreadLocalRandom"><a href="#3-2-ThreadLocalRandom" class="headerlink" title="3.2 ThreadLocalRandom"></a>3.2 ThreadLocalRandom</h4><pre><code>package com.ccpc.edu.xidian.cn.ccpc.example.random;

import java.util.concurrent.ThreadLocalRandom;

public class example1 {

    public static void main(String[] args) {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        for (int i = 0; i &lt; 10; i++){
            System.out.println(random.nextInt(5));
        }
    }
}
</code></pre><p>ThreadLocalRandom random = ThreadLocalRandom.current();来获取当前线程的随机数生成器。</p>
<p>==ThreadLocalRandom 可以被联想到ThreadLocal（通过让每一个线程复制一份变量，使得每一个线程对变量进行操作时实际是操作自己本地内存的副本，从而避免对共享变量进行同步）。ThreadLocalRandom 的实现也是如此。==</p>
<blockquote>
<p>提示：Random类的缺点是多个线程会使用同一个原子性种子变量，从而导致对原子变量更新的竞争。</p>
</blockquote>
<h4 id="3-3-源码分析"><a href="#3-3-源码分析" class="headerlink" title="3.3 源码分析"></a>3.3 源码分析</h4><p>ThreadLocalRandom 类似于一个ThreadLocal类，就是个工具类。当线程调用ThreadLocalRandom负责初始化调用线程的threadLocalRandomSeed变量，也就是初始化种子。</p>
<p>当多线程通过ThreadLocalRandom random = ThreadLocalRandom.current();获取ThreadLocalRandom 实例时，其实获取的是同一个实例。但是由于具体的种子是存放在线程里面的，所以在ThreadLocalRandom 实例里面只包含与线程无关的通用算法，是线程安全的。</p>
<h4 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h4><p>ThreadLocalRandom 使用ThreadLocal的原理，让每个线程都持有一本地种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下==计算新种子时时根据自己线程内维护的种子变量进行更新，从而避免竞争。==</p>
<hr>
<h3 id="第4章-Java-并发包中原子操作类原理剖析"><a href="#第4章-Java-并发包中原子操作类原理剖析" class="headerlink" title="第4章 Java 并发包中原子操作类原理剖析"></a>第4章 Java 并发包中原子操作类原理剖析</h3><p>JUC包提供一系列原子性操作类，这些类都使用非阻塞算法CAS实现的，相比锁实现原子性操作在性能上有很大的提升。</p>
<h4 id="4-1-原子变量操作类"><a href="#4-1-原子变量操作类" class="headerlink" title="4.1 原子变量操作类"></a>4.1 原子变量操作类</h4><p>JUC并发包包含有 AtomicInteger、AtomicLong等。它们原理相似。</p>
<p>AtomicLong是原子性递增或递减类，其内部使用Unsafe来实现。</p>
<p>因为AtomincLong类也是在rt.jar包下面，AtomicLong就是通过BootStrap类加载器进行加载的。所以能够通过Unsafe.getUnsafe()方法获取Unsafe的实例。</p>
<h4 id="4-2-LongAdder"><a href="#4-2-LongAdder" class="headerlink" title="4.2 LongAdder"></a>4.2 LongAdder</h4><p>AtomicLong通过CAS提供了非阻塞的原子性操作，相比于使用阻塞算法的同步器来说它好。</p>
<p>在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS操作，这就会白白浪费CPU资源。</p>
<p>在JDK8中使用LongAdder用来克服在高并发下使用AtomicLong的缺点。</p>
<p>在LongAdder内部维护多个Cell变量，每个Cell变量里面有一个初始值为0的long型变量。在这种情况下，相对AtomicLong来说争夺单个变量更新操作的线程量会减少，所以变相的减少了争夺共享资源的并发量。</p>
<p>另外，多个线程在争夺同一个Cell原子变量时如果失败，并不是在当前Cell变量上一直自旋CAS重试，而是尝试在其它Cell的变量上进行CAS尝试，这改变增加了当前线程CAS成功的可能性。</p>
<p>最后在获取LongAdder当前值时，是将所有Cell变量的value值累加后再加上base返回的。</p>
<blockquote>
<p>提示：LongAdder维护了一个延迟初始化的原子性更新数组（默认情况下Cell数组是null）和一个基值变量base。</p>
</blockquote>
<h4 id="4-3-LongAccumulator类"><a href="#4-3-LongAccumulator类" class="headerlink" title="4.3 LongAccumulator类"></a>4.3 LongAccumulator类</h4><p>LongAdder是LongAccumulator的特例。</p>
<p>LongAccumulator相比于LongAdder可以为累加器提供非0的初始值，后者只能提供默认的0值。同时前者能够指定累加规则</p>
<hr>
<h3 id="第5章-Java并发包中并发List源码剖析"><a href="#第5章-Java并发包中并发List源码剖析" class="headerlink" title="第5章 Java并发包中并发List源码剖析"></a>第5章 Java并发包中并发List源码剖析</h3><p>在并发包中只有CopyOnWriteArrayList，是一个线程安全的ArrayList，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也是使用了写时复制策略。</p>
<blockquote>
<p>提示：在CopyOnWriteArrayList中迭代器的弱一致性是指返回迭代器之后，其它线程对list的增删改对迭代器是不可见的。</p>
</blockquote>
<h4 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h4><p>CopyOnWriteArrayList 使用写时复制的策略来保证list的一致性，而获取-修改-写入三步操作并不是原子性的，所以在增删改的过程中都使用独占锁，来保证某个时间只有一个线程能对list数组进行修改。</p>
<p>另外，CopyOnWriteArrayList提供了弱一致性的迭代器，从而保证在获取迭代器后，其它线程对list的修改是不可见的，迭代器遍历的数组是一个快照。</p>
<hr>
<h3 id="第6章-Java并发包中锁原理剖析"><a href="#第6章-Java并发包中锁原理剖析" class="headerlink" title="第6章 Java并发包中锁原理剖析"></a>第6章 Java并发包中锁原理剖析</h3><h4 id="6-1-LockSupport工具类"><a href="#6-1-LockSupport工具类" class="headerlink" title="6.1 LockSupport工具类"></a>6.1 LockSupport工具类</h4><p>JDK中的rt.jar包里面的LockSupport是个工具类，它的主要作用是唤醒和挂起线程，该工具类是创建锁和其它同步类的基础。</p>
<p>LockSupport 与每个使用它的线程都关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的。</p>
<p>LockSupport 是使用Unsafe类实现的。</p>
<h5 id="1-void-park-方法"><a href="#1-void-park-方法" class="headerlink" title="1. void park()方法"></a>1. void park()方法</h5><p>如果调用park()方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.park()时会马上返回，否则调用线程会被禁止参与线程的调度（被挂起）。</p>
<blockquote>
<p>提示：因调用park()方法而被阻塞的线程被其它线程中断而返回时并不会抛出InterruptedException异常。</p>
</blockquote>
<h5 id="2-void-unpark-Thread-thread-方法"><a href="#2-void-unpark-Thread-thread-方法" class="headerlink" title="2. void unpark(Thread thread)方法"></a>2. void unpark(Thread thread)方法</h5><p>当一个线程调用unpark()时，如果参数thread线程没有持有与LockSupport类关联的许可证，则让thread线程持有。</p>
<p>如果thread之前因为调用park()而被挂起，在调用unpark()之后，该线程会被唤醒。</p>
<h5 id="3-void-parkNanos-long-nanos-方法"><a href="#3-void-parkNanos-long-nanos-方法" class="headerlink" title="3. void parkNanos(long nanos)方法"></a>3. void parkNanos(long nanos)方法</h5><p>该方法与park()方法类似，不同在于如果没有拿到许可证，则调用线程会被挂起nanos时间后修改为自动返回。</p>
<p>…</p>
<h4 id="6-2-抽象同步队列AQS"><a href="#6-2-抽象同步队列AQS" class="headerlink" title="6.2 抽象同步队列AQS"></a>6.2 抽象同步队列AQS</h4><h5 id="1-AQS概述"><a href="#1-AQS概述" class="headerlink" title="1. AQS概述"></a>1. AQS概述</h5><p>它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。</p>
<h4 id="6-3-独占锁-ReentrantLock-原理"><a href="#6-3-独占锁-ReentrantLock-原理" class="headerlink" title="6.3 独占锁 ReentrantLock 原理"></a>6.3 独占锁 ReentrantLock 原理</h4><h5 id="1-类图结构"><a href="#1-类图结构" class="headerlink" title="1. 类图结构"></a>1. 类图结构</h5><p>ReentrantLock 是可重入独占锁，同时只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的AQS阻塞队列里面。</p>
<p>ReentrantLock 最终还是使用AQS实现，并且根据参数来决定内部是公平还是非公平锁，默认非公平锁。</p>
<h4 id="6-4-读写锁-ReentrantReadWriteLock-的原理"><a href="#6-4-读写锁-ReentrantReadWriteLock-的原理" class="headerlink" title="6.4 读写锁 ReentrantReadWriteLock 的原理"></a>6.4 读写锁 ReentrantReadWriteLock 的原理</h4><p>解决线程安全使用ReentrantLock就可以，但是ReentrantLock是独占锁，某时只有一个线程可以获取该锁，而在实际中会有写少读多的场景。</p>
<p>ReentrantReadWriteLock 采用读写分离的策略，允许多个线程可以同时获取读锁。</p>
<p>ReentrantReadWriteLock 巧妙使用state的高16位表示读状态，也就是获取到读锁的次数。使用低16位表示获取到写锁的线程的可重入次数。</p>
<h4 id="6-5-StampedLock"><a href="#6-5-StampedLock" class="headerlink" title="6.5 StampedLock"></a>6.5 StampedLock</h4><hr>
<h3 id="第7章-并发队列原理剖析"><a href="#第7章-并发队列原理剖析" class="headerlink" title="第7章 并发队列原理剖析"></a>第7章 并发队列原理剖析</h3><h4 id="7-1-ConcurrentLinkedQueue-原理探究"><a href="#7-1-ConcurrentLinkedQueue-原理探究" class="headerlink" title="7.1 ConcurrentLinkedQueue 原理探究"></a>7.1 ConcurrentLinkedQueue 原理探究</h4><p>ConcurrentLinkedQueue 是线程安全的无界非阻塞队列，底层使用单向链表实现，对入队和出队操作使用CAS来实现线程安全。</p>
<h4 id="7-2-LinkedBlockingQueue-原理探究"><a href="#7-2-LinkedBlockingQueue-原理探究" class="headerlink" title="7.2 LinkedBlockingQueue 原理探究"></a>7.2 LinkedBlockingQueue 原理探究</h4><p>该队列是使用独占锁实现的阻塞队列。</p>
<h5 id="1-offer"><a href="#1-offer" class="headerlink" title="1. offer()"></a>1. offer()</h5><p>向队列尾部插入一个元素。</p>
<h5 id="2-put"><a href="#2-put" class="headerlink" title="2. put()"></a>2. put()</h5><p>向队列尾部插入一个元素，如果队列中有空闲则插入后直接返回，否则队列已满则阻塞当前线程，直到队列有空闲插入成功后返回。</p>
<h5 id="3-poll"><a href="#3-poll" class="headerlink" title="3. poll()"></a>3. poll()</h5><p>从队列头部获取并移除一个元素，如果队列为空则返回null。该方法不是阻塞的。</p>
<h5 id="4-peek"><a href="#4-peek" class="headerlink" title="4. peek()"></a>4. peek()</h5><p>….</p>
<hr>
<h3 id="第8章-Java并发包线程池ThreadPoolExecutor原理探究"><a href="#第8章-Java并发包线程池ThreadPoolExecutor原理探究" class="headerlink" title="第8章 Java并发包线程池ThreadPoolExecutor原理探究"></a>第8章 Java并发包线程池ThreadPoolExecutor原理探究</h3><p>线程池解决：1. 在执行大量异步任务时线程池能够提供较好的性能。2. 线程池提供了一种资源限制和管理的手段，可限制线程的个数，动态新增线程等。</p>
<h4 id="8-3-源码分析"><a href="#8-3-源码分析" class="headerlink" title="8.3 源码分析"></a>8.3 源码分析</h4><h5 id="1-public-void-execute-Runnable-command"><a href="#1-public-void-execute-Runnable-command" class="headerlink" title="1. public void execute(Runnable command)"></a>1. public void execute(Runnable command)</h5><p>该方法作用是提交任务command到线程池进行执行。</p>
<hr>
<h3 id="第9章-Java并发包-ScheduledThreadPoolExecutor-原理"><a href="#第9章-Java并发包-ScheduledThreadPoolExecutor-原理" class="headerlink" title="第9章 Java并发包 ScheduledThreadPoolExecutor 原理"></a>第9章 Java并发包 ScheduledThreadPoolExecutor 原理</h3><p>ThreadPoolExecutor只是Executors工具的部分功能。ScheduledThreadPoolExecutor 是一个可以在指定一定延迟时间后或者定时进行任务调度执行的线程池。</p>
<h4 id="9-2-类图介绍"><a href="#9-2-类图介绍" class="headerlink" title="9.2 类图介绍"></a>9.2 类图介绍</h4><pre><code>/**
 * Period in nanoseconds for repeating tasks.  A positive
 * value indicates fixed-rate execution.  A negative value
 * indicates fixed-delay execution.  A value of 0 indicates a
 * non-repeating task.
 */
private final long period;
</code></pre><p>在ScheduledFutureTask内部有一个变量period用来表示任务类型。</p>
<pre><code>period = 0 表示一次性任务，执行完便退出。

period &lt; 0 表示fixed-delay以固定延迟的定时可可重复执行任务

period &gt; 0 表示fixed-rate以固定频率的定时可重复执行任务
</code></pre><h4 id="9-3-原理剖析"><a href="#9-3-原理剖析" class="headerlink" title="9.3 原理剖析"></a>9.3 原理剖析</h4><h5 id="1-schedule"><a href="#1-schedule" class="headerlink" title="1. schedule"></a>1. schedule</h5><pre><code>/**
 * @throws RejectedExecutionException {@inheritDoc}
 * @throws NullPointerException       {@inheritDoc}
 */
public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                   long delay,
                                   TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();

    //任务转换
    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,
        new ScheduledFutureTask&lt;Void&gt;(command, null,
                                      triggerTime(delay, unit)));

    //添加任务到延迟队列
    delayedExecute(t);
    return t;
}
</code></pre><p>该方法的作用是提交一个延迟执行的任务，任务从提交时间算起，延迟单位为unit的delay时间后开始执行，提交的任务不是周期性任务，任务只会执行一次。</p>
<h5 id="2-scheduleWithFixedDelay"><a href="#2-scheduleWithFixedDelay" class="headerlink" title="2. scheduleWithFixedDelay"></a>2. scheduleWithFixedDelay</h5><pre><code>/**
 * @throws RejectedExecutionException {@inheritDoc}
 * @throws NullPointerException       {@inheritDoc}
 * @throws IllegalArgumentException   {@inheritDoc}
 */
public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                 long initialDelay,
                                                 long delay,
                                                 TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    if (delay &lt;= 0)
        throw new IllegalArgumentException();

    //任务转换，注意这里是period=-delay&lt;0
    ScheduledFutureTask&lt;Void&gt; sft =
        new ScheduledFutureTask&lt;Void&gt;(command,
                                      null,
                                      triggerTime(initialDelay, unit),
                                      unit.toNanos(-delay));
    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
    sft.outerTask = t;
    delayedExecute(t);
    return t;
}
</code></pre><p>当任务执行完毕之后，让其延迟固定时间后再次运行。initialDelay表示提交任务后延迟多少时间来开始执行command，delay表示任务执行完后延长多少时间再次运行command任务，unit时间单位。</p>
<p>任务会一直运行直到任务运行中抛出异常被取消或者关闭线程池。</p>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>fixed-delay类型的任务执行原理是，==当添加一个任务到延迟队列后，等待initialDelay时间后，任务就会过期，过期的任务就会被从队列移除，并执行。== 执行完毕后，会重新设置任务的延迟时间，然后再将任务放入延迟队列，循环往复。</p>
<blockquote>
<p>注意：如果一个任务在执行过程中抛出异常，那么这个任务就结束了，但是不影响其它任务的执行。</p>
</blockquote>
<h5 id="4-scheduleAtFixedRate"><a href="#4-scheduleAtFixedRate" class="headerlink" title="4. scheduleAtFixedRate"></a>4. scheduleAtFixedRate</h5><pre><code>/**
 * @throws RejectedExecutionException {@inheritDoc}
 * @throws NullPointerException       {@inheritDoc}
 * @throws IllegalArgumentException   {@inheritDoc}
 */
public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                              long initialDelay,
                                              long period,
                                              TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    if (period &lt;= 0)
        throw new IllegalArgumentException();
    ScheduledFutureTask&lt;Void&gt; sft =
        new ScheduledFutureTask&lt;Void&gt;(command,
                                      null,
                                      triggerTime(initialDelay, unit),
                                      unit.toNanos(period));
    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
    sft.outerTask = t;
    delayedExecute(t);
    return t;
}
</code></pre><p>该方法是相对起始时间点以固定频率调用指定任务（fixed-rate任务）。当将任务提交到线程池并延迟initialDelay时间（时间单位为unit）后开始执行任务command。然后从initialDelay+period时间点再次执行，然后在initialDelay+2*period时间点再次执行，循环往复，直到抛出异常或调用了任务的cancel()方法取消任务或者关闭线程池。</p>
<p>scheduleAtFixedRate 原理与 scheduleWithFixedDelay 类似。</p>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h5><p>相对于fixed-delay任务来说，fixed-rate方式执行规则是，时间为 initialDelay+n*period 时间启动任务，但是如果当前任务还没执行完，下一次要执行任务的时间到了，并不会并发执行，下次要执行的任务会被延迟执行。</p>
<h4 id="9-4-总结"><a href="#9-4-总结" class="headerlink" title="9.4 总结"></a>9.4 总结</h4><p>ScheduledThreadPoolExecutor 的实现原理是，内部使用 DelayQueue 来存放具体任务。任务分为3种：1. 一次性执行任务，执行完毕之后就结束，fixed-delay任务保证同一个任务在多次执行之间间隔固定时间。2. fixed-rate任务保证按照固定的频率执行，任务类型施一公period的值来区分。</p>
<hr>
<h3 id="第10章-Java并发包中线程同步器原理剖析"><a href="#第10章-Java并发包中线程同步器原理剖析" class="headerlink" title="第10章 Java并发包中线程同步器原理剖析"></a>第10章 Java并发包中线程同步器原理剖析</h3><h4 id="10-1-CountDownLatch原理"><a href="#10-1-CountDownLatch原理" class="headerlink" title="10.1 CountDownLatch原理"></a>10.1 CountDownLatch原理</h4><p>在CountDownLatch出现之前一般都是使用join()方法来实现这一点，但是join()方法不够灵活，不能够满足不同场景的需求。</p>
<blockquote>
<p>总结：CountDownLatch与join()方法区别：1. 调用一个子线程join()方法之后，会一直阻塞直到子线程运行完毕。2. countDownLatch使用计数器来允许子线程运行完毕或者在运行中递减计数，可以在子线程运行的任何时候让await()方法返回而不一定必须等到线程结束。 ==另外，使用线程池来管理线程时，一般都是直接添加Runnable到线程池，这时候就没法再次调用线程的join()方法。</p>
</blockquote>
<h5 id="1-void-await"><a href="#1-void-await" class="headerlink" title="1. void await()"></a>1. void await()</h5><p>在线程调用CountDownLatch对象的await()方法之后，当前线程会被阻塞，直到：1. 当所有线程都调用了CountDownLatch对象的countDown()方法后，计数器值为0。2. 其它线程调用了当前线程的interrupt()方法中断了当前线程，当前线程会抛出IE异常，然后返回。</p>
<h5 id="2-boolean-await-long-timeout-TimeUnit-unit"><a href="#2-boolean-await-long-timeout-TimeUnit-unit" class="headerlink" title="2. boolean await(long timeout, TimeUnit unit)"></a>2. boolean await(long timeout, TimeUnit unit)</h5><p>在线程调用CountDownLatch对象的await()方法之后，当前线程会被阻塞，直到：1. 所有线程都调用了CountDownLatch对象的countDown方法后，计数器值为0时，返回true。2. 设置的timeout时间到了，因为超时返回false。3. 其它线程调用了当前线程的interrupt()方法中断了当前线程，当前线程抛出IE异常，然后返回。</p>
<h5 id="3-void-countDown"><a href="#3-void-countDown" class="headerlink" title="3. void countDown()"></a>3. void countDown()</h5><p>线程调用该方法之后，计数器的值递减，递减后如果计数器值为0则唤醒所有因调用await()方法而被阻塞的线程，否则什么都不用做。</p>
<h5 id="4-long-getCount"><a href="#4-long-getCount" class="headerlink" title="4. long getCount()"></a>4. long getCount()</h5><p>获取当前计数器的值，也就是AQS的state值，一般在测试时使用该方法。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>CountDownLatch是使用AQS的状态变量来存放计数器的值。在计数器值变为0时，当前线程还要调用AQS的doReleaseShared()方法来激活由于调用await()方法而被阻塞的线程。</p>
<h4 id="10-2-回环屏障-CyclicBarrier-原理"><a href="#10-2-回环屏障-CyclicBarrier-原理" class="headerlink" title="10.2 回环屏障 CyclicBarrier 原理"></a>10.2 回环屏障 CyclicBarrier 原理</h4><p>因为CountDownLatch的计数器是一次性的，在等到计数器值变为0后，再调用CountDownLatch的await()和countDown()方法都会立刻返回，这就起不到线程同步的效果。</p>
<p>CyclicBarrier 的功能并不限于CountDownLatch的功能。它可以让一组线程全部达到一个状态后再全部同时执行。</p>
<p>线程在调用 await() 方法之后就会被阻塞，等到所有线程都调用了 await() 方法之后，线程们就会冲破屏障，继续向下运行。</p>
<pre><code>/**
 * Creates a new {@code CyclicBarrier} that will trip when the
 * given number of parties (threads) are waiting upon it, and which
 * will execute the given barrier action when the barrier is tripped,
 * performed by the last thread entering the barrier.
 *
 * @param parties the number of threads that must invoke {@link #await}
 *        before the barrier is tripped
 * @param barrierAction the command to execute when the barrier is
 *        tripped, or {@code null} if there is no action
 * @throws IllegalArgumentException if {@code parties} is less than 1
 */
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}
</code></pre><h5 id="1-int-await"><a href="#1-int-await" class="headerlink" title="1. int await()"></a>1. int await()</h5><p>当前线程调用该方法时会被阻塞，直到满足条件：1. parties个线程都调用了await()方法，也就是线程到达屏障点。2. 其它线程调用了当前线程的interrupt()方法中断了当前线程，则当前线程抛出IE异常返回。返回。</p>
<h5 id="2-boolean-await-long-timeout-TimeUnit-unit-1"><a href="#2-boolean-await-long-timeout-TimeUnit-unit-1" class="headerlink" title="2. boolean await(long timeout, TimeUnit unit)"></a>2. boolean await(long timeout, TimeUnit unit)</h5><p>当前线程调用该方法阻塞，直到满足条件返回：1. parties个线程都调用了await()方法返回true。2. 设置的超时时间到了后返回false。3. 其它线程调用当前线程的interrupt()方法中断当前线程，则抛出IE异常并返回。</p>
<h5 id="3-int-dowait-boolean-timed-long-nanos"><a href="#3-int-dowait-boolean-timed-long-nanos" class="headerlink" title="3. int dowait(boolean timed, long nanos)"></a>3. int dowait(boolean timed, long nanos)</h5><pre><code>private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        ...
        int index = --count;
        if (index == 0) {  // tripped
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    command.run();
                ranAction = true;
                nextGeneration();
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        // loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                if (!timed)
                    trip.await();
                else if (nanos &gt; 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation &amp;&amp; ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    Thread.currentThread().interrupt();
                }
            }
            ...
        }
    } finally {
        lock.unlock();
    }
}
</code></pre><p>当线程调用 dowait() 方法之后，首先会获取独占锁lock，如果在创建 CyclicBarrier 时传递的参数是10，那么后面9个调用线程会被阻塞。然后获取到锁的线程会对计数器count进行递减操作。</p>
<h4 id="10-3-信号量-Semaphore-原理"><a href="#10-3-信号量-Semaphore-原理" class="headerlink" title="10.3 信号量 Semaphore 原理"></a>10.3 信号量 Semaphore 原理</h4><p>它内部的计数器是递增的，并且在一开始初始化 Semaphore 时可以指定一个初始值，但不需要知道需要同步的线程个数，而是在需要同步的地方调用 acquire() 方法时指定需要同步的线程个数。</p>
<blockquote>
<p>提示：如果在构建Semaphore时传递的参数N，并在M个线程中调用了该信号量的release()方法，那么在调用acquire()使M个线程同步时传递的参数应该是M+N。</p>
</blockquote>
<h5 id="1-void-acquire"><a href="#1-void-acquire" class="headerlink" title="1. void acquire()"></a>1. void acquire()</h5><p>当前线程调用该方法的目的是希望获取一个信号量资源。</p>
<p>如果当前信号量个数大于0，则当前信号量的计数会减1，然后该方法直接返回。否则如果当前信号量个数等于0，则当前线程会被放入AQS的阻塞队列。</p>
<p>当其它线程调用了当前线程的interrupt()方法中断了当前线程时，则当前线程抛出IE异常返回。</p>
<h5 id="2-void-acquire-int-permits"><a href="#2-void-acquire-int-permits" class="headerlink" title="2. void acquire(int permits)"></a>2. void acquire(int permits)</h5><p>该方法只需要获取permits个信号量值。</p>
<h5 id="3-void-acquireUniterruptibly"><a href="#3-void-acquireUniterruptibly" class="headerlink" title="3. void acquireUniterruptibly()"></a>3. void acquireUniterruptibly()</h5><p>该方法与acquire()方法类似，不同在于该方法对中断不响应。</p>
<h5 id="4-void-acquireUniterruptibly-int-permits"><a href="#4-void-acquireUniterruptibly-int-permits" class="headerlink" title="4. void acquireUniterruptibly(int permits)"></a>4. void acquireUniterruptibly(int permits)</h5><p>与acquire(int permits)方法不一样在于该方法对中断不响应。</p>
<h5 id="5-void-release"><a href="#5-void-release" class="headerlink" title="5. void release()"></a>5. void release()</h5><p>该方法作用在于将当前的Semaphore对象的信号量值增加1，如果当前线程因为调用acquire()方法被阻塞而被放入AQS的阻塞队列，则会根据公平策略选择一个信号量个数能被满足的线程进行激活，激活的线程会尝试获取刚增加的信号量。</p>
<h5 id="6-void-release-int-permits"><a href="#6-void-release-int-permits" class="headerlink" title="6. void release(int permits)"></a>6. void release(int permits)</h5><p>与方法release()不同的在于，前者每次调用会在信号量值原来的基础上增加permits，而后者每次增加1。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/Java%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h2><p>所有要实现序列化的类都必须要实现Serializable接口(位于java.lang包中)。如果一个类能够被序列化，那么它的子类也能够被序列化。由于static代表类的成员，transient(Java语言关键字 当其声明一个实例变量时，当对象存储时，它的值不需要维持)代表对象的临时数据。</p>
<h3 id="1-使用序列化的场合"><a href="#1-使用序列化的场合" class="headerlink" title="1.使用序列化的场合"></a>1.使用序列化的场合</h3><pre><code>1.需要通过网络来发送对象，或对象的状态需要被持久化到数据库或文件中。
2.序列化能实现深复制，即可以复制引用对象。
</code></pre><h3 id="2-反序列化"><a href="#2-反序列化" class="headerlink" title="2.反序列化"></a>2.反序列化</h3><p>将流转换为对象，在序列化与反序列化的过程中，serialVersionID起着非常重要的作用，所以在编程的时候最好显示的声明 static final serialVersionID 。</p>
<pre><code>自定义serialVersionID优点：
    1.提高程序的运行效率
    2.提高程序不同平台上的兼容性
    3.增强程序各个版本之间的可兼容性
</code></pre><h3 id="3-对象序列化-存储-的方法步骤"><a href="#3-对象序列化-存储-的方法步骤" class="headerlink" title="3.对象序列化(存储)的方法步骤"></a>3.对象序列化(存储)的方法步骤</h3><pre><code>1.创建FileOutputStream，如果文件不存在会自动被创建
FileOutputStream fileStream = new FileOutputStream(&quot;file.ser&quot;);//创建存储文件的对象
2.创建ObjectOutputStream
ObjectOutputStream os = new ObjectOutputStream(fileStream);
3.写入对象
os.writeObject(characterOne);
4.关闭ObjectOutputStream
os.close();//关闭所关联的输出串流
</code></pre><blockquote>
<p>提示：如果需要类被序列化，就实现Serializable接口，此接口没有任何方法需要实现。其唯一的目的就是声明有实现它的类是可以被序列化的。即此类型对象可以通过序列化机制来进行存储。</p>
</blockquote>
<h3 id="4-对象反序列化的步骤"><a href="#4-对象反序列化的步骤" class="headerlink" title="4.对象反序列化的步骤"></a>4.对象反序列化的步骤</h3><pre><code>1.创建FileInputStream类
FileInputStream fileStream = new FileInputStream(&quot;myfile.ser&quot;);
2.创建ObjectInputStream
ObjectInputStream os = new ObjectInputStream(fileStream);
3.读取文件
Object one = os.readObject();//每次调用readObject()都会从stream中读取下一个对象
4.转换对象类型
类型 name = (类型) one;//返回值是Object类型，因此需要转换类型
5.关闭ObjectInputStream
os.close();//FileInputStream会自动跟着关掉
</code></pre><blockquote>
<p>反序列化是，Java虚拟机会通过尝试在堆上创建一个新的对象，让它维持与被序列化时有相同状态来恢复对象的原状。</p>
</blockquote>
<pre><code>package cn.edu.xidian.B.redis;

import java.io.*;

public class SerializeUtil {

    /**
     * 序列化
     * @param object
     * @return
     */
    public static byte[] serialize(Object object){
        ObjectOutputStream oos = null;
        ByteArrayOutputStream baos = null;
        try {
            baos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(baos);

            oos.writeObject(object);
            byte[] bytes = baos.toByteArray();
            return bytes;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 反序列化
     * @param bytes
     * @return
     */
    public static Object unSerialize(byte[] bytes){
        ByteArrayInputStream bais = null;
        try {
            bais = new ByteArrayInputStream(bytes);
            ObjectInputStream ois = new ObjectInputStream(bais);
            return ois.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/Java%20%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在JDK1.5之前，在定义常量的时候都是:<code>public static final</code>，然后现在可以将相关的常量分组到一个枚举类中，同时枚举量比常量方便多了，提供更多的方法。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><strong>1.常量</strong><br></p>
<pre><code>public enum Color{
    RED,GREEN,BLANK,YELLOW
}
</code></pre><p><strong>2.switch</strong><br></p>
<pre><code>enum Signal{
    GREEN,YELLOW,RED
}
public class TLight{
    Signal color = Signal.RED;
    public void change(){
        switch(color){
            case RED:
                color = Signal.GREEN;
                break;
            case YELLOW:
                color = Signal.RED;
                break;
            case GREEN:
                color = Signal.YELLOW;
                break;
        }
    }
}
</code></pre><p><strong>3.向枚举中添加新方法</strong><br><br>这里如果需要定义新的方法，那么需要在enum实例序列的最后添加一个分号，同时需要先定义enum实例。</p>
<pre><code>public enum Color{
    RED(&quot;红色&quot;,1),GREEN(&quot;绿色&quot;,2),BLANK(&quot;白色&quot;,3),YELLOW(&quot;黄色&quot;,4);

    //定义成员变量
    private String cname;
    private int index;
    //构造方法
    private Color(String cname, int index){
        this.cname = cname;
        this.index = index;
    }

    //普通方法
    public static String getCname(int index){
        for(Color c:color.values()){
            if(c.getIndex() == index){
                return c.cname;
            }
        }
        return null;
    }

    //get/set
    public String ...
}
</code></pre><p><strong>4.覆盖枚举的方法</strong><br></p>
<pre><code>public class Test {
    public enum Color {
        RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);
        // 成员变量
        private String name;
        private int index;

        // 构造方法
        private Color(String name, int index) {
            this.name = name;
            this.index = index;
        }

        // 覆盖方法
        @Override
        public String toString() {
            return this.index + &quot;_&quot; + this.name;
        }
    }

    public static void main(String[] args) {
        System.out.println(Color.RED.toString());
    }
}
</code></pre><p><strong>5.实现接口</strong><br><br>枚举都是继承java.lang.Enum类，同时因为Java不支持多继承，所以枚举对象不能再继承其它类。</p>
<pre><code>public interface Behaviour {
    void print();

    String getInfo();
    }

    public enum Color implements Behaviour {
        RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;,4);
        // 成员变量
        private String name;
        private int index;

        // 构造方法
        private Color(String name, int index) {
            this.name = name;
            this.index = index;
        }

        // 接口方法

        @Override
        public String getInfo() {
            return this.name;
        }

        // 接口方法
        @Override
        public void print() {
            System.out.println(this.index + &quot;:&quot; + this.name);
        }
}
</code></pre><p><strong>6.使用接口组织枚举</strong><br></p>
<pre><code>public interface Food {
    enum Coffee implements Food {
        BLACK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO
    }

    enum Dessert implements Food {
        FRUIT, CAKE, GELATO
    }
}
</code></pre><p><strong>7.枚举集合</strong><br><br><code>java.util.EnumSet</code>和<code>java.util.EnumMap</code>是两个枚举集合。<code>EnumSet</code>保证集合中的元素不重复;<code>EnumMap</code>中的<code>key</code>是<code>enum</code>类型，而<code>value</code>则可以是任意类型。</p>
<blockquote>
<p>注意：枚举类型都是Enum类的子类，其继承了Enum类的方法，如<code>toString()</code>方法，这方法能够返回枚举常量名。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/undefined/Java%20%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>
<blockquote>
<p>注意：Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象，然后通过Annotation对象来取得注解里的元数据。此外Annotation不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一的执行。访问和处理Annotation的工具统称API。</p>
</blockquote>
<blockquote>
<p>注解的API：</p>
</blockquote>
<pre><code>Package java.lang.annotation
</code></pre><h4 id="1-注解的应用结构图"><a href="#1-注解的应用结构图" class="headerlink" title="1.注解的应用结构图"></a>1.注解的应用结构图</h4><p>调用/结构关系：A&lt;–B&lt;–C</p>
<p>现在对A,B,C解释如下：</p>
<p>A:注解类</p>
<pre><code>@interface A{
}
</code></pre><p>B:应用了“注解类”的类</p>
<pre><code>@A
Class B{
}
</code></pre><p>C:对“应用了注解类的类”进行反射操作的类</p>
<pre><code>Class C{
   public void f(){
     B.class.isAnnotationPresent(A.class);
     A a = B.class.getAnnotion(A.class);
   }
}
</code></pre><h4 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h4><p>元注解的作用就是负责注解其他注解。四个元注解分别是：@Target,@Retention,@Documented,@Inherited</p>
<ul>
<li>@Retention</li>
</ul>
<p>表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy中，包括RetentionPolicy.SOURCE,RetentionPolicy.CLASS(默认),RetentionPolicy.RUNTIME分别对应：java源文件–&gt;class文件–&gt;内存中的字节码</p>
<pre><code>RetentionPolicy.SOURCE 注解将被编译器丢弃 
RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃
RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 
</code></pre><ul>
<li>@Target 表示该注解用于什么地方，可能的值在枚举类ElemenetType中,包括</li>
</ul>
<pre><code>ElemenetType.CONSTRUCTOR 构造器声明 
ElemenetType.FIELD 域声明（包括 enum 实例） 
ElemenetType.LOCAL_VARIABLE 局部变量声明 
ElemenetType.METHOD 方法声明 
ElemenetType.PACKAGE 包声明 
ElemenetType.PARAMETER 参数声明 
ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 
</code></pre><ul>
<li><p>@Documented 将此注解包含在javadoc中，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当于@see,@param等</p>
</li>
<li><p>@Inherited 允许子类继承父类中的注解</p>
</li>
<li><p>@Override 限定重写父类方法 用来指定覆盖的，它可以强制一个子类必须覆盖父类的方法。@Override 主要帮助程序员避免一些低级错误。@Override只修饰方法，不能修饰其他元素。</p>
</li>
<li><p>@Deprecated 用于表示某个程序元素(类、方法等)已经过时，当其他程序使用已过时的类、方法时，编译器将发出警告</p>
</li>
<li><p>@SupperessWarnings 抑制编译器警告 指示被该Annotation修饰的程序元素(以及该程序元素中的所有子元素)取消显示指定编译器警告。@SupperessWarnings会一直作用于该程序的所有子元素。</p>
</li>
<li><p>@SafeVarargs Java把引发这种错误的原因称为”堆污染”，当把一个不带泛型的对象赋给一个带泛型的变量时，往往会发生这种”堆污染”。</p>
</li>
</ul>
<h4 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h4><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
<p>1.定义注解格式：</p>
<pre><code>public @interface 注解名 {定义体}
</code></pre><p>2.注解参数的可支持数据类型：</p>
<pre><code>1.所有基本数据类型(int,float,boolean,byte,double,char,long,short) 
2.String类型 
3.Class类型 
4.enum类型 
5.Annotation类型 
6.以上所有类型的数组
</code></pre><p>3.示例代码</p>
<p>参考【参考资料】中 <a href="https://blog.csdn.net/tigerdsh/article/details/8848890&quot;" target="_blank" rel="noopener">java 注解的几大作用及使用方法详解（完）</a></p>
<p>下面的示例，是上文提到的A&lt;–B&lt;–C的扩充版本。自定义了一个注解@A，然后在B类中使用了注解@A,最后在类C中利用反射读取@A中的信息</p>
<p>A.java</p>
<pre><code>package com.iot.annotation;

import java.lang.annotation.*;

/**
 * Created by brian on 2016/2/20.
 */
@Target({ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR})
@Retention(RetentionPolicy.RUNTIME)
public @interface A {
    String name();
    int id() default 0;
    Class&lt;Long&gt; gid();
}
</code></pre><p>B.java</p>
<pre><code>package com.iot.annotation;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by brian on 2016/2/20.
 */
@A(name=&quot;type&quot;,gid=Long.class)//类注解
public class B {
    @A(name=&quot;param&quot;,id=1,gid=Long.class) //类成员注解
    private Integer age;

    @A(name=&quot;construct&quot;,id=2,gid=Long.class) //构造方法注解
    public B(){}

    @A(name=&quot;public method&quot;,id=3,gid=Long.class) //类方法注解
    public void a(){

    }

    @A(name=&quot;protected method&quot;,id=4,gid=Long.class) //类方法注解
    protected void b(){
        Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0);
    }


    @A(name=&quot;private method&quot;,id=5,gid=Long.class) //类方法注解
    private void c(){
        Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0);
    }

    public void b(Integer a){

    }
}
</code></pre><p>C.java</p>
<pre><code>package com.iot.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

/**
 * Created by brian on 2016/2/20.
 */
public class C {

    /**
     * 简单打印出B类中所使用到的类注解
     * 该方法只打印了 Type 类型的注解
     * @throws ClassNotFoundException
     */
    public static void parseTypeAnnotation() throws ClassNotFoundException{
        Class clazz = Class.forName(&quot;com.iot.annotation.B&quot;);

        Annotation[] annotations = clazz.getAnnotations();
        for(Annotation annotation :annotations){
            A a = (A)annotation;
            System.out.println(&quot;id = &quot;+a.id()+&quot; ;name = &quot;+a.name()+&quot; ;gid = &quot;+a.gid());
        }

    }

    /**
     * 简单打印出B类中所使用到的方法注解
     * 该方法只打印了 Method 类型的注解
     */
    public static void parseMethodAnnotation() {
        Method[] methods = B.class.getDeclaredMethods();
        for (Method method : methods) {
            /*
             * 判断方法中是否有指定注解类型的注解
             */
            boolean hasAnnotation = method.isAnnotationPresent(A.class);
            if (hasAnnotation) {
                /*
                 * 根据注解类型返回方法的指定类型注解
                 */
                A annotation = method.getAnnotation(A.class);
                System.out.println(&quot;method = &quot; + method.getName()
                        + &quot; ; id = &quot; + annotation.id() + &quot; ; description = &quot;
                        + annotation.name() + &quot;; gid= &quot; + annotation.gid());
            }
        }
    }

    /**
     * 简单打印出B类中所使用到的方法注解
     * 该方法只打印了 Method 类型的注解
     */
    public static void parseConstructAnnotation(){
        Constructor[] constructors = B.class.getConstructors();
        for (Constructor constructor : constructors) {
            /*
             * 判断构造方法中是否有指定注解类型的注解
             */
            boolean hasAnnotation = constructor.isAnnotationPresent(A.class);
            if (hasAnnotation) {
                /*
                 * 根据注解类型返回方法的指定类型注解
                 */
                A annotation =(A) constructor.getAnnotation(A.class);
                System.out.println(&quot;constructor = &quot; + constructor.getName()
                        + &quot; ; id = &quot; + annotation.id() + &quot; ; description = &quot;
                        + annotation.name() + &quot;; gid= &quot;+annotation.gid());
            }
        }
    }

    public static void main(String[] args) throws ClassNotFoundException {
        parseTypeAnnotation();
        parseMethodAnnotation();
        parseConstructAnnotation();
    }

}
</code></pre>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 类加载器</title>
    <url>/undefined/Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java的类加载器就是在运行时在JVM中动态地加载所需的类，Java类加载器基于三个机制：委托、可见、单一。将classpath下的那些.class文件加载进内存，处理后成为字节码，这些工作是类加载器做的。</p>
<ul>
<li>委托机制： 指的是将加载类的请求传递给父加载器，如果父加载器找不到或者不能加载这个类，那么再加载它。<br></li>
<li>可见性机制：指的是父加载器加载的类都能被子加载器看见，但是子加载器加载的类父加载器是看不见的。<br></li>
<li>单一性机制：指的是一个类只能被同一种加载器加载一次。</li>
</ul>
<h4 id="1-默认类加载器"><a href="#1-默认类加载器" class="headerlink" title="1.默认类加载器"></a>1.默认类加载器</h4><p>在系统中默认的类加载器有三个：BootStrap | ExtClassLoader | AppClassLoader 。</p>
<p>虽然说类加载器也是java类，但是BootStrap不是。验证程序：</p>
<pre><code>public class ClassLoaderTest {
    public static void main(String[] args) {
        System.out.println(System.class.getClassLoader());
    }
}
</code></pre><p>output：</p>
<pre><code>null
</code></pre><p>如果使用System.out.println(System.class.getClassLoader().toString);则报空指针异常(NullPointerException)。所以得到System类是由BootStrap类加载器加载的。</p>
<h4 id="2-类加载器的委托机制"><a href="#2-类加载器的委托机制" class="headerlink" title="2.类加载器的委托机制"></a>2.类加载器的委托机制</h4><p>一般加载类的顺序：1.首先当前线程的类加载器去加载线程中的第一个类。2.然后如果类A应用了类B，java的虚拟机将使用加载类A的类加载器来加载类B。3.同时还可以直接调用ClassLoader.loadClass()方法来制定某个加载器去加载某个类。</p>
<h4 id="3-自定义类加载器编写原理"><a href="#3-自定义类加载器编写原理" class="headerlink" title="3.自定义类加载器编写原理"></a>3.自定义类加载器编写原理</h4><p>父类:</p>
<pre><code>loadClass(类加载的流程，模板)
findClass供子类覆盖的、被loadClass方法调用的类加载逻辑
defineClass得到class文件转换成字节码
</code></pre><p>子类:</p>
<pre><code>覆盖findClass方法

如：
    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</code></pre><p>然后在API文档中的例子为：</p>
<pre><code>class NetworkClassLoader extends ClassLoader {
     String host;
     int port;

     public Class findClass(String name) {
         byte[] b = loadClassData(name);
         return defineClass(name, b, 0, b.length);
     }

     private byte[] loadClassData(String name) {
         // load the class data from the connection
          . . .
     }
}
</code></pre>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/undefined/Java%20%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型表示将集合中的一个元素限定为一个特定的类型。参数化类型，将类型由原来的具体的类型参数化，类似于方法中变量参数。在使用泛型类时，虽然传入了不同的泛型参数，但是并没有真正意义上生成不同的类型，传入不同的泛型实参的泛型类在内存上只有一个，没有真正意义上生成不同的类型，传入不同参数的泛型类在内存上只有一个，即还是原来的基本类型，在逻辑上可以理解成多个不同的泛型类型。</p>
<blockquote>
<p>提示：foreach()方法作为遍历集合中的所有元素的方法。</p>
</blockquote>
<blockquote>
<blockquote>
<p>总结：泛型类型在逻辑上可以看成多个不同的类型，但是在实际上都是相同的基本类型。</p>
</blockquote>
</blockquote>
<pre><code>ArrayList&lt;E&gt; -- 泛型类型
ArrayList -- 原始类型
E -- 类型参数
&lt;&gt; -- 读作&quot;typeof&quot;
ArrayList&lt;Integer&gt; -- 参数化的类型
Integer -- 实际类型参数
</code></pre><blockquote>
<p>注意：1.参数类类型与原始类型相互兼容。</p>
</blockquote>
<pre><code>ArrayList  collection1 = new ArrayList&lt;Integer&gt;();//通过,无warning
ArrayList&lt;Integer&gt; collection2 = new ArrayList();//通过,有warning
</code></pre><blockquote>
<p>注意：2.参数类型不考虑类型的继承关系。</p>
</blockquote>
<pre><code>ArrayList&lt;String&gt; collection3 = new ArrayList&lt;Object&gt;();//编译不通过
ArrayList&lt;Object&gt; collection4 = new ArrayList&lt;String&gt;();//编译不通过

ArrayList collection5 = new ArrayList&lt;Integer&gt;();
ArrayList&lt;String&gt; collection6 = collection5;//编译通过
</code></pre><blockquote>
<p>注意：ArrayList<string>像一种新的特殊的ArrayList类，但是实际上系统并没有为ArrayList<string>生成新的class文件，并且不会把ArrayList<string>当做一种新的类型来处理，所以不存在泛型类这一说。不管泛型的类型形参传入哪一种类型实参，对于Java而言，他们依然被当成同一个类型来处理，在内存中也占用一块内存空间，故而在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。</string></string></string></p>
</blockquote>
<pre><code>//下面程序错误，不能再静态变量声明中使用类型形参
public class R&lt;T&gt;{
    static T info;
    //不能再静态方法声明中使用类型形参
    public static void bar(T msg){

    }
}
</code></pre><h4 id="1-”-”通配符"><a href="#1-”-”通配符" class="headerlink" title="1.”?”通配符"></a>1.”?”通配符</h4><p>“?”通配符表示任意类型，使用”?”通配符可以引用各种参数化的类型，可以调用与参数化无关的方法(如：size()方法)，不能调用与参数化有关的方法(如：add()方法)。</p>
<blockquote>
<p>通配符的扩展：</p>
</blockquote>
<pre><code>1.限定通配符的上边界
ArrayList&lt;? extends Number &gt; collection1= new ArrayList&lt;Integer &gt;();//编译通过
ArrayList&lt;? extends Number &gt; collection2= new ArrayList&lt;String&gt;();//编译不通过

2.限定通配符的下边界
ArrayList&lt;? super Integer &gt; collection3= new ArrayList&lt;Number&gt;();//编译通过
ArrayList&lt;? super Integer &gt; collection4= new ArrayList&lt;String&gt;();//编译不通过
</code></pre><h4 id="2-自定义泛型方法"><a href="#2-自定义泛型方法" class="headerlink" title="2.自定义泛型方法"></a>2.自定义泛型方法</h4><p>Java的泛型基本上完全在编译器中实现，用于编译器执行类型检查和类型判断，然后生成普通的非泛型的字节码，这种实现技术为“擦除”(erasure)。</p>
<blockquote>
<p>注意：因为泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。</p>
</blockquote>
<blockquote>
<p>擦除实例：</p>
</blockquote>
<pre><code>public class GenericTest {
    public static void main(String[] args) {
        new GenericTest().testType();
    }

    public void testType(){
        ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;();

        System.out.println(collection1.getClass()==collection2.getClass());
        //两者class类型一样,即字节码一致

        System.out.println(collection2.getClass().getName());
        //class均为java.util.ArrayList,并无实际类型参数信息
    }
}
</code></pre><p>输出：</p>
<pre><code>true
java.util.ArrayList
</code></pre><blockquote>
<p>注意：使用反射可以跳过编译器，向某个泛型集合中注入其他类型数据。</p>
</blockquote>
<blockquote>
<p>注意：只有引用类型才能作为泛型方法的实际参数。如：</p>
</blockquote>
<pre><code>public class GenericTest {
    public static void main(String[] args) {
        swap(new String[]{&quot;111&quot;,&quot;222&quot;},0,1);//编译通过

        //swap(new int[]{1,2},0,1);
        //编译不通过,因为int不是引用类型

        swap(new Integer[]{1,2},0,1);//编译通过
    }

    /*交换数组a 的第i个和第j个元素*/
    public static &lt;T&gt; void swap(T[]a,int i,int j){
        T temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
</code></pre><blockquote>
<p>提示：基本类型有些时候可以作为实参，因为自动装箱与拆箱。如：</p>
</blockquote>
<pre><code>//该实例还表明当实参不一致时，T取交集，即第一个共同的父类。
public class GenericTest {
    public static void main(String[] args) {
        new GenericTest().testType();
        int a = biggerOne(3,5);
        //int 和 double,取交为Number
        Number b = biggerOne(3,5.5);
        //String和int 取交为Object
        Object c = biggerOne(&quot;1&quot;,2);
    }
    //从x,y中返回y
    public static &lt;T&gt; T biggerOne(T x,T y){
        return y;
    }
}
</code></pre><h4 id="3-类型参数推断"><a href="#3-类型参数推断" class="headerlink" title="3.类型参数推断"></a>3.类型参数推断</h4><p>编译器在判断泛型方法的实际类型参数的过程称之为类型推断。</p>
<pre><code>1.当某个 类型变量 只在整个 参数列表 的 所有参数 和 返回值 中的一处被应用，那么根据调用方法时该处的 实际应用类型 来确定。即 直接根据调用方法 时 传递的参数类型 或 返回值 来决定 泛型参数 的类型。

如：
    swap(new String[3],1,2) -&gt; static &lt;E&gt; void swap(E[]a,int i,int j);

2.当某个 类型变量 在整个 参数列表 的 所有参数 和 返回值 中的 多处被应用 ，如 调用方法 时这么多处的 实际应用类型 都对应 同一种类型 ，则 泛型参数的类型 就是 该类型 。

如：
    add(3,5) -&gt; static &lt;T&gt; T add(T a,T b);

3.当 某个类型变量 在整个 参数列表 的 所有参数 和 返回值 中的*多处被应用了，如果 调用方法 时这么多处的 实际应用类型 对应 不同的类型 ,且没有 返回值 ，则取多个参数中的 最大交集类型 ，即第一个公共父类。

如：
    fill(new Integer[3],3.5) -&gt; static &lt;T&gt; void fill(T a[],T v);

4.当某个 类型变量 在整个 参数列表 的 所有参数 和 返回值 中的 多处被应用 ，如果 调用方法 时这么多处的 实际应用类型 对应不同的 类型 ,且使用有 返回值 ，则优先考虑 返回值的类型 。

如：
    int x = add(3,3.5) -&gt; static &lt;T&gt; T add(T a,T b);

5.参数类型的类型推断具有传递性。

如：
    //该例推断的实际类型为Object，编译通过
    copy(new Integer[5],new String[5]) -&gt; static &lt;T&gt; void copy(T []a,T []b);

    //该例则根据参数化的ArrayList类实例将类型变量直接确定为String类型，编译报错
    copy(new ArrayList&lt;String&gt;,new Integer[5]) -&gt; static &lt;T&gt; void copy(Collection&lt;T&gt;a,T[]b);
</code></pre><h4 id="4-自定义泛型"><a href="#4-自定义泛型" class="headerlink" title="4.自定义泛型"></a>4.自定义泛型</h4><pre><code>如：
    public class GenericDao&lt;T&gt;{
        public void add(T x){
        }

        public T findById(int id){
            return null;
        }

        public void delete(T obj){
        }

        public void delete(int id){
        }

        public void update(T obj){
        }

        public T findByUserName(String name){
            return null;
        }

        public &lt;T&gt; Set&lt;T&gt; findByConditions(String where){
            return null;
        }

    }
</code></pre><blockquote>
<p>注意：当一个变量被声明为泛型时，只能被实例变量和方法调用(还有内嵌类型)，而不能被静态变量和静态方法调用。因为静态成员是被所参数化的类所共享的，所以静态成员不应该有类级别的类型参数。</p>
</blockquote>
<h4 id="5-泛型方法与泛型类的比较"><a href="#5-泛型方法与泛型类的比较" class="headerlink" title="5.泛型方法与泛型类的比较"></a>5.泛型方法与泛型类的比较</h4><pre><code>如：
    public class A&lt;T&gt;(){
        //泛型类的成员方法，该T受A后面的T的限制
        public T memberFunc(){
            return null;
        }
        //泛型方法，这里的T和和类A的T是不同的
        public static &lt;T&gt; T genericFunc(T a){
            return null;
        }
        public static void main(String[] args) {
            //编译不通过
            //Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);

            //编译通过
            Set&lt;Integer&gt; set=  A&lt;String&gt;().findByConditions(&quot;s&quot;);
        }
    }
</code></pre><blockquote>
<p>总结：从这个例子可以得到泛型方法中的T与类中的T是不相同的。</p>
</blockquote>
<h4 id="6-泛型与反射"><a href="#6-泛型与反射" class="headerlink" title="6.泛型与反射"></a>6.泛型与反射</h4><p><strong>1.通过反射获取泛型的实际类型参数</strong><br><br>将泛型变量当成方法的参数，利用method类的getGenericParameterTypes()方法来获取泛型的实际类型参数。</p>
<pre><code>如：
    public class GenericTest {
        public static void main(String[] args) throws Exception {
            getParamType();
        }

         /*利用反射获取方法参数的实际参数类型*/
        public static void getParamType() throws NoSuchMethodException{
            Method method = GenericTest.class.getMethod(&quot;applyMap&quot;,Map.class);
            //获取方法的泛型参数的类型
            Type[] types = method.getGenericParameterTypes();
            System.out.println(types[0]);
            //参数化的类型
            ParameterizedType pType  = (ParameterizedType)types[0];
            //原始类型
            System.out.println(pType.getRawType());
            //实际类型参数
            System.out.println(pType.getActualTypeArguments()[0]);
            System.out.println(pType.getActualTypeArguments()[1]);
        }

        /*供测试参数类型的方法*/
        public static void applyMap(Map&lt;Integer,String&gt; map){

        }

    }
</code></pre><p>output：</p>
<pre><code>java.util.Map&lt;java.lang.Integer, java.lang.String&gt;
interface java.util.Map
class java.lang.Integer
class java.lang.String
</code></pre><h4 id="7-泛型派生类"><a href="#7-泛型派生类" class="headerlink" title="7.泛型派生类"></a>7.泛型派生类</h4><p>当创建带泛型类型声明的接口、父类时，可以为该接口创建实现类，或从该父类派生子类，当使用这些接口和父类时，不能再包含类型形参。</p>
<pre><code>//定义类A继承Apple类，Apple类不能再跟类型形参
pulic class A extends Apple&lt;T&gt;{};//这样的定义方式是错误的

//如果想从Apple类派生一个子类,使用Apple类时为T形参传入一个String类型
public class A extends Apple&lt;String&gt;
</code></pre><hr>
<hr>
<blockquote>
<p>扩展：泛型</p>
</blockquote>
<pre><code>泛型的好处：
    1.将运行时的异常提前到编译阶段.
    2.避免了无谓的强制类型转换
</code></pre><blockquote>
<blockquote>
<p>注意：泛型是jdk1.5加的特性</p>
</blockquote>
</blockquote>
<p>泛型在集合中的常见应用：</p>
<blockquote>
<p>注意：泛型没有多态的概念，左右两边的数据类型必须要一致，或者只写一边的泛型类型。</p>
</blockquote>
<blockquote>
<blockquote>
<p>推荐使用：两边都写泛型</p>
</blockquote>
</blockquote>
<blockquote>
<p>自定义泛型：自定义泛型就是一个数据类型的占位符或者是一个数据类型的常量。</p>
</blockquote>
<p>在方法上自定义泛型：</p>
<pre><code>修饰符 &lt;声明自定义的泛型&gt;返回值类型 函数名(使用自定义的泛型){

    }
</code></pre><blockquote>
<blockquote>
<p>方法泛型注意事项：<br>    1.在方法上自定义泛型，这个自定义泛型的具体数据类型是在调用该方法时传入实参时确定具体的数据类型的。<br>    2.自定义泛型只要符合标识符的命名规则即可，但自定义泛型我们一般都习惯使用一个大写字母(E T)表示。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：在泛型中不能使用基本数据类型，如果需要使用基本数据类型，那么就使用基本数据类型对应的包装类型<br>如：</p>
</blockquote>
<pre><code>char(基本类型)-----&gt;Character(包装类型)
int------&gt;Integer
boolean--&gt;Boolean
</code></pre><blockquote>
<p>泛型类</p>
</blockquote>
<p>泛型类的自定义格式：</p>
<pre><code>class 类名&lt;声明自定义类型&gt;{

    }
</code></pre><blockquote>
<blockquote>
<p>泛型类要注意的事项：</p>
</blockquote>
</blockquote>
<pre><code>1.在类上自定义泛型的具体数据类型是在使用该类的时候创建对象时确定的。
2.如果一个类在类上已经声明了自定义类型，且如果使用该类创建对象的时候没有指定泛型的具体数据类型，那么默认为Object类型。
3.在类上自定义泛型不能作用于静态的方法，如果静态的方法需要使用自定义泛型，那么需要在方法上自己声明使用。
</code></pre><blockquote>
<p>泛型接口：</p>
</blockquote>
<p>泛型接口的定义格式：</p>
<pre><code>interface 接口名&lt;声明自定义类型&gt;{

}
</code></pre><p>泛型接口要注意的事项：<br>    1.接口上自定义的泛型的具体数据类型是在实现一个接口的时候指定的。<br>    2.在接口上自定义的泛型如果在实现接口的时候没有指定具体的数据类型，那么默认为Object类型</p>
<p>需求：目前实现一个接口的时候，不明确目前要操作的数据类型，需要等待创建接口实现类对象的时候时候才能指定泛型的具体数据类型。</p>
<p>如果要延长接口自定义泛型的具体数据类型，格式如下：</p>
<pre><code>public class Demo4&lt;T&gt; implements Dao&lt;T&gt;{

        }
</code></pre><p>泛型的上下限：</p>
<p>需求1：定义一个函数可以接收任意类型的集合对象，要求接收的集合对象只能存储Interger或者是Integer的父类类型数据。<br>需求2：定义一个函数可以接收任意类型的集合对象，要求接收的集合对象只能存储Number或者是Number子类类型数据。</p>
<p>泛型中的通配符：？ </p>
<pre><code>例：？ super Integer：表示只能存储Integer或者Integer父类元素 泛型的下限
    ？ extends Number：表示只能存储Number或者Number类型的子类数据 泛型的上限
</code></pre>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/undefined/Java%20%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>[TOC]</p>
<blockquote>
<p>注意：Object类型的数组可以存储任意类型的数据。</p>
</blockquote>
<h4 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h4><p>集合是存储对象数据的容器。</p>
<p>1.集合比数组的优势：</p>
<pre><code>1.集合可以存储任意类型的数据，数组只能存储同一种数据类型的数据(Object类型的数组除外)。
2.集合的长度是会发生变化的，数组的长度是固定的。
</code></pre><p>2.集合类的继承体系：</p>
<pre><code>Collection：是所有单例集合的根接口，其有两个接口List/Set
Set：如果实现了Set接口的集合类，具备特点：无序、不可重复。
List：如果实现了List接口的集合类，具备的特点：有序、可重复。有序：集合的有序不是指自然顺序，而是指添加进去的顺序与元素出来的顺序一致。
</code></pre><blockquote>
<p>提示：Collection与Collections的区别在于Collection是一个集合接口，其提供了对集合对象进行操作的通用接口方法。实现接口类主要有List/Set，该接口的设计是为各种具体的集合提供最大化的统一操作方式。Collections是针对集合类的一个包装类，它提供了一系列静态方法以实现对各种集合的搜索、排序、线程安全化等操作。<br></p>
</blockquote>
<blockquote>
<blockquote>
<p>继承：1.父类定义完整的成员、静态成员、非静态成员、构造方法，静态变量和静态方法都可以通过子类名.父类静态成员的形式调用。2.所有的私有成员不能继承private修饰的成员。3.构造函数不能被继承。</p>
</blockquote>
</blockquote>
<p><strong>super关键字</strong><br><br>this关键字和super关键字很像，this关键字指向的是当前对象的调用，super关键字指向的是当前对象调用的父类。this/super关键字只能在有对象的前提下使用，不能在静态上下文使用。</p>
<blockquote>
<p>提示：子类的构造函数默认第一行会调用父类的无参构造函数。super();</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在子类构造函数第一行通过super关键字调用父类任何构造函数，如果显式调用父类的构造函数，编译器自动添加的调用父类无参数的构造就消失，构造函数的调用只能放在第一行，只能调用一次。super()和this()不能同时存在构造函数的第一行。</p>
</blockquote>
</blockquote>
<hr>
<p>Collection接口中的方法(因为接口Collection不可以直接实现，此时使用多态ArrayList)：</p>
<pre><code>增加：&lt;br&gt;
   1.add(E e)：添加成功返回true，添加失败返回false&lt;br&gt;
   2.addAll(Collection c)：把一个集合中的元素添加到另外一个集合中去。例：c2.add(&quot;王林&quot;);c.addAll(c2);//就是将c2的元素添加到c集合中去。

删除：&lt;br&gt;
   1.clear()：清空集合中的元素&lt;br&gt;
   2.remove(o)：指定集合中的元素删除，删除成功返回true，删除失败返回false&lt;br&gt;
   3.removeAll()：该方法是删除一个集合中与另一个集合的交集元素。c.removeAll(c2);//删除c集合中与c2集合中的交集元素，因为是c集合调用此方法。&lt;br&gt;
   4.retainAll()：保留c集合与c2的交集元素，其它的元素一并删除。c.retainAll(c2);//


查看：&lt;br&gt;
   size()：查看集合中元素的个数。c.size();//查看c集合中元素的个数

判断：&lt;br&gt;
   1.isEmpty()：该方法是判断集合是否为空&lt;br&gt;
   2.contains(Object o)：判断集合中是否存在指定的元素&lt;br&gt;
   3.containsAll(Collection c)：判断集合c中是否包含c2的所有元素。c.containsAll(c2);//

迭代：&lt;br&gt;
 遍历集合中的元素的方法：&lt;br&gt;
    方式一：使用toArray()方法 将c集合中的所有元素存储到一个Object数组中返回。&lt;br&gt;
    方式二：使用迭代器iterator()遍历，Iterator it=c.iterator();//返回一个迭代器&lt;br&gt;
   1.toArray()：将集合中的元素全部存储到一个Object数组中返回。

   2.iterator()：

迭代器的作用：用于抓取集合中的元素，就类似与抓娃娃机里面的那个爪子一样。iterator实际上返回的是iterator接口的实现类对象。

迭代器的方法：&lt;br&gt;
    1.hasNext()：问是否存在下一个元素，如果有元素则返回true，否则返回false。(当前指针是否有指向元素，如果有返回true，否则返回false)&lt;br&gt;
    2.next()：获取当前指针指向的元素并返回当前的元素，然后指针向下移动一个单位。&lt;br&gt;
    3.remove()：删除迭代器最后一次返回的元素。
</code></pre><blockquote>
<p>注意：从Object数组中取出的元素只能使用Object类型声明变量接收，如果需要其它的变量类型，需要强制转换。</p>
</blockquote>
<h4 id="2-List："><a href="#2-List：" class="headerlink" title="2.List："></a>2.List：</h4><p>List继承Collection接口，所以Collection中有的方法，在List接口中也适用。</p>
<p>List接口中特有的方法：</p>
<pre><code>1.添加：
    add(int index,E element)：将指定元素添加到集合中的指定索引值位置上。
    addAll(int index,Collection c)：将指定集合添加到另一集合中指定索引值的位置上。

2.获取：
    get(int index)：使用get方法遍历集合中的元素，即获取指定索引值位置的集合中的元素
    indexOf(Object o)：找出指定元素第一次出现在集合中的索引值
    lastIndexOf(Object o)：找出指定元素最后一次出现在集合中的索引值
    subList(fromIndex,toIndex)：指定开始与结束的索引值，截取集合中的元素(在Java中截取都是包头不包尾的，如果想要截取到指定长度的元素，应该将末尾值加1)

3.修改：
    set(int index,E element)：使用指定的元素替换指定索引值的元素
</code></pre><blockquote>
<p>注意：List接口中特有的方法具备的特点：操作的方法都存在索引值，同时只有List接口下面的集合类才具备索引值。其它接口类下面的集合类都没有索引值。</p>
</blockquote>
<pre><code>4.迭代：
    listIterator():该方法返回的是一个List接口中特有的迭代器

ListIterator接口中特有的方法：
    hasPrevious()：判断是否存在上一个元素
    previous()：获取上一个元素，即当前指针先向上移动一个单位，然后再取出当前指针指向的元素

    add(E e)：将当前元素插入到当前指针指向的位置上
    set(E e)：替代迭代器最后一次返回的元素
</code></pre><p>练习：使用三种方式遍历集合的元素</p>
<pre><code>1.使用get方法遍历
2.使用迭代器正序遍历
3.使用迭代器逆序遍历
</code></pre><hr>
<pre><code>package cn.itcast.collelction;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class demo4 {
    public static void main(String[] args){
        List list=new ArrayList();
        list.add(&quot;张三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        System.out.println(&quot;=======使用get方法遍历======&quot;);
        for(int i=0;i&lt;list.size();i++){
            System.out.println(list.get(i)+&quot;,&quot;);
        }
        System.out.println(&quot;========使用迭代其正序遍历======&quot;);
        ListIterator it=list.listIterator();//获取迭代器
        while(it.hasNext()){
            System.out.println(it.next()+&quot;,&quot;);
        }
        System.out.println(&quot;=========使用迭代逆序遍历=======&quot;);
        while(it.hasPrevious()){//hasPrevious()：判断是否存在上一个元素
            System.out.println(it.previous()+&quot;,&quot;);//previous()：获取上一个元素，即当前指针先向上移动一个单位，然后再取出当前指针指向的元素
        }

    }

}
</code></pre><p>迭代器：指专门取出集合元素的对象，但是此对象很特殊，不能直接创建对象(new)，该对象是以内部类的形式存在每个集合类的内部。因为每个容器都有取出元素的功能。即Iterator是一个对象，它的工作是遍历并选择序列中的对象，它提供一种访问一个容器(container)对象中的各个元素，而又不必暴露该对象内部细节的方法。所以通过迭代器，开发人员不需要了解容器底层的接口，就可以实现对容器的遍历。</p>
<blockquote>
<p>迭代器在遍历元素时注意事项：<br>    1.在迭代器(内存模型)迭代元素的过程中，不允许使用集合对象改变集合中的元素的个数，如果需要添加删除只能使用迭代器的方法进行操作。如果使用了集合对象改变集合中元素个数就会出现ConcurrentModificationException异常。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：1.使用容器iterator()方法返回一个Iterator，然后通过Iterator的next()方法返回第一个元素。2.使用Iterator的hasNext()方法判断容器中是否还有元素，如果有，可以使用next()方法获取下一个元素。3.可以通过remove()方法删除迭代器返回的元素。</p>
</blockquote>
</blockquote>
<h4 id="3-List的实现类"><a href="#3-List的实现类" class="headerlink" title="3.List的实现类"></a>3.List的实现类</h4><pre><code>1.ArrayList
    ArrayList特有的方法：
     1.ensureCapacity(int minCapacity) 该操作增加ArrayList容量
        2.trimToSize()
ArrayList底层维护了一个Object数组实现的(底层是Objec数组写的)，所谓动态的是它的大小可变。 特点：查询速度块，增删慢(因为此时如果ArrayList长度不够用的时候需要创建新的ArrayList对象，然后将原来的数据拷贝到新建的对象中，那么这一过程就非常的漫长)
</code></pre><p>ArrayList何时使用：根据数据特点，如果当前数据查询比较多，增删比较少的时候，那么就使用ArrayList存储这批数据。比如高校的图书馆，这时候查询的操作比较多，然后增删的操作比较少，此时可以使用ArrayList来操作。</p>
<p>笔试题目：使用ArrayList无参构造函数创建一个对象时，默认的容量是多少？如果长度不够使用时又自增增长多少？<br><br>答：ArrayList底层是维护了一个Object数组实现的，使用无参构造函数时，Object数组默认的容量是10，当长度不够用时，自动增长0.5倍。</p>
<pre><code>2.LinkedList
实现原理：使用链表数据结构实现的。特点：查询速度慢，增删快(因为内存地址不连续，所以查询的时候需要遍历集合完之后才能查询到相应的元素的位置)
LinkedList的特有方法：
    addFirst()：将元素添加到集合的首位置上
    addLast()：将元素添加到集合的末尾处
    getFirst()：获取集合中首位置的元素
    getLast()：获取集合中末尾的元素
    removeFirst()：删除集合中的首位置元素并返回
    removeLast()：删除集合中的末尾位置元素并返回

    descendingIterator()：

    push()：进栈
    pop()：出栈

    offer()：进队列
    poll()：出队列
</code></pre><p>机试题目：使用LinkedList实现堆栈数据结构的存储方式与队列的数据结构存储方式</p>
<pre><code>3.Vector(了解) 底层是维护了一个Object的数组实现的，实现与ArrayList一样，但是Vector是线程安全的，操作效率低。(已经被ArrayList取代)
</code></pre><p>笔试题：说出ArrayList与Vector的区别？<br><br>答：相同点：ArrayList与Vector底层都是使用了Object数组实现的。<br>    不同点：1.ArrayList是线程不同步的，操作效率高。Vector是线程同步的，操作效率低。<br>        2.ArrayList是JDK1.2出现的，Vector是jdk1.0出现的。</p>
<hr>
<blockquote>
<p>ArrayList/Vector/LinkedList之间的区别：ArrayList/Vector/LinkedList类均在java.util包中，均为可伸缩数组，即可以动态改变长度的数组。ArrayList和Vector是在内存中开辟一块连续的空间来存储的，由于数据存储是连续的，所以他们支持用序号(下标)来访问元素，同时索引数据的速度比较快，但是在插入元素时需要移动容器中的元素，所以对数据的插入操作执行比较慢。ArrayList与Vector最大的区别是synchronization(同步)的使用，没有一个ArrayList的方法是同步的，而Vector的大部分方法都是直接或间接同步的，所以Vector是线程安全的，而ArrayList是线程不安全的。LinkedList是采用双向列表来实现的，对数据的索引需要从列表头开始遍历，因此用于随机访问则效率低下，但是在插入元素时不需要对数据进行移动，所以插入效率较高。此外，LinkedList是非线程安全的容器。</p>
</blockquote>
<h4 id="4-Set接口"><a href="#4-Set接口" class="headerlink" title="4.Set接口"></a>4.Set接口</h4><p>Set接口实现的集合类特点：无序、不可重复 </p>
<pre><code>1.无序：元素添加的顺序与出来的顺序是不一样的 
2.不可重复：set集合里面的元素是不可重复的。
</code></pre><p>1.Set接口下面的特有方法</p>
<pre><code>Set接口下面的实现类：

1.HashSet：底层是使用哈希表来支持的，特点：存取速度快。
    实现原理：往HashSet添加元素的时候HashSet会先调用元素的hashCode()方法得到元素的哈希值，然后通过元素的哈希值经过移位运算，就可以算出该元素在哈希表中的存储位置。
          情况一：如果算出元素存储的位置目前没有存储元素，那么该元素可以直接存储到该位置。
          情况二：如果算出该元素的存储位置目前已经存在有元素，那么会调用该元素的equals()方法与该位置的元素再比较一次，如果equals方法返回的是true，那么该元素与此位置上的元素是重复的，不允许添加，反之可以直接添加。

    哈希表的特点：桶式结构(一个空间里面可以装多个元素)
注意：HashCode值在默认情况下是表示的内存地址，但是在引用类的时候类会重写hashCode()方法，所以hashCode值可能会相同。

2.TreeSet：如果元素具备自然顺序特性，那么就按照元素自然顺序的特性进行排序存储

    TreeSet注意事项：
        1.往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。
        2.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素的比较规则定义在compareTo(T o)方法中。
        3.如果在比较元素的时候，compareTo()方法返回的是0，那么该元素就被视为重复元素，不允许添加(注意：TreeSet与hashCode()、equals()方法是没有任何关系的)
        4.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类与没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个比较器。
        5.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口，在创建TreeSet对象的时候也传入了比较器，那么是以比较器的比较规则优先使用。

自定义比较器：自定义一个类实现Comparator接口，把元素与元素之间的比较规则定义在compare()方法即可。
    格式：
    class 类名 implements Comparator{

        }
</code></pre><p>推荐使用：比较器(comparator)<br>        TreeSet实现原理：<br>            底层是使用红黑树(二叉树)数据结构实现的。存储规则：左小右大</p>
<p>注意：TreeSet是可以对字符串进行排序的，因为字符串已经实现了Comparable接口。</p>
<p>字符串比较规则：<br>    情况一：可以找到不同字符，比较的就是对应位置上的字符。</p>
<pre><code>情况二：找不到对应不同的字符，比较的就是字符串的长度。
</code></pre><blockquote>
<p>注意：1.eclipse的快捷键：Ctrl+shift+/ 添加多行注释 Ctrl+shift+\ 取消多行注释</p>
</blockquote>
<h4 id="5-Map接口"><a href="#5-Map接口" class="headerlink" title="5.Map接口"></a>5.Map接口</h4><p>Map中的元素是两个对象，一个对象作为键，一个对象作为值。键是不可以重复的，但是值可以重复。Map与Collection在集合框架中属于并列的存在。Map存储的是键值对。Map接口，表示将键映射到值的对象，一个映射不能包含重复的键，每个键最多能映射到一个值。</p>
<pre><code>1.HashMap 采用哈希表实现，无序。底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。

    1.1 LinkedHashMap：该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率

2.TreeMap 可以对键进行排序，底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator 进行比较排序。return 0，来判断键的唯一性。

3.Hashtable 底层是哈希表数据结构，线程同步，不可以存入null键，null值。效率较低，被 HashMap 替代
</code></pre><p>案例：使用HashMap建立学生姓名与年龄之间的映射关系。</p>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class Demo {
    public static void main(String[] args) {
        //定义一个Map容器对象
        Map&lt;String,Integer&gt; map1 = new HashMap&lt;String,Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);
        //添加重复的键值(值不同)，会返回集合中原有(重复键)的值
        System.out.println(map1.put(&quot;jack&quot;,30));//20

        Map&lt;String,Integer&gt; map2 = new HashMap&lt;String,Integer&gt;();
        map2.put(&quot;Aaron&quot;,25);
        map2.put(&quot;Brian&quot;,35);
        System.out.println(&quot;map2:&quot;+map2);
        //从指定的映射中将所有映射关系复制到此映射中
        map1.putAll(map2);
        System.out.println(&quot;map1:&quot;+map1);

        //删除
        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);                
        // 指定key，返回删除的键值对映射的值。
        // remove() 该方法删除关联对象，指定key对象
        // clear() 清空集合对象
        System.out.println(&quot;value:&quot; + map1.remove(&quot;java&quot;));
        map1.clear();
        System.out.println(&quot;map1:&quot; + map1);

        //获取
        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);
        // V get(Object key) 通过指定的key对象获取value对象
        // int size() 获取容器的大小
        System.out.println(&quot;value:&quot; + map1.get(&quot;jack&quot;));
        System.out.println(&quot;map.size:&quot; + map1.size());

        //判断
        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);
        System.out.println(&quot;isEmpty:&quot; + map1.isEmpty());//长度为0返回true，否则返回false
        System.out.println(&quot;containskey:&quot; + map1.containsKey(&quot;jack&quot;));//判断集合中是否包含指定key
        System.out.println(&quot;containsvalues:&quot; + map1.containsValue(100));
    }
}
</code></pre><p><strong>5.1 HashMap</strong><br><br>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</p>
<pre><code>import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

public class Demo {
    public static void main(String[] args){
        HashMap&lt;Person,String&gt; hashMap = new HashMap&lt;Person,String&gt;();
        hashMap.put(new Person(&quot;jack&quot;,20),&quot;1001&quot;);
        hashMap.put(new Person(&quot;Aaron&quot;,20),&quot;1002&quot;);
        System.out.println(hashMap);
        System.out.println(hashmap.put(new Person(&quot;rose&quot;,18),&quot;10086&quot;));

        Set&lt;Entry&lt;Person,String&gt;&gt; entrySet = new hashMap.entrySet();
        Iterator&lt;Entry&lt;Person,String&gt;&gt; it = entrySet.iterator();

        while(it.hasNext()) {
            Entry&lt;Person,String&gt; next = it.next();
            Person key = next.getKey();
            String value = next.getValue();
            System.out.println(key+&quot;=&quot;+value);
        }
    }
}

class Person {
    private String name;
    private int age;

    Person() {}

    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    //set/get方法

    @Override
    public int hashCode(){
        return this.name.hashCode()+age*37;
    }

    @Override
    public String toString(){
        return &quot;PersonName:&quot;+this.name+&quot;age:&quot;+age;
    }
}
</code></pre><p><strong>5.2 TreeMap</strong><br></p>
<blockquote>
<p>注意：Set的元素不可重复，Map的键不可重复，如果存入重复元素如何处理?<br><br>    1.Set元素重复元素不能存入add方法返回false。<br>    2.Map的重复健将覆盖旧键，将旧值返回。</p>
</blockquote>
<h4 id="6-使用Lambda表达式遍历集合"><a href="#6-使用Lambda表达式遍历集合" class="headerlink" title="6.使用Lambda表达式遍历集合"></a>6.使用Lambda表达式遍历集合</h4><p>Java8 为Iterable接口新增方法forEach()，用来遍历集合中的元素。</p>
<blockquote>
<p>注意：Iterator必须依附Collection对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/undefined/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java集合框架-面试"><a href="#Java集合框架-面试" class="headerlink" title="Java集合框架 - 面试"></a>Java集合框架 - 面试</h2><p>[TOC]</p>
<h3 id="数据结构与算法-考试"><a href="#数据结构与算法-考试" class="headerlink" title="数据结构与算法 - 考试"></a>数据结构与算法 - 考试</h3><pre><code>1.数据结构

    1.数组和链表的区别

    2.链表的操作：翻转、链表环路检测、双向链表、循环链表等相关操作

    3.队列和栈的应用

    4.二叉树的遍历方式及其递归和非递归的实现

    5.红黑树的旋转（难）

2.算法

    1.内部排序：递归、交换（冒泡、快排）、选择、插入等

    2.外部排序：利用有限内幕才能配合海量的外部存储来处理超大数据集
</code></pre><h3 id="Java集合-List-Set"><a href="#Java集合-List-Set" class="headerlink" title="Java集合 - List | Set"></a>Java集合 - List | Set</h3><pre><code>1.Collection

    1.List

        1.特点

            1.有序

            2.可重复

            3.通过索引操作元素

        2.分类

            1.底层是数组，查询快，增删慢

                1.ArrayList 线程不安全，效率高

                2.Vector 线程安全，效率低

            2.底层是链表，查询慢，增删快

                1.LinkedList 线程不安全，效率高

    2.Set

        1.特点

            1.无序

            2.元素唯一

        2.分类

            1.底层是哈希表

                HashSet 保证元素唯一性

            2.底层是二叉树

                TreeSet 保证元素排序，自然顺序，让对象所属的类去实现Comparable接口，无参构造。比较接口Comparator，带参构造
</code></pre><h3 id="Java集合-Map"><a href="#Java集合-Map" class="headerlink" title="Java集合 - Map"></a>Java集合 - Map</h3><pre><code>1.HashMap | HashTable | ConccurentHashMap 区别

    1.HashMap

        1.在Java8之前采用 数组+链表 的方式实现HashMap，利用他们各自的优势实现

        2.在Java8之后采用 数组+链表+红黑树 的方式实现HashMap

        3.HashMap.put()方法逻辑（Java 8之后）

            1.如果HashMap未被初始化过，则初始化

            2.对key求hash值，然后再计算下标

            3.如果没有碰撞，直接放入桶中

            4.如果碰撞了，以链表的方式链接到后面

            5.如果链表长度超过阈值，就将链表转换成红黑树

            6.如果链表长度低于6，就将红黑树转回链表

            7.如果节点已经存在就替换旧值

            8.如果桶满了（容量16*加载因子0.75），就需要resize（扩容2倍后重排）

        4.减少碰撞

            1.扰动函数：促使元素位置分布均匀，减少碰撞几率

            2.使用final对象，并采用合适的equals和hashcode方法

        5.扩容问题

            1.多线程环境下，调整大小会存在条件竞争，容易造成死锁

            2.rehashing是比较耗时的过程

    2.线程安全的HashMap

        通过调用synchronizedMap(hashMap)方法让HashMap变成线程安全。

    3.如何优化Hashtable

        1.通过琐细粒度化，将整锁拆解成多个锁进行优化

    4.ConcurrentHashMap.put()方法逻辑

        1.判断Node[]数组是否初始化，没有则进行初始化操作

        2.通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头节点），添加失败则进入下一次循环。

        3.检查到内部正在扩容，将帮助其一起扩容

        4.如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）

            如果是Node（链表结构）则执行链表的添加操作

            如果是TreeNode（树型结构）则执行树添加操作

        5.判断链表长度已经达到临界值8（8是默认值），当节点数超过这个值需要将链表转换成树结构

        总结：比起Segment，锁的拆分更细

            1.首先使用无锁操作CAS插入头节点，失败则循环重试

            2.如果头节点已经存在，则尝试获取头节点的同步锁，再进行操作

    5.总结：三者的区别

        1.HashMap 线程不安全，底层是通过 数组+链表+红黑树实现

        2.Hashtable 线程安全，底层是通过锁住整个对象，然后由数组+链表实现

        3.ConccurentHashMap 线程安全，CAS+同步锁，数组+链表+红黑树

        4.HashMap的key、value均可为null，而其它两个类不支持
</code></pre><h4 id="HashMap-Hashtable-区别"><a href="#HashMap-Hashtable-区别" class="headerlink" title="HashMap | Hashtable 区别"></a>HashMap | Hashtable 区别</h4><h5 id="1-线程是否安全"><a href="#1-线程是否安全" class="headerlink" title="1. 线程是否安全"></a>1. 线程是否安全</h5><p>HashMap是非线程安全的，Hashtable是线程安全的。Hashtable内部的方法基本都经过synchronized修饰。</p>
<h5 id="2-效率"><a href="#2-效率" class="headerlink" title="2. 效率"></a>2. 效率</h5><p>因为线程安全的问题，HashMap要比Hashtable效率高一点，另外，Hashtable基本被淘汰。</p>
<h5 id="3-对null-key-和-null-value的支持"><a href="#3-对null-key-和-null-value的支持" class="headerlink" title="3. 对null key 和 null value的支持"></a>3. 对null key 和 null value的支持</h5><p>在HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null。但是在Hashtable中put进的键值只要有一个null，就直接抛NPE异常。</p>
<h5 id="4-初始容量大小和每次扩容大小的不同"><a href="#4-初始容量大小和每次扩容大小的不同" class="headerlink" title="4. 初始容量大小和每次扩容大小的不同"></a>4. 初始容量大小和每次扩容大小的不同</h5><pre><code>1. 创建时如果不指定容量初始值，Hashtable默认的初始大小为11，之后每次扩容变为原来的 2n+1。HashMap默认的初始化大小为16，之后每次扩容，容量变为原来的2倍。

2. 创建时如果给定了容量的初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩容到2的幂次方大小（HashMap中的tableSizeFor()方法保证），也就是说HashMap总是使用2的幂次方作为哈希表的大小。
</code></pre><h5 id="5-底层数据结构"><a href="#5-底层数据结构" class="headerlink" title="5. 底层数据结构"></a>5. 底层数据结构</h5><p>JDK 8以后的HashMap在解决哈希冲突时有变化，当链表长度大于阈值（默认8）时，将链表转化为红黑树，以减少搜索时间。而Hashtable没有这样的机制。</p>
<h4 id="HashMap-HashSet-区别"><a href="#HashMap-HashSet-区别" class="headerlink" title="HashMap | HashSet 区别"></a>HashMap | HashSet 区别</h4><p>我们知道，HashSet底层是基于HashMap实现。</p>
<h5 id="1-HashSet如果检验重复"><a href="#1-HashSet如果检验重复" class="headerlink" title="1. HashSet如果检验重复"></a>1. HashSet如果检验重复</h5><pre><code>1. HashSet 计算对象的hashcode值来判断对象加入的位置，同时与其他加入的对象的hashcode值比较。如果没有相符的hashcode值则假设对象没有重复出现。否则调用equals()方法检查hashcode值相等的对象是否真的相同，如果两者相同，则加入操作失败。
</code></pre><h5 id="2-hashcode-equals-相关规定"><a href="#2-hashcode-equals-相关规定" class="headerlink" title="2. hashcode() | equals() 相关规定"></a>2. hashcode() | equals() 相关规定</h5><pre><code>如果两个对象相等，则hashcode一定也是相同的

两个对象相等,对两个equals方法返回true

两个对象有相同的hashcode值，它们也不一定是相等的

综上，equals方法被覆盖过，则hashCode方法也必须被覆盖

hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
</code></pre><h5 id="3-equals-区别"><a href="#3-equals-区别" class="headerlink" title="3. == | equals() 区别"></a>3. == | equals() 区别</h5><pre><code>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同

==是指对内存地址进行比较，equals()是对字符串的内容进行比较

==指引用是否相同，equals()指的是值是否相同
</code></pre><h3 id="HashMap-底层实现"><a href="#HashMap-底层实现" class="headerlink" title="HashMap 底层实现"></a>HashMap 底层实现</h3><h4 id="1-JDK-1-8-previous"><a href="#1-JDK-1-8-previous" class="headerlink" title="1. JDK 1.8 previous"></a>1. JDK 1.8 previous</h4><p>JDK1.8 之前 HashMap 底层是 ==数组和链表== 结合在一起使用也就是 ==链表散列==。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<blockquote>
<p>JDK 8 的hash()方法</p>
</blockquote>
<pre><code>static final int hash(Object key) {
  int h;
  // key.hashCode()：返回散列值也就是hashcode
  // ^ ：按位异或
  // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<h4 id="2-JDK-1-8-next"><a href="#2-JDK-1-8-next" class="headerlink" title="2. JDK 1.8 next"></a>2. JDK 1.8 next</h4><p>在 JDK 1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认是8）时，将链表转换为红黑树，以减少搜索时间。</p>
<p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
<h4 id="3-HashMap-的长度为何是2的幂次方"><a href="#3-HashMap-的长度为何是2的幂次方" class="headerlink" title="3. HashMap 的长度为何是2的幂次方"></a>3. HashMap 的长度为何是2的幂次方</h4><p>为让HashMap存取高效，尽量减少碰撞，即就是尽量让数据均匀分布。Hash值得取值范围大概有40亿的映射空间，只要哈希函数映射得比较均匀松散，一般难以出现碰撞，但是一个40亿长度的数组，内存是放不下的，所以这个散列值不能直接拿来用，在我们用之前需要先对数组的长度取模运算，得到的余数才能用来作为要存放的位置（对应数组下标）。这个数组下标的计算方法时：(n - 1) &amp; hash。（n表示数组长度）。所以这也就是为啥HashMap的长度要是2的幂次方。</p>
<h4 id="4-HashMap多线程操作导致死循环问题"><a href="#4-HashMap多线程操作导致死循环问题" class="headerlink" title="4. HashMap多线程操作导致死循环问题"></a>4. HashMap多线程操作导致死循环问题</h4><p>这里主要原因是因为 在并发下的 rehash() 操作造成元素之间会形成一个循环链表。在JDK 1.8之后解决了这个问题，但是还是不建议在多线程环境下使用HashMap，因为在多线程环境下使用HashMap还是会存在其它问题，如：数据丢失等。在并发环境下推荐使用：ConcurrentHashMap。</p>
<h3 id="ConcurrentHashMap-Hashtable-区别"><a href="#ConcurrentHashMap-Hashtable-区别" class="headerlink" title="ConcurrentHashMap | Hashtable 区别"></a>ConcurrentHashMap | Hashtable 区别</h3><p>Hashtable 与 ConcurrentHashMap 的区别主要体现在实现线程安全的方式不同。</p>
<h4 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a>1. 底层数据结构</h4><p>JDK 1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK 1.8 采用的数据结构跟HashMap JDK 1.8 的结构一样 数组+链表/红黑二叉树 。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<h4 id="2-实现线程安全的方式"><a href="#2-实现线程安全的方式" class="headerlink" title="==2. 实现线程安全的方式=="></a>==2. 实现线程安全的方式==</h4><p>① ==在JDK1.7的时候，ConcurrentHashMap（分段锁）== 对整个桶数组进行了分割分段(Segment)，==每一把锁只锁容器其中一部分数据==，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK 1.8 的时候已经摒弃了Segment的概念，而是直接用 ==Node 数组+链表+红黑树== 的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p>
<p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<h4 id="3-ConcurrentHashMap-线程安全的具体实现方式（底层具体实现）"><a href="#3-ConcurrentHashMap-线程安全的具体实现方式（底层具体实现）" class="headerlink" title="3. ConcurrentHashMap 线程安全的具体实现方式（底层具体实现）"></a>3. ConcurrentHashMap 线程安全的具体实现方式（底层具体实现）</h4><h5 id="1-JDK-1-7"><a href="#1-JDK-1-7" class="headerlink" title="1. JDK 1.7"></a>1. JDK 1.7</h5><p>首先将数据分为一段一段的存储，然后将每一段数据陪一把锁，当一个线程占用锁访问其中一个段数据时，其它段数据也能被其它线程访问。</p>
<blockquote>
<p>提示：ConcurrentHashMap 是由 Segment数组结构 和HashEntry 数组结构构成。</p>
</blockquote>
<p>Segment 实现了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<h5 id="2-JDK-1-8"><a href="#2-JDK-1-8" class="headerlink" title="2. JDK 1.8"></a>2. JDK 1.8</h5><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS和synchronized 来保证并发安全。数据结构跟 HashMap 1.8 的结构类似，==数组+链表/红黑二叉树==。Java  8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）</p>
<p>==synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。==</p>
<h3 id="comparable-comparator-区别"><a href="#comparable-comparator-区别" class="headerlink" title="comparable() | comparator 区别"></a>comparable() | comparator 区别</h3><ul>
<li>comparable 接口实际上是出自 java.lang 包，它有一个 compareTo(Object obj) 方法用来排序。</li>
<li>comparator 接口实际上是出自 java.util 包，它有一个 compare(Object o1, Object o2) 方法用来排序。</li>
</ul>
<p>一般地，如果我们需要对一个集合自定义排序时，我们需要重写 compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式：1. 重写方法。2. 使用两个参数版的Collections.sort()。</p>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h5 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h5><pre><code>1. ArrayList：Object数组

2. Vector：Object数组

3. LinkedList：双向链表（JDK 1.6之前为循环链表，JDK 1.7取消循环）
</code></pre><h5 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h5><pre><code>1. HashSet（无序|唯一）：基于HashMap实现，底层采用HashMap来保存元素。

2. LinkedHashSet：继承了HashSet，并且其内部是通过LinkedHashMap来实现的。

3. TreeSet（有序|唯一）：红黑树（自平衡排序二叉树）。
</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><p>JDK 1.8 之前HashMap由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（拉链法解决冲突）。JDK 1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转为红黑树，以减少搜索时间。</p>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是==基于拉链式散列结构即由数组和链表或红黑树==组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
<h5 id="3-Hashtable"><a href="#3-Hashtable" class="headerlink" title="3. Hashtable"></a>3. Hashtable</h5><p>数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<h5 id="4-TreeMap"><a href="#4-TreeMap" class="headerlink" title="4. TreeMap"></a>4. TreeMap</h5><p>红黑树（自平衡排序二叉树）</p>
<h3 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h3><p>主要根据集合的特点选用，如我们需要根据键值获取到元素值时就选用Map接口下的集合。需要排序时选择TreeMap，不需要排序时选择HashMap，需要保证线程安全时选用ConcurrentHashMap。只需要存放元素值时，选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合如：TreeSet或HashSet，不需要就选择List接口的ArrayList或LinkedList，然后再根据实现这些接口的集合特点来选用。</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 新特性</title>
    <url>/undefined/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><h2 id="一、Lambda-表达式"><a href="#一、Lambda-表达式" class="headerlink" title="==一、Lambda 表达式=="></a>==<strong>一、Lambda 表达式</strong>==</h2><h3 id="1-Lambda-表达式使用前后对比"><a href="#1-Lambda-表达式使用前后对比" class="headerlink" title="1. Lambda 表达式使用前后对比"></a>1. Lambda 表达式使用前后对比</h3><h4 id="使用前："><a href="#使用前：" class="headerlink" title="使用前："></a>使用前：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例一：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"我爱北京天安门！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	r1.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">			System.out.println(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	con.accept(<span class="string">"熙熙攘攘"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用后："><a href="#使用后：" class="headerlink" title="使用后："></a>使用后：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例一：	</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Runnable r2 = () -&gt; System.out.println(<span class="string">"我爱这三秦大地！"</span>);</span><br><span class="line">	r2.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Consumer&lt;String&gt; con2 = (String t) -&gt; System.out.println(t);</span><br><span class="line">	con2.accept(<span class="string">"多么美丽"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Lambda-表达式的基本语法"><a href="#2-Lambda-表达式的基本语法" class="headerlink" title="2.Lambda 表达式的基本语法"></a>2.Lambda 表达式的基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*   <span class="number">1</span>. 举例：</span><br><span class="line">*     (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">*  <span class="number">2</span>. 格式：</span><br><span class="line">*     -&gt; ：Lambda操作符 或 箭头操作符</span><br><span class="line">*     -&gt; 左边： Lambda形参列表（其实就是接口中的抽象方法的形参列表）</span><br><span class="line">*     -&gt; 右边： Lambda 体（其实就是重写的抽象方法的方法体）</span><br></pre></td></tr></table></figure>
<h3 id="3-Lambda-表达式的使用（6种情况）"><a href="#3-Lambda-表达式的使用（6种情况）" class="headerlink" title="3.Lambda 表达式的使用（6种情况）"></a>3.Lambda 表达式的使用（6种情况）</h3><h4 id="无参，无返回值。"><a href="#无参，无返回值。" class="headerlink" title="无参，无返回值。"></a>无参，无返回值。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"我爱北京天安门！"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   r1.run();</span><br><span class="line">   System.out.println(<span class="string">"*********************************"</span>);</span><br><span class="line">   </span><br><span class="line">   Runnable r2 = () -&gt; System.out.println(<span class="string">"我爱这三秦大地！"</span>);</span><br><span class="line">   r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="需要一个参数，无返回值。"><a href="#需要一个参数，无返回值。" class="headerlink" title="需要一个参数，无返回值。"></a>需要一个参数，无返回值。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   con.accept(<span class="string">"熙熙攘攘"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; con2 = (String t) -&gt; System.out.println(t);</span><br><span class="line">   con2.accept(<span class="string">"多么美丽"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型推断。"><a href="#类型推断。" class="headerlink" title="类型推断。"></a>类型推断。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Consumer&lt;String&gt; con = (String t) -&gt; System.out.println(t);</span><br><span class="line">   con.accept(<span class="string">"西安城墙"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"*********************"</span>);</span><br><span class="line">   <span class="comment">//类型推断</span></span><br><span class="line">   Consumer&lt;String&gt; con2 = (t) -&gt; System.out.println(t);</span><br><span class="line">   con2.accept(<span class="string">"威武雄壮"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda-若只需要一个参数，参数的小括号可以省略"><a href="#Lambda-若只需要一个参数，参数的小括号可以省略" class="headerlink" title="Lambda 若只需要一个参数，参数的小括号可以省略"></a>Lambda 若只需要一个参数，参数的小括号可以省略</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Consumer&lt;String&gt; con = (String t) -&gt; System.out.println(t);</span><br><span class="line">   con.accept(<span class="string">"西安城墙"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"*********************"</span>);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; con1 = t -&gt; System.out.println(t);</span><br><span class="line">   con1.accept(<span class="string">"威武雄壮"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda-需要两个或者多个参数，多条执行语句，并且可以有返回值"><a href="#Lambda-需要两个或者多个参数，多条执行语句，并且可以有返回值" class="headerlink" title="Lambda 需要两个或者多个参数，多条执行语句，并且可以有返回值"></a>Lambda 需要两个或者多个参数，多条执行语句，并且可以有返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">   System.out.println(<span class="string">"******************************"</span>);</span><br><span class="line">   Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">      System.out.println(o1);</span><br><span class="line">      System.out.println(o2);</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当-lambda-体只有一条语句时，return-与大括号若有，都可以省略"><a href="#当-lambda-体只有一条语句时，return-与大括号若有，都可以省略" class="headerlink" title="当 lambda 体只有一条语句时，return 与大括号若有，都可以省略"></a>当 lambda 体只有一条语句时，return 与大括号若有，都可以省略</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"***********************"</span>);</span><br><span class="line">   </span><br><span class="line">   Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">   System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h3><p>​    <strong>-&gt; 左边</strong>：Lambda 形参列表的参数类型可以省略（类型推断），如果形参列表只有一个参数，其一对() 也可以省略</p>
<p>​    <strong>-&gt; 右边</strong>： Lambda体 应该使用一对{} 包裹，如果只有一条执行语句（可能是return 语句），可以省略大括号以及 return 关键字</p>
<h3 id="5-Lambda-表达式的实质"><a href="#5-Lambda-表达式的实质" class="headerlink" title="5.Lambda 表达式的实质"></a>5.Lambda 表达式的实质</h3><p>==Lambda表达式的本质： 作为函数式接口的实例。==</p>
<h3 id="6-何时使用Lambda表达式："><a href="#6-何时使用Lambda表达式：" class="headerlink" title="6.何时使用Lambda表达式："></a>6.何时使用Lambda表达式：</h3><p><strong>当需要给一个函数式接口实例化的时候，可以使用Lambda表达式。</strong></p>
<p>以前可以通过匿名实现类表示的现在都可以用Lambda表达式来书写.</p>
<h3 id="7-常使用的Lambda表达式"><a href="#7-常使用的Lambda表达式" class="headerlink" title="7.常使用的Lambda表达式"></a>7.常使用的Lambda表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用的Lambda 表达式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 集合遍历</span></span><br><span class="line">   List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">   list.forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   list.forEach(t -&gt; System.out.print(t + <span class="string">" "</span>));</span><br><span class="line">   list.forEach(System.out :: println);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 集合排序</span></span><br><span class="line">   list.sort(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   list.sort((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">   list.sort(Integer :: compareTo);</span><br><span class="line">   <span class="comment">//开启线程</span></span><br><span class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"run"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"run1"</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、函数式接口"><a href="#二、函数式接口" class="headerlink" title="二、函数式接口"></a>二、函数式接口</h2><h3 id="1-什么是函数接口："><a href="#1-什么是函数接口：" class="headerlink" title="1.什么是函数接口："></a>1.什么是函数接口：</h3><p>​    <strong>如果一个接口只声明了一个抽象方法，那么这个接口就成为函数式接口</strong>，我们可以在接口上面使用@FunctionalInterface 这个注解，用来检查它是否是一个函数式接口</p>
<h3 id="2-Java内置四大核心函数式接口"><a href="#2-Java内置四大核心函数式接口" class="headerlink" title="2.Java内置四大核心函数式接口"></a>2.Java内置四大核心函数式接口</h3><p>消费型接口：Consumer<t>         void accept(T t)<br>供给型接口：Supplier<t>             T get()<br>函数型接口：Function&lt;T, R&gt;         R apply(T t)<br>断定型接口：Predicate<t>         boolean test(T t)</t></t></t></p>
<h3 id="3-何时使用函数式接口："><a href="#3-何时使用函数式接口：" class="headerlink" title="3.何时使用函数式接口："></a>3.何时使用函数式接口：</h3><p>如果我们的开发中需要定义一个函数式接口，首先看看在已有的JDK提供的函数式接口是否提供了能满足需求的函数式接口，如果有则直接使用即可。</p>
<h2 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h3><p>方法引用可以看做是 Lambda 表达式的深层次的表达，换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，<strong>也可以认为是 Lambda 表达式的一个语法糖。</strong></p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><p>​    当要传递给Lambda 体的操作，已经有实现的方法了，可以使用方法引用。</p>
<h3 id="3-格式"><a href="#3-格式" class="headerlink" title="3.格式"></a>3.格式</h3><p>​    类（对象） :: 方法名</p>
<h3 id="4-分为以下三种情况"><a href="#4-分为以下三种情况" class="headerlink" title="4.分为以下三种情况"></a>4.分为以下三种情况</h3><p>对象     ：：     非静态方法<br>类     ：：     静态方法</p>
<p>类     ：：     非静态方法</p>
<h3 id="5-要求"><a href="#5-要求" class="headerlink" title="5.要求"></a>5.要求</h3><p>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同。(针对 情况1 或者 情况2)</p>
<p><strong>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或者无参数）时： ClassName  :: methodName</strong></p>
<h3 id="6-使用建议"><a href="#6-使用建议" class="headerlink" title="6.使用建议"></a>6.使用建议</h3><p>如果给函数式接口提供实例，恰好满足我们的方法引用的要求，大家就可以考虑给我们的函数式接口提供实例，如果不熟悉方法引用，那么还可以使用 Lambda 表达式。</p>
<h3 id="7-使用举例："><a href="#7-使用举例：" class="headerlink" title="7.使用举例："></a>7.使用举例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//情况一： 对象 ：： 实例方法</span></span><br><span class="line">   <span class="comment">//Consumer 中的void accept(T t)</span></span><br><span class="line">   <span class="comment">//PrintStream 中的 void println (T t)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">      con1.accept(<span class="string">"西安"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"*********************"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//对象调用非静态方法</span></span><br><span class="line">      PrintStream ps = System.out;</span><br><span class="line">      Consumer&lt;String&gt; con2 = ps :: println;</span><br><span class="line">      con2.accept(<span class="string">"XiAn"</span>);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Employee emp = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Tom"</span>, <span class="number">23</span>, <span class="number">8000.00</span>);</span><br><span class="line">      Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">      System.out.println(sup1.get());</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"***********"</span>);</span><br><span class="line">      Supplier&lt;String&gt; sup2 = emp :: getName;</span><br><span class="line">      System.out.println(sup2.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//情况二： 类 ：： 静态方法</span></span><br><span class="line">   <span class="comment">//Comparator 中的int compare(T t1, T t2)</span></span><br><span class="line">   <span class="comment">//Integer 中的 int compare(T t1, T t2)</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);</span><br><span class="line">      System.out.println(com1.compare(<span class="number">12</span>, <span class="number">32</span>));</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">      Comparator&lt;Integer&gt; com2 = Integer :: compare;</span><br><span class="line">      System.out.println(com1.compare(<span class="number">12</span>, <span class="number">32</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Function 中的 R apply(T t)</span></span><br><span class="line">   <span class="comment">//Math 中的 round (Double d)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Function&lt;Double, Long&gt; func = <span class="keyword">new</span> Function&lt;Double, Long&gt;() &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Double t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.round(t);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      System.out.println(func.apply(<span class="number">1.2324</span>));</span><br><span class="line">      System.out.println(<span class="string">"**************************"</span>);</span><br><span class="line"></span><br><span class="line">      Function&lt;Double, Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">      System.out.println(func1.apply(<span class="number">1.2324</span>));</span><br><span class="line">      System.out.println(<span class="string">"**************************"</span>);</span><br><span class="line">      </span><br><span class="line">      Function&lt;Double, Long&gt; func2 = Math :: round;</span><br><span class="line">      System.out.println(func2.apply(<span class="number">1.243</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//情况三： 类 ：： 实例方法（有难度）</span></span><br><span class="line">   <span class="comment">//Comparator 中的int compare(T t1, T t2)</span></span><br><span class="line">   <span class="comment">//String 中的 int t1.compareTo(t2)</span></span><br><span class="line">   <span class="comment">// t1 作为调用者 调用 t2</span></span><br><span class="line">   <span class="meta">@Test</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">      System.out.println(com1.compare(<span class="string">"abc"</span>, <span class="string">"abd"</span>));</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"********************************"</span>);</span><br><span class="line">      Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">      System.out.println(com2.compare(<span class="string">"abc"</span>, <span class="string">"abd"</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      BiPredicate&lt;String,    String&gt; pre1 = (str1, str2) -&gt; str1.equals(str2);</span><br><span class="line">      System.out.println(pre1.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>));</span><br><span class="line">      BiPredicate&lt;String,    String&gt; pre2 = String :: equals;</span><br><span class="line">      System.out.println(pre2.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、构造器引用以及数组引用"><a href="#四、构造器引用以及数组引用" class="headerlink" title="四、构造器引用以及数组引用"></a>四、构造器引用以及数组引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器引用：</span></span><br><span class="line"><span class="comment">//Supplier 中的 T get()</span></span><br><span class="line"><span class="comment">//Employee 中的无参构造器： Employee()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">   System.out.println(sup1.get());</span><br><span class="line">   System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">   Supplier&lt;Employee&gt; sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">   System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function 中的 R apply (T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Function&lt;Integer, Employee&gt; func1 = id -&gt; <span class="keyword">new</span> Employee(id);</span><br><span class="line">   System.out.println(func1.apply(<span class="number">1001</span>));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">   Function&lt;Integer, Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">   System.out.println(func2.apply(<span class="number">1002</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组引用</span></span><br><span class="line"><span class="comment">//Function 中的 R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Function&lt;Integer , String[]&gt; function = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">   System.out.println(Arrays.toString(function.apply(<span class="number">3</span>)));</span><br><span class="line">   Function&lt;Integer , String[]&gt; function1 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">   System.out.println(Arrays.toString(function1.apply(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、Stream-API"><a href="#五、Stream-API" class="headerlink" title="==五、Stream API=="></a>==<strong>五、Stream API</strong>==</h2><h3 id="1-Stream-API-的理解"><a href="#1-Stream-API-的理解" class="headerlink" title="1.Stream API 的理解"></a>1.Stream API 的理解</h3><ul>
<li>Stream 关注的是对数据的运算，与CPU打交道。集合关注的是对数据的存储，与内存打交道。    </li>
<li>Java8 提供了一套api，使用这套api可以对内存中的数据进行过滤，排序，映射，规约等操作，类似于sql语句。</li>
</ul>
<h3 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2.注意点"></a>2.注意点</h3><p>①：Stream 自己不会存储元素<br>②：Stream 不会改变原对象，相反，他们会返回一个持有结果的新的Stream。<br>③：Stream 的操作时延迟执行的。这也就意味着他们会等到需要结果的时候才执行</p>
<h3 id="3-Stream的使用流程"><a href="#3-Stream的使用流程" class="headerlink" title="3.Stream的使用流程"></a>3.Stream的使用流程</h3><p>①：Stream 的实例化<br>②：一系列的中间操作（过滤，映射，规约等）<br>③：终止操作。</p>
<h3 id="4-使用流程的注意点"><a href="#4-使用流程的注意点" class="headerlink" title="4.使用流程的注意点"></a>4.使用流程的注意点</h3><p>4.1 一个中间操作链，对数据源的数据进行处理。<br>4.2 一旦执行终止操作，就执行中间操作链，之后，<strong>不会再被使用</strong></p>
<h3 id="5-步骤一：Stream的实例化"><a href="#5-步骤一：Stream的实例化" class="headerlink" title="5.步骤一：Stream的实例化"></a>5.步骤一：Stream的实例化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest1</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式一：通过集合</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">      Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//default Stream&lt;E&gt; parallelstream() : 返回一个并行流</span></span><br><span class="line">      Stream&lt;Employee&gt; parallelstream = employees.parallelStream();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式二：通过数组</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">      <span class="comment">//调用Arrays类中的 static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) 返回一个流</span></span><br><span class="line">      IntStream intStream = Arrays.stream(arr);</span><br><span class="line">      </span><br><span class="line">      Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Tyrone"</span>);</span><br><span class="line">      Employee e2 = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Monkey"</span>);</span><br><span class="line">      Employee[] emps = &#123;e1, e2&#125;;</span><br><span class="line">      Stream&lt;Employee&gt; stream1 = Arrays.stream(emps);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式三：通过Stream的of()</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式四：创建无限流</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代</span></span><br><span class="line">      <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">      <span class="comment">// 遍历前十个偶数</span></span><br><span class="line">      Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//生成</span></span><br><span class="line">      <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate()</span></span><br><span class="line">      Stream.generate(Math :: random).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-步骤二：中间操作"><a href="#6-步骤二：中间操作" class="headerlink" title="6.步骤二：中间操作"></a>6.步骤二：中间操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 筛选与切片</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//filter ( Predicate p) —接收 Lambda ， 从流中排除某些元素</span></span><br><span class="line">      Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">      <span class="comment">//练习查询员工工资大于 7000的 员工信息</span></span><br><span class="line">      stream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out :: println);</span><br><span class="line">      System.out.println(<span class="string">"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line">      <span class="comment">//limit — 截断流，使其元素不超过给定数量 </span></span><br><span class="line">      <span class="comment">//这里一定要重新生成一个stream </span></span><br><span class="line">       list.stream().limit(<span class="number">3</span>).forEach(System.out :: println);</span><br><span class="line">       System.out.println(<span class="string">"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//skip—跳过元素，返回一个扔掉了前 n 个元素的流，若流中元素不足 n 个，则返回一个空流。 </span></span><br><span class="line">       list.stream().skip(<span class="number">3</span>).forEach(System.out :: println);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//distinct —筛选，通过流所生成的元素 hashcode 和 equals 去除重复元素。</span></span><br><span class="line">      list.stream().distinct();<span class="comment">//其实就是元素去重而已</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 2. 映射</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//map(function f) 接受一个函数作为参数 将元素转换成其他形式的提取信息</span></span><br><span class="line">      List&lt;String&gt; list = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">      list.stream().map(str -&gt;str.toUpperCase()).forEach(System.out :: println);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//练习1： 获取员工姓名长度大于3的员工的姓名</span></span><br><span class="line">      List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;String&gt; names = employees.stream().map(e -&gt; e.getName());</span><br><span class="line">        names.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习2：</span></span><br><span class="line">      Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest2::StringToStream);</span><br><span class="line">      streamStream.forEach(s -&gt; &#123;</span><br><span class="line">         s.forEach(System.out :: println);</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(<span class="string">"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//flatMap(Function f) ——接收一个函数作为参数，将流中的每个值都转换称为另外一个流，然后把所有的流连接成一个流。</span></span><br><span class="line">      <span class="comment">//适用于 Stream 套 Stream</span></span><br><span class="line">      Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest2::StringToStream);</span><br><span class="line">      characterStream.forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//将字符串中的多个字符添加到 list 之中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Stream&lt;Character&gt; <span class="title">StringToStream</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">      ArrayList list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(Character c : str.toCharArray() ) &#123;</span><br><span class="line">         list.add(c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list.stream();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//sorted() 自然排序</span></span><br><span class="line">      <span class="comment">//sorted(Comparator com) 定制排序</span></span><br><span class="line">      List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">343</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">76</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">5646</span>, <span class="number">44</span>, -<span class="number">12</span>, -<span class="number">56</span>);</span><br><span class="line">      list1.stream().sorted().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将会抛出异常</span></span><br><span class="line">      <span class="comment">//List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line">      <span class="comment">//employees.stream().sorted().forEach(System.out :: println);</span></span><br><span class="line">      <span class="comment">//定制排序</span></span><br><span class="line">      List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">      employees.stream().sorted((e1, e2) -&gt; &#123;</span><br><span class="line">          <span class="keyword">int</span> index = Integer.compare(e1.getAge(), e2.getAge());</span><br><span class="line">          <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(e1.getSalary(), e2.getSalary());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-步骤三：终止操作"><a href="#7-步骤三：终止操作" class="headerlink" title="7.步骤三：终止操作"></a>7.步骤三：终止操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest3</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 匹配与查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">//        检查是否匹配所有元素</span></span><br><span class="line">        <span class="comment">//练习 ： 是否所有的员工的年龄全大于 18 岁</span></span><br><span class="line">        System.out.println(employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>));</span><br><span class="line"><span class="comment">//        检查是否至少匹配一个元素</span></span><br><span class="line">        <span class="comment">//是否存在员工工资大于 10000 的</span></span><br><span class="line">        System.out.println(employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>));</span><br><span class="line"><span class="comment">//        检查是否没有匹配元素</span></span><br><span class="line">        <span class="comment">//是否存在员工姓 “小”</span></span><br><span class="line">        System.out.println(employees.stream().allMatch(e -&gt; e.getName().startsWith(<span class="string">"小"</span>)));</span><br><span class="line"><span class="comment">//        返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; first = employees.stream().findFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line"><span class="comment">//        返回任意一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; any = employees.parallelStream().findAny();</span><br><span class="line">        System.out.println(any);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">//        返回元素的个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//        返回流中的最大值(最大年龄)</span></span><br><span class="line">        Stream&lt;Double&gt; doubleStream = employees.stream().map(employee -&gt; employee.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; max = doubleStream.max(Double::compareTo);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        <span class="comment">//返回流中的最小值 （最小年龄的员工）</span></span><br><span class="line">        Optional&lt;Employee&gt; min = employees.stream().min((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()));</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//内部迭代</span></span><br><span class="line">        employees.stream().forEach(System.out :: println);</span><br><span class="line">        System.out.println(<span class="string">"=-============================================="</span>);</span><br><span class="line">        employees.forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 规约</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reduce() 可以将流中的元素反复结合起来，得到一个值，返回</span></span><br><span class="line">        <span class="comment">//练习 ： 计算 1 - 10 的和</span></span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        Integer sum = integers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reduce()</span></span><br><span class="line">        <span class="comment">//计算所有员工的工资的总和</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Double&gt; salary = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; sumMoney = salary.reduce((d1, d2) -&gt; d1 + d2);</span><br><span class="line"><span class="comment">//        Optional&lt;Double&gt; sumMoney = salary.reduce(Double :: sum);</span></span><br><span class="line">        System.out.println(sumMoney);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 收集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//collect() —— 将流转换为其他形式。接受一个Collector 接口的实现，用于给Stream</span></span><br><span class="line">        <span class="comment">//练习： 查找工资大于 6000 的员工， 结果返回一个 List 或 Set</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line">        employeeList.forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、Optional类的使用"><a href="#六、Optional类的使用" class="headerlink" title="六、Optional类的使用"></a>六、Optional类的使用</h2><h3 id="1-理解："><a href="#1-理解：" class="headerlink" title="1.理解："></a>1.理解：</h3><p>==<strong>为了解决空指针而生</strong>==</p>
<p>Optional<t> 类 是一个容器类，他可以保存类型T的值，代表这个值存在。或仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在Optional 可以更好地表达这个概念，<strong>而且可以避免空指针异常。</strong></t></p>
<h3 id="2-常用方法："><a href="#2-常用方法：" class="headerlink" title="2.常用方法："></a>2.常用方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个空的opti 对象, 里面的 value 为 null</span></span><br><span class="line">        Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">        <span class="keyword">if</span>(!op1.isPresent()) &#123; <span class="comment">//判断是否包含数据 （false 表示不包含）</span></span><br><span class="line">            System.out.println(<span class="string">"数据为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        <span class="comment">//如果封装到数据 value 为空 则 get 报错</span></span><br><span class="line">        <span class="comment">//System.out.println(op1.get());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="comment">//把对象封装进 Optional ， of(T t)方法要求 t 不能为空</span></span><br><span class="line">        <span class="comment">//* @param value the value to be present, which must be non-null</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">        <span class="comment">// get 通常与 of 搭配使用 用于 获取 内部的数据</span></span><br><span class="line">        System.out.println(op1.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String str  = "beijing";</span></span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// ofNullable( T t) : 封装数据 t 赋给 Optional， 不要求 t 非空</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">        <span class="comment">// orElse(T t) : 如果 Optional 内部的 value 为空，则返回 t，非空 返回 value</span></span><br><span class="line">        String str2 = op1.orElse(<span class="string">"shanghai"</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-典型练习："><a href="#3-典型练习：" class="headerlink" title="3.典型练习："></a>3.典型练习：</h3><p>总之 Optional 就是为了尽可能避免 空指针异常而出现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 Optional 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGirlName2</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line">    Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">    Boy boy1 = boyOptional.orElse(<span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">"琪琪"</span>)));</span><br><span class="line">    Girl girl = boy1.getGirl();</span><br><span class="line">    Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">    Girl girl1 = girlOptional.orElse(<span class="keyword">new</span> Girl(<span class="string">"小芳"</span>));</span><br><span class="line">    <span class="keyword">return</span> girl1.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架 - ArrayList与源码分析</title>
    <url>/undefined/Java%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6%20-%20List%E9%9B%86%E5%90%88%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java集合框架-ArrayList与源码分析"><a href="#Java集合框架-ArrayList与源码分析" class="headerlink" title="Java集合框架 - ArrayList与源码分析"></a>Java集合框架 - ArrayList与源码分析</h2><pre><code>//ArrayList继承关系
java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractList&lt;E&gt;
               ↳     java.util.ArrayList&lt;E&gt;

public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}
</code></pre><p>ArrayList继承了AbstractList，实现了List。它是一个数组队列，相当于动态数组。提供了相关的添加、删除、修改和遍历等功能。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList实现了RandomAccess接口，即提供了随机访问功能。RandomAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号来快速获取元素对象，这就是快速随机访问。后面会比较List的“快速随机访问”和使用“Iterator迭代器访问”的效率。</p>
<p>ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>
<p>ArrayList实现了java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>
<blockquote>
<p>注意：和Vector不同，ArrayList中的操作是非线程安全的。所以建议在单线程中使用ArrayList，在多线程中选择Vector或者CopyOnWriteArrayList。</p>
</blockquote>
<blockquote>
<p>提示：1. ArrayList是基于动态数组实现的，在增删时候，需要数组的拷贝复制。</p>
<ol start="2">
<li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍。</li>
<li>删除元素时不会减少容量，若希望减少容量则调用trimToSize()。</li>
<li>它不是线程安全的。它能存放null值。</li>
</ol>
</blockquote>
<h3 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h3><p>Vector底层也是数组，与ArrayList最大的区别就是：同步（线程安全）。</p>
<p>在要求非同步的情况下，我们一般都是使用ArrayList来替代Vector的。</p>
<p>如果想要ArrayList实现同步，可以使用Collections的方法：</p>
<pre><code>List list = Collections.synchronizedList(new ArrayList(...));
</code></pre><p>就可以实现同步了。</p>
<p>还有另外的一个区别：ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector扩展1倍。</p>
<h3 id="LinkedList-解析"><a href="#LinkedList-解析" class="headerlink" title="LinkedList 解析"></a>LinkedList 解析</h3><p>LinkedList底层是双向链表，</p>
]]></content>
      <categories>
        <category>JAVA 容器</category>
      </categories>
      <tags>
        <tag>JAVA 容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java底层知识</title>
    <url>/undefined/Java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java底层知识"><a href="#Java底层知识" class="headerlink" title="Java底层知识"></a>Java底层知识</h2><p>[TOC]</p>
<h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，将字节码转换成具体平台上的机器指令。</p>
<blockquote>
<p>提示：JVM不将源码直接解析成机器码去执行的原因是因为，如果直接解析成机器码执行，那么每次还需要重新检测语法、句法、语义，这样一来整体的性能就会受到影响。</p>
</blockquote>
<h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><pre><code>JVM的组成

    1.Class Loader 依据特定格式，加载.class文件到内存

    2.Execution Engine 对命令进行解析

    3.Runtime Data Area JVM内存空间结构模型

    4.Native Interface (本地接口) 作用是融合不同的开发语言的原生库为Java所用
</code></pre><h3 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code>类从编译到执行的过程

    1.编译器将xxx.java源文件编译成xxx.class字节码文件

    2.ClassLoader将字节码转换成JVM中的Class&lt;xxx&gt;对象

    3.JVM利用Class&lt;xxx&gt;对象实例化为xxx对象
</code></pre><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流，它是Java的核心组件，所有的Class都有ClassLoader进行加载，ClassLoader负责通过Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化等操作。</p>
<pre><code>ClassLoader的种类：

    1.BootStrapClassLoader 加载核心库java.*

    2.ExtClassLoader 加载扩展库javax.*

    3.AppClassLoader 加载程序所在目录

    4.自定义ClassLoader

        关键函数

            findClass

            defineClass
</code></pre><h3 id="ClassLoader双亲委派机制"><a href="#ClassLoader双亲委派机制" class="headerlink" title="ClassLoader双亲委派机制"></a>ClassLoader双亲委派机制</h3><pre><code>提示：使用双亲委派机制去加载类的原因：1.避免多份同样字节码的加载。2.
</code></pre><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><pre><code>1.隐式加载 new

2.显示加载 loadClass forName等

    类的装载过程

        1.加载 通过ClassLoader加载class文件字节码，生成Class对象

        2.链接

            1.校验 检查加载的class的正确性和安全性

            2.准备 为类变量分配存储空间并设置类变量初始值

            3.解析 JVM将常量池内的符号引用转换为直接引用

        3.初始化 执行类变量赋值和静态代码块
</code></pre><h4 id="loadClass-forName-的区别"><a href="#loadClass-forName-的区别" class="headerlink" title="loadClass | forName 的区别"></a>loadClass | forName 的区别</h4><pre><code>1.Class.forName得到的class是已经初始化完成的

2.Classloader.loadClass得到的class是还没有链接的
</code></pre><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><pre><code>1.当前线程所执行的字节码行号指示器（逻辑）

2.改变计数器的值来选取下一条需要执行的字节码指令

3.和线程是一对一的关系，即线程私有

4.对Java方法计数，如果是Native方法则计数器值为undefined

5.不会发生内存泄漏
</code></pre><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><pre><code>1.Java方法执行的内存模型

2.包含多个栈帧


    局部变量表：包含方法执行过程中的所有变量

    操作数栈：入栈、出栈、复制、变换、产生消费变量
</code></pre><h4 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h4><pre><code>1.JVM三大性能调优参数

    -Xms 

        规定每个线程虚拟机栈的大小 （堆栈）

    -Xmx

        堆的初始值

    -Xss

        堆能达到的最大值
</code></pre><h5 id="Java内存中堆和栈的区别（内存分配策略）"><a href="#Java内存中堆和栈的区别（内存分配策略）" class="headerlink" title="Java内存中堆和栈的区别（内存分配策略）"></a>Java内存中堆和栈的区别（内存分配策略）</h5><pre><code>1.静态存储：编译时确定每个数据目标在运行时的存储空间需求

2.栈式存储：数据区需求在编译时未知，运行时模块入口前确定

3.堆式存储：编译时或运行时模块入口都无法确定，动态分配

堆和栈的联系：

    1.引用对象、数组时，栈里定义变量保存堆中目标的首地址

        在栈内存中存的地址（指向对应堆内存空间），在堆内存中存的是new出来的对象实例和数组

    2.管理方式：栈自动释放，堆需要GC

    3.空间大小：栈空间大小比堆小

    4.碎片相关：栈产生的碎片远小于堆

    5.分配方式：栈支持静态和动态分配，而堆仅支持动态分配

    6.效率：栈的效率要比堆高
</code></pre><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><pre><code>1.可以作为GC Root的对象

    1.虚拟机栈中引用的对象（栈帧中的本地变量表）

    2.方法区中的常量引用的对象

    3.方法区中的类静态属性引用的对象

    4.本地方法栈中JNI(Native方法)的引用对象

    5.活跃线程的引用对象

2.垃圾回收算法（不再做笔记）

    1.标记-清除

    2.复制

        1.解决碎片化问题

        2.顺序分配内存，简单高效

        3.适用于对象存活率低的场景

    3.标记-整理

    4.分代收集

        1.GC分类：

            1.Minor GC

            2.Full GC

        2.年轻代：尽可能快速地收集掉那些生命周期短的对象

            1.Eden区

            2.两个Survivor区

        3.对象晋升到老年代

            1.经历一定Minor次数依然存活的对象

            2.Survivor区或Eden区中存放不下的对象

            3.新生成的大对象（-XX:+PretenuerSizeThreshold命令控制对象大小）

        4.常用性能调优参数

            1.-XX:SurvivorRatio：Eden和Survivor的比值，默认8:1

            2.-XX:NewRatio：老年代和年轻代内存大小的比值

            3.-XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值

        4.老年代：存放生命周期较长的对象

        5.触发Full GC的条件

            1.老年代空间不足

            2.永久代空间不足

            3.Minor GC晋升到老年代的平均大小大于老年代的剩余空间

            4.调用System.gc()

        6.stop-the-world

            1.JVM由于要执行GC而停止了应用程序的执行

            2.任何一种GC算法中都会发生

            3.多数GC优化都是通过减少stop-the-world发生的时间来提高性能优化

        7.safepoint

            1.分析过程中对象引用关系不会发生变化的点

            2.产生safepoint的地方：方法调用、循环跳转、异常跳转等

            3.安全点的数量要适中
</code></pre><h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h4><pre><code>1.JVM的运行模式

    1.Server 启动较慢，启动之后程序运行较快

    2.Client 相反地

    提示：可以利用 java -version 命令来查看JVM的运行模式

2.年轻代常见的垃圾收集器

    1.Serial收集器（命令 -XX:UseSerialGC 命令可以让JVM在年轻代处理垃圾回收，是复制算法）

        1.单线程收集，进行垃圾收集时，必须暂停所有工作线程

        2.简单高效，Client模式下默认的年轻代收集器

    2.ParNew收集器（命令 -XX:UseParNewGC 命令可以让JVM在年轻代处理垃圾回收，复制算法）

        1.多线程回收，其余行为特点和Serial收集器一样

        2.单核执行效率不如Serial，在多核执行才有优势

    3.Parallel Scavenge收集器（命令 -XX:+UseParallelGC 命令...，复制算法）

        1.吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

        2.比起关注用户线程停顿时间，更关注系统的吞吐量

        3.在多核下执行才有优势，Server模式下默认的年轻代收集器

3.老年代常用的垃圾收集器

    1.Serial Old收集器（命令 -XX:+UseSerialOldGC 命令...，标记-整理算法）

        1.单线程收集，进行垃圾收集时，必须暂停所有工作线程

        2.简单高效，Client模式下默认的老年代收集器

    2.Parallel Old收集器（命令 -XX:+UseParallelOldGC 命令...，标记-整理）

        1.多线程，吞吐量优先

    3.CMS收集器（命令 -XX:+UseConcMarkSweepGC 命令...，标记-清除）

        垃圾收集过程：

            1.初始标记：stop-the-world

            2.并发标记：并发追溯标记，程序不会停顿

            3.并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象

            4.重新标记：暂停虚拟机，扫描CMS堆中的剩余对象

            5.并发清理：清理垃圾对象，程序不会停顿

            6.并发重置：重置CMS收集器的数据结构


4.年轻代和老年代通用

    1.G1垃圾收集器（-XX:+UseG1GC 复制+标记-整理算法）

        Garbage First 收集器的特点：

            1.并发和并行

            2.分代收集

            3.空间整合

            4.可预测的停顿

            5.将整个Java堆内存划分为多个大小相等的Region

            6.年轻代和老年代不再物理隔离

            7.
</code></pre><h3 id="GC面试题"><a href="#GC面试题" class="headerlink" title="GC面试题"></a>GC面试题</h3><h4 id="1-Object的finalize-方法的作用是否与C-的析构函数作用相同"><a href="#1-Object的finalize-方法的作用是否与C-的析构函数作用相同" class="headerlink" title="1.Object的finalize()方法的作用是否与C++的析构函数作用相同"></a>1.Object的finalize()方法的作用是否与C++的析构函数作用相同</h4><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><pre><code>1.javap -c 对编译之后的.class文件作反汇编操作

2.javac 编译生成字节码 .class 文件

3.
</code></pre>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架 - Collection架构与源码分析</title>
    <url>/undefined/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20Collection%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java集合框架-Collection架构与源码分析"><a href="#Java集合框架-Collection架构与源码分析" class="headerlink" title="Java集合框架 - Collection架构与源码分析"></a>Java集合框架 - Collection架构与源码分析</h2><p>Collection是一个接口，它主要的两个分支是List和Set。List和Set都是接口，它们继承与Collection。List是有序的队列，可以用重复的元素；而Set是数学概念中的集合，不能有重复的元素。List和Set都有它们各自的实现类。</p>
<p>我们抽象出AbstractCollection类来让其他类继承，该类实现类Collection中的绝大部分方法。AbstractList和AbstractSet都继承与AbstractCollection，具体的List实现类继承与AbstractList，而Set的实现类则继承与AbstractSet。</p>
<p>Collection中有个iterator()方法，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>//Collection定义
public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}
</code></pre><p>从Collection的定义可以看出，Collection是一个接口。是一个高度抽象出来的集合，包含了集合的基本操作：添加|删除|清空|遍历|是否为空|获取大小等。Collection接口的所有子类都必须实现2中构造函数：1.不带参数的构造函数。2.参数为Collection的构造函数。ps：带参数的构造函数可以用来转换Collection类型。</p>
<pre><code>// Collection的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void            clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]        toArray()
</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code>//List定义
public interface List&lt;E&gt; extends Collection&lt;E&gt; {}
</code></pre><p>从List定义可以得到，List接口继承Collection接口即List是集合的一种。List是有序的队列，List中的每一个元素都有一个索引，第一个元素的索引值为0，往后的元素的索引值依次+1.，List中允许有重复的元素。List继承Collection自然包含了Collection的所有接口，由于List是有序队列，所以它也有自己额外的API接口。</p>
<pre><code>// Collection的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void            clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]        toArray()
// 相比与Collection，List新增的API：
abstract void                add(int location, E object) //在指定位置添加元素
abstract boolean             addAll(int location, Collection&lt;? extends E&gt; collection) //在指定位置添加其他集合中的元素
abstract E                   get(int location) //获取指定位置的元素
abstract int                 indexOf(Object object) //获得指定元素的索引
abstract int                 lastIndexOf(Object object) //从右边的索引
abstract ListIterator&lt;E&gt;     listIterator(int location) //获得iterator
abstract ListIterator&lt;E&gt;     listIterator()
abstract E                   remove(int location) //删除指定位置的元素
abstract E                   set(int location, E object) //修改指定位置的元素
abstract List&lt;E&gt;             subList(int start, int end) //获取子list
</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>//Set的定义
public interface Set&lt;E&gt; extends Collection&lt;E&gt; {}
</code></pre><p>Set也继承与Collection接口，且里面不能有重复元素。关于API，Set与Collection的API完全一样，不再赘述。</p>
<h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h3><pre><code>//AbstractCollection的定义
public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}
</code></pre><p>AbstractCollection是一个抽象类，实现了Collection中除了iterator()和size()之外的所有方法。AbstractCollection的主要作用是方便其它类实现Collection。如：ArrayList | LinkedList等。它们如果想要实现Collection接口，通过继承AbstractCollection就已经实现大部分方法，再实现iterator()和size()方法即可。</p>
<pre><code>//AbtractCollection源码在这里省略是因为是实现上面的所有方法
</code></pre><h3 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h3><pre><code>//定义
public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}
</code></pre><p>从定义可以看出，AbstractList是一个继承AbstractCollection，并且实现了List接口的抽象类。它实现了List中除了size()、get(int location)之外的方法。</p>
<p>AbstractList的主要作用：它实现了List接口中的大部分函数，从而方便其它类继承List。另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()方法。</p>
<pre><code>//这里省略源码复制，后面对比看..
</code></pre><h3 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h3><pre><code>//定义
public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}
</code></pre><p>AbstractSet是一个继承与AbstractCollection，并且实现了Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，所以Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()外的方法。所以源码和AbstractCollection的一样。</p>
<pre><code>//源码省略...
</code></pre><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><pre><code>//定义
public interface Iterator&lt;E&gt; {}
</code></pre><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历其中的元素。Iterator提供的API接口包括：是否存在下一个元素，获取下一个元素和删除当前元素。</p>
<blockquote>
<p>注意：Iterator遍历Collection时，是fail-fast机制：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程A访问集合时，就会抛出CurrentModificationException异常，产生fail-fast事件。</p>
</blockquote>
<pre><code>// Iterator的API
abstract boolean hasNext()
abstract E next()
abstract void remove()
</code></pre>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码解析</title>
    <url>/undefined/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h2><p>[TOC]</p>
<h3 id="1-默认属性"><a href="#1-默认属性" class="headerlink" title="1. 默认属性"></a>1. 默认属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">//默认初始容量 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大值 2^30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认扩容因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//转为红黑树的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;<span class="comment">//由树转换为链表的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//默认的树存在的最小数组长度 此长度最少是TREEIFY_THRESHOLD的四倍（注释之中说的很清楚）</span></span><br></pre></td></tr></table></figure>
<h3 id="2-put方法"><a href="#2-put方法" class="headerlink" title="2. put方法"></a>2. put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//hashcode是32位的，无符号右移16位，那生成的就是16位0加原高位的16位值， 就是对半了，异或计算也就变成</span></span><br><span class="line"><span class="comment">//了高16位和低16位进行异或，原高16位不变。这么干主要用于当hashmap 数组比较小的时候所有二进制都参与运</span></span><br><span class="line"><span class="comment">//算了，防止hash冲突太大，</span></span><br></pre></td></tr></table></figure>
<h4 id="putval-添加-方法"><a href="#putval-添加-方法" class="headerlink" title="==putval(添加)方法=="></a>==putval(添加)方法==</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果存储元素的table为空，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">///这里的resize  是初始化的时候调用 后面会讲</span></span><br><span class="line">            n = (tab = resize()).length;    <span class="comment">// 获取默认长度（16）</span></span><br><span class="line">    	<span class="comment">//p = tab[i = (n - 1) &amp; hash] 获取要插入的元素在hash桶中的位置</span></span><br><span class="line">        <span class="comment">// 如果根据hash值获取的结点为空（这个位置没有节点）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)      <span class="comment">// 此处 &amp; 代替了 %（效率更高）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//则直接新建一个结点</span></span><br><span class="line">        <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果有节点</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果新插入的结点和table中p结点的hash值，key值相同的话</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;<span class="comment">//则进行覆盖</span></span><br><span class="line">            <span class="comment">// 如果是红黑树结点的话，进行红黑树插入（上次分享了红黑树）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//定位到这个hash桶了 但是这里面是链表（没有进行过树化）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 如果p节点的next为空 直接在后面插入(代表这个单链表只有一个头部结点)</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//插入完成之后再次判断是否要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">//转换为红黑树</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">////如果下一个节点e 不为null 并且这个链表中的节点就是你要找的节点 终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 及时更新p 保证p是最后一个</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果存在这个映射就覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 判断是否允许覆盖，并且value是否为空、</span></span><br><span class="line">                <span class="comment">//onlyIfAbsent 如果为true，不更改现有值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);     <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 执行到这里，说明是增加了新的元素，而不是替换了老的元素，所以相关计数需要累加</span></span><br><span class="line">        ++modCount;     <span class="comment">// 更改操作次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)     <span class="comment">// 大于临界值</span></span><br><span class="line">            <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">            <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">            resize();  </span><br><span class="line">        <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回空</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="PUT方法的流程："><a href="#PUT方法的流程：" class="headerlink" title="==PUT方法的流程：=="></a>==PUT方法的流程：==</h5><ul>
<li><strong>1、如果未被初始化，则初始化</strong></li>
<li><strong>2、根据KEY求Hash值，然后计算下标。</strong></li>
<li><strong>3、如果没有碰撞直接放入bucket中。</strong></li>
<li><strong>4、如果碰撞了，则以链表的方式连接到后面。</strong></li>
<li><strong>5、如果链表长度大于 8，则调转换为红黑树的方法</strong></li>
<li><strong>6、如果树节点个数低于 6，则调转换链表的方法</strong></li>
<li><strong>7、如果节点已经存在则直接替换</strong></li>
<li><strong>8、如果超过了阈值，则进行扩容</strong></li>
</ul>
<h4 id="resize-扩容-方法"><a href="#resize-扩容-方法" class="headerlink" title="resize(扩容)方法"></a>resize(扩容)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化或者扩容之后元素调整</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧元素数组的各种信息</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//如果你是新创建的话 表的大小就是0 否则就是原来的大小</span></span><br><span class="line">        <span class="comment">//第一次是为0的 代表 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;就是16</span></span><br><span class="line">        <span class="comment">// 老的扩容阀值设置</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新数组的长度及扩容的临界值（都初始化为0）</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;   <span class="comment">// 如果原table不为空</span></span><br><span class="line">            <span class="comment">// 如果数组元素个数大于等于限定的最大容量（2的30次方）</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 扩容阀值设置为int最大值（2的31次方 -1 ），因为oldCap再乘2就溢出了</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//直接返回</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）newCap = oldCap &lt;&lt; 1 相当于*2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//并且旧的容量大于默认的初始化大小16</span></span><br><span class="line">                <span class="comment">// 新的扩容阈值 = 旧的扩容阈值 * 2 </span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">            newCap = oldThr;<span class="comment">//如果旧的扩容本来就大于0，那么新的容量就是旧的扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// threshold（旧的扩容）为0，则使用默认值</span></span><br><span class="line">            <span class="comment">// 能运行到这里的话，说明是调用无参构造函数创建的该map，并且第一次添加元素</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//16 </span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//0.75*16=12</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  <span class="comment">// 如果阈值值还为0，则设置临界值</span></span><br><span class="line">            <span class="comment">//计算得到新的阙值</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//新的阙值 =  如果新的容量&lt;最大的容量 并且 新的阈值&lt;最大的容量 ，那么新的阙值 = 计算的             //否则=最大int</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr; <span class="comment">//阙值 = 新的阙值(更新阈值)</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    		<span class="comment">////创建一个新的哈希数组桶 大小为新的容量</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;   <span class="comment">// 调整数组大小之后，需要调整红黑树或者链表的指向</span></span><br><span class="line">            <span class="comment">//遍历旧的hash桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//如果旧的hash桶的元素不为null  e为旧的hash桶的元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;<span class="comment">//旧的hash桶设置为null(主要为了使得数组可被回收)</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果你是一个元素</span></span><br><span class="line">                        <span class="comment">//那么在新的hash桶中给你安排一个位置  </span></span><br><span class="line">                        <span class="comment">//位置是你的hash值 &amp; 新的桶的容量-1（再次分配位置） </span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 	<span class="comment">//如果你不只一个元素并且是TreeNode</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//调用split方法</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//如果你是普通的链表</span></span><br><span class="line">                        <span class="comment">// 链表调整</span></span><br><span class="line">                        <span class="comment">// 按命名来翻译的话，应该叫低位首尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 按命名来翻译的话，应该叫高位首尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//以上的低位指的是新数组的 0 到 oldCap-1 、高位指定的是oldCap 到 newCap - 1</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//看是否需要进行位置变化 新增位的值 不需要变化就放在原来的位置</span></span><br><span class="line">                            <span class="comment">//如果hash值和老的长度做与运算，结果为0，那么该hash值再和新数组的长度取摸的话值也不会放生变化，所以该元素的在新数组的位置和在老数组的位置是相同的，所以该元素可以放置在低位链表中。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// 如果没有尾，说明链表为空</span></span><br><span class="line">                                    loHead = e;<span class="comment">// 链表为空时，头节点指向该元素</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 如果有尾，那么链表不为空，把该元素挂到链表的最后。</span></span><br><span class="line">                                    loTail.next = e; </span><br><span class="line">                                loTail = e;<span class="comment">// 把尾节点设置为当前元素</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果与运算结果不为0，说明hash值大于老数组长度（例如hash值为17）</span></span><br><span class="line">                            <span class="comment">// 此时该元素应该放置到新数组的高位位置上</span></span><br><span class="line">                            <span class="comment">//例：老数组长度16，那么新数组长度为32，hash为17的应该放置在数组的第17个位置上，也就是下标为16，那么下标为16已经属于高位了，低位是[0-15]，高位是[16-31]</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//需要变化 就构建高位放置的链表</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">// 如果没有尾，说明链表为空</span></span><br><span class="line">                                    hiHead = e;<span class="comment">// 链表为空时，头节点指向该元素</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 如果有尾，那么链表不为空，把该元素挂到链表的最后</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;<span class="comment">// 把尾节点设置为当前元素</span></span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">// 低位的元素组成的链表还是放置在原来的位置</span></span><br><span class="line">                            </span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;<span class="comment">//赋值 （原来位置</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高位的元素组成的链表放置的位置只是在原有位置上偏移了老数组的长度个位置</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             <span class="comment">// 销毁实例，等待GC回收</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// 例：hash为 17 在老数组放置在0下标，在新数组放置在16下标；                                   //hash为 18 在老数组放置在1下标，在新数组放置在17下标； </span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新的数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 总结一下</span></span><br><span class="line"><span class="comment"> *  1、如果你是新创建的话 旧的表的大小就是0 否则就是原来的大小</span></span><br><span class="line"><span class="comment"> *  2、 如果原table不为空且数组元素个数大于等于限定的最大容量（2的30次方），扩容阀值设置为int最大值</span></span><br><span class="line"><span class="comment"> *    直接返回。</span></span><br><span class="line"><span class="comment"> *  3、新的表的大小等于旧的乘2,如果其大小小于最大容量，并且旧的容量大于默认的初始化大小16，</span></span><br><span class="line"><span class="comment"> *     新的扩容阈值 = 旧的扩容阈值 * 2 </span></span><br><span class="line"><span class="comment"> *  4、如果是是调用无参构造函数创建的该map，并且第一次添加元素，给附上初始值16</span></span><br><span class="line"><span class="comment"> *  5、如果阈值值还为0，则设置临界值：新的阙值 =  如果新的容量&lt;最大的容量 并且 新的阈值&lt;最大的容量</span></span><br><span class="line"><span class="comment"> *     那么新的阙值 = 计算的  否则=最大int</span></span><br><span class="line"><span class="comment"> *  6、创建一个新的哈希数组桶 大小为新的容量，然后遍历旧的哈希桶</span></span><br><span class="line"><span class="comment"> *  7、如果旧的hash桶的元素不为null，旧的hash桶设置为null(主要为了使得数组可被回收)这里已经用e接收了</span></span><br><span class="line"><span class="comment"> *  8、如果你是一个元素，那么在新的hash桶中给你安排一个位置，</span></span><br><span class="line"><span class="comment"> *	   位置是你的hash值 &amp; 新的桶的容量-1（再次分配位置）</span></span><br><span class="line"><span class="comment"> *  9、如果你不只一个元素并且是TreeNode,那么调用split方法，进行树的修剪</span></span><br><span class="line"><span class="comment"> *  10、如果你是一个普通链表，且(e.hash &amp; oldCap) == 0，则挂到低位链，否则挂到高位链</span></span><br><span class="line"><span class="comment"> *  11、如果链表上存在元素，则尾插。</span></span><br><span class="line"><span class="comment"> *  12、把老数组赋空，便于GC回收。</span></span><br><span class="line"><span class="comment"> *  13、高位的元素组成的链表放置的位置只是在原有位置上偏移了老数组的长度个位置</span></span><br><span class="line"><span class="comment"> 		例：hash为 17 在老数组放置在0下标，在新数组放置在16下标；                                   	//hash为 18 在老数组放置在1下标，在新数组放置在17下标； </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="split-红黑树修剪-方法"><a href="#split-红黑树修剪-方法" class="headerlink" title="split(红黑树修剪)方法"></a><strong>split</strong>(红黑树修剪)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上述方法在resize()过程中被调用 </span><br><span class="line">和链表的修剪差不多（再次操作看看是否要再次保留红黑树）</span><br><span class="line">目的是将树的数据重新散列到数组中</span><br><span class="line"><span class="comment">//被调用的代码 split(当前hash表，新的哈希桶，要分割的元素的下标，旧的容量) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;<span class="comment">//这里的this :    e = oldTab[j] 上下文中的代码</span></span><br><span class="line">            </span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//低位的头和低位的尾</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//高位的头和高位的尾</span></span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>; <span class="comment">//地位和高位的2个计数器</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;<span class="comment">//获取下一个节点</span></span><br><span class="line">                e.next = <span class="keyword">null</span>;<span class="comment">//设置为null</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果 e.hash 与 原来旧的容量 &amp; 为 0 说明不需要进行移动位置  </span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;<span class="comment">//将e 复制给头</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//如果尾巴不为null 尾巴的next 为 e</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;<span class="comment">//将e 作为新的尾巴</span></span><br><span class="line">                    ++lc;<span class="comment">//次数 + 1 </span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)<span class="comment">//否则需要移动位置</span></span><br><span class="line">                        hiHead = e;<span class="comment">//高位的链表和低位一样</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123; <span class="comment">//如果有链表</span></span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<span class="comment">//如果长度 &lt;= 6  </span></span><br><span class="line">                <span class="comment">//取消树化 将这个树里面的链表结构变成普通的链表结构</span></span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead; <span class="comment">//否则将地位复制给原来的下标</span></span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);<span class="comment">//进行树化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);<span class="comment">//进行了移位 位置偏移 下标 + 原来的容器大小</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="untreeify-非树化-方法"><a href="#untreeify-非树化-方法" class="headerlink" title="untreeify(非树化)方法"></a>untreeify(非树化)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果链表的长度 &lt;= UNTREEIFY_THRESHOLD(<span class="number">6</span>) 就进行非树化，否则就进行树化。</span><br><span class="line">这里的非树化就是将TreeNode转换成Node</span><br><span class="line">		<span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">            <span class="comment">//将q转换成普通的Nod return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span></span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p; <span class="comment">//头为p</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;<span class="comment">//返回这个链表</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeifyBin-树化-方法"><a href="#treeifyBin-树化-方法" class="headerlink" title="treeifyBin(树化)方法"></a>treeifyBin(树化)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeifyBin方法，应该可以解释为：把容器里的元素变成树结构   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tab：元素数组，</span></span><br><span class="line"><span class="comment"> * hash：hash值（要增加的键值对的key的hash值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果元素数组为空 或者 数组长度小于 树结构化的最小限制</span></span><br><span class="line"><span class="comment">     * MIN_TREEIFY_CAPACITY 默认值64，对于这个值可以理解为：如果元素数组长度小于这个值，没有必要去进行结构转换</span></span><br><span class="line"><span class="comment">     * 当一个数组位置上集中了多个键值对，那是因为这些key的hash值和数组长度取模之后结果相同。（并不是因为这些key的hash值相同）</span></span><br><span class="line"><span class="comment">     * 因为hash值相同的概率不高，所以可以通过扩容的方式，来使得最终这些key的hash值在和新的数组长度取模之后，拆分到多个数组位置上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize(); <span class="comment">// 扩容，可参见resize方法解析</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果元素数组长度已经大于等于了 MIN_TREEIFY_CAPACITY，那么就有必要进行结构转换了</span></span><br><span class="line">    <span class="comment">// 根据hash值和数组长度进行取模运算后，得到链表的首节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">// 定义首、尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// 将该节点转换为 树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">// 如果尾节点为空，说明还没有根节点</span></span><br><span class="line">                hd = p; <span class="comment">// 首节点（根节点）指向 当前节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 尾节点不为空，以下两行是一个双向链表结构</span></span><br><span class="line">                p.prev = tl; <span class="comment">// 当前树节点的 前一个节点指向 尾节点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 尾节点的 后一个节点指向 当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p; <span class="comment">// 把当前节点设为尾节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 继续遍历链表</span></span><br><span class="line">        <span class="comment">// 到目前为止 也只是把Node对象转换成了TreeNode对象，把单向链表转换成了双向链表</span></span><br><span class="line">        <span class="comment">// 把转换后的双向链表，替换原来位置上的单向链表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">//此处单独解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeify-打头树化-方法"><a href="#treeify-打头树化-方法" class="headerlink" title="treeify(打头树化)方法"></a>treeify(打头树化)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为HashMap的元素数组,</span></span><br><span class="line"><span class="comment"> * treeify方法是TreeNode类的一个实例方法，通过TreeNode对象调用，实现该对象打头的链表转换为树结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; <span class="comment">// 定义树的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123; <span class="comment">// 遍历链表，x指向当前节点、next指向下一个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>; <span class="comment">// 设置当前节点的左右节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果还没有根节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>; <span class="comment">// 当前节点的父节点设为空</span></span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">// 当前节点的红色属性设为false（把当前节点设为黑色）</span></span><br><span class="line">            root = x; <span class="comment">// 根节点指向到当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果已经存在根节点了</span></span><br><span class="line">            K k = x.key; <span class="comment">// 取得当前链表节点的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash; <span class="comment">// 取得当前链表节点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 定义key所属的Class</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span></span><br><span class="line">                <span class="comment">// GOTO1</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph; <span class="comment">// dir 标识方向（左右）、ph标识当前树节点的hash值</span></span><br><span class="line">                K pk = p.key; <span class="comment">// 当前树节点的key</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前树节点hash值 大于 当前链表节点的hash值</span></span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识当前链表节点会放到当前树节点的左侧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>; <span class="comment">// 右侧</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果两个节点的key的hash值相等，那么还要通过其他方式再进行比较</span></span><br><span class="line"><span class="comment">                 * 如果当前链表节点的key实现了comparable接口，并且当前树节点和链表节点是相同Class的实例，那么通过comparable的方式再比较两者。</span></span><br><span class="line"><span class="comment">                 * 如果还是相等，最后再通过tieBreakOrder比较一次</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 保存当前树节点</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果dir 小于等于0 ： 当前链表节点一定放置在当前树节点的左侧，但不一定是该树节点的左孩子，也可能是左孩子的右孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果dir 大于0 ： 当前链表节点一定放置在当前树节点的右侧，但不一定是该树节点的右孩子，也可能是右孩子的左孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩子 为 起始节点  再从GOTO1 处开始 重新寻找自己（当前链表节点）的位置</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂载到当前树节点的左或者右侧了。</span></span><br><span class="line"><span class="comment">                 * 挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点进行处理了。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 当前链表节点 作为 当前树节点的子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 作为左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// 作为右孩子</span></span><br><span class="line">                    root = balanceInsertion(root, x); <span class="comment">// 重新平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把所有的链表节点都遍历完之后，最终构造出来的树可能经历多个平衡操作，根节点目前到底是链表的哪一个节点是不确定的</span></span><br><span class="line">    <span class="comment">// 因为我们要基于树来做查找，所以就应该把 tab[N] 得到的对象一定根节点对象，而目前只是链表的第一个节点对象，所以要做相应的处理。</span></span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">// 单独解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="moveRootToFront-保证根节点-方法"><a href="#moveRootToFront-保证根节点-方法" class="headerlink" title="moveRootToFront(保证根节点)方法"></a>moveRootToFront(保证根节点)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把红黑树的根节点设为  其所在的数组槽 的第一个元素</span></span><br><span class="line"><span class="comment"> * 首先明确：TreeNode既是一个红黑树结构，也是一个双链表结构</span></span><br><span class="line"><span class="comment"> * 这个方法里做的事情，就是保证树的根节点一定也要成为链表的首节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// 根节点不为空 并且 HashMap的元素数组不为空</span></span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash; <span class="comment">// 根据根节点的Hash值 和 HashMap的元素数组长度  取得根节点在数组中的位置</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; <span class="comment">// 首先取得该位置上的第一个节点对象</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123; <span class="comment">// 如果该节点对象 与 根节点对象 不同</span></span><br><span class="line">            Node&lt;K,V&gt; rn; <span class="comment">// 定义根节点的后一个节点</span></span><br><span class="line">            tab[index] = root; <span class="comment">// 把元素数组index位置的元素替换为根节点对象</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">// 获取根节点对象的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">// 如果后节点不为空 </span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp; <span class="comment">// root后节点的前节点  指向到 root的前节点，相当于把root从链表中摘除</span></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>) <span class="comment">// 如果root的前节点不为空</span></span><br><span class="line">                rp.next = rn; <span class="comment">// root前节点的后节点 指向到 root的后节点</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 如果数组该位置上原来的元素不为空</span></span><br><span class="line">                first.prev = root; <span class="comment">// 这个原有的元素的 前节点 指向到 root，相当于root目前位于链表的首位</span></span><br><span class="line">            root.next = first; <span class="comment">// 原来的第一个节点现在作为root的下一个节点，变成了第二个节点</span></span><br><span class="line">            root.prev = <span class="keyword">null</span>; <span class="comment">// 首节点没有前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这一步是防御性的编程</span></span><br><span class="line"><span class="comment">         * 校验TreeNode对象是否满足红黑树和双链表的特性</span></span><br><span class="line"><span class="comment">         * 如果这个方法校验不通过：可能是因为用户编程失误，破坏了结构（例如：并发场景下）；也可能是TreeNode的实现有问题（这个是理论上的以防万一）；</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="putTreeVal-树的添加节点-方法"><a href="#putTreeVal-树的添加节点-方法" class="headerlink" title="putTreeVal(树的添加节点)方法"></a>putTreeVal(树的添加节点)方法</h4><p>​    当同一个位置上链表中的元素达到8个的时候，就会再将这些元素构建成一个红黑树（参见：treeifyBin方法分析），同时把==原来的单链表结构变成了双链表结构==，也就是这些==元素即维持着红黑树的结构又维持着双链表的结构==。当第9个相同hash值的键值对put过来时，发现该位置已经是一个树节点了，那么就会调用putTreeVal方法，将这个新的值设置到指定的key上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当存在hash碰撞的时候，且元素数量大于8个时候，就会以红黑树的方式将这些元素组织起来</span></span><br><span class="line"><span class="comment"> * map 当前节点所在的HashMap对象</span></span><br><span class="line"><span class="comment"> * tab 当前HashMap对象的元素数组</span></span><br><span class="line"><span class="comment"> * h   指定key的hash值</span></span><br><span class="line"><span class="comment"> * k   指定key</span></span><br><span class="line"><span class="comment"> * v   指定key上要写入的值</span></span><br><span class="line"><span class="comment"> * 返回：指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 定义k的Class对象</span></span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>; <span class="comment">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>; <span class="comment">// 父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点开始遍历，没有终止条件，只能从内部退出</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk; <span class="comment">// 声明方向、当前节点hash值、当前节点的键对象</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前节点hash 大于 指定key的hash值</span></span><br><span class="line">            dir = -<span class="number">1</span>; <span class="comment">// 要添加的元素应该放置在当前节点的左侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">// 如果当前节点hash 小于 指定key的hash值</span></span><br><span class="line">            dir = <span class="number">1</span>; <span class="comment">// 要添加的元素应该放置在当前节点的右侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">// 如果当前节点的键对象 和 指定key对象相同</span></span><br><span class="line">            <span class="keyword">return</span> p; <span class="comment">// 那么就返回当前节点对象，在外层方法会对v进行写入</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class="line"><span class="comment">             * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点</span></span><br><span class="line"><span class="comment">             * 如果得到了键的equals相等的的节点就返回</span></span><br><span class="line"><span class="comment">             * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123; <span class="comment">// 如果还没有比对过当前节点的所有子节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch; <span class="comment">// 定义要返回的节点、和子节点</span></span><br><span class="line">                searched = <span class="keyword">true</span>; <span class="comment">// 标识已经遍历过一次了</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了</span></span><br><span class="line"><span class="comment">                 * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了</span></span><br><span class="line"><span class="comment">                 * find 方法内部还会有递归调用。参见：find方法解析</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q; <span class="comment">// 找到了指定key键对应的</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点</span></span><br><span class="line">            dir = tieBreakOrder(k, pk); <span class="comment">// 再比较一下当前节点键和指定key键的大小</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 定义xp指向当前节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果dir小于等于0，那么看当前节点的左节点是否为空，如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">        * 如果dir大于等于0，那么看当前节点的右节点是否为空，如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">        * 如果以上两条当中有一个子节点不为空，这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next; <span class="comment">// 获取当前节点的next节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); <span class="comment">// 创建一个新的树节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;  <span class="comment">// 左孩子指向到这个新的树节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x; <span class="comment">// 右孩子指向到这个新的树节点</span></span><br><span class="line">            xp.next = x; <span class="comment">// 链表中的next节点指向到这个新的树节点</span></span><br><span class="line">            x.parent = x.prev = xp; <span class="comment">// 这个新的树节点的父节点、前节点均设置为 当前的树节点</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>) <span class="comment">// 如果原来的next节点不为空</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x; <span class="comment">// 那么原来的next节点的前节点指向到新的树节点</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));<span class="comment">// 重新平衡，以及新的根节点置顶</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回空，意味着产生了一个新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="balanceInsertion-树的平衡-方法"><a href="#balanceInsertion-树的平衡-方法" class="headerlink" title="balanceInsertion(树的平衡)方法"></a>balanceInsertion(树的平衡)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">红黑树插入节点后，需要重新平衡</span><br><span class="line"> root 当前根节点</span><br><span class="line"> x 新插入的节点</span><br><span class="line"> 返回重新平衡后的根节点</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>; <span class="comment">// 新插入的节点标为红色</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这一步即定义了变量，又开起了循环，循环没有控制条件，只能从内部跳出</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点、xpp：爷爷节点、xppl：左叔叔节点、xppr：右叔叔节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// L1</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 父节点不为空</span></span><br><span class="line">        <span class="comment">// 如果父节点为黑色 或者 【（父节点为红色 但是 爷爷节点为空） -&gt; 这种情况何时出现？】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) <span class="comment">// L2</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">// 如果父节点是爷爷节点的左孩子  // L3</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">// 如果右叔叔不为空 并且 为红色  // L3_1</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>; <span class="comment">// 右叔叔置为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 运行到这里之后，就又会进行下一轮的循环了，将爷爷节点当做处理的起始节点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果右叔叔为空 或者 为黑色 // L3_2</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">// 如果当前节点是父节点的右孩子 // L3_2_1</span></span><br><span class="line">                    root = rotateLeft(root, x = xp); <span class="comment">// 父节点左旋，见下文左旋方法解析</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// 获取爷爷节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果父节点不为空 // L3_2_2</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点 置为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; <span class="comment">// 爷爷节点不为空</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为 红色</span></span><br><span class="line">                        root = rotateRight(root, xpp);  <span class="comment">//爷爷节点右旋，见下文右旋方法解析</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果父节点是爷爷节点的右孩子 // L4</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123; <span class="comment">// 如果左叔叔是红色 // L4_1</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>; <span class="comment">// 左叔叔置为 黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 运行到这里之后，就又会进行下一轮的循环了，将爷爷节点当做处理的起始节点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果左叔叔为空或者是黑色 // L4_2</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">// 如果当前节点是个左孩子 // L4_2_1</span></span><br><span class="line">                    root = rotateRight(root, x = xp); <span class="comment">// 针对父节点做右旋，见下文右旋方法解析</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// 获取爷爷节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果父节点不为空 // L4_2_4</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; <span class="comment">//如果爷爷节点不为空</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为红色</span></span><br><span class="line">                        root = rotateLeft(root, xpp); <span class="comment">// 针对爷爷节点做左旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点左旋</span></span><br><span class="line"><span class="comment"> * root 根节点</span></span><br><span class="line"><span class="comment"> * p 要左旋的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123; <span class="comment">// 要左旋的节点以及要左旋的节点的右孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>) <span class="comment">// 要左旋的节点的右孩子的左节点 赋给 要左旋的节点的右孩子 节点为：rl</span></span><br><span class="line">            rl.parent = p; <span class="comment">// 设置rl和要左旋的节点的父子关系【之前只是爹认了孩子，孩子还没有答应，这一步孩子也认了爹】</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要左旋的节点的右孩子的父节点  指向 要左旋的节点的父节点，相当于右孩子提升了一层，</span></span><br><span class="line">        <span class="comment">// 此时如果父节点为空， 说明r 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>) </span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) <span class="comment">// 如果父节点不为空 并且 要左旋的节点是个左孩子</span></span><br><span class="line">            pp.left = r; <span class="comment">// 设置r和父节点的父子关系【之前只是孩子认了爹，爹还没有答应，这一步爹也认了孩子】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 要左旋的节点是个右孩子</span></span><br><span class="line">            pp.right = r; </span><br><span class="line">        r.left = p; <span class="comment">// 要左旋的节点  作为 他的右孩子的左节点</span></span><br><span class="line">        p.parent = r; <span class="comment">// 要左旋的节点的右孩子  作为  他的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点右旋</span></span><br><span class="line"><span class="comment"> * root 根节点</span></span><br><span class="line"><span class="comment"> * p 要右旋的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123; <span class="comment">// 要右旋的节点不为空以及要右旋的节点的左孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>) <span class="comment">// 要右旋的节点的左孩子的右节点 赋给 要右旋节点的左孩子 节点为：lr</span></span><br><span class="line">            lr.parent = p; <span class="comment">// 设置lr和要右旋的节点的父子关系【之前只是爹认了孩子，孩子还没有答应，这一步孩子也认了爹】</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要右旋的节点的左孩子的父节点  指向 要右旋的节点的父节点，相当于左孩子提升了一层，</span></span><br><span class="line">        <span class="comment">// 此时如果父节点为空， 说明l 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>) </span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p) <span class="comment">// 如果父节点不为空 并且 要右旋的节点是个右孩子</span></span><br><span class="line">            pp.right = l; <span class="comment">// 设置l和父节点的父子关系【之前只是孩子认了爹，爹还没有答应，这一步爹也认了孩子】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 要右旋的节点是个左孩子</span></span><br><span class="line">            pp.left = l; <span class="comment">// 同上</span></span><br><span class="line">        l.right = p; <span class="comment">// 要右旋的节点 作为 他左孩子的右节点</span></span><br><span class="line">        p.parent = l; <span class="comment">// 要右旋的节点的父节点 指向 他的左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>​     ConcurrentHashMap是Java并发包中提供的一个<strong>线程安全且高效</strong>的HashMap实现。<strong>==ConcurrentHashMap不允许key或value为null值==。</strong></p>
<h3 id="2-为什么HashMap用于多线程会出错？："><a href="#2-为什么HashMap用于多线程会出错？：" class="headerlink" title="2.为什么HashMap用于多线程会出错？："></a>2.为什么HashMap用于多线程会出错？：</h3><p>​             JDK1.7 的 HashMap在高并发环境下会形成<strong>环状链表</strong>，导致get操作时，进入死循环，所以，在并发环境中使用HashMap是非常危险的。</p>
<h3 id="3-为什么不用Hashtable？"><a href="#3-为什么不用Hashtable？" class="headerlink" title="3.为什么不用Hashtable？"></a>3.为什么不用Hashtable？</h3><p>​       HashTable线程安全的策略实现代价却太大了，简单粗暴，<strong>get/put</strong>所有相关操作都是synchronized<strong>的</strong>，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并<strong>发场景中性能就会非常差</strong>。</p>
<h3 id="4、ConcurrentHashMap-java7-中的实现方式"><a href="#4、ConcurrentHashMap-java7-中的实现方式" class="headerlink" title="4、ConcurrentHashMap java7 中的实现方式"></a>4、ConcurrentHashMap java7 中的实现方式</h3><p><img src="images/1.png" alt=""></p>
<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的==”分段锁”==思想。</p>
<h4 id="4-1-java7中的优缺点"><a href="#4-1-java7中的优缺点" class="headerlink" title="4.1 java7中的优缺点"></a>4.1 java7中的优缺点</h4><p>​    ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个==Segment==数组。每个段其实==就是一个小的Hashtable==，它们有自己的锁。==只要多个修改操作发生在不同的段上，它们就可以并发进行。（JDK7中是这样实现的）==</p>
<p>​    ==但是！！！==有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁.</p>
<p>​    所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</p>
<h3 id="ConcurrentHashMap-java8-中的实现"><a href="#ConcurrentHashMap-java8-中的实现" class="headerlink" title="ConcurrentHashMap java8 中的实现"></a>ConcurrentHashMap java8 中的实现</h3><h4 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h4><p>​    JDK8：ConcurrentHashMap在JDK8中进行了巨大改动，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用==CAS==算法。</p>
<h4 id="2、什么是volatille关键字？"><a href="#2、什么是volatille关键字？" class="headerlink" title="2、什么是volatille关键字？"></a>2、什么是volatille关键字？</h4><p>volatile是一种轻量级的同步机制，它主要有两个特性：</p>
<p>一是保证共享变量对所有线程的可见性；（==内存可见性==）</p>
<p>二是禁止指令重排序优化。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像<strong>num++这种复合操作（读写存）</strong>，volatile无法保证其原子性。</p>
<h4 id="3、重要属性"><a href="#3、重要属性" class="headerlink" title="==3、重要属性=="></a>==3、重要属性==</h4><h5 id="3-1-sizeCtl"><a href="#3-1-sizeCtl" class="headerlink" title="3.1 sizeCtl"></a>3.1 sizeCtl</h5><p>​    可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个==控制标识符==，在不同的地方有不同用途，而且它的<strong>取值不同，也代表不同的含义</strong>。</p>
<ul>
<li><strong>负数代表正在进行初始化或扩容操作</strong>         </li>
<li><strong>-1代表正在初始化</strong></li>
<li><strong>-N 表示有N-1个线程正在进行扩容操作</strong></li>
<li><strong>正数或0代表hash表还没有被初始化，</strong>这个数值表示初始化或下一次进行扩容的大小，==这一点类似于扩容阈值的概念==。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的</li>
</ul>
<h5 id="3-2初始化数组-initTable"><a href="#3-2初始化数组-initTable" class="headerlink" title="3.2初始化数组 initTable"></a>3.2初始化数组 initTable</h5><p>​    初始化方法主要应用了关键属性sizeCtl 如果这个值〈<strong>0，表示其他线程正在进行初始化，就放弃这个操作。</strong>在这也可以<strong>看出</strong>ConcurrentHashMap的==初始化只能由一个线程完成==。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p>
<h5 id="3-3-核心内容"><a href="#3-3-核心内容" class="headerlink" title="3.3 核心内容"></a>3.3 核心内容</h5><ul>
<li>forword （(transfer)扩容时标记，碰到这个标记直接跳过），==类似于大家一起搭积木==</li>
<li>Moved （在put时候碰到Moved ，则帮助其扩容 helptransfer）</li>
<li>sizeCtl</li>
<li>CAS</li>
<li>Volatile（val 和 next 都用了）</li>
<li>以上五点保证了 ConcurrentHashMap 的高并发情况下的线程安全问题</li>
<li>java7中只有1000多行代码，而在Java8中重新编写了现在有6000多行代码</li>
</ul>
<h4 id="PUT流程："><a href="#PUT流程：" class="headerlink" title="==PUT流程：=="></a>==PUT流程：==</h4><ul>
<li><strong>1、判断是否初始化过，没有则进行初始化。</strong></li>
<li><strong>2、通过Hash定位到数组的索引坐标，判断是否有Node 节点，</strong><ul>
<li><strong>如果没有则使用 CAS 进行添加，添加失败进入下次循环</strong></li>
</ul>
</li>
<li><strong>3、检查到内部在扩容，就帮助他一块扩容（Moved ）</strong></li>
<li><strong>4、如果 Node 节点存在，则使用 synchronized 锁住头结点，</strong><ul>
<li><strong>如果是链表结构就进行链表的添加操作</strong><ul>
<li><strong>如果是红黑树结构就进行红黑树的添加操作</strong></li>
<li><strong>5、判断链表的长度是否大于 8，如果大于就去转为树结构</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j</title>
    <url>/undefined/Log4j/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>log4j配置文件基本格式：</p>
</blockquote>
<pre><code>#配置根Logger
log4j.rootLogger  =   [ level ]   ,  appenderName1 ,  appenderName2 ,  …

#配置日志信息输出目的地Appender
log4j.appender.appenderName  =  fully.qualified.name.of.appender.class 
　　log4j.appender.appenderName.option1  =  value1 
　　… 
　　log4j.appender.appenderName.optionN  =  valueN 

#配置日志信息的格式（布局）
log4j.appender.appenderName.layout  =  fully.qualified.name.of.layout.class 
　　log4j.appender.appenderName.layout.option1  =  value1 
　　… 
　　log4j.appender.appenderName.layout.optionN  =  valueN 
　　
</code></pre><blockquote>
<blockquote>
<p>注意：[level] 是日志输出级别，共有5级：</p>
</blockquote>
</blockquote>
<pre><code>FATAL - 0  

ERROR - 3 表示严重错误，主要是程序的错误。

WARN - 4 表示一般的警告，如session丢失。

INFO - 6 表示一般要显示的信息，如登录登出信息。

DEBUG - 7 表示程序的调试信息 
</code></pre><blockquote>
<blockquote>
<p>Appender：为日志输出目的地，Log4j提供的appender有以下几种：</p>
</blockquote>
</blockquote>
<pre><code>org.apache.log4j.ConsoleAppender（控制台），

org.apache.log4j.FileAppender（文件），

org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），

org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），

org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre><blockquote>
<blockquote>
<p>Layout：日志输出格式，Log4j提供的layout有以下几种：</p>
</blockquote>
</blockquote>
<pre><code>org.apache.log4j.HTMLLayout（以HTML表格形式布局），

org.apache.log4j.PatternLayout（可以灵活地指定布局模式），

org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），

org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</code></pre><blockquote>
<blockquote>
<p>打印参数: Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，如下:</p>
</blockquote>
</blockquote>
<pre><code>%m   输出代码中指定的消息
</code></pre><p>　　%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL<br>　　%r   输出自应用启动到输出该log信息耗费的毫秒数<br>　　%c   输出所属的类目，通常就是所在类的全名<br>　　%t   输出产生该日志事件的线程名<br>　　%n   输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n”<br>　　%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921<br>　　%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 
　　</p>
<blockquote>
<blockquote>
<p>配置文件：</p>
</blockquote>
</blockquote>
<pre><code>### set log levels ###
log4j.rootLogger = debug ,  stdout ,  D ,  E

### 输出到控制台 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n

### 输出到日志文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = logs/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 保存异常信息到单独文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = logs/error.log ## 异常日志文件名
log4j.appender.D.Append = true
log4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><blockquote>
<blockquote>
<p>控制台选项</p>
</blockquote>
</blockquote>
<pre><code>Threshold=DEBUG:指定日志消息的输出最低层次。

ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。

Target=System.err：默认情况下是：System.out,指定输出控制台

FileAppender 选项

    Threshold=DEBUF:指定日志消息的输出最低层次。

    ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。

    File=mylog.txt:指定消息输出到mylog.txt文件。

    Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。

RollingFileAppender 选项

    Threshold=DEBUG:指定日志消息的输出最低层次。

    ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。

    File=mylog.txt:指定消息输出到mylog.txt文件。

    Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。

    MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。

    MaxBackupIndex=2:指定可以产生的滚动文件的最大数。
</code></pre>]]></content>
      <categories>
        <category>Log4j</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>Logback</title>
    <url>/undefined/Logback/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Logback日志配置"><a href="#Logback日志配置" class="headerlink" title="Logback日志配置"></a>Logback日志配置</h2><p>程序中的日志的目的主要分为两个：1.做故障测试，在程序调试环节中起到非常重要的作用。2.显示程序运行状态。</p>
<h4 id="Logback主要模块"><a href="#Logback主要模块" class="headerlink" title="Logback主要模块"></a>Logback主要模块</h4><pre><code>1.logback-access 该模块与server容器集成，提供通过http来访问日志的功能，表示第三方软件可以通过logback这个日志工具来访问到记录日志。

2.logback-classic 该模块是log4j 

3.logback-core 该模块为前两个模块提供基础的服务。
</code></pre><h4 id="logback主要标签"><a href="#logback主要标签" class="headerlink" title="logback主要标签"></a>logback主要标签</h4><pre><code>1.logger 作为日志的记录器，存放日志对象、定义日志的类型以及日志的级别等。

2.appender 指定日志输出的目的地 这里的媒介可以是控制台、文件、远程套接字容器等。

3.layout 用来格式化日志信息输出
</code></pre>]]></content>
      <categories>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/undefined/Maven/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="一、什么是Maven"><a href="#一、什么是Maven" class="headerlink" title="一、什么是Maven"></a>一、什么是Maven</h2><p><strong>1、 Maven是一款服务于Java平台的自动化构建工具</strong>。</p>
<p>​     发展历史： Make -&gt; Ant -&gt; Maven -&gt; Gradle</p>
<p>​    项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。</p>
<h2 id="二、为什么要使用Maven"><a href="#二、为什么要使用Maven" class="headerlink" title="二、为什么要使用Maven"></a>二、为什么要使用Maven</h2><h3 id="2-1-不使用Maven开发存在的问题"><a href="#2-1-不使用Maven开发存在的问题" class="headerlink" title="2.1 不使用Maven开发存在的问题"></a>2.1 不使用Maven开发存在的问题</h3><ol>
<li>一个项目就是一个工程</li>
<li>项目中需要的jar包必须手动“复制”、”粘贴” 到WEB-INF/lib 项目下</li>
<li>项目中所需要的jar包都是必须是提前下载好的</li>
<li>项目中一个jar包所依赖的其他jar包必须手动导进来</li>
</ol>
<h3 id="2-2-Maven-的优点"><a href="#2-2-Maven-的优点" class="headerlink" title="2.2 Maven 的优点"></a>2.2 Maven 的优点</h3><p>1、原来的项目中需要的jar包必须手动“复制”、”粘贴” 到WEB-INF/lib 项目下，而<strong>借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程只需要“引用”这个文件，并不需要重复复制到工程中。</strong><br>2、原来的项目中所需要的jar包都是提前下载好的，而Maven在<strong>联网状态下会自动下载所需要的jar包</strong>。首<strong>先在本地仓库中找，找不到就在网上进行下载。</strong><br>3、原来的项目中一个jar包所依赖的其他jar包必须手动导进来，<strong>而Maven会自动将被依赖的jar包导进来。</strong><br>4、原来的项目一个项目就是一个工程，而<strong>借助Maven可以将一个项目拆分成多个工程。</strong></p>
<h2 id="三、Maven-构建过程的环节"><a href="#三、Maven-构建过程的环节" class="headerlink" title="三、Maven 构建过程的环节"></a>三、Maven 构建过程的环节</h2><p>1、清理：将以前的编译得到的旧的class字节码文件删除</p>
<p>2、编译：将Java源程序编译为class字节码文件</p>
<p>3、测试：自动测试，自动调用 junit 程序</p>
<p>4、报告：测试程序执行的结果</p>
<p>5、打包：动态web工程打 war 包， Java工程打 jar 包</p>
<p>6、安装：Maven特定的概念——将打包得到的文件复制到 “仓库” 中指定的位置</p>
<p>7、部署：将动态生成的 war 包复制到 Servlet 容器指定的目录下，使其可以正常运行</p>
<h2 id="四、Maven-的核心概念"><a href="#四、Maven-的核心概念" class="headerlink" title="四、Maven 的核心概念"></a>四、Maven 的核心概念</h2><h3 id="4-1-约定的目录概念（一般）"><a href="#4-1-约定的目录概念（一般）" class="headerlink" title="4.1 约定的目录概念（一般）"></a>4.1 约定的目录概念（一般）</h3><h4 id="4-1-1-约定的目录结构："><a href="#4-1-1-约定的目录结构：" class="headerlink" title="4.1.1 约定的目录结构："></a>4.1.1 约定的目录结构：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] 根目录：工程名</span><br><span class="line">[2] src目录：源码</span><br><span class="line">[3] pom.xml 文件： Maven 工程的核心配置文件</span><br><span class="line">[4] main 目录： 存放主程序 </span><br><span class="line">[5] test 目录： 存放测试程序</span><br><span class="line">[6] java 目录： 存放Java 源文件</span><br><span class="line">[7] resources 目录： 存放框架或者其他工具的配置文件</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-为什么要使用约定的目录文件："><a href="#4-1-2-为什么要使用约定的目录文件：" class="headerlink" title="4.1.2 为什么要使用约定的目录文件："></a>4.1.2 为什么要使用约定的目录文件：</h4><ul>
<li>Maven 要负责我们这个项目的自动化构建，以编译为例，Maven 想要自动进行构建，那么他必须知道Java的源文件保存在哪里</li>
<li>如果想要我们自定义的东西被框架或者是工具知道。（配置文件）</li>
</ul>
<h3 id="4-2-POM（一般）"><a href="#4-2-POM（一般）" class="headerlink" title="4.2 POM（一般）"></a>4.2 POM（一般）</h3><p>​    含义：Project Object Model 项目对象模型</p>
<p>​    POM.xml 是 Maven 工程的核心配置文件，与构建过程相关的一切设置都在这个文件之中进行配置。重要程度相当于 web.xml 对于动态web工程。</p>
<h3 id="4-3-坐标（一般）"><a href="#4-3-坐标（一般）" class="headerlink" title="4.3 坐标（一般）"></a>4.3 坐标（一般）</h3><h4 id="​-4-3-1-数学中的坐标："><a href="#​-4-3-1-数学中的坐标：" class="headerlink" title="​    4.3.1 数学中的坐标："></a>​    4.3.1 数学中的坐标：</h4><p>​        [1] 在平面或者空间上 使用 x，y，z，来确定平面或者空间之中的任何一个点。</p>
<h4 id="​-4-3-2-Maven-中的坐标："><a href="#​-4-3-2-Maven-中的坐标：" class="headerlink" title="​    4.3.2 Maven 中的坐标："></a>​    4.3.2 Maven 中的坐标：</h4><p>​        使用下面三个向量在仓库之中唯一定位一个Maven工程。</p>
<h5 id="（-G-）groupid-公司或者组织域名倒序-项目名"><a href="#（-G-）groupid-公司或者组织域名倒序-项目名" class="headerlink" title="（==G==）groupid:公司或者组织域名倒序 + 项目名"></a>（==G==）groupid:公司或者组织域名倒序 + 项目名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br></pre></td></tr></table></figure>
<h5 id="​-（-A-）artifactid-模块名"><a href="#​-（-A-）artifactid-模块名" class="headerlink" title="​        （==A==）artifactid: 模块名"></a>​        （==A==）artifactid: 模块名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br></pre></td></tr></table></figure>
<h5 id="​-（-V-）version-版本信息"><a href="#​-（-V-）version-版本信息" class="headerlink" title="​        （==V==）version: 版本信息"></a>​        （==V==）version: 版本信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">文件路径：</span><br><span class="line">org\springframework\spring-web\5.0.8.RELEASE\spring-web-5.0.8.RELEASE.jar</span><br></pre></td></tr></table></figure>
<h3 id="4-4-依赖（重要）"><a href="#4-4-依赖（重要）" class="headerlink" title="4.4 依赖（重要）"></a>4.4 依赖（重要）</h3><h4 id="4-4-1-依赖解析："><a href="#4-4-1-依赖解析：" class="headerlink" title="4.4.1 依赖解析："></a>4.4.1 依赖解析：</h4><p>​        Maven 解析依赖信息时，会到本地仓库之中查找被依赖的jar包。</p>
<p>​        对于我们自己开发的 Maven 工程，使用 ==<strong>mvn install </strong>== 命令安装之后就可以进入仓库。</p>
<h4 id="4-4-2-依赖的范围："><a href="#4-4-2-依赖的范围：" class="headerlink" title="4.4.2 依赖的范围："></a>4.4.2 依赖的范围：</h4><ul>
<li><p><strong>compile</strong></p>
<ul>
<li>对主程序是否有效： 有效</li>
<li>对测试程序是否有效： 有效</li>
<li>是否参与打包： 参与</li>
</ul>
</li>
<li><p><strong>test</strong></p>
<ul>
<li>对主程序是否有效： 无效<ul>
<li>对测试程序是否有效：  有效</li>
<li>是否参与打包： 不参与</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>provided</strong></p>
<ul>
<li>对主程序是否有效：  有效<ul>
<li>对测试程序是否有效：  有效</li>
<li>是否参与打包： 不参与</li>
<li>是否参与部署： 不参与<h4 id="4-4-3-依赖的传递性"><a href="#4-4-3-依赖的传递性" class="headerlink" title="4.4.3 依赖的传递性"></a>4.4.3 依赖的传递性</h4></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    【1】好处：可以传递的依赖不必在每个工程模块之中都重复声明。只需要在‘最下面“声明一次即可。 </p>
<p>​    【2】注意：<strong>非 compile 范围的依赖无法传递。</strong></p>
<h4 id="4-4-4-依赖的排除"><a href="#4-4-4-依赖的排除" class="headerlink" title="4.4.4 依赖的排除"></a>4.4.4 依赖的排除</h4><p>​    【1】 需要依赖排除的场合</p>
<p>​        不稳定的jar包，不想让他加入到工程之中。</p>
<p>​    【2】如何排除(以排除AAAA为例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;exclusions&gt;</span><br><span class="line">	&lt;exclusion&gt;</span><br><span class="line">		&lt;groupId&gt;AAAAAAAAA&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;AAAAA&lt;/artifactId&gt;</span><br><span class="line">	&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-5-依赖的原则："><a href="#4-4-5-依赖的原则：" class="headerlink" title="4.4.5 依赖的原则："></a>4.4.5 依赖的原则：</h4><p>​    【1】 路径最短者优先</p>
<p>​    【2】 路径相同者先声明者优先</p>
<h4 id="4-4-6-统一管理依赖的版本"><a href="#4-4-6-统一管理依赖的版本" class="headerlink" title="4.4.6 统一管理依赖的版本"></a>4.4.6 统一管理依赖的版本</h4><p>​    假设Spring 的 jar 包的依赖版本都是 4.0.0， 此时想要统一升级成为 4.1.1 怎么办？</p>
<p>​    【1】 手动逐一修改，不可靠</p>
<p>​    【2】 建议配置方式：</p>
<p>​        i：使用 properties 标签统一声明版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-仓库（了解）"><a href="#4-5-仓库（了解）" class="headerlink" title="4.5 仓库（了解）"></a>4.5 仓库（了解）</h3><p>​    Maven 仓库分为：</p>
<ul>
<li>本地仓库<ul>
<li>当前电脑上部署的仓库目录，为当前电脑上的所有Maven工程服务</li>
</ul>
</li>
<li>远程仓库<ul>
<li>私服：搭建在局域网上面的Maven仓库，为当前局域网范围内的所有 Maven 工程服务。</li>
<li>中央仓库：架设在 Internet 之中，为全世界的 Maven 工程服务。</li>
<li>中央仓库镜像： 为了分担中央仓库的流量，提升用户访问速度。<ul>
<li>仓库之中保存了什么？</li>
</ul>
</li>
</ul>
</li>
<li>Maven 自身需要的插件</li>
<li>第三方工具或者工具的jar包</li>
<li>我们自己开发的Maven工程</li>
</ul>
<h3 id="4-6-生命周期-插件-目标（了解）"><a href="#4-6-生命周期-插件-目标（了解）" class="headerlink" title="4.6 生命周期/插件/目标（了解）"></a>4.6 生命周期/插件/目标（了解）</h3><h3 id="4-7-继承（了解）"><a href="#4-7-继承（了解）" class="headerlink" title="4.7 继承（了解）"></a>4.7 继承（了解）</h3><h3 id="4-8-聚合（了解）"><a href="#4-8-聚合（了解）" class="headerlink" title="4.8 聚合（了解）"></a>4.8 聚合（了解）</h3><h2 id="五、Maven-常用命令："><a href="#五、Maven-常用命令：" class="headerlink" title="五、Maven 常用命令："></a>五、Maven 常用命令：</h2><h3 id="5-1-命令使用范围："><a href="#5-1-命令使用范围：" class="headerlink" title="5.1 命令使用范围："></a>5.1 命令使用范围：</h3><p><strong>执行与构建相关的 Maven 命令，必须进入 pom.xml 所在的目录。</strong></p>
<h3 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="==5.2 常用命令=="></a>==5.2 常用命令==</h3><h4 id="1-mvn-clean：-清理"><a href="#1-mvn-clean：-清理" class="headerlink" title="1. mvn clean： 清理"></a>1. mvn clean： 清理</h4><h4 id="2-mvn-compile-：-编译主程序"><a href="#2-mvn-compile-：-编译主程序" class="headerlink" title="2. mvn compile ： 编译主程序"></a>2. mvn compile ： 编译主程序</h4><h4 id="3-mvn-test-compile-：编译测试程序"><a href="#3-mvn-test-compile-：编译测试程序" class="headerlink" title="3.mvn test-compile ：编译测试程序"></a>3.mvn test-compile ：编译测试程序</h4><h4 id="4-mvn-test-：-执行测试"><a href="#4-mvn-test-：-执行测试" class="headerlink" title="4. mvn test ： 执行测试"></a>4. mvn test ： 执行测试</h4><h4 id="5-mvn-package：-打包"><a href="#5-mvn-package：-打包" class="headerlink" title="5. mvn package： 打包"></a>5. mvn package： 打包</h4><h4 id="6-mvn-install-：将自己的-jar-包加入到本地仓库之中"><a href="#6-mvn-install-：将自己的-jar-包加入到本地仓库之中" class="headerlink" title="6. mvn install ：将自己的 jar 包加入到本地仓库之中"></a>6. mvn install ：将自己的 jar 包加入到本地仓库之中</h4><h2 id="六、Maven-生命周期："><a href="#六、Maven-生命周期：" class="headerlink" title="六、Maven 生命周期："></a>六、Maven 生命周期：</h2><p>​    1、各个构建环节的顺序：不能打乱顺序，必须按照既定的正确顺序来执行。</p>
<p>​    2、Maven 的核心程序定义了抽象的生命周期，生命周期的各个阶段的具体任务是由插件来完成的。</p>
<p>​    3、Maven 的核心程序为了更好地实现自动化构建，按照这一特点执行生命周期之中的各个阶段，不论要执行那个阶段，<strong>都是从这个生命周期的最初的位置开始执行的</strong>。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 框架</title>
    <url>/undefined/MyBatis%20%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="MyBatis-框架"><a href="#MyBatis-框架" class="headerlink" title="MyBatis 框架"></a>MyBatis 框架</h2><p><strong>1.执行流程</strong><br></p>
<pre><code>1.配置sqlMapConfig.xml(mybatis全局配置文件)：配置数据源、事务等mybatis运行环境(后面直接交给spring)。

2.配置映射文件：mapper.xml

3.sqlSessionFactory(会话工厂)：根据配置文件创建sqlSession。

4.sqlSession(会话)：面向用户的接口，根据会话工厂创建。作用是操作数据库。

5.Excutor(执行器)：作用是sqlSession内部通过该执行器操作数据。

6.mappedStatement(底层封装对象)：作用是对操作数据库存储对象，包括sql语句、输入参数、输出结果类型。
</code></pre>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis缓存机制</title>
    <url>/undefined/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="MyBatis缓存机制"><a href="#MyBatis缓存机制" class="headerlink" title="MyBatis缓存机制"></a>MyBatis缓存机制</h2><p>[TOC]</p>
<h3 id="MyBatis的缓存机制以及流程"><a href="#MyBatis的缓存机制以及流程" class="headerlink" title="MyBatis的缓存机制以及流程"></a>MyBatis的缓存机制以及流程</h3><p>mybatis提供了<strong>缓存机制减轻数据库压力，提高数据库性能</strong></p>
<p>mybatis的缓存分为两级：==一级缓存、二级缓存==</p>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是<strong>SqlSession级别</strong>的缓存，缓存的数据只在SqlSession内有效</p>
<p>在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个<strong>HashMap用于存储缓存数据</strong>，此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问,<strong>每一个 session 会话都会有各自的缓存，这缓存是局部的，也就是所谓的一级缓存</strong></p>
<p>每个SqlSession中持有了<a href="https://www.baidu.com/s?wd=Executor&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">Executor</a>，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<strong>MappedStatement</strong>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache</p>
<p><strong>配置：</strong></p>
<p>开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，SESSION或者STATEMENT，默认是SESSION级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是STATEMENT级别，可以理解为缓存只对当前执行的这一个Statement有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;setting name=<span class="string">"localCacheScope"</span> value=<span class="string">"SESSION"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>具体流程：</strong></p>
<p>　　　　1.第一次执行select完毕会将查到的数据写入SqlSession内的HashMap中缓存起来</p>
<p>　　　　2.第二次执行select会从缓存中查数据，如果select相同切传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率‘</p>
<p><strong>源码</strong></p>
<ul>
<li><p>首先需要初始化SqlSession，通过<strong>DefaultSqlSessionFactory开启SqlSession</strong>    </p>
</li>
<li><p>SqlSession创建完毕后，根据Statment的不同类型，会进入SqlSession的不同方法中，如果是Select语句的话，最后会执行到SqlSession的selectList</p>
</li>
<li>SqlSession把具体的查询职责委托给了Executor。如果只开启了一级缓存的话，首先会进入BaseExecutor的query方法</li>
<li>在query方法执行的最后，会判断一级缓存级别是否是STATEMENT级别，如果是的话，就清空缓存，这也就是STATEMENT级别的一级缓存无法共享localCache的原因</li>
<li>SqlSession的insert方法和delete方法，都会统一走update的流程</li>
<li>每次执行update前都会清空localCache</li>
</ul>
<p>==BaseExecutor==： BaseExecutor是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;<span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;<span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>在一级缓存的介绍中提到<strong>对Local Cache的查询和写入是在Executor内部完成</strong>的。在阅读BaseExecutor的代码后发现<strong>Local Cache是BaseExecutor内部的一个成员变量</strong>，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;<span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localCache;</span><br></pre></td></tr></table></figure>
<p> ==Cache==： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作</p>
<p>BaseExecutor成员变量之一的==PerpetualCache，是对Cache接口最基本的实现==，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作</p>
<p><strong>注意事项：</strong></p>
<p>　　　　1.如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读</p>
<p>　　　　2.当一个SqlSession结束后那么他里面的一级缓存也就不存在了，mybatis默认是开启一级缓存，不需要配置t</p>
<p>　　　　3.mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用<strong>[namespace:sql:参数]</strong>作为key，<strong>查询返回的语句作为value</strong>保存的</p>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是<strong>mapper级别</strong>的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的</p>
<p>就是同一个namespace的mappe.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区,  如果两个mapper的namespace相同，即使是两个mapper，那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域中</p>
<p>　　<strong>1.</strong>二级缓存默认是没有开启的。需要在setting全局参数中配置开启二级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;setting name=<span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong>在MyBatis的映射XML中配置cache或者 cache-ref 。</p>
<p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>type：cache使用的类型，默认是<strong>PerpetualCache</strong>，这在一级缓存中提到过</li>
<li>eviction： 定义回收的策略，常见的有FIFO，LRU。</li>
<li>flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。</li>
<li>size： 最多缓存对象的个数。</li>
<li>readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li>
<li>blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li>
</ul>
<p>cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;cache-ref namespace=<span class="string">"mapper.StudentMapper"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>在userMapper.xml中配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;cache eviction=<span class="string">"LRU"</span> flushInterval=<span class="string">"60000"</span> size=<span class="string">"512"</span> readOnly=<span class="string">"true"</span>/&gt;当前mapper下所有语句开启二级缓存</span><br></pre></td></tr></table></figure>
<p>　　这里配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的</p>
<p>　　若想禁用当前select语句的二级缓存，添加<strong>useCache=”false”</strong>修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"getCountByName"</span> parameterType=<span class="string">"java.util.Map"</span> resultType=<span class="string">"INTEGER"</span> statementType=<span class="string">"CALLABLE"</span> useCache=<span class="string">"false"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>当开启缓存后，数据的查询执行的流程就是 <strong>二级缓存 -&gt; 一级缓存 -&gt; 数据库</strong></p>
<p>开启二级缓存后，会使用==CachingExecutor==装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示</p>
<p><img src="E:\java\笔记\spring源码解析\images\16.png" alt=""></p>
<p><img src="E:\java\笔记\spring源码解析\images\11.png" alt=""></p>
<p><img src="E:\java\笔记\spring源码解析\images\12.png" alt=""></p>
<p><strong>具体流程：</strong></p>
<p>　　　　1.当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存</p>
<p>　　　　2.当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能　</p>
<ul>
<li><p>CachingExecutor的query方法，首先会从MappedStatement中获得在配置初始化时赋予的Cache</p>
</li>
<li><p>然后是判断是否需要刷新缓存，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure>
<p>在默认的设置中SELECT语句不会刷新缓存，insert/update/delte会刷新缓存。进入该方法。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();   </span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyBatis的CachingExecutor持有了<strong>TransactionalCacheManager</strong>，即上述代码中的tcm。</p>
</li>
</ul>
<p>  TransactionalCacheManager中持有了一个Map，代码如下所示：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;Cache, TransactionalCache&gt;();</span><br></pre></td></tr></table></figure>
<p>  这个Map保存了Cache和用TransactionalCache包装后的Cache的映射关系。</p>
<p>  TransactionalCache实现了Cache接口，CachingExecutor会默认使用他包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。</p>
<p>  在TransactionalCache的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  CachingExecutor继续往下走，ensureNoOutParams主要是用来处理存储过程的，暂时不用考虑。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ensureNoOutParams(ms, parameterObject, boundSql);</span><br></pre></td></tr></table></figure>
<p>  之后会尝试从tcm中获取缓存的列表。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure>
<p>  在getObject方法中，会把获取值的职责一路传递，最终到PerpetualCache。如果没有查到，会把key加入Map集合，这个主要是为了统计命中率。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = delegate.getObject(key);<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entriesMissedInCache.add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  CachingExecutor继续往下走，如果查询到数据，则调用tcm.putObject方法，往缓存中放入值。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">    list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116&#125;</span></span><br></pre></td></tr></table></figure>
<p>  tcm的put方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从以上的代码分析中，我们可以明白，如果不调用commit方法的话，由于TranscationalCache的作用，并不会对二级缓存造成直接的影响。因此我们看看Sqlsession的commit方法中做了什么。代码如下所示：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br></pre></td></tr></table></figure>
<p>  因为我们使用了CachingExecutor，首先会进入CachingExecutor实现的<strong>commit</strong>方法。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  会把具体commit的职责委托给包装的Executor。主要是看下tcm.commit()，tcm最终又会调用到TrancationalCache。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  看到这里的clearOnCommit就想起刚才TrancationalCache的clear方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入flushPendingEntries方法。代码如下所示：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    ................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在flushPendingEntries中，将待提交的Map进行循环处理，委托给包装的Cache类，进行putObject的操作。</p>
<p>  后续的查询操作会重复执行这套流程。如果是insert|update|delete的话，会统一进入CachingExecutor的update方法，其中调用了这个函数，代码如下所示：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>useCache和flushCache</strong></p>
<p>　　mybatis中还可以配置userCache和flushCache等配置项，userCache是用来设置<strong>是否禁用二级缓存</strong>的，在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">`&lt;select id=``"selectUserByUserId"` `useCache=``"false"` `resultType=``"com.ys.twocache.User"` `parameterType=``"int"``&gt;``    ``select * from user where id=#&#123;id&#125;``&lt;/select&gt;`</span><br></pre></td></tr></table></figure>
<p>　　这种情况是针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存，直接从数据库中获取。 </p>
<p>　　在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。</p>
<p> 　  设置statement配置中的flushCache=”true” 属性，默认情况下为true，即<strong>刷新缓存</strong>，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">`&lt;select id=``"selectUserByUserId"` `flushCache=``"true"` `useCache=``"false"` `resultType=``"com.ys.twocache.User"` `parameterType=``"int"``&gt;``    ``select * from user where id=#&#123;id&#125;``&lt;/select&gt;`</span><br></pre></td></tr></table></figure>
<p>　　一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读</p>
<p><strong>注意事项：</strong></p>
<p>　　　　1.如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读</p>
<p>　　　　2.mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。</p>
<h3 id="二级缓存整合ehcache"><a href="#二级缓存整合ehcache" class="headerlink" title="二级缓存整合ehcache"></a>二级缓存整合ehcache</h3><p>以上是mybatis自带的二级缓存，但是这个缓存是单服务器工作，无法实现<strong>分布式缓存</strong>。那么什么是分布式缓存呢？假设现在有两个服务器1和2，用户访问的时候访问了1服务器，查询后的缓存就会放在1服务器上，假设现在有个用户访问的是2服务器，那么他在2服务器上就无法获取刚刚那个缓存</p>
<p><img src="E:\java\笔记\spring源码解析\images\17.png" alt=""></p>
<p>在几个不同的服务器之间，我们使用第三方缓存框架，将缓存都放在这个第三方框架中，然后无论有多少台服务器，我们都能从缓存中获取数据,即mybaits和第三方框架ehcache的整合</p>
<p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。mybatis本身默认实现了一个，但是这个缓存的实现无法实现分布式缓存，所以我们要自己来实现。ehcache分布式缓存就可以，mybatis提供了一个针对cache接口的ehcache实现类，这个类在mybatis和ehcache的整合包中。</p>
<p><strong>①、导入 mybatis-ehcache 整合包（最上面的源代码中包含有）</strong></p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170814205927896-1579894274.png" alt="img"></p>
<p><strong>②、在全局配置文件 mybatis-configuration.xml 开启缓存</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">`&lt;!--开启二级缓存  --&gt;``&lt;settings&gt;``    ``&lt;setting name=``"cacheEnabled"` `value=``"true"``/&gt;``&lt;/settings&gt;`</span><br></pre></td></tr></table></figure>
<p><strong>③、在 xxxMapper.xml 文件中整合 ehcache 缓存</strong></p>
<p>将如下的类的全类名写入<cache type=""></cache>的type属性中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">`&lt;!-- 开启本mapper的namespace下的二级缓存``    ``type:指定cache接口的实现类的类型，不写type属性，mybatis默认使用PerpetualCache``    ``要和ehcache整合，需要配置type为ehcache实现cache接口的类型``--&gt;``&lt;cache type=``"org.mybatis.caches.ehcache.EhcacheCache"``&gt;&lt;/cache&gt;`</span><br></pre></td></tr></table></figure>
<p><strong>④、配置缓存参数</strong></p>
<p>在 classpath 目录下新建一个 ehcache.xml 文件，并增加如下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">`&lt;?xml version=``"1.0"` `encoding=``"UTF-8"``?&gt;``&lt;ehcache xmlns:xsi=``"http://www.w3.org/2001/XMLSchema-instance"``    ``xsi:noNamespaceSchemaLocation=``"../config/ehcache.xsd"``&gt;` `    ``&lt;diskStore path=``"F:\develop\ehcache"``/&gt;` `    ``&lt;defaultCache``            ``maxElementsInMemory=``"10000"``            ``eternal=``"false"``            ``timeToIdleSeconds=``"120"``            ``timeToLiveSeconds=``"120"``            ``maxElementsOnDisk=``"10000000"``            ``diskExpiryThreadIntervalSeconds=``"120"``            ``memoryStoreEvictionPolicy=``"LRU"``&gt;``        ``&lt;persistence strategy=``"localTempSwap"``/&gt;``    ``&lt;/defaultCache&gt;``    ` `&lt;/ehcache&gt;`</span><br></pre></td></tr></table></figure>
<p>diskStore：指定数据在磁盘中的存储位置。<br>defaultCache：当借助CacheManager.add(“demoCache”)创建Cache时，EhCache便会采用   <defalutcache>指定的的管理策略<br><strong>以下属性是必须的</strong>：<br>​       maxElementsInMemory - 在内存中缓存的element的最大数目<br>​       maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大<br>​      eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要  根据timeToIdleSeconds，timeToLiveSeconds判断<br>​      overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上<br><strong>以下属性是可选的：</strong><br>​       timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大<br>​       timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大<br>​       diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.<br>​        diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。<br>​        diskExpiryThreadIntervalSeconds - 磁盘缓存的 清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作<br>​       memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</defalutcache></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQ-视图</title>
    <url>/undefined/MySQL%20%E5%91%BD%E4%BB%A4%20%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图 view"></a>视图 view</h2><h4 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h4><p>通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>视图是对于若干张基本表的引用，是一张虚表，查询语句执行的结果，不存储具体的数据，可以进行有限制的增删改查。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>方便操作，最主要的是查询操作，减少复杂的sql语句，增强可读性。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><pre><code>1.分割数据，通过select与where来定义视图，从而可以分割数据基表中某些对于用户不关心的数据，使用户把注意力集中到所关心的数据列.进一步简化浏览数据工作。
2.给数据提供一定的逻辑独立性，如果我们为某一个基表定义一个视图，即使以后基本表的内容的发生改变了也不会影响“视图定义”所得到的数据。
3.视图能像基本表一样授予或撤消访问许可权，给用户是表的一部分访问权限而不是全部。
4.视图可以间接对表进行更新,因此视图的更新就是表的更新。
</code></pre><h4 id="规则和限制"><a href="#规则和限制" class="headerlink" title="规则和限制"></a>规则和限制</h4><pre><code>1.唯一命名，不能与表或者其它视图重名。
2.视图可以嵌套，可以从其它视图中构造视图。
3.order by可以用在视图定义中，但是如果select语句从视图中检索数据的时候，在视图中的order by语句将会被覆盖。
</code></pre><h4 id="视图-基本表区别"><a href="#视图-基本表区别" class="headerlink" title="视图/基本表区别"></a>视图/基本表区别</h4><pre><code>1.视图是已经编译好的sql语句，表不是。
2.视图没有实际的物理记录。表有。
3.表是内容，视图是窗口。
4.表只用物理空间，而视图不占用物理空间。视图只是逻辑概念的存在，表可以随时进行修改，但是视图只能由创建的语句来修改。
5.视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。
6.视图的建立和删除只影响视图本身，不影响对应的基本表。
</code></pre><hr>
<hr>
<h2 id="Java-数据库的操作"><a href="#Java-数据库的操作" class="headerlink" title="Java 数据库的操作"></a>Java 数据库的操作</h2><h4 id="1-如何通过JDBC访问数据库"><a href="#1-如何通过JDBC访问数据库" class="headerlink" title="1.如何通过JDBC访问数据库"></a>1.如何通过JDBC访问数据库</h4><pre><code>步骤：
1.加载JDBC驱动器
2.加载JDBC驱动(Class.forName(driver)) //driver=&quot;com.mysql.jdbc.Driver&quot;
3.建立数据库连接，取得Connection对象
4.建立Statement对象或是PreparedStatement对象
5.执行sql语句
6.访问结果集ResultSet对象
7.依次将ResultSet、Statement、PreparedStatement、Connection对象关闭，释放掉所占用资源
</code></pre><h4 id="2-JDBC处理事务采用的方法"><a href="#2-JDBC处理事务采用的方法" class="headerlink" title="2.JDBC处理事务采用的方法"></a>2.JDBC处理事务采用的方法</h4><p>一个事务是由一条或多条对数据库操作的SQL语句组成的一个不可分割的工作单元，只有当事务中的所有操作都正常执行完了，整个事务才会被提交给数据库。在JDBC中一般通过commit()方法或rollback()方法来结束事务的操作。</p>
<blockquote>
<p>扩展：JDBC有哪些事务隔离级别</p>
</blockquote>
<h4 id="3-Class-forName-方法的作用"><a href="#3-Class-forName-方法的作用" class="headerlink" title="3.Class.forName()方法的作用"></a>3.Class.forName()方法的作用</h4><p>此方法的作用就是将类加载到JVM中，它会返回一个与带有给定字符串名的类或接口相关联的class对象，并且jvm会执行该类的静态代码段</p>
<h4 id="4-Statement、PreparedStatement、CallableStatement之间的区别"><a href="#4-Statement、PreparedStatement、CallableStatement之间的区别" class="headerlink" title="4.Statement、PreparedStatement、CallableStatement之间的区别"></a>4.Statement、PreparedStatement、CallableStatement之间的区别</h4><pre><code>1.Statement用于执行不带参数的简单SQL语句，并返回它所生成结果的对象，每次执行SQL语句时，数据库都要编译该SQL语句
2.PreparedStatement表示预编译SQL语句的对象，用于执行带参数的预编译SQL语句
3.CallableStatement提供用来调用数据库中存储过程的接口，如果有输出参数要注册，说明是输出参数
</code></pre><h4 id="5-getString-方法与getObject-方法的区别"><a href="#5-getString-方法与getObject-方法的区别" class="headerlink" title="5.getString()方法与getObject()方法的区别"></a>5.getString()方法与getObject()方法的区别</h4><pre><code>1.getObject()方法可以解决当查询结果集中的数据量较大时，避免其不会抛出OracleException异常。
2.getString()方法或getInt()方法被调用时，程序会一次性将数据都放在内存中，然后通过ResultSet的next()和getString()方法来获取数据。
</code></pre><h4 id="6-使用JDBC需要注意的一些问题"><a href="#6-使用JDBC需要注意的一些问题" class="headerlink" title="6.使用JDBC需要注意的一些问题"></a>6.使用JDBC需要注意的一些问题</h4><pre><code>1.首先要建立数据库的连接，才能完成对数据库的访问
2.正常关闭和释放JDBC连接，JDBC资源才可以被快速地重用，从而使得系统性能得到改善。
</code></pre><hr>
<hr>
<h2 id="MySQL数据库字段-时间类型"><a href="#MySQL数据库字段-时间类型" class="headerlink" title="MySQL数据库字段 时间类型"></a>MySQL数据库字段 时间类型</h2><p>在MySQL中经常用来存储日期的数据类型包括：Date Datetime Timestamp</p>
<p><strong>1.Date数据类型</strong><br><br>表示用来存储没有时间的日期，此类型的格式为：YYYY-MM-DD 范围是：1000-00-00到9999-12-31</p>
<p><strong>2.Datetime类型</strong><br><br>存储有日期和时间的数据，此类型的格式：  YYYY-MM-DD HH:MM:SS 范围是：1000-00-00 00:00:00 - 9999-12-31 23:59:59 </p>
<p><strong>3.Timestamp类型</strong><br><br>存储既有时间又有日期的数据，此类型的格式：  YYYY-MM-DD HH:MM:SS 范围是：1000-00-00 00:00:00 - 9999-12-31 23:59:59</p>
<p><strong>4.TIMESTAMP和DATETIME相同点</strong><br><br> 两者都可用来表示YYYY-MM-DD HH:MM:SS[.fraction]类型的日期</p>
<p><strong>5.TIMESTAMP和DATETIME的不同点</strong><br><br>1.两者的存储方式不一样，TIMESTAMP将客户端插入的时间从当前时区转换为UTC(世界标准时间)存储。查询的时候又转化为客户端当前时区时间进行返回。对于DATETIME两者不做任何的改变，基本都是原样的输入输出。</p>
<p>2.两者能够存储的时间范围不一样，timestamp所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’。datetime所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</p>
<hr>
<hr>
<h2 id="MySQL-命令"><a href="#MySQL-命令" class="headerlink" title="MySQL - 命令"></a>MySQL - 命令</h2><pre><code>1.存储引擎：ENGINE = engine_name
存储引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 

2.列属性：
    1.unique 唯一索引(唯一约束) 使得某字段的值不能重复
    2.auto_increment 自增约束 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;
    3.foreign key 外键约束 用于限制主表与从表的数据完整性。存在外键的表称之为从表，外键指向的表称之为主表。作用：保持数据的一致性，完整性，主要目的是控制存储在外键表(从表)中的数据。

3.属性
    1.group子句 group by 字段/别名 [排序方式]
    group by 表示按照某种方式进行分组

    排序方式：升序：ASC，降序：DESC

        合计函数需要配合group by使用：
            1.count 返回不同的非NULL值数目 count(*)、count(字段)
            2.sum 求和
            3.max 求最大值
            4.min 求最小值
            5.avg 求平均值

    2.having子句 与where 功能 用法相同，执行时机不同

        where 在开始时执行检测数据，对原数据进行过滤。having 对筛选出的结果再次进行过滤。having 字段必须是查询出来的，where 字段必须是数据表存在的。

    3.order by 子句 排序子句
        order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC

    4.limit 子句，限制结果数量子句
        仅仅只对处理好的结果进行数量限制，将处理好的结果看作是一个集合，按照记录出现的顺序，索引从0开始。

        limit 起始位置,获取条数 省略第一个参数，表示从索引0开始，limit获取条数。

    5.distinct all 选项
        distinct 表示去除重复记录，默认值为all，全部记录。

    6.列子查询 
        如果子查询结果返回的是一列，使用 in 或者 not in 完成查询。

    7.JOIN
        该命令用于根据两个或多个表中的列之间的关系，从这些表中查询数据。
        select * from persons INNER JOIN Orders ON persons.id_p = Orders.id_p ORDER BY persons.LastName
</code></pre><blockquote>
<p>扩展：1.JOIN: 如果表中有至少一个匹配，则返回行。2.INNER JOIN：该语句表示产生的结果集中是两个表的交集。3.FULL[OUTER] JOIN：表示产生两个表的并集。 2.LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行。表示产生左边表的完全集，如果右表中有匹配则有值，否则由null代替。 3.RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行  4.FULL JOIN: 只要其中一个表中存在匹配，就返回行</p>
</blockquote>
<pre><code>8.mysql操作查询结果(case when then else end)
    在这里case有两种格式：
        1.简单case函数
            CASE sex 
                WHEN &apos;1&apos; THEN &apos;男&apos; 
                WHEN &apos;2&apos; THEN &apos;女&apos; 
            ELSE &apos;其他&apos; END 

        2.case搜索函数 
            CASE WHEN sex = &apos;1&apos; THEN &apos;男&apos; 
                WHEN sex = &apos;2&apos; THEN &apos;女&apos; 
            ELSE &apos;其他&apos; END 
</code></pre><blockquote>
<p>注意：这两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和case搜索函数相比，功能方面会有些限制，比如写判断式。还有一个需要注意的问题，case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。 </p>
</blockquote>
<pre><code>9.mysql cast &amp; convert函数
    MySQL的CAST()和CONVERT()函数可用来获取一个类型的值，并产生另一个类型的值。
    用法：
        CAST(value as type);
        CONVERT(value, type);
</code></pre><blockquote>
<p>注意：转换的类型是有限制的，该类型可包括(BINARY,CHAR,DATE,TIME,DATETIME,DECIMAL,SIGNED,UNSIGNED)。</p>
</blockquote>
<pre><code>10.mysql using &amp; on 
    在用join进行多表查询的时候，通常使用on来建立两表的关系，但还有一个更方便的关键字using
        例：
            select a.name,b.age from test as a
                join test2 as b
                on a.id=b.id

            select a.name,b.age from test as a
                join test2 as b
                using(id)
        //上面的两个程序实等价的。

11.mysql FIND_IN_SET()函数
    FIND_IN_SET(str, strList)：str表示要查询的字符串 strList表示查询字段中包含str结果。

        select * from tt_course WHERE FIND_IN_SET(&apos;15&apos;, btype);
</code></pre><blockquote>
<p>注意：FIND_IN_SET与like的区别：like是广泛的模糊查询，字符串中没有分隔符。FIND_IN_SET是精确匹配，字段值以英文”,”分割，FIND_IN_SET查询的结果小于like查询的结果。</p>
</blockquote>
<hr>
<blockquote>
<p>提示：在mysql中使用Navicat可视化界面的时候如果遇到错误：<code>1045 Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:YES)</code>或许是因为误删了root用户，然后在Navicat中直接添加上root用户即可。密码和你数据库密码一致。(user:root pass:xxx)。</p>
</blockquote>
<hr>
<h2 id="MySQL的主从分离实现"><a href="#MySQL的主从分离实现" class="headerlink" title="MySQL的主从分离实现"></a>MySQL的主从分离实现</h2><p>利用mysql的主从配置实现主从分离。1.从数据库层面实现主从分离的配置。2.从程序的读写方面实现(不需要改变现有的程序)。</p>
<h4 id="主从库理论"><a href="#主从库理论" class="headerlink" title="主从库理论"></a>主从库理论</h4><p>主从同步工作原理：1.主数据库将数据信息记录到二进制文件当中。2.然后从服务器就会同步主服务器的数据信息。3.然后从服务器上的线程同步执行操作。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQ-联合查询</title>
    <url>/undefined/MySQL%20%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><pre><code>SELECT
    curriculum_design.tname
FROM
    curriculum_design
INNER JOIN teacher
WHERE
    score = 0
AND `status` = 1
AND `year` = 2018
GROUP BY curriculum_design.tid
</code></pre>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化-explain详解</title>
    <url>/undefined/MySQL%E4%BC%98%E5%8C%96%20-%20Explain%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="数据访问缓慢原因查询命令"><a href="#数据访问缓慢原因查询命令" class="headerlink" title="数据访问缓慢原因查询命令"></a>数据访问缓慢原因查询命令</h1><h2 id="mysql-explain"><a href="#mysql-explain" class="headerlink" title="mysql explain"></a>mysql explain</h2><p>在数据查询或者访问过程中出现访问慢等情况时，可以使用<code>explain</code>命令能够查看sql语句的执行计划，sql语句有没有使用上索引，有没有做全表检查，所以深入了解mysql的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节。<br><a id="more"></a></p>
<h4 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a>1.id</h4><p>id表示sql执行的顺序标识，从大到小的执行。此外，如果id相同时，执行顺序由上到下。如果是子查询，id的序号会递增，id值越大优先级越高，越先执行。</p>
<h4 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2.select_type"></a>2.select_type</h4><p>表示查询中每个select子句的类型，如下所示：</p>
<pre><code>(1) SIMPLE(简单SELECT,不使用UNION或子查询等)

(2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)

(3) UNION(UNION中的第二个或后面的SELECT语句)

(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)

(5) UNION RESULT(UNION的结果)

(6) SUBQUERY(子查询中的第一个SELECT)

(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)

(8) DERIVED(派生表的SELECT, FROM子句的子查询)

(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)
</code></pre><h4 id="3-table"><a href="#3-table" class="headerlink" title="3.table"></a>3.table</h4><p>表示显示这一行的数据是关于哪张表的，有些时候不是真实的表的名字，看到的是derivedx(x是个数字,我的理解是第几步执行的结果)</p>
<h4 id="4-type"><a href="#4-type" class="headerlink" title="4.type"></a>4.type</h4><p>访问类型，是mysql在表中找到所需行的方式。常见的类型有：</p>
<pre><code>ALL, index,  range, ref, eq_ref, const, system, NULL (从最差到最好)

    ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行

    index: Full Index Scan，index与ALL区别为index类型只遍历索引树

    range:只检索给定范围的行，使用一个索引来选择行

    ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

    eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件

    const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system

    NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
</code></pre><blockquote>
<p>注意：上面的type性能是：从左到右，性能从差到好。</p>
</blockquote>
<h4 id="5-possible-keys"><a href="#5-possible-keys" class="headerlink" title="5.possible_keys"></a>5.possible_keys</h4><p>表示能够指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。</p>
<blockquote>
<p>注意：该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询。</p>
</blockquote>
<h4 id="6-Key"><a href="#6-Key" class="headerlink" title="6.Key"></a>6.Key</h4><p>key列显示MySQL实际决定使用的键（索引）</p>
<blockquote>
<p>注：如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
</blockquote>
<h4 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7.key_len"></a>7.key_len</h4><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）。</p>
<blockquote>
<p>注：不损失精确性的情况下，长度越短越好。</p>
</blockquote>
<h4 id="8-ref"><a href="#8-ref" class="headerlink" title="8.ref"></a>8.ref</h4><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p>
<h4 id="9-rows"><a href="#9-rows" class="headerlink" title="9.rows"></a>9.rows</h4><p>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数。</p>
<h4 id="10-Extra"><a href="#10-Extra" class="headerlink" title="10.Extra"></a>10.Extra</h4><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p>
<pre><code>Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤。

Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。看到这个的时候表示查询需要优化。这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。

Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。当看到这个的时候，表示查询需要优化。

Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。

Impossible where：这个值强调了where语句会导致没有符合条件的行。

Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行。
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>explain不会告诉关于触发器，存储过程的信息或者用户自定义函数对查询的影响情况。不考虑缓存情况等。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化-show profile</title>
    <url>/undefined/MySQL%E4%BC%98%E5%8C%96%20-%20show%20profile/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="1-通过show-profile分析SQL"><a href="#1-通过show-profile分析SQL" class="headerlink" title="1.通过show profile分析SQL"></a>1.通过show profile分析SQL</h4><p>1.通过@@have_profiling参数可以看出MySQL是否支持profile。</p>
<pre><code>SELECT @@have_profiling
</code></pre><p>2.通过set profiling = 1 命令开启Session级别的profile。</p>
<pre><code>SELECT @@profiling
SET profiling=1
</code></pre><p>3.通过show PROFILE FOR QUERY 命令可以看到执行过程中线程的每个状态和消耗的时间。</p>
<p>4.show profile命令能够在做SQL优化时帮助我们了解时间都耗费到哪里。</p>
]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化-trace分析</title>
    <url>/undefined/MySQL%E4%BC%98%E5%8C%96%20-%20trace%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="mysql优化-trace分析"><a href="#mysql优化-trace分析" class="headerlink" title="mysql优化 - trace分析"></a>mysql优化 - trace分析</h2><p>通过trace文件能够进一步了解为什么优化器选择A执行计划而不选择B执行计划，帮助我们更好的理解优化器是如何选择执行计划的。</p>
]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化-索引优化</title>
    <url>/undefined/MySQL%E4%BC%98%E5%8C%96%20-%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%8ASQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="MySQL-索引优化"><a href="#MySQL-索引优化" class="headerlink" title="MySQL - 索引优化"></a>MySQL - 索引优化</h2><p>[TOC]<br>通过索引可以帮助我们解决大多数的SQL性能问题。</p>
<p>MySQL索引类比是一本书前面的目录，能加快数据库的查询速度。</p>
<p>在没有索引的情况下，数据库会遍历全部数据后选择符合条件的。而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。<br><a id="more"></a></p>
<blockquote>
<p>提示：索引最大的优势在于将无序的数据变成有序的数据(相对)。</p>
</blockquote>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>因为在二叉搜索树中，左边的节点值比根节点值小，右边节点值比根节点值大，同时左右子节点都是排序树。</p>
<ul>
<li>优点，可以解决大量数据索引无法一次加载进内存中问题，二叉搜索树可以批量加载数据进内存</li>
<li>缺点，检索时间与树的高度有关，树的高度越高，检索次数及时间相对就会越久。极端情况下，如果数据本身就是有序的，二叉搜索树会退化成链表，性能会急剧降低。</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是一种自平衡二叉树，主要解决二叉搜索树在极端情况下退化为链表的情况，在数据插入的时候同时调整整个树，使得其节点尽量均匀分布，保持平衡性，目的在于降低树的高度，提高查询效率。</p>
<ul>
<li>优点，解决二叉搜索树的极端情况的退化问题</li>
<li>缺点，检索时间依旧与树的高度有关，当数据量很大时，树的高度就会很高，检索的次数就比较多，检索的时间会比较久，效率低。</li>
</ul>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>通过一定的算法计算数据的Hash值，然后得到数据的存放位置，例HashMap采用就是这种数据索引结构。</p>
<ul>
<li>优点，检索时间快，平均检索时间为O(1)。</li>
<li>缺点，因为哈希值是通过算法计算出来的，存在Hash碰撞的可能，如HashMap对于Hash值相同的数据，会在Hash值所在桶创建一个链表，用于存放相同Hash值的数据。在数据量很大的情况下，内存无法加载全部的数据索引。</li>
</ul>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树是一种多路搜索树，每个子节点可以拥有多于2个子节点，M路的B树最多可拥有M个子节点。设计成多路，其目的是为了降低树的高度，降低查询次数，提高查询效率。</p>
<pre><code>1. 叶节点具有相同的深度（通常为3-5）

2. 叶节点的指针为空

3. 节点中的数据索引从左到右递增排序
</code></pre><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B树是一种多路搜索树，每个子节点可以拥有多于2个子节点，M路的B树最多可拥有M个子节点。设计成多路，其目的是为了降低树的高度，降低查询次数，提高查询效率。</p>
<pre><code>1. 非叶子节点不存储data，只存储索引，可以放更多的索引

2. 叶子节点不存储指针

3. 顺序访问指针，提高区间访问的性能
</code></pre><h4 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h4><pre><code>1. B+Tree中的非叶子结点不存储数据，只存储键值

2. B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址

3. B+Tree的每个非叶子节点由n个键值key和n个指针point组成
</code></pre><h3 id="1-索引类型-normal-unique-full-text"><a href="#1-索引类型-normal-unique-full-text" class="headerlink" title="1.索引类型 normal | unique | full text"></a>1.索引类型 normal | unique | full text</h3><pre><code>1.normal 普通索引

2.unique 唯一索引，不允许重复的索引

3.full text 表示全文搜索的索引
</code></pre><h3 id="2-索引的存储分类"><a href="#2-索引的存储分类" class="headerlink" title="2.索引的存储分类"></a>2.索引的存储分类</h3><p>在MySQL中索引使用的数据结构主要有btree索引和哈希索引。</p>
<h4 id="1-B树索引"><a href="#1-B树索引" class="headerlink" title="1 B树索引"></a>1 B树索引</h4><p>MySQL中的btree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎实现的方式是不同的。</p>
<h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><p>B+Tree叶节点的data域存放的是数据记录的地址。</p>
<p>在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><p>其数据文件本身就是索引文件。</p>
<p>相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。</p>
<p>这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。</p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</p>
<p>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h4 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2 哈希索引"></a>2 哈希索引</h4><p>哈希索引，底层的数据结构是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快。其余大部分场景使用btree索引。</p>
<p>哈希索引不适用于范围查找。</p>
<h4 id="3-R树索引（空间索引）"><a href="#3-R树索引（空间索引）" class="headerlink" title="3 R树索引（空间索引）"></a>3 R树索引（空间索引）</h4><p>空间索引是MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。</p>
<h4 id="4-全文索引-full-text"><a href="#4-全文索引-full-text" class="headerlink" title="4 全文索引(full text)"></a>4 全文索引(full text)</h4><p>全文索引是MyISAM的一种特殊类型，主要用于全文索引。</p>
<hr>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p>本部分细节都是基于MySQL的InnoDB引擎。我们清楚，索引类似于字典的目录，可以提高查询的效率。</p>
<h3 id="1-索引的优点"><a href="#1-索引的优点" class="headerlink" title="1 索引的优点"></a>1 索引的优点</h3><pre><code>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
4.在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
</code></pre><h3 id="2-索引的缺点"><a href="#2-索引的缺点" class="headerlink" title="2 索引的缺点"></a>2 索引的缺点</h3><pre><code>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
</code></pre><h3 id="3-索引的分类"><a href="#3-索引的分类" class="headerlink" title="3 索引的分类"></a>3 索引的分类</h3><pre><code>1.普通索引：基本的索引，其没有任何的限制

2.唯一索引：与普通索引类似，不同的是MySQL数据库索引列的值必须唯一，但允许有空值。

3.主键索引：特殊的唯一索引，不允许有空值。

4.全文索引：表示全文搜索的索引。

5.单列索引和多列索引
    单列索引：表示只有一个字段的方式。
    多列索引：
</code></pre><blockquote>
<p>注意：索引使用原则：1.选择唯一索引。 2.为经常需要排序 | 分组 | 联合操作的字段建立索引。3.为常作为查询条件的字段建立索引。4.限制索引的数目。5.尽量使用数据量少的索引。6.尽量使用前缀索引。7.删除不再使用或者很少使用的索引。8.不推荐同一列建立多个索引。9.经常更新或者修改的列不要建立索引。</p>
</blockquote>
<h3 id="1-最左前缀原则"><a href="#1-最左前缀原则" class="headerlink" title="1.最左前缀原则"></a>1.最左前缀原则</h3><p>在一张表中依据name字段来建立索引，采用B+树的结构。然后进行模糊查询。SQL语句如下所示：</p>
<pre><code>select id from table where name like &apos;张%&apos;
</code></pre><p>这样这段SQL语句就会根据模糊查询对表进行向右的查询，直到没有满足条件的为止。所以这种从左至右的查询原则就是最左前缀原则。</p>
<h3 id="2-B-树做索引，而非哈希表做索引原因"><a href="#2-B-树做索引，而非哈希表做索引原因" class="headerlink" title="2.B+树做索引，而非哈希表做索引原因"></a>2.B+树做索引，而非哈希表做索引原因</h3><blockquote>
<p>1.哈希表是将索引字段映射成对应的哈希码然后存放在对应的位置，这样的话如果要进行模糊查询的话显然哈希表这种结构是不支持的，只能遍历这个表。B+树可以通过最左前缀原则快速找到对应的数据。</p>
</blockquote>
<blockquote>
<p>2.哈希表不支持范围查找，只能遍历全表。</p>
</blockquote>
<blockquote>
<p>3.索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码，则形成的索引结构会是一条很长的链表，查找的时间会大大增加。</p>
</blockquote>
<h3 id="3-主键索引与非主键索引的区别"><a href="#3-主键索引与非主键索引的区别" class="headerlink" title="3.主键索引与非主键索引的区别"></a>3.主键索引与非主键索引的区别</h3><p>非主键索引的叶子节点存放的是主键的值，而主键索引的叶子节点存放的是整行数据。其中非主键索引也被称为二级索引，主键索引被称为聚簇索引。</p>
<h3 id="4-使用主键自增索引原因"><a href="#4-使用主键自增索引原因" class="headerlink" title="4.使用主键自增索引原因"></a>4.使用主键自增索引原因</h3><p>如果使用的主键是自增的，那么每次插入的ID都会比前面的大，那么每次只需要在后面插入就行了，不需要移动位置和分裂操作等，这样能够提高性能。</p>
<h3 id="5-索引优化策"><a href="#5-索引优化策" class="headerlink" title="5.索引优化策"></a>5.索引优化策</h3><h4 id="1-不在索引列上进行运算或使用函数"><a href="#1-不在索引列上进行运算或使用函数" class="headerlink" title="1.不在索引列上进行运算或使用函数"></a>1.不在索引列上进行运算或使用函数</h4><p>因为在列上进行运算或者使用函数会使索引失效，从而进行全表扫描。</p>
<pre><code>//这样会走索引
select * from table where id = &apos;4&apos;

//这样会走全表扫描
select * from table where id + 1 = 4
</code></pre><h4 id="2-注意隐式类型转换"><a href="#2-注意隐式类型转换" class="headerlink" title="2.注意隐式类型转换"></a>2.注意隐式类型转换</h4><p>这里假设id为varchar类型：</p>
<pre><code>//走全表扫描
select * from table where id = 100

//走索引扫描
select * from table where id = &apos;100&apos;
</code></pre><p>这里是因为隐式类型转换在索引字段上做了函数操作，所以会进行全表扫描。</p>
<h4 id="3-前导模糊查询不会用到索引"><a href="#3-前导模糊查询不会用到索引" class="headerlink" title="3.前导模糊查询不会用到索引"></a>3.前导模糊查询不会用到索引</h4><p>%李、%李% 这样都会导致全表扫描，非前导模糊查询可以使用索引。</p>
<h3 id="6-选择合适的列建立索引"><a href="#6-选择合适的列建立索引" class="headerlink" title="6.选择合适的列建立索引"></a>6.选择合适的列建立索引</h3><pre><code>1.在where从句，group by从句，order by从句，on从句中出现的列。
2.索引字段越小越好。

3.离散度大的列放到联合索引的前面：select * from payment where staff_id = 2 and customer_id = 584; 在这里建立索引是：(index(staff_id, customer_id)) 还是：index(customer_id, staff_id) 在这里因为customer_id离散度更大，所以应该使用index(customer_id, staff_id)。
</code></pre><h3 id="7-索引的维护及优化-重复及冗余索引"><a href="#7-索引的维护及优化-重复及冗余索引" class="headerlink" title="7.索引的维护及优化 重复及冗余索引"></a>7.索引的维护及优化 重复及冗余索引</h3><p>重复索引表示相同的列以相同的顺序建立同类型的索引，例如：在id为主键的时候，建立id索引和主键索引就是重复的索引。</p>
<pre><code>1.查找重复及冗余索引

    使用 pt-duplicate-key-checker 工具检查重复及冗余索引 需要的参数是 用户名和密码

2.删除不用的索引

    通过使用 pt-index-usage 工具来进行索引使用情况的分析
</code></pre><hr>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="MySQL慢查日志对有效率问题的SQL进行监控"><a href="#MySQL慢查日志对有效率问题的SQL进行监控" class="headerlink" title="MySQL慢查日志对有效率问题的SQL进行监控"></a>MySQL慢查日志对有效率问题的SQL进行监控</h3><pre><code>//1.查看数据库是否开启检查日志
show variable like &apos;slow_query_log&apos;

set global slow_query_log_file=&apos;/home/mysql/sql_log/mysql-slow.log&apos;
</code></pre><h3 id="通过show-processlist-命令查看当前MySQL进行的线程"><a href="#通过show-processlist-命令查看当前MySQL进行的线程" class="headerlink" title="通过show processlist 命令查看当前MySQL进行的线程"></a>通过show processlist 命令查看当前MySQL进行的线程</h3><pre><code>show processlist 
</code></pre><h3 id="通过show-status命令了解各种SQL的执行频率"><a href="#通过show-status命令了解各种SQL的执行频率" class="headerlink" title="通过show status命令了解各种SQL的执行频率"></a>通过show status命令了解各种SQL的执行频率</h3><pre><code>show [session | global] status 
</code></pre><h3 id="通过命令-show-profile-分析SQL"><a href="#通过命令-show-profile-分析SQL" class="headerlink" title="通过命令 show profile 分析SQL"></a>通过命令 show profile 分析SQL</h3><pre><code>show profiles | show profile
</code></pre><h3 id="通过命令-trace-分析优化器如何选择执行计划"><a href="#通过命令-trace-分析优化器如何选择执行计划" class="headerlink" title="通过命令 trace 分析优化器如何选择执行计划"></a>通过命令 trace 分析优化器如何选择执行计划</h3><pre><code>1. 打开trace，设置格式为JSON，设置trace能够使用的最大大小
</code></pre><hr>
<h2 id="Count-和Max-优化"><a href="#Count-和Max-优化" class="headerlink" title="Count()和Max()优化"></a>Count()和Max()优化</h2><h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><pre><code>max()函数：如：查询最后支付时间 select max(payment_date) from payment;
</code></pre><blockquote>
<p>优化：可以在表payment上建立一个索引 idx_paydate 在列 payment_date 。从而通过索引大大的减少了SQL执行时间，提高效率。</p>
</blockquote>
<h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count()函数"></a>count()函数</h3><pre><code>count()函数：如：在一条sql中同时查出2005年和2006年电影的数量 select COUNT(release_year=&apos;2006&apos; or null) as &apos;2006年电影数量&apos;, count(release_year=&apos;2005&apos; or null) as &apos;2005年电影数量&apos; from film;
</code></pre><blockquote>
<p>注意：count(<em>)和count(id)查询的值是不一样的，count(</em>)查询的值会包括null值。</p>
</blockquote>
<hr>
<h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><p>通常情况下，需要将子查询优化为join查询，但是在优化时要注意关联键是否有一对多的关系，需要注意重复数据。如果存在重复的数据，使用 distinct 命令去掉重复的数据。</p>
<pre><code>explain select title, release_year, length from film where film_id IN(
    select film_id from film_actor where actor_id IN(
        select actor_id from actor where first_name = &apos;Aaron&apos;
    )
)
</code></pre><hr>
<h2 id="GROUP-BY优化"><a href="#GROUP-BY优化" class="headerlink" title="GROUP BY优化"></a>GROUP BY优化</h2><p>如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL禁止排序。</p>
<pre><code>优化前：

    explain select actor.first_name, actor,last_name, COUNT(*) FROM sakia.film_actor INNER JOIN sakila.actor USING(actor_id) GROUP BY film_actor.actor_id;

优化后：

    explain select actor.first_name, actor.last_name, c.cnt from sakila.actor INNER JOIN(SELECT actor_id, COUNT(*) AS cnt from sakila.film_actor GROUP BY actor_id) AS c USING(actor_id);
</code></pre><hr>
<h2 id="limit-优化"><a href="#limit-优化" class="headerlink" title="limit 优化"></a>limit 优化</h2><p>limit常用于分页处理，经常会伴随order by从句使用，因此大多数时候会使用filesorts 这样会造成大量的 IO 问题。</p>
<pre><code>select film_id, description from sakila.film order by title limit 50, 5;
</code></pre><h3 id="1-使用有索引的列或主键进行-order-by-操作"><a href="#1-使用有索引的列或主键进行-order-by-操作" class="headerlink" title="1.使用有索引的列或主键进行 order by 操作"></a>1.使用有索引的列或主键进行 order by 操作</h3><pre><code>select film_id, description from saklia.film order by film_id limit 50, 5;
</code></pre><h3 id="2-记录上次返回的主键，在下次查询时使用主键过滤"><a href="#2-记录上次返回的主键，在下次查询时使用主键过滤" class="headerlink" title="2.记录上次返回的主键，在下次查询时使用主键过滤"></a>2.记录上次返回的主键，在下次查询时使用主键过滤</h3><pre><code>select film_id, description from saklia.film where film_id &gt; 55 and film_id &lt;= 60 order by film_id limit 1, 5;
</code></pre><blockquote>
<p>注意：这里避免数据量大是扫描过多的记录。</p>
</blockquote>
<hr>
<h2 id="OR优化"><a href="#OR优化" class="headerlink" title="OR优化"></a>OR优化</h2><p>在含有OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引，如果没有索引，则应该考虑增加索引。</p>
<hr>
<h2 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h2><p>在一般分页查询时，通过创建覆盖索引能够比较好的提高性能</p>
<hr>
<h2 id="SQL技巧"><a href="#SQL技巧" class="headerlink" title="SQL技巧"></a>SQL技巧</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><pre><code>^ 字符串开始处进行匹配

$ 字符串末尾处进行匹配

. 匹配任意单个字符

[...] 匹配出括号内的任意字符

[^...] 匹配非括号内的任意字符

a* 匹配零个或多个a字符（包括空串）

a+ 匹配1个或多个a（不包括空串）

a? 匹配1个或零个a

a1 | a2 匹配a1或a2

...
</code></pre><h3 id="RAND-随机行"><a href="#RAND-随机行" class="headerlink" title="RAND() 随机行"></a>RAND() 随机行</h3>]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化-数据表结构优化</title>
    <url>/undefined/MySQL%E4%BC%98%E5%8C%96%20-%20%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="MySQL优化-数据表结构优化"><a href="#MySQL优化-数据表结构优化" class="headerlink" title="MySQL优化 - 数据表结构优化"></a>MySQL优化 - 数据表结构优化</h2><h4 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h4><pre><code>1.使用可以存下我们数据最小的数据类型。
2.使用简单的数据类型，int要比varchar类型在mysql处理上简单。
3.尽可能的使用not null定义字段。
4.尽量少用text类型，非用不可的时候考虑分表。
</code></pre><a id="more"></a>
<pre><code>例：

    1.使用int来存储日期时间，利用 FROM_UNIXTIME(), UNIX_TIMESTAMP()两个函数来进行转换。

        create table test(id int auto_increment not null), timestr int, primary key(id);

        insert into test(timestr) values(UNIX_TIMESTAMP(&apos;2014-06-01 13:12:00&apos;));

        select FROM_UNIXTIME(timestr) FROM test;

    2.使用bigint来存储ip地址，利用 INET_ATON(), INET_NTOA() 两个函数来进行转换。

        create table sessions(id int auto_increment not null, ipaddress bigint, primary key(id));

        insert into sessions(ipaddress) values(INET_ATON(&apos;192.168.0.1&apos;));

        select INET_NTOA(ipaddress) from sessions;
</code></pre><h4 id="表的范式化和反范式化"><a href="#表的范式化和反范式化" class="headerlink" title="表的范式化和反范式化"></a>表的范式化和反范式化</h4><p>范式化是值数据库设计的规范，目前说到的范式化是指第三设计范式，即要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。不符合第三范式要求的表存在下列问题：</p>
<pre><code>1.数据冗余：(分类，分类描述)对于每一个商品都会进行记录。
2.数据的插入异常。
3.数据的更新异常。
4.数据的删除异常。
</code></pre><blockquote>
<p>提示：解决不符合第三范式表的方法是将该表分表，建立不同的表。</p>
</blockquote>
<p>反范式化表示为了查询效率的考虑将原本符合第三范式的表适当增加冗余，达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</p>
<h4 id="表的垂直拆分"><a href="#表的垂直拆分" class="headerlink" title="表的垂直拆分"></a>表的垂直拆分</h4><p>垂直拆分表示将原来一个有很多列的表拆分成多个表，这解决了表的宽度过宽问题，通常情况下表的垂直拆分可以按照以下原则进行：</p>
<pre><code>1.将不太常用的字段单独存放在一个表中。
2.将大字段独立存放在一个表中。
3.将经常一起使用的字段放在一起。
</code></pre><h4 id="表的水平拆分"><a href="#表的水平拆分" class="headerlink" title="表的水平拆分"></a>表的水平拆分</h4><p>水平拆分是为了解决单表中数据量过大的问题，水平拆分的每一个表的结构都是完全一致的。这一拆分解决了表的数据量问题。</p>
<pre><code>表水平拆分方法：对id进行hash运算(取模)，如果拆分成5个表，则使用mod(id)取出0-4个值，针对不同的hashID将数据存到不同的表中。
</code></pre>]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQ-分区</title>
    <url>/undefined/MySQL%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL分区可以管理非常大的表，采用分而治之的逻辑，分区引入分区键概念，让数据根据规则分布在不同的分区中，让一个大对象变成一些小对象。</p>
<pre><code>命令：show variables 查看当前MySQL是否支持分区
</code></pre><p>MySQL支持RANGE，LIST，HASH和KEY四种分区。其中，每个分区又都有一种特殊的类型。对于RANGE分区，有RANGE COLUMNS分区。对于LIST分区，有LIST COLUMNS分区。对于HASH分区，有LINEAR HASH分区。对于KEY分区，有LINEAR KEY分区。</p>
<h4 id="1-RANGE分区"><a href="#1-RANGE分区" class="headerlink" title="1.RANGE分区"></a>1.RANGE分区</h4><p>RANGE即范围分区，根据区间来判断位于哪个分区。如id值小于5在p0分区，如果id值大于5小于10在p1分区，类似地，依次类推得到各个分区。if…else if..。</p>
<pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
</code></pre><blockquote>
<p>注意：RANGE分区返回值必须是整数。</p>
</blockquote>
<h4 id="2-RANGE-COLUMNS分区"><a href="#2-RANGE-COLUMNS分区" class="headerlink" title="2.RANGE COLUMNS分区"></a>2.RANGE COLUMNS分区</h4><p>RANGE COLUMNS是RANGE分区的一种特殊类型，它与RANGE分区的区别如下：</p>
<pre><code>1. RANGE COLUMNS不接受表达式，只能是列名。而RANGE分区则要求分区的对象是整数。
2. RANGE COLUMNS允许多个列，在底层实现上，它比较的是元祖（多个列值组成的列表），而RANGE比较的是标量，即数值的大小。
3. RANGE COLUMNS不限于整数对象，date，datetime，string都可作为分区列。

CREATE TABLE rcx (
    a INT,
    b INT,
    c CHAR(3),
    d INT
)
PARTITION BY RANGE COLUMNS(a,d,c) (
    PARTITION p0 VALUES LESS THAN (5,10,&apos;ggg&apos;),
    PARTITION p1 VALUES LESS THAN (10,20,&apos;mmmm&apos;),
    PARTITION p2 VALUES LESS THAN (15,30,&apos;sss&apos;),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
</code></pre><blockquote>
<p>注意：同RANGE分区类似，它的区间范围必须是递增的，有时候，列涉及的太多，不好判断区间的大小，可采用下面的方式进行判断。<code>SELECT (5,10) &lt; (5,12), (5,11) &lt; (5,12), (5,12) &lt; (5,12);</code></p>
</blockquote>
<h4 id="3-LIST分区-列表分区"><a href="#3-LIST分区-列表分区" class="headerlink" title="3.LIST分区 列表分区"></a>3.LIST分区 列表分区</h4><pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
</code></pre><h4 id="4-LIST-COLUMNS分区"><a href="#4-LIST-COLUMNS分区" class="headerlink" title="4.LIST COLUMNS分区"></a>4.LIST COLUMNS分区</h4><p>LIST COLUMNS分区同样是LIST分区的一种特殊类型，它和RANGE COLUMNS分区较为相似，同样不接受表达式，同样支持多个列支持string,date和datetime类型。</p>
<pre><code>CREATE TABLE customers_1 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES IN(&apos;2010-02-01&apos;, &apos;2010-02-02&apos;, &apos;2010-02-03&apos;,
        &apos;2010-02-04&apos;, &apos;2010-02-05&apos;, &apos;2010-02-06&apos;, &apos;2010-02-07&apos;),
    PARTITION pWeek_2 VALUES IN(&apos;2010-02-08&apos;, &apos;2010-02-09&apos;, &apos;2010-02-10&apos;,
        &apos;2010-02-11&apos;, &apos;2010-02-12&apos;, &apos;2010-02-13&apos;, &apos;2010-02-14&apos;),
    PARTITION pWeek_3 VALUES IN(&apos;2010-02-15&apos;, &apos;2010-02-16&apos;, &apos;2010-02-17&apos;,
        &apos;2010-02-18&apos;, &apos;2010-02-19&apos;, &apos;2010-02-20&apos;, &apos;2010-02-21&apos;),
    PARTITION pWeek_4 VALUES IN(&apos;2010-02-22&apos;, &apos;2010-02-23&apos;, &apos;2010-02-24&apos;,
        &apos;2010-02-25&apos;, &apos;2010-02-26&apos;, &apos;2010-02-27&apos;, &apos;2010-02-28&apos;)
);
</code></pre><h4 id="5-HASH分区"><a href="#5-HASH分区" class="headerlink" title="5.HASH分区"></a>5.HASH分区</h4><p>和RANGE，LIST分区不同的是，HASH分区无需定义分区的条件。只需要指明分区数即可。</p>
<pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4;
</code></pre><blockquote>
<p>注意：1. HASH分区可以不用指定PARTITIONS子句，如上文中的PARTITIONS 4，则默认分区数为4。2. 不允许只写PARTITIONS，而不指定分区数。3. 同RANGE分区和LIST分区一样，PARTITION BY HASH (expr)子句中的expr返回的必须是整数值。4. HASH分区的底层实现其实是基于MOD函数。</p>
</blockquote>
<p>譬如，对于下表</p>
<pre><code>CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY HASH( YEAR(col3) )
    PARTITIONS 4;
</code></pre><p>如果你要插入一个col3为“2005-09-15”的记录，则分区的选择是根据以下值决定的：</p>
<pre><code>MOD(YEAR(&apos;2005-09-01&apos;),4)
=  MOD(2005,4)
=  1
</code></pre><h4 id="6-LINEAR-HASH分区"><a href="#6-LINEAR-HASH分区" class="headerlink" title="6.LINEAR HASH分区"></a>6.LINEAR HASH分区</h4><p>LINEAR HASH分区是HASH分区的一种特殊类型，与HASH分区是基于MOD函数不同的是，它基于的是另外一种算法。</p>
<pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT,
    store_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITIONS 4;
</code></pre><blockquote>
<p>说明：1. 它的优点是在数据量大的场景，譬如TB级，增加、删除、合并和拆分分区会更快，缺点是，相对于HASH分区，它数据分布不均匀的概率更大。</p>
</blockquote>
<h4 id="7-KEY分区"><a href="#7-KEY分区" class="headerlink" title="7.KEY分区"></a>7.KEY分区</h4><p>KEY分区其实跟HASH分区差不多，不同点如下：</p>
<pre><code>1. KEY分区允许多列，而HASH分区只允许一列。

2. 如果在有主键或者唯一键的情况下，key中分区列可不指定，默认为主键或者唯一键，如果没有，则必须显性指定列。

3. KEY分区对象必须为列，而不能是基于列的表达式。

4. KEY分区和HASH分区的算法不一样，PARTITION BY HASH (expr)，MOD取值的对象是expr返回的值，而PARTITION BY KEY (column_list)，基于的是列的MD5值。


CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;
</code></pre><p>在没有主键或者唯一键的情况下，格式如下：</p>
<pre><code>CREATE TABLE tm1 (
    s1 CHAR(32)
)
PARTITION BY KEY(s1)
PARTITIONS 10;
</code></pre><h4 id="8-LINEAR-KEY分区"><a href="#8-LINEAR-KEY分区" class="headerlink" title="8.LINEAR KEY分区"></a>8.LINEAR KEY分区</h4><p>同LINEAR HASH分区类似。</p>
<pre><code>CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1. MySQL分区中如果存在主键或唯一键，则分区列必须包含在其中。
2. 对于原生的RANGE分区，LIST分区，HASH分区，分区对象返回的只能是整数值。
3. RANGE COLUMNS，LIST COLUMNS，KEY，LINEAR KEY分区对象只能是列，不能是基于列的表达式。
</code></pre>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQ-存储引擎</title>
    <url>/undefined/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="数据库与实例"><a href="#数据库与实例" class="headerlink" title="数据库与实例"></a>数据库与实例</h3><h5 id="数据库的概述："><a href="#数据库的概述：" class="headerlink" title="数据库的概述："></a>数据库的概述：</h5><p>​        简单说就是存放数据的仓库，这个仓库按一定的数据结构（数据的组织形式、或数据之间的联系）来组织和存储的，数据库分为关系型数据库（Oracle，MySQL，SQLServer）和非关系型数据库（NOSQL，Memcaced，redis等）</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>​        MySQL实例是由线程和内存组成，它是真正用于操作数据库文件的，一般情况下一个实例操作一个或多个数据库，在实例启动的时候MySQL会读取配置文件，MySQL如果找不到配置文件则会按照默认参数设置启动实例</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>​        只要由多个查询需要在同一时刻修改数据，都会产生并发控制问题，解决方法：并发控制</p>
<h6 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h6><ul>
<li>共享锁：读锁，它是共享的，互相不阻塞，多个用户在同一时刻可以读取同一个资源且互不干扰</li>
<li>排他锁 ：写锁，它会阻塞其他的写锁和读锁，写锁比读锁具有更高的优先级</li>
</ul>
<h6 id="锁策略"><a href="#锁策略" class="headerlink" title="锁策略"></a>锁策略</h6><ul>
<li>表锁：它是mysql中最基本的锁策略，并且开销最小，锁定整张表</li>
<li>行锁：最大程度支持并发处理，InnoDB就使用了行锁，但它的行锁不是那么简单（后续讲）</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​      ==实现了ACID，会需要更强的cpu处理能力，更大的内存和更大的磁盘空间==</p>
<ul>
<li><strong>原子性Atomicity</strong>：一个事务被视为一个不可分割的最小工作单元，整个事务的操作要么全部成功，要么全部       失败</li>
<li><strong>一致性consistency</strong>：就是一个事务没有提交commit，系统崩溃，那么事务中所做的修改不会保存到数据库中</li>
<li><strong>隔离性isolation</strong>：一个事务所作的操作在提交之前，对其他事务是不可见的</li>
<li><strong>持久性durability</strong>：一旦事务提交，所做的修改就会永久保存到数据库中，即使系统崩溃，改的数据也不会丢失</li>
</ul>
<p>​       MySQL==默认采用自动提交==AUTOCOMMIT模式，如果不是显示开始一个事务，每个查询都会被当作一个事务执行提交操作，可通过AUTOCOMMIT变量来启用或禁用自动提交模式</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>​       它是一个存储引擎，用来==负责mysql中的数据的存储和提取==，不会去解析SQL，但是会解析外键定义，它的<strong>数据都存储在表空间</strong>中tablespace，由一系列的数据文件组成，它采用MVCC来支持高并发，<strong>实现了四个标准的隔离级别</strong>，默认级别是：==<strong>REPEATABLE READ（可重复度读）</strong>==</p>
<p>​        InnoDB的表是基于==聚簇索引==建立的</p>
<p>​        表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page），表空间中的页大小都为 16KB，每个 16KB 大小的页中可以存放 2200 行的记录，对<code>nnodb_page_size</code> 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同</p>
<p>​         <strong>表的定义</strong>和<strong>数据索引</strong>等信息分开存储，其中<strong>表的定义</strong>存储在 <code>.frm</code>文件中，<strong>数据索引</strong>储在 <code>.ibd</code> 文件中</p>
<h5 id="在InnoDB中，它为每行记录都增加了三个隐藏的字段"><a href="#在InnoDB中，它为每行记录都增加了三个隐藏的字段" class="headerlink" title="在InnoDB中，它为每行记录都增加了三个隐藏的字段"></a>在InnoDB中，它为每行记录都增加了三个隐藏的字段</h5><ul>
<li><p>事务id：6字节</p>
</li>
<li><p>回滚指针：7字节</p>
</li>
<li><p>隐藏的id</p>
<p><img src="images\111.png" alt=""></p>
</li>
</ul>
<p>​        <strong>为了支持事务，引入如下概念：</strong></p>
<p>​         redo log：保存执行的SQL语句，当MySQL执行recovery时重新执行redo log记录里面的sql操作就好，当客户端每执行一个sql时，先被写到log buffer，当执行commit时，log buffer再被视情况刷新到磁盘</p>
<p>​         undo log：主要是用来回滚，就是复制事务前的数据库内容到undo buffer，再合适的时间undo buffer中的内容刷新到磁盘，它两都是环形缓冲，undo buffer均放在ibd数据文件（表空间）中，undo log被划分为多个段，具体某行的undo log就保存在某段，即<strong>回滚段</strong></p>
<h6 id="当事务1更改此行的值时，会进行如下操作："><a href="#当事务1更改此行的值时，会进行如下操作：" class="headerlink" title="当事务1更改此行的值时，会进行如下操作："></a>当事务1更改此行的值时，会进行如下操作：</h6><p>用排他锁锁定该行</p>
<p>记录redo log</p>
<p>把改行修改前的值copy到undo log</p>
<p>修改当前行的值，填写事务编号，使用回滚指针指向undo log中的修改前的行</p>
<p>​        当有多行修改记录时，通过回滚指针连在一起，可通过当前指针的回滚指针回溯，InnoDB的purge线程，它会查询比现在最老的活动事务还早道德undo log，删除它们</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><strong>未提交读</strong>：就是脏读，事务的修改即使没有提交，对其他事务都是可见的，事务可以读取未提交的数据</li>
<li><strong>提交读</strong>：一个事务所作的操作在提交之前，对其他事务是不可见的，即不可重复读（隔离性）</li>
<li>==<strong>可重复读</strong>==：解决了脏读，该级别保证在同一个事务中多次读取同样的结果是一致的，但是它解决不了幻读，<strong>幻读即在读取数据的时候，另一个事务又插入了 新的记录</strong>，当之前事务再次读取时，产生了幻行，InnoDB的通过<strong>MVCC</strong>解决了幻读</li>
<li><strong>可串行化</strong>：最高的级别，强制事务串行执行，避免了幻读，采用行锁</li>
</ul>
<h4 id="显示隐式锁"><a href="#显示隐式锁" class="headerlink" title="显示隐式锁"></a>显示隐式锁</h4><p>​       采用两阶段锁定协议，在事务执行过程中，随时都能锁，锁只有在执行commit或rollback时才会被释放，所有锁在同一时刻被释放，这是隐式锁定，InnoDB会根据隔离级别自动加锁</p>
<h3 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h3><p>​         它是行级锁的一个变种，通过保存数据在<strong>某个时间点的快照</strong>来实现，更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，每行数据都存在一个版本，每次数据更新时都会更新该版本，各个事务之间无干扰；保存时比较版本号，成功则覆盖，失败则rollback，在默认隔离级别下，MVCC的具体操作(innoDB)： ==InnoDB的MVCC通过在每行记录后面保存两个隐藏的列来实现，一个保存创建时间，一个保存删除时间==</p>
<ul>
<li>select：查找版本早于或=当前事务版本的数据行，确保读取的行在事务开始之前就已经存在，要么是事务自己插入的</li>
<li>insert：为插入的每一行保存当前系统版本号</li>
<li>delete删除每一行保存当前系统版本号为行删除标志</li>
<li>update：保存当前系统版本号，同时保存当前系统版本号到原来的行作为行删除标志</li>
</ul>
<p>​        InnoDB并没有实现核心的饿多版本共存，<strong>undo log里面的内容只是串行化的结果</strong>，不属于多版本共存，当事务影响到多行数据时，MVCC就无能为力，InnoDB只是提供读的非阻塞而已</p>
<h4 id="InnoDB缓存池"><a href="#InnoDB缓存池" class="headerlink" title="InnoDB缓存池"></a>InnoDB缓存池</h4><p>​           缓存索引、缓存行的数据、自适应哈希索引、插入缓冲、锁以及内部数据结构，使用缓存池可以延迟写入，就是合并多个写入操作，然后一起顺序写回，InnoDB严重依赖缓存池</p>
<h4 id="innodb相关磁盘文件："><a href="#innodb相关磁盘文件：" class="headerlink" title="innodb相关磁盘文件："></a>innodb相关磁盘文件：</h4><ul>
<li><ul>
<li>ibdata1:</li>
<li><ul>
<li>回滚段</li>
<li>表元数据</li>
<li>double write</li>
<li>insert buffer dump等</li>
</ul>
</li>
<li>ib_logfile0/1</li>
<li>.frm:表定义文件</li>
<li>.ibd:数据文件,innodb_file_per_table=1</li>
</ul>
<h4 id="性能相关参数："><a href="#性能相关参数：" class="headerlink" title="性能相关参数："></a>性能相关参数：</h4></li>
<li><p>innodb_log_file_size</p>
</li>
<li><p>innodb_log_files_in_group</p>
</li>
<li><p>原因：当redo log 采用轮寻范式ib_logfile0写完，写ib_logfile1完,清楚ib_logfile0并继续写入ib_logfile0;当ib_logfile1写完，ib_logfile0中还有数据没有持久化到磁盘，又来了新的写入，此时会阻塞新写入，强制刷新ib_logfile0到磁盘，再将新写，写入ib_logfile0;这样就是说，logfile越大其写入越不容易阻塞，写入性能也就越好。</p>
</li>
<li><p>数据节点每页16K</p>
</li>
<li><p>innodb数据块缓存池</p>
</li>
<li><p>数据读写经过缓存池</p>
<ul>
<li><p>数据以整页为单位读取</p>
</li>
<li><p>LRU策略（最少使用）换出，</p>
</li>
</ul>
<h4 id="innodb数据持久化：通过事务日志"><a href="#innodb数据持久化：通过事务日志" class="headerlink" title="innodb数据持久化：通过事务日志"></a>innodb数据持久化：通过事务日志</h4></li>
<li><p>innodb_flush_log_at_trx_commit</p>
</li>
<li><ul>
<li>0：每秒写入并持久化一次（不安全，性能高，无论mysql或服务器宕机，都会丢数据），<strong>延迟写</strong></li>
<li>1：每次commit都持久化（安全，性能低，IO负担重）<strong>，实时写，实时刷</strong></li>
<li>2：每次commit都写入内存的redo log缓存，每秒再刷新到磁盘（安全，性能折中，mysql宕机数据不会丢失，服务器宕机数据会丢失），<strong>实时写，延时刷</strong></li>
</ul>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>​         通过事务日志来减少提交事务时的开销，因为事务修改的数据和索引通常会映射到表空间的随机位置，这样刷新到磁盘需要很多随机IO，InnoDB用日志把<strong>随机变为顺序</strong>，InnoDB最后还是把变更写到数据文件，日志有固定的大小，它以<strong>环形方式写入</strong>，写到日志尾部时，会重新跳到头部开始，不会覆盖还没有写入到数据文件的日志记录</p>
<p>​       InnoDB变更任何数据时，会写一条变更记录到内存日志缓冲区，在缓冲区满的时候或事务提交的 时候，InnoDB都会刷写缓冲区的内容到磁盘日志文件，它默认通过一个后台线程来写脏页，并且会合并写入，更有效地顺序写出到磁盘</p>
<p>​        要修改日志文件大小，就要完全关闭MySQL，将旧的日志文件移到其他地方，重新配置参数，然后重启</p>
<h5 id="InnoDB刷新日志缓存"><a href="#InnoDB刷新日志缓存" class="headerlink" title="InnoDB刷新日志缓存"></a>InnoDB刷新日志缓存</h5><p>​       当它把日志缓冲刷新到磁盘日志文件上时，会使用一个Mutex锁住缓冲区，InnoDB有一个group Commit功能，可以在一个IO操作中提交多个事务，</p>
<p>​       <strong>日志缓冲文件写到日志文件</strong>：就是简单地把数据从InnoDB的内存缓冲转移到操作系统的缓存，即内存，并没有真正持久化</p>
<p>​       <strong>把日志刷新到持久化缓存</strong>：这是一个阻塞IO的调用，将缓存刷出缓存，并确认写到磁盘中，直到数据被完全写回才会完成</p>
<h5 id="双写缓存"><a href="#双写缓存" class="headerlink" title="双写缓存"></a>双写缓存</h5><p>​      InnoDB用双写缓存来避免当页没有写完整所导致的数据损坏，保证了数据完整性</p>
<p>​      当InnoDB从缓存池刷新页面到磁盘时，会先把它们放在双写缓冲（<strong>顺序的，只调用一次fsync()</strong>），然后再写到其所属的数据区域，保证每个页面的写入都是完整的并且是持久化的</p>
<p>​      如果一个不完整的页写到了双写缓存，InnoDB恢复时，用原始页面替换掉这个损坏页面</p>
<p>​      如果页的真实位置损坏了，InnoDB恢复时，用双写缓存的页面替换掉这个损坏页面，在每个页面末尾都会有一个校验值，能知道它什么时候损坏</p>
<h4 id="innodb关键特性"><a href="#innodb关键特性" class="headerlink" title="innodb关键特性"></a>innodb关键特性</h4></li>
<li><p>插入缓冲（insert buffer）</p>
</li>
<li><p>两次写（Double write）</p>
</li>
<li><p>自适应哈希索引（adaptive hash index）</p>
</li>
<li><p>异步io（Async IO）</p>
</li>
<li><p>刷新领接页（Flush Neighbor  Page）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQ</title>
    <url>/undefined/MySQL%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h2 id="数据文件："><a href="#数据文件：" class="headerlink" title="数据文件："></a>数据文件：</h2><p>MyISAM：</p>
<ol>
<li><p>frm 文件：存放表结构</p>
<ol start="2">
<li><p>myd 文件：存放表数据</p>
<ol start="3">
<li>myi 文件：存放表索引</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>INNODB：</p>
<ol>
<li>frm 存放表结构</li>
<li>ibd：</li>
</ol>
<h2 id="1-MySQL逻辑架构"><a href="#1-MySQL逻辑架构" class="headerlink" title="1.MySQL逻辑架构"></a>1.MySQL逻辑架构</h2><p>​    <img src="images/1.jpg" alt=""></p>
<p>​    <img src="images/2.jpg" alt=""></p>
<p><strong>连接层：</strong>，所包含的服务并不是MySQL所独有的技术。它们都是服务于C/S程序或者是这些程序所需要的 ：连接处理，身份验证，安全性等等。</p>
<p><strong>服务层</strong>。这是MySQL的核心部分。通常叫做 SQL Layer。在  MySQL据库系统处理底层数据之前的所有工作都是在这一层完成的，包括权限判断， sql解析，行计划优化， query cache  的处理以及所有内置的函数(如日期,时间,数学运算,加密)等等。各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视 图等。</p>
<p><strong>引擎层</strong>：通常叫做StorEngine Layer  ，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。就像Linux众多的文件系统  一样。每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎API来与它们交互的。这个接口隐藏  了各个存储引擎不同的地方。对于查询层尽可能的透明。这个API包含了很多底层的操作。如开始一个事  物，或者取出有特定主键的行。存储引擎不能解析SQL，互相之间也不能通信。仅仅是简单的响应服务器 的请求。</p>
<p><strong>存储层</strong>：数据存储层，主要是将数据存储到运行于裸设备上的文件系统之上，并完成与存储引擎的交互。</p>
<h2 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2.存储引擎"></a>2.存储引擎</h2><h3 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>
<p><img src="images/3.jpg" alt=""></p>
<p>支持八种存储引擎，默认使用<strong>InnoDB</strong>。</p>
<h3 id="2-InnoDB-和-MyISAM"><a href="#2-InnoDB-和-MyISAM" class="headerlink" title="2.InnoDB 和 MyISAM"></a>2.InnoDB 和 MyISAM</h3><h4 id="2-2-1两者的区别："><a href="#2-2-1两者的区别：" class="headerlink" title="2.2.1两者的区别："></a>2.2.1两者的区别：</h4><p><img src="images/4.jpg" alt=""></p>
<h4 id="2-2-2-为什么MyISAM-查询要比-InnoDB-要快"><a href="#2-2-2-为什么MyISAM-查询要比-InnoDB-要快" class="headerlink" title="2.2.2 为什么MyISAM 查询要比 InnoDB 要快"></a>2.2.2 为什么MyISAM 查询要比 InnoDB 要快</h4><p>INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多；<br>    1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少；<br>    2）innodb寻址要映射到块，再到行，MYISAM 记录的直接是文件的OFFSET，定位比INNODB要快<br>    3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护</p>
<p>MVCC ( Multi-Version Concurrency Control )多版本并发控制： </p>
<p>​    InnoDB：<strong>通过为每一行记录添加两个额外的隐藏的值来实现MVCC</strong>，这两个值一个记录这行数据<strong>何时被创建</strong>，另外一个记录这行<strong>数据何时过期（或者被删除）。</strong>但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLE  READ时这种策略是如何应用到特定的操作的：</p>
<p>​    SELECT InnoDB必须每行数据来保证它符合两个条件：</p>
<p>　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。</p>
<p>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。</p>
<h4 id="2-2-3主要区别："><a href="#2-2-3主要区别：" class="headerlink" title="2.2.3主要区别："></a>2.2.3主要区别：</h4><ul>
<li>1).<strong>［事务］</strong>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</li>
<li>2).<strong>［锁］</strong>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li>
<li>3).<strong>［全文索引］</strong>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li>
<li>4).<strong>［查询效率］</strong>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li>
<li>5).<strong>［外健］</strong>MyISAM不支持外健，InnoDB支持。</li>
<li>6).<strong>［count］</strong>==MyISAM保有表的总行数，InnoDB只能遍历==。</li>
<li>6).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li>
<li>7).<strong>InnoDB表比MyISAM表更安全</strong>，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li>
<li><strong>8）MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</strong></li>
<li>具体见：<a href="https://blog.csdn.net/silyvin/article/details/80140153" target="_blank" rel="noopener">https://blog.csdn.net/silyvin/article/details/80140153</a></li>
</ul>
<p><strong>9）InnoDB提供多版本数据支持  <a href="https://blog.csdn.net/zhangliangzi/article/details/51379274，MyIsam不支持" target="_blank" rel="noopener">https://blog.csdn.net/zhangliangzi/article/details/51379274，MyIsam不支持</a></strong></p>
<p><strong>10）两者都仅支持B＋树索引，不支持hash索引</strong></p>
<h4 id="2-2-4应用场景："><a href="#2-2-4应用场景：" class="headerlink" title="2.2.4应用场景："></a>2.2.4应用场景：</h4><ul>
<li>1).MyISAM管理<strong>非事务表</strong>。它提供<strong>高速存储和检索</strong>，以及<strong>全文搜索能力</strong>。如果应用中需要执行<strong>==大量的SELECT查询==</strong>，那么MyISAM是更好的选择。</li>
<li>2).InnoDB用于事务处理应用程序，具有众多特性，包括<strong>ACID事务支持</strong>。如果应用中需要<strong>==执行大量的INSERT或UPDATE操作==，则应该使用InnoDB</strong>，这样可以提高多用户<strong>并发操作的性能</strong>。</li>
</ul>
<h4 id="2-2-5为什么存储要使用B-树"><a href="#2-2-5为什么存储要使用B-树" class="headerlink" title="2.2.5为什么存储要使用B+树"></a>2.2.5为什么存储要使用B+树</h4><p><img src="images/5.jpg" alt=""></p>
<p><img src="images/6.jpg" alt=""></p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>​    B+树是一种<strong>平衡的多路查找树</strong></p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li><p>有n棵子树的结点中含有n个<a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97" target="_blank" rel="noopener">关键字</a>，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
</li>
<li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
<li><p>所有的非终端结点可以看成是<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">索引</a>部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。</p>
</li>
</ol>
<p>人话：</p>
<pre><code>1. 每一个父节点的元素都出现在子节点中，是子节点中最大（最小的）元素。
2. 叶子节点包含了全部的数据信息；
3. 每一个叶子节点都指向了下一个叶子节点，形成了一个有序链表；
4. ==**非叶子节点，只起到索引的作用。**==，不存储数据。
</code></pre><h5 id="优势："><a href="#优势：" class="headerlink" title="==优势：=="></a>==优势：==</h5><ol>
<li><p>单一节点存储更多的元素，使得查询的IO次数更少。</p>
</li>
<li><p>所有查询都要查找到叶子节点，查询性能稳定。</p>
</li>
<li><p>所有叶子节点形成有序链表，便于范围查询。(底部有链表)</p>
</li>
<li>B+树还有一个最大的好处，<strong>方便扫库</strong>，<strong>B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了</strong>，<strong>B+树支持range-query非常方便</strong>，而B树不支持。这是==数据库选用B+树的最主要原因==。</li>
</ol>
<h2 id="3-索引优化分析"><a href="#3-索引优化分析" class="headerlink" title="3.索引优化分析"></a>3.索引优化分析</h2><h3 id="3-1-SQL执行顺序"><a href="#3-1-SQL执行顺序" class="headerlink" title="3.1 SQL执行顺序"></a>3.1 SQL执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	* </span><br><span class="line">from </span><br><span class="line">	&lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line">where</span><br><span class="line">	&lt;where_condition&gt;</span><br><span class="line">group by</span><br><span class="line">	&lt;group_by_list&gt;</span><br><span class="line">having</span><br><span class="line">	&lt;having_condition&gt;</span><br><span class="line">order by</span><br><span class="line">	&lt;order_by_condition&gt;</span><br><span class="line">limit</span><br><span class="line">	&lt;limit_number&gt;</span><br></pre></td></tr></table></figure>
<p><img src="images/7.jpg" alt=""></p>
<h3 id="3-2-7种join理论"><a href="#3-2-7种join理论" class="headerlink" title="3.2 ==7种join理论=="></a>3.2 ==7种join理论==</h3><p><img src="images/8.jpg" alt=""></p>
<p><img src="images/9.jpg" alt=""></p>
<p>表结构：</p>
<p>​    <img src="images/10.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inner join</span><br><span class="line">select * from emp e inner join dept d on  d.id = e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/11.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left join </span><br><span class="line">select * from emp e left join dept d on  d.id = e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/12.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">right join</span><br><span class="line">select * from emp e right join dept d on  d.id = e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/13.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A 的独有（B的 id为 null）</span><br><span class="line">select * from emp e left join dept d on  d.id = e.deptid where d.id is null;</span><br></pre></td></tr></table></figure>
<p><img src="images/14.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B 的独有（A 的id为null）</span><br><span class="line">select * from emp e right join dept d on  d.id = e.deptid where e.id is null;</span><br></pre></td></tr></table></figure>
<p><img src="images/15.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全集</span><br><span class="line"> select * from emp e right join dept d on  d.id = e.deptid</span><br><span class="line"> union</span><br><span class="line"> select * from emp e left join dept d on d.id= e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/16.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A的独有 加上 B的独有</span><br><span class="line">select * from emp e right join dept d on  d.id = e.deptid where e.id is null</span><br><span class="line">union</span><br><span class="line">select * from emp e left join dept d on  d.id = e.deptid where d.id is null;</span><br></pre></td></tr></table></figure>
<p><img src="images/17.png" alt=""></p>
<h3 id="3-3-什么是索引："><a href="#3-3-什么是索引：" class="headerlink" title="3.3  什么是索引："></a>3.3  什么是索引：</h3><p>​    索引是一种数据结构；</p>
<p>​    官方定义：索引是一种帮助MySQL高效获取数据的数据结构。</p>
<p>​    可以简单理解为是一种==排好序的快速查找数据结构==</p>
<p><img src="images/18.png" alt=""></p>
<h4 id="3-3-1-索引的优势劣势"><a href="#3-3-1-索引的优势劣势" class="headerlink" title="3.3.1 索引的优势劣势"></a>3.3.1 索引的优势劣势</h4><p>优点：创建索引可以大大提高系统的性能:<br>    第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>    第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>    第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>    第四，在使用分组和排序 子句进行<a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">数据检索</a>时，同样可以显著减少查询中分组和排序的时间。<br>    第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。     </p>
<p>缺点：</p>
<p>​    第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>​    第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。<br>​    第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 </p>
<h4 id="3-3-2索引的分类"><a href="#3-3-2索引的分类" class="headerlink" title="3.3.2索引的分类"></a>3.3.2索引的分类</h4><ul>
<li>单值索引：即一个索引包含一个列</li>
<li>唯一索引：索引列的值必须唯一</li>
<li>复合索引：一个索引可以包含多个列</li>
</ul>
<h2 id="创建索引-："><a href="#创建索引-：" class="headerlink" title="==创建索引==："></a>==创建索引==：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">create index indesName on tableName(columnName(length));</span><br><span class="line"></span><br><span class="line">alter tableName Add index indexName on (columnName(length));</span><br><span class="line"></span><br><span class="line">删除;</span><br><span class="line">Drop index indexName on tableName；</span><br><span class="line"></span><br><span class="line">查看索引：</span><br><span class="line">show index from tableName;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-那些情况适合建立索引？"><a href="#3-3-3-那些情况适合建立索引？" class="headerlink" title="3.3.3 那些情况适合建立索引？"></a>3.3.3 那些情况适合建立索引？</h4><ol>
<li><strong>主键</strong>建立唯一索引</li>
<li>频繁<strong>作为查询条件</strong>的字段</li>
<li>查询中与其他表有关联的字段，比如<strong>外键</strong>建立索引</li>
<li>查询中<strong>排序的字段</strong>创建索引将大大提高排序的速度</li>
<li>查询中<strong>统计或者分组字段</strong></li>
<li>==高并发的情况下一般选择复合索引==</li>
</ol>
<h4 id="3-3-4-那些情况不适合建立索引？"><a href="#3-3-4-那些情况不适合建立索引？" class="headerlink" title="3.3.4 那些情况不适合建立索引？"></a>3.3.4 那些情况不适合建立索引？</h4><ol>
<li><strong>频繁更新的字段</strong>不适合创建索引，因为每次更新不单单是更新了记录还会更新索引文件。</li>
<li><strong>where条件里用不到的字段</strong>不创建索引</li>
<li><strong>表记录太少</strong>。</li>
<li><strong>数据重复且分布平均的表字段</strong>，因此应该只为最经常查询和最经常排序的数据列建立索引。如果某个数据列包含许多重复的内容，为它建立索引就没太大的实际效果。</li>
</ol>
<h4 id="3-3-5-什么是聚簇索引？什么是非聚簇索引？"><a href="#3-3-5-什么是聚簇索引？什么是非聚簇索引？" class="headerlink" title="3.3.5 什么是聚簇索引？什么是非聚簇索引？"></a>3.3.5 什么是聚簇索引？什么是非聚簇索引？</h4><p>​     在<a href="https://www.baidu.com/s?wd=%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《数据库原理》</a>里面，对聚簇索引的解释是:<strong>聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关</strong>。<strong>==正式因为如此，所以一个表最多只能有一个聚簇索引==</strong>。</p>
<pre><code>不过这个定义太抽象了。在SQL Server中，索引是通过二叉树的数据结构来描述的，我们可以这么理解
</code></pre><p>​    聚簇索引：<strong>索引的叶节点就是数据节点。</strong></p>
<p>​    非聚簇索引：<strong>叶节点仍然是索引节点，只不过有一个指针指向对应的数据块</strong></p>
<h3 id="3-4-性能分析前提"><a href="#3-4-性能分析前提" class="headerlink" title="3.4 性能分析前提"></a>3.4 性能分析前提</h3><ol>
<li><p>MysqI中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行划(<em><u>他认为最优的数据检索方式，<strong>但不见得是DBA认为是最优的</strong>，这部分最耗费时间</u></em>)</p>
</li>
<li><p>当客户端向MySQL请求一条Query,命令解析器模块完成请求分类，区别出是SELECT并转发给MySQLQuery Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些 常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一- 些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息(如果有)，看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p>
</li>
</ol>
<h3 id="3-5explain-命令"><a href="#3-5explain-命令" class="headerlink" title="3.5explain 命令"></a>3.5explain 命令</h3><h4 id="3-5-1-怎么玩？"><a href="#3-5-1-怎么玩？" class="headerlink" title="3.5.1 怎么玩？"></a>3.5.1 怎么玩？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain + SQL 语句</span><br><span class="line">例:</span><br><span class="line">	explain select * from emp;</span><br></pre></td></tr></table></figure>
<p>​    包含的信息：</p>
<p> <img src="images/19.png" alt=""></p>
<h4 id="3-5-2-能干什么？"><a href="#3-5-2-能干什么？" class="headerlink" title="3.5.2 能干什么？"></a>3.5.2 能干什么？</h4><ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以被使用</li>
<li>哪些索引实际被使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="3-5-3-explain-id介绍："><a href="#3-5-3-explain-id介绍：" class="headerlink" title="3.5.3 explain id介绍："></a>3.5.3 explain id介绍：</h4><p>​    select 查询的序列号，包含一组数字，表示查询中执行的select字句或者操作表的顺序。</p>
<p>​    三种情况：</p>
<pre><code>1. id 相同：执行顺序由上至下
2. id 不同：值越大越先执行
3. id 相同 也 不同：值越大越先执行，相同的执行顺序由上至下
</code></pre><p> <img src="images/20.png" alt=""></p>
<p> <img src="images/21.png" alt=""></p>
<p> <img src="images/22.png" alt=""></p>
<h4 id="3-5-4-explain之select-type和table介绍"><a href="#3-5-4-explain之select-type和table介绍" class="headerlink" title="3.5.4 explain之select_type和table介绍"></a>3.5.4 explain之select_type和table介绍</h4><p><strong>table</strong>：显示这一行数据时来自于哪一张表的。</p>
<p>select_type：显示此次查询的类型：</p>
<pre><code>1. simple：简单的 select 查询，其中不包含子查询或者 union
              2. primary：查询中若包含任何复杂的子部分，则最外层被标记为primary
          3. subquery：子查询
                    4. derived：衍生表
        5. union：若第二个select 出现在union 之后 ，则被标记为union
                 6. union result：
</code></pre><h4 id="3-5-5-explain之type介绍"><a href="#3-5-5-explain之type介绍" class="headerlink" title="3.5.5 explain之type介绍"></a>3.5.5 explain之type介绍</h4><p>type代表查询用了何种类型</p>
<p> <img src="images/23.png" alt=""></p>
<p>==从最好到最差依次为：==</p>
<p>​    ==system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all==</p>
<p><strong>一般来说最好达到 range 最好是 ref！</strong></p>
<p>type详解：</p>
<pre><code>1. system：表只有一行记录，这是const类型的特例，平时不会出现，可以忽略不计
2. const：常量查询
3. eq_ref：唯一性索引扫描，常见于主键或者唯一索引
4. ref：非唯一性索引扫描，返回匹配某个值的所有行（本质上也是索引查询），他可能会查出多个行与之匹配；
5. range：范围查询
6. index：遍历索引树
7. all：全表扫描
</code></pre><p> <img src="images/24.png" alt=""></p>
<p> <img src="images/25.png" alt=""></p>
<p> <img src="images/26.png" alt=""></p>
<p> <img src="images/27.png" alt=""></p>
<p> <img src="images/28.png" alt=""></p>
<h4 id="3-5-6-explain之possible-keys和key介绍"><a href="#3-5-6-explain之possible-keys和key介绍" class="headerlink" title="3.5.6 explain之possible_keys和key介绍"></a>3.5.6 explain之possible_keys和key介绍</h4><p>possible_keys：理论上要用到的索引，==实际上并不一定被用到。==</p>
<p>key：实际被用到的索引</p>
<h4 id="3-5-7explain之key-len介绍"><a href="#3-5-7explain之key-len介绍" class="headerlink" title="3.5.7explain之key_len介绍"></a>3.5.7explain之key_len介绍</h4><p>key_len：表示索引中用到的字节数，可以通过该数值计算查询中使用到的索引的长度，<strong>==越小越好==</strong></p>
<p>key_len大，查询的精度一般也大。理论上key_len越小越好，但是查询精度的提高必须得牺牲一定的空间</p>
<p><img src="images/29.png" alt=""></p>
<h4 id="3-5-8-explain之ref介绍"><a href="#3-5-8-explain之ref介绍" class="headerlink" title="3.5.8 explain之ref介绍"></a>3.5.8 explain之ref介绍</h4><p>ref： 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或者常量被用于查找索引列上的值。</p>
<p><img src="images/30.png" alt=""></p>
<p><img src="images/31.png" alt=""></p>
<h4 id="3-5-9-explain之rows介绍"><a href="#3-5-9-explain之rows介绍" class="headerlink" title="3.5.9 explain之rows介绍"></a>3.5.9 explain之rows介绍</h4><p>rows：根据表统计的信息以及索引的选用情况，大致估算出找到所需记录所<strong>==需要读取的行数。==</strong></p>
<p><img src="images/32.png" alt=""></p>
<h4 id="3-5-10-explain之Extra介绍"><a href="#3-5-10-explain之Extra介绍" class="headerlink" title="3.5.10 explain之Extra介绍"></a>3.5.10 explain之Extra介绍</h4><p>主要有以下三种情况：</p>
<p>​    Using filesort：九死一生，使用了文件内排序（<strong>MySQL中无法利用索引完成的排序操作称为:文件排序”</strong>）</p>
<p>​    Using temporary：十死无生，用不上索引，还使用了临时表</p>
<p>​    Using index：发财了，大好事，用上了索引</p>
<h3 id="3-6心法口诀"><a href="#3-6心法口诀" class="headerlink" title="==3.6心法口诀=="></a>==3.6心法口诀==</h3><p>==<strong>全值匹配我最爱，最左前缀要遵守；</strong>==<br><strong>==带头大哥不能死，中间兄弟不能断；==</strong><br><strong>==索引列上少计算，范围之后全失效；==</strong><br><strong>==百分like加右边，覆盖索引不写星；==</strong><br><strong>==不等空值还有or，索引失效要少用；==</strong><br><strong>==字符串里有引号，SQL高级也不难；==</strong></p>
<h3 id="3-7小表驱动大表（exists-和-in）"><a href="#3-7小表驱动大表（exists-和-in）" class="headerlink" title="3.7小表驱动大表（exists 和 in）"></a>3.7小表驱动大表（exists 和 in）</h3><p>永远小表驱动大表！！！<br>select * from emp e where e.deptno in (select deptno from dept d);（in 里面是小表）</p>
<p>select * from emp e where exists (select 1 from dept d where e.deptno = d.deptno);<br>（exists  里面是大表）</p>
<h3 id="3-8-order-by-和-group-by-优化"><a href="#3-8-order-by-和-group-by-优化" class="headerlink" title="3.8 order by 和 group by 优化"></a>3.8 order by 和 group by 优化</h3><p>order by 里面默认是升序 ASC。别跳楼机（上下上下）。</p>
<p>order by 满足以下两种情况会使用useing index：<br>    ==1、order by 语句使用索引最左前列==<br>    ==2、使用 where 字句 和 order by 字句条件列组合满足索引最左前列。==</p>
<h4 id="3-8-1-单路双路算法"><a href="#3-8-1-单路双路算法" class="headerlink" title="3.8.1 单路双路算法"></a>3.8.1 单路双路算法</h4><p>​    order by 双路算法：Mysql4.1之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和ORDER BY列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段。文件的磁盘IO非常耗时的，所以在Mysql4.1之后，出现了第二种算法，就是单路排序。<br>​    <strong>读取两次 排序一次 读取数据一次</strong></p>
<p>​    order by 单路算法：从磁盘读取查询所需要的所有列，按照ORDER BY在buffer对它进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在了内存里。<br>​    <strong>是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序</strong></p>
<p>​    <strong>存在问题</strong>：有可能单路排序算法一次拿不出数据，那么就还比双路排序更消耗IO，效率更慢！<br>在sort_buffer中，单路排序要比双路排序占很多空间，因为单路排序把所有的字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能读取sort_buffer容量大小的数据，进行排序(创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再次排序…从而多次I/O。偷鸡不成蚀把米。<br>​    ==<strong>一次拿不完，需要多拿几次。。。==</strong><br>比如：内存就是2M，一次查1000条数据刚好，也就是最大1000条数据，但是一次要查5000条，那么不够了，照这样需要查5次刚好，如果把2M改为10M，那么就刚好了</p>
<h4 id="3-8-2-如何提高-order-by的速度："><a href="#3-8-2-如何提高-order-by的速度：" class="headerlink" title="3.8.2 如何提高 order by的速度："></a>3.8.2 如何提高 order by的速度：</h4><ol>
<li><p>order by 时select * 不要用，这是一个大忌，要写出只需要query 的字段即可。</p>
<p>​    a：当查询的字段大小综合小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法—单路排序，否则用老算法—多路排序。假设只需要查10个字段，但是SELECT *会查80个字段，那么就容易把sort_buffer缓冲区用满。</p>
<pre><code>b：两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size大小。
</code></pre></li>
<li><p>尝试提高 sort_buffer_size</p>
<p>​    不管用哪种算法，提高这个参数都会提高效率。当然要根据系统能力去提高，因为这个参数是针对每个进程的。</p>
</li>
<li><p>尝试提高 max_length_for_sort_data </p>
<p>​    提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率</p>
</li>
</ol>
<h4 id="3-8-3-order-by-内功心法："><a href="#3-8-3-order-by-内功心法：" class="headerlink" title="3.8.3 order by 内功心法："></a>3.8.3 order by 内功心法：</h4><p>为排序使用索引<br>==MYSQL两种排序方式：文件排序和扫描有序索引排序==<br>==Mysql能为排序和查询使用相同的索引。也就是创建索引先把数据排序了，查询的时候再利用索引，一举两得。==</p>
<p>KEY a_b_c(a,b,c)<br><strong>order by 能使用索引最左前缀</strong></p>
<p>ORDER BY a<br>ORDER BY a,b<br>ORDER BY a,b,c<br>ORDER BY a DESC,b DESC,c DESC</p>
<p><strong>如果where使用索引的最左前缀定义为常量，则order by 能使用索引</strong></p>
<p>WHERE a = const ORDER BY b,c<br>WHERE a = const AND b = const ORDER BY c<br>WHERE a = const AND b &gt; const ORDER BY b,c</p>
<p>不使用索引进行排序</p>
<p>ORDER BY a ASC,b DESC, c DESC //<strong>排序不一致</strong><br>WHERE g = const ORDER BY b,c //<strong>丢失a索引</strong><br>WHERE a = const ORDER BY c //<strong>丢失b索引</strong><br>WHERE a = const ORDER BY a,d //<strong>d不是索引的一部分</strong><br>WHERE a in (….) ORDER BY b,c //<strong>对于排序来说，多个相等条件也是范围查询</strong></p>
<p>GROUP BY的优化</p>
<p>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。<br>当无法使用索隐裂，考虑增大max_length_for_sort_data和sort_buffer_size的参数设置。<br><strong>==WHERE 高于 HAVING，能写在WHERE限定的条件就不要去HAVING限定了。==</strong></p>
<h2 id="4-慢查询日志"><a href="#4-慢查询日志" class="headerlink" title="4.慢查询日志"></a>4.慢查询日志</h2><h3 id="4-1-什么是慢查询日志？"><a href="#4-1-什么是慢查询日志？" class="headerlink" title="4.1 什么是慢查询日志？"></a>4.1 什么是慢查询日志？</h3><p>​    MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中<strong>==响应时间超过阀值==</strong>的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p>
<p>​    <strong>long_query_time的默认值为10</strong>，意思是运行10S以上的语句。</p>
<p>​    <strong>默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数</strong>，<strong>当然，如果不是调优需要的话，一般不建议启动该参数</strong>，因为<strong>开启慢查询日志会或多或少带来一定的性能影响</strong>。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>
<h3 id="4-2-查看慢查询日志是否开启"><a href="#4-2-查看慢查询日志是否开启" class="headerlink" title="4.2 查看慢查询日志是否开启"></a>4.2 查看慢查询日志是否开启</h3><p>​    命令：(<strong>默认关闭的!!如果不是调优需要请不要开启！</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看：</span><br><span class="line">show variables like &apos;%slow_query_log%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="images/33.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置开启：</span><br><span class="line">set global slow_query_log = 1;</span><br></pre></td></tr></table></figure>
<p><img src="images/34.png" alt=""></p>
<p>需要注意的是使用set global slow_query_log=1;开启慢查询日志<strong>==只对当前数据库生效,如果MySQL重启后则会失效。==</strong></p>
<p><strong>一般不建议永久开启慢查询日志，如果一定要做，只能修改配置文件!!</strong>(自行百度)</p>
<h3 id="4-3-设置其他参数"><a href="#4-3-设置其他参数" class="headerlink" title="4.3 设置其他参数"></a>4.3 设置其他参数</h3><h4 id="4-3-1-查看当前默认慢查询时间："><a href="#4-3-1-查看当前默认慢查询时间：" class="headerlink" title="4.3.1 查看当前默认慢查询时间："></a>4.3.1 查看当前默认慢查询时间：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES LIKE &apos;%long_query_time%&apos;；</span><br><span class="line">默认是10秒</span><br></pre></td></tr></table></figure>
<p><img src="images/35.png" alt=""></p>
<p>long_query_time默认是10秒。也就是<strong>==大于10秒==</strong>的sql会记录在慢查询日志中。<strong>非大于等于</strong>。</p>
<h4 id="4-3-2-修改慢查询时间：（需要重连）"><a href="#4-3-2-修改慢查询时间：（需要重连）" class="headerlink" title="4.3.2 修改慢查询时间：（需要重连）"></a>4.3.2 修改慢查询时间：（需要重连）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global long_query_time = 3; 设置慢查询时间为3秒</span><br><span class="line"></span><br><span class="line">show variables like &apos;%long_query_time%&apos;;再次查看 不好使了</span><br><span class="line"></span><br><span class="line">show global variables like &apos;%long_query_time%&apos;;需要这个命令查看</span><br><span class="line"></span><br><span class="line">然后重新连接就好了。</span><br></pre></td></tr></table></figure>
<p><img src="images/36.png" alt=""></p>
<h4 id="4-3-3-查看慢查询条数"><a href="#4-3-3-查看慢查询条数" class="headerlink" title="4.3.3 查看慢查询条数"></a>4.3.3 查看慢查询条数</h4><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show GLOBAL STATUS LIKE &apos;%Slow_queries%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="images/37.png" alt=""></p>
<h4 id="4-3-4-永久生效配置："><a href="#4-3-4-永久生效配置：" class="headerlink" title="4.3.4 永久生效配置："></a>4.3.4 永久生效配置：</h4><p><img src="images/38.png" alt=""></p>
<h3 id="4-4-日志分析工具-mysqldumpslow"><a href="#4-4-日志分析工具-mysqldumpslow" class="headerlink" title="4.4  日志分析工具 mysqldumpslow"></a>4.4  日志分析工具 mysqldumpslow</h3><p>​    在生产环境之中，如果要手工分析日志，查找，分析SQL，显然是一个体力活，MySQL提供了日志分析工具，<strong>mysqldumpslow！</strong></p>
<h4 id="4-4-1-windows怎么做！！"><a href="#4-4-1-windows怎么做！！" class="headerlink" title="4.4.1 windows怎么做！！"></a>4.4.1 windows怎么做！！</h4><p>​    以下是windows环境需要安装其他支持软件的步骤，<strong>非windows直接忽略</strong><br>​    windows要执行mysqldumpslow需要安装ActivePerl因为windows上这是一个perl脚本,需要安装ActivePerl才能执行，linux下就可以直接执行mysqldumpslow了。<br>​    安装ActivePerl的步骤我就不多说了。安装好后会在环境变量PATH中找到perl的bin目录。我重启了电脑让环境变量生效。</p>
<p>验证ActivePerl是否安装成功</p>
<p>​    <img src="images/39.png" alt=""></p>
<h4 id="4-4-2-怎么玩？"><a href="#4-4-2-怎么玩？" class="headerlink" title="4.4.2 怎么玩？"></a>4.4.2 怎么玩？</h4><p><img src="images/40.png" alt=""></p>
<p><img src="images/41.png" alt=""></p>
<h2 id="5-show-profile"><a href="#5-show-profile" class="headerlink" title="5. show profile"></a>5. show profile</h2><h3 id="5-1show-profile-是什么？"><a href="#5-1show-profile-是什么？" class="headerlink" title="5.1show profile 是什么？"></a>5.1show profile 是什么？</h3><p>是MySQL提供用来分析当前会话中语句执行的资源消耗情况，可以用于SQL调优的测量。</p>
<p>默认情况下是关闭的，默认存储最近15条的运行记录。</p>
<h3 id="5-2-怎么玩？"><a href="#5-2-怎么玩？" class="headerlink" title="5.2 怎么玩？"></a>5.2 怎么玩？</h3><ol>
<li>开启功能，默认是关闭的</li>
<li>运行SQL （select * from emp;）</li>
<li>查看结果：show profiles;</li>
<li>进行诊断：show profile cpu，block io for query 上一步前面的问题SQL的号码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">show variables like &apos;profiling&apos;;查看是否开启</span><br><span class="line"></span><br><span class="line">set profiling = on;开启</span><br><span class="line"> </span><br><span class="line">show variables like &apos;profiling&apos;;再次查看</span><br></pre></td></tr></table></figure>
<p><img src="images/42.png" alt=""></p>
<p>运行SQL：</p>
<p><img src="images/43.png" alt=""></p>
<p>==查看结果：==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>
<p><img src="images/44.png" alt=""></p>
<p>进行诊断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profile cpu,block io query 6;</span><br></pre></td></tr></table></figure>
<p><img src="images/45.png" alt=""></p>
<p>show profiles 后面还可以有别的参数：</p>
<p><img src="images/46.png" alt=""></p>
<h3 id="5-3致命伤："><a href="#5-3致命伤：" class="headerlink" title="5.3致命伤："></a>5.3致命伤：</h3><p>那么如何查看show profile + 参数 查询出来的结果呢？</p>
<p><strong>==如果在status出现了以下内容，证明sql可能有问题==</strong></p>
<ol>
<li><p>converting HEAP to MYISAM</p>
</li>
<li><p>Creating tmp table 创建临时表</p>
</li>
<li><p>Copying to tmp table on disk</p>
</li>
<li><p>locked</p>
</li>
</ol>
<h4 id="5-3-1-converting-HEAP-to-MYISAM"><a href="#5-3-1-converting-HEAP-to-MYISAM" class="headerlink" title="5.3.1 converting HEAP to MYISAM"></a>5.3.1 converting HEAP to MYISAM</h4><p>==查询结果太大。内存不够用了，往磁盘上搬了。==</p>
<h4 id="5-3-2-Creating-tmp-table"><a href="#5-3-2-Creating-tmp-table" class="headerlink" title="5.3.2 Creating tmp table"></a>5.3.2 Creating tmp table</h4><p>==创建临时表：==</p>
<p>​    ==拷贝数据到临时表==</p>
<p>​    ==用完再删除==</p>
<h4 id="5-3-3-Copying-to-tmp-table-on-disk"><a href="#5-3-3-Copying-to-tmp-table-on-disk" class="headerlink" title="5.3.3 Copying to tmp table on disk"></a>5.3.3 Copying to tmp table on disk</h4><p>==把内存中临时表复制到磁盘，危险！！！！==</p>
<h4 id="5-3-4-locked（表锁了）"><a href="#5-3-4-locked（表锁了）" class="headerlink" title="5.3.4 locked（表锁了）"></a>5.3.4 locked（表锁了）</h4><h4 id="5-3-5-其他演示："><a href="#5-3-5-其他演示：" class="headerlink" title="5.3.5 其他演示："></a>5.3.5 其他演示：</h4><p><img src="images/47.png" alt=""></p>
<h2 id="6-数据库的锁机制"><a href="#6-数据库的锁机制" class="headerlink" title="6.数据库的锁机制"></a>6.数据库的锁机制</h2><h3 id="6-1-锁的定义"><a href="#6-1-锁的定义" class="headerlink" title="6.1 锁的定义"></a>6.1 锁的定义</h3><p>锁是计算机用来协调多个进程或线程并发访问某一个资源的机制。</p>
<p>在数据库之中，除了传统的计算资源（cpu，RAM，IO等）的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性，有效性是所有数据库，必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁是十分重要的，也十分复杂。</p>
<p><img src="images/48.png" alt=""></p>
<h3 id="6-2锁的分类"><a href="#6-2锁的分类" class="headerlink" title="6.2锁的分类"></a>6.2锁的分类</h3><p>读写锁，行锁，表锁。</p>
<p>读锁（共享锁）：针对同一份数据，多个读操作之间同时进行 不会有任何的影响</p>
<p>写锁（排它锁）：当前操作没有完成的时候，他会阻断其他的写锁和读锁。</p>
<p>表锁（偏读）</p>
<p>行锁（偏写）</p>
<h2 id="7-MyISAM-锁"><a href="#7-MyISAM-锁" class="headerlink" title="7. MyISAM 锁"></a>7. MyISAM 锁</h2><h3 id="7-1-读锁（MyISAM）"><a href="#7-1-读锁（MyISAM）" class="headerlink" title="7.1 读锁（MyISAM）"></a>7.1 读锁（MyISAM）</h3><p>偏向 MyISAM引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率高，并发度最低。</p>
<p>建表：</p>
<p><img src="images/49.png" alt=""></p>
<p><img src="images/50.png" alt=""></p>
<h4 id="7-1-1-手动添加表锁："><a href="#7-1-1-手动添加表锁：" class="headerlink" title="7.1.1 手动添加表锁："></a>7.1.1 手动添加表锁：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock table 表名字  read(write), 表名字2 read(write),其它;</span><br><span class="line"></span><br><span class="line">show open tables;查看表的锁定情况</span><br><span class="line"></span><br><span class="line">lock table mylock read,emp write;</span><br><span class="line">给mylock表加读锁（共享锁），给emp表加写锁（排它锁）</span><br><span class="line"></span><br><span class="line">unlock tables; 释放锁</span><br></pre></td></tr></table></figure>
<p><img src="images/51.png" alt=""></p>
<p><img src="images/52.png" alt=""></p>
<h4 id="7-1-2-读锁场景模拟："><a href="#7-1-2-读锁场景模拟：" class="headerlink" title="7.1.2 读锁场景模拟："></a>7.1.2 读锁场景模拟：</h4><p>给mylock 加上读锁：</p>
<p><img src="images/53.png" alt=""></p>
<p>都可以查互不影响。</p>
<p><strong>尝试session 1 进行update 操作：</strong></p>
<p><img src="images/54.png" alt=""></p>
<p><strong>不可以进行update操作；</strong></p>
<p><strong>尝试session 1 进行select 其他表操作：</strong></p>
<p><img src="images/55.png" alt=""></p>
<p><strong>不可以进行读其他表操作；</strong></p>
<p>尝试 session 2 进行update 操作；</p>
<p><img src="images/56.png" alt=""></p>
<p>session 2 一直处于阻塞状态；</p>
<p><strong>==在session 1解除锁定之后，session 2 才会执行。==</strong></p>
<p><img src="images/57.png" alt=""></p>
<h4 id="7-1-3-读锁总结"><a href="#7-1-3-读锁总结" class="headerlink" title="==7.1.3 读锁总结=="></a>==7.1.3 读锁总结==</h4><table>
<thead>
<tr>
<th>session 1</th>
<th style="text-align:center">session 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以读mylock</td>
<td style="text-align:center">可以读mylock</td>
</tr>
<tr>
<td>不可以读别的表</td>
<td style="text-align:center">可以读别的表</td>
</tr>
<tr>
<td>不可以update mylock</td>
<td style="text-align:center">不可以update（必须等待session 1释放锁）</td>
</tr>
<tr>
<td>不可以update 其他表</td>
<td style="text-align:center">可以update其他表</td>
</tr>
</tbody>
</table>
<p><strong>==一句话：读锁，别的可以读，写要阻塞，自己只能读自己。==</strong></p>
<h3 id="7-2写锁（MyISAM）"><a href="#7-2写锁（MyISAM）" class="headerlink" title="7.2写锁（MyISAM）"></a>7.2写锁（MyISAM）</h3><h4 id="7-2-1-写锁场景模拟"><a href="#7-2-1-写锁场景模拟" class="headerlink" title="7.2.1 写锁场景模拟"></a>7.2.1 写锁场景模拟</h4><p>session 1 给 mylock 加上 写锁；</p>
<p><img src="images/58.png" alt=""></p>
<p>session 1 <strong>可以读 可以写</strong>  <strong>不可以的读其他的</strong></p>
<p><img src="images/59.png" alt=""></p>
<p><img src="images/62.png" alt=""></p>
<p>sessoin 2  <strong>连读都不可以</strong></p>
<p><img src="images/60.png" alt=""></p>
<p>只有在 session 1 释放锁之后才可以查询；</p>
<p><img src="images/61.png" alt=""></p>
<h4 id="7-2-2-写锁总结"><a href="#7-2-2-写锁总结" class="headerlink" title="7.2.2 写锁总结"></a>7.2.2 写锁总结</h4><table>
<thead>
<tr>
<th style="text-align:center">session 1</th>
<th style="text-align:center">session 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可以读mylock</td>
<td style="text-align:center">不可以读mylock</td>
</tr>
<tr>
<td style="text-align:center">不可以读别的</td>
<td style="text-align:center">可以读别的</td>
</tr>
<tr>
<td style="text-align:center">可以update mylock</td>
<td style="text-align:center">不可以update mylock</td>
</tr>
</tbody>
</table>
<p><strong>==一句话总结：写锁，自己只可以自己玩自己的，不能玩别的，别人只能玩别的，不能玩你的。（独占）==</strong></p>
<h3 id="7-3-MyISAM案例总结"><a href="#7-3-MyISAM案例总结" class="headerlink" title="7.3  MyISAM案例总结"></a>7.3  MyISAM案例总结</h3><table>
<thead>
<tr>
<th style="text-align:center">锁类型</th>
<th style="text-align:center">可否兼容</th>
<th style="text-align:center">读锁</th>
<th style="text-align:center">写锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读锁</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">写锁</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>结论:</p>
<p>结合上表,所以对MyISAM表进行操作,会有以下情况:</p>
<p>1、对MyISAM表的读操作(加读锁) ,不会阻塞其他进程对同一表的读请求,但会阻塞对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。</p>
<p>2、对MyISAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作</p>
<p><strong>==简而言之,就是读锁会阻塞写,但是不会堵塞读。而写锁则会把读和写都堵塞,==</strong></p>
<h3 id="7-4-其他查看命令"><a href="#7-4-其他查看命令" class="headerlink" title="7.4 其他查看命令"></a>7.4 其他查看命令</h3><p>看看那些表 被锁了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;table%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="images/63.png" alt=""></p>
<p>解释：</p>
<p>Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每次获取数值加一；<br>Table_locks_waited：出现表级锁定而发生等待的次数（不能立即获取锁，每次等待数值加一），<strong>==此值高说明出现严重的表级锁争用情况。==</strong></p>
<p>show status like ‘table%’;</p>
<p>主要看两行的后一行  Table_locks_waited的值偏大是不好的；</p>
<p><strong>==myisam的读写锁调度是写优先，myisam不适合做写为主表的引擎。写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。==</strong></p>
<h2 id="8-INNODB-锁"><a href="#8-INNODB-锁" class="headerlink" title="8. INNODB 锁"></a>8. INNODB 锁</h2><p><strong>InnoDB与MyISAM的最大不同有两点：一是支持事务，而是采用了行级锁。</strong></p>
<h3 id="8-1-数据库的事务（ACID）："><a href="#8-1-数据库的事务（ACID）：" class="headerlink" title="8.1 数据库的事务（ACID）："></a>8.1 数据库的事务（ACID）：</h3><h4 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h4><p>​    原子性是指事务包含的所有操作<strong>要么全部成功，要么全部失败</strong>回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h4 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h4><p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一<strong>个事务执行之前和执行之后都必须处于一致性状态。</strong></p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h4 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h4><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　关于事务的隔离性数据库提供了<strong>多种隔离级别</strong>，稍后会介绍到。</p>
<h4 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h4><p>　　持久性是指<strong>一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的</strong>，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h3 id="8-2-事务的隔离性"><a href="#8-2-事务的隔离性" class="headerlink" title="8.2 事务的隔离性"></a>8.2 事务的隔离性</h3><p>​    以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h4 id="​8-2-1更新丢失"><a href="#​8-2-1更新丢失" class="headerlink" title="​8.2.1更新丢失"></a>​8.2.1更新丢失</h4><p>​     当两个或多个事务选择同行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。<br>​    例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员<strong>覆盖前一个程序员</strong>所做的更改。</p>
<p><strong>如果在一一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</strong> </p>
<h4 id="8-2-2-脏读"><a href="#8-2-2-脏读" class="headerlink" title="8.2.2 脏读"></a>8.2.2 脏读</h4><p>​    <strong>一个事务读到另外一个事务已经修改还没有提交的数据。</strong>此时如果A事务回滚，那么 B读取到的数据就无效了，不符合一致性。</p>
<h4 id="8-2-3-不可重复读"><a href="#8-2-3-不可重复读" class="headerlink" title="8.2.3 不可重复读"></a>8.2.3 不可重复读</h4><p> 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做“不可重复读”.</p>
<p><strong>事务A读取到了事务B已经提交的修改数据，不符合隔高性</strong></p>
<p><strong>一句话:一个事务先后读取同一条记录，但两次读取的数据不同。</strong></p>
<h4 id="8-2-4-幻读"><a href="#8-2-4-幻读" class="headerlink" title="8.2.4 幻读"></a>8.2.4 幻读</h4><pre><code>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读“；
</code></pre><p><strong>一句话:事务A读取到了事务B体提交的新增数据，不符合隔高性。</strong></p>
<p>多说一句:幻读和脏读有点类似，</p>
<p><strong>==脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。==</strong></p>
<h3 id="8-3-数据库的事务隔离级别"><a href="#8-3-数据库的事务隔离级别" class="headerlink" title="8.3 数据库的事务隔离级别"></a>8.3 数据库的事务隔离级别</h3><p>脏读，幻读 和 不可重复读其实都是数据库一致性问题，必须由数据库提供一定的事务隔离机制来进行解决。</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交（read-uncommitted）</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>​     <strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“==串行化”==进行，这显然与==“并发”==是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力</strong>。</p>
<h4 id="8-3-1-INNODB-RR-隔离级别下-如何-避免幻读的"><a href="#8-3-1-INNODB-RR-隔离级别下-如何-避免幻读的" class="headerlink" title="==8.3.1 INNODB  RR 隔离级别下 如何 避免幻读的=="></a>==8.3.1 INNODB  RR 隔离级别下 如何 避免幻读的==</h4><p><strong>官方文档：在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 gap 锁或者 next-key锁 (行锁+gap锁)。</strong></p>
<ul>
<li><p><strong>其实 就是 通过 快照读（伪MVCC模式） + undo log + read view</strong> </p>
<ul>
<li>TRX_ID(事务 ID),     ROLL_PTR(回滚指针)</li>
</ul>
<p><img src="images/112.png" alt=""></p>
</li>
<li><p><strong>next-key锁（行锁 加上 gap锁）</strong></p>
<ul>
<li>gap 出现的场景<ul>
<li>不走索引（会上锁所有的gap）</li>
<li>where 命中不全（5,7,9 只命中了 5,7） 那么会在 5 - 9 之家加上 gap锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-查看当前事务的隔离级别"><a href="#8-3-1-查看当前事务的隔离级别" class="headerlink" title="8.3.1 查看当前事务的隔离级别"></a>8.3.1 查看当前事务的隔离级别</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;tx_isolation&apos;;</span><br><span class="line">默认是 RR（可重复读） 级别</span><br></pre></td></tr></table></figure>
<p><img src="images/64.png" alt=""></p>
<h4 id="8-3-2-：Spring-中的事务传播行为"><a href="#8-3-2-：Spring-中的事务传播行为" class="headerlink" title="8.3.2 ：Spring  中的事务传播行为"></a>8.3.2 ：Spring  中的事务传播行为</h4><p><strong>在TransactionDefinition接口中定义了七个事务传播行为：</strong></p>
<p>（1）PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 </p>
<p>（2）PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</p>
<p>（3）PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p>（4）PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<p>（5）PROPAGATION_NOT_SUPPORTED  总是非事务地执行，并挂起任何存在的事务</p>
<p>（6）PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常； </p>
<p>（7）PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p>
<h4 id="8-3-3-事务是否只读"><a href="#8-3-3-事务是否只读" class="headerlink" title="8.3.3 事务是否只读"></a>8.3.3 事务是否只读</h4><p><strong>是否只读</strong></p>
<p>​    如果事务只对后端的数据库进行读操作，数据库可以利用事务ID只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让他应用它认为合适的优化措施。因为是否只读是在事务启动的时候由数据库实施的，所以只有对那些具备可能启动一个新事务的传播行为（  PROPAGATION_REQUIRED , PROPAGATION_REQUIRED_NEW , PROPAGATION_NESTED  ）的方法来说，才有意义。</p>
<h4 id="8-3-3-事务超时"><a href="#8-3-3-事务超时" class="headerlink" title="8.3.3 事务超时"></a>8.3.3 事务超时</h4><p>​    为了使应用程序很好地运行，事务不能运行太长时间。因为超时时钟会在事务开始时启动，所以只有对那些具备可能启动一个新事务的传播行为（<br>PROPAGATION_REQUIRED , PROPAGATION_REQUIRED_NEW , PROPAGATION_NESTED<br>）的方法来说，才有意义。</p>
<h4 id="8-3-34-事务回滚"><a href="#8-3-34-事务回滚" class="headerlink" title="8.3.34.事务回滚"></a>8.3.34.事务回滚</h4><p>​    事务回滚规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有在遇到运行时期异常才回滚，而在遇到检查型异常时不会回滚</p>
<ol>
<li>Spring管理事务默认回滚的异常是什么？</li>
</ol>
<p>​      答案是 RuntimeException</p>
<h3 id="8-4-行锁（INNODB）"><a href="#8-4-行锁（INNODB）" class="headerlink" title="8.4 行锁（INNODB）"></a>8.4 行锁（INNODB）</h3><h4 id="8-4-1-行锁案例模拟"><a href="#8-4-1-行锁案例模拟" class="headerlink" title="8.4.1 行锁案例模拟"></a>8.4.1 行锁案例模拟</h4><p>建表，建立索引；</p>
<p><img src="images/65.png" alt=""></p>
<p>演示前先把 autocommit 关闭了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit = 0；</span><br></pre></td></tr></table></figure>
<p><img src="images/66.png" alt=""></p>
<p>模拟开始：</p>
<p><strong>1) session 1 update 一行数据：</strong></p>
<p><img src="images/67.png" alt=""></p>
<p>session 2 查询不到，因为是session 1 <strong>没有提交</strong>；</p>
<p>提交之后：</p>
<p><img src="images/68.png" alt=""></p>
<p><strong>2) session 1 和 session 2 同时 update 同一行数据：</strong></p>
<p><img src="images/69.png" alt=""></p>
<p><strong>session 1 完成了 ，session 2 处于阻塞状态。</strong></p>
<p><strong>3） session 1 和 session 2 同时 update 不同行数据：</strong></p>
<p><img src="images/70.png" alt=""></p>
<p><strong>两个sessionupdate不同的行，不会有冲突</strong></p>
<h4 id="8-4-2-索引失效行锁变表锁"><a href="#8-4-2-索引失效行锁变表锁" class="headerlink" title="==8.4.2 索引失效行锁变表锁=="></a>==8.4.2 索引失效行锁变表锁==</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update test_innodb set a = 41 where b = 4000;  varchar 没加单引号 导致索引失效</span><br><span class="line">update test_innodb set b = &apos;5000&apos; where a= 5; 导致不同行也会阻塞，行锁变为表锁</span><br></pre></td></tr></table></figure>
<p><img src="images/71.png" alt=""></p>
<h4 id="8-4-3-间隙锁的危害"><a href="#8-4-3-间隙锁的危害" class="headerlink" title="8.4.3  间隙锁的危害"></a>8.4.3  间隙锁的危害</h4><p><strong>前提a的值并不是自增的，1,3,4,5,6,7,8,9</strong>(表数据没有 2 )</p>
<p><img src="images/72.png" alt=""></p>
<p>演示：</p>
<p><img src="images/73.png" alt=""></p>
<p>session 1 操作 a&gt;1 and a&lt;6 的数据，虽然没有 2 但是他把2 也锁了，导致session 2 插入阻塞； </p>
<p>  间隙锁:</p>
<p>​      什么是间隙锁？</p>
<p>​      当我们用<strong>范围条件而不是相等条件</strong>检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;<strong>==对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”==</strong>，</p>
<p>​      <strong>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁) 。</strong></p>
<p>​      危害</p>
<p>​      因为Query执行过程中通过过范围查找的话，他<strong>会锁定整个范围内所有的索引键值，即使这个键值并不存在。</strong></p>
<p>​      间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被<strong>无辜的锁定</strong>.而造成在锁定的时候<strong>无法插入锁定键值范围内的任何数据</strong>。在某些场景下这可能会对性能<strong>造成很大的危害</strong></p>
<p>​    ==<strong>简单来说，session1使用了范围条件检索数据，比如id范围在3到10，那么即便id为6的数据不存在，它这不存在的一行也会被锁。如果另一个session想要插入id为6的数据的时候，就会阻塞。</strong>==</p>
<h4 id="8-4-4-如何锁定一行"><a href="#8-4-4-如何锁定一行" class="headerlink" title="8.4.4  如何锁定一行"></a>8.4.4  如何锁定一行</h4><p><img src="images/74.png" alt=""></p>
<p> 三步走：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_innodb where a = 3 for update;</span><br><span class="line">这时候其实已经锁定了某一行</span><br><span class="line">commit;  </span><br><span class="line">提交后就解锁了</span><br></pre></td></tr></table></figure>
<p><img src="images/75.png" alt=""></p>
<p>锁定一行的三步：</p>
<p>begin;</p>
<p><strong>select * from test_innodb_lock where a=8  ==for update==;</strong></p>
<p>这时候其实已经锁定了某一行</p>
<p>commit;  提交后就解锁了</p>
<h4 id="8-4-5-行锁总结"><a href="#8-4-5-行锁总结" class="headerlink" title="8.4.5  行锁总结"></a>8.4.5  行锁总结</h4><p>​      Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在<strong>整体并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统<strong>并发量较高的时候，Innodb的 整体性能和MyISAM相比就会有比较明显的优势了</strong>。</p>
<p>​      但是，Innodb的行级锁定同样也有其脆弱的一面，<strong>当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</strong></p>
<h4 id="8-4-6-查看行锁状态"><a href="#8-4-6-查看行锁状态" class="headerlink" title="8.4.6  查看行锁状态"></a>8.4.6  查看行锁状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;innodb_row_lock%&apos; ;</span><br></pre></td></tr></table></figure>
<p><img src="images/76.png" alt=""></p>
<hr>
<p>各个状态量的说明如下：</p>
<p> Innodb_row_lock_current_waits:当前正在等待的锁定的数量<br> Innodb_row_lock_time：从系统启动到现在，锁定的总时间长度<br> Innodb_row_lock_time_avg：每次等待所花的平均时间<br> Innodb_row_lock_time_max：从系统启动到现在，最长一次等待时间<br> Innodb_row_lock_waits：从系统启动到现在，总等待次数</p>
<p>对于这五个变量，有三个比较重要:</p>
<p><strong>==Innodb_row_lock_current_waits:当前正在等待的锁定的数量==</strong></p>
<p> ==<strong>Innodb_row_lock_waits：从系统启动到现在，总等待次数</strong>==</p>
<p> ==<strong>Innodb_row_lock_time：从系统启动到现在，锁定的总时间长度</strong>==</p>
<h4 id="8-4-7-优化建议"><a href="#8-4-7-优化建议" class="headerlink" title="==8.4.7  优化建议=="></a>==8.4.7  优化建议==</h4><p>1）尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</p>
<p>2）合理设计索引，尽量缩小锁的范围</p>
<p>3）尽可能较少检索条件，避免间隙锁</p>
<p>4）尽量控制事务大小，减少锁定资源量和时间长度</p>
<p>5）尽可能低级别事务隔离</p>
<h3 id="8-5-prepare（预处理）-机制"><a href="#8-5-prepare（预处理）-机制" class="headerlink" title="==8.5  prepare（预处理） 机制=="></a>==8.5  prepare（预处理） 机制==</h3><h4 id="8-5-1-普通流程"><a href="#8-5-1-普通流程" class="headerlink" title="8.5.1 普通流程"></a>8.5.1 普通流程</h4><p>​    指客户端将要执行的SQL发送给服务器，服务器先进行编译后立刻执行</p>
<ul>
<li>mysql客户端发送SQL指令，服务器端接受指令，进行编译执行，返回结果给客户端</li>
<li>客户端接受执行结果，解析结果、</li>
<li>客户端再次发送sql指令(可能相同)，服务器端接受指令，编译执行，返回执行结果</li>
<li>客户端接受执行结果，解析结果</li>
</ul>
<p>​        <strong>这样每条sql语句请求一次，mysql服务器就要接收并处理一次，当一个脚本文件对同一条语句反复执行多次的时候，mysql服务器压力会变大</strong></p>
<h4 id="8-5-2-prepare-流程"><a href="#8-5-2-prepare-流程" class="headerlink" title="8.5.2 prepare 流程"></a>8.5.2 prepare 流程</h4><p>​    是指客户端将要执行的SQL先发送给服务器，服务器先进行编译，不执行。等到客户端要服务端执行时，发送一条执行指令，让服务器执行已经提前处理好的SQL指令是减轻服务器压力的一种技术。</p>
<ul>
<li><p>mysql客户端发送SQL指令(预处理包装)，服务器端接受指令，进行编译，返回预处理编译结果</p>
</li>
<li><p>客户端接受编译结果，解析结果，发送预处理执行指令</p>
</li>
<li><p>服务器端接受指令，执行编译后的预处理指令，返回执行结果</p>
</li>
<li><p>客户端接受执行结果，解析结果</p>
</li>
</ul>
<p>==<strong>其实就是省去了 编译的时间。</strong>==</p>
<h4 id="8-5-3-prepare-如何操作"><a href="#8-5-3-prepare-如何操作" class="headerlink" title="8.5.3 prepare 如何操作"></a>8.5.3 prepare 如何操作</h4><p>   将sql语句强制一分为二：</p>
<ul>
<li>第一部分为前面相同的命令和结构部分</li>
<li>第二部分为后面可变的数据部分</li>
</ul>
<p>​    在执行sql语句的时候，首<strong>先将前面相同的命令和结构部分发送给MySQL服务器</strong>，让MySQL服务器事先进行一次预处理（此时并没有真正的执行sql语句），而为了保证sql语句的结构完整性，在<strong>第一次发送sql语句</strong>的时候将其中可变的数据部分都用一个数据占位符来表示！比如问号？就是常见的数据<strong>占位符</strong>！</p>
<h4 id="8-5-4-预处理实现"><a href="#8-5-4-预处理实现" class="headerlink" title="8.5.4 预处理实现"></a>8.5.4 预处理实现</h4><p>1、 设置语句</p>
<p>2、set 值</p>
<p>3、 EXECUTE 执行</p>
<p>4、 删除 PREPARE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; PREPARE prod FROM &quot;INSERT INTO examlple VALUES(?,?)&quot;; </span><br><span class="line">mysql&gt; SET @p=&apos;1&apos;; </span><br><span class="line">mysql&gt; SET @q=&apos;2&apos;; </span><br><span class="line">mysql&gt; EXECUTE prod USING @p,@q; </span><br><span class="line">mysql&gt; SET @name=&apos;3&apos;; </span><br><span class="line">mysql&gt; EXECUTE prod USING @p,@name; </span><br><span class="line">mysql&gt; DEALLOCATE PREPARE prod;</span><br></pre></td></tr></table></figure>
<p>​    <strong>每一次执行完EXECUTE时，须执行DEALLOCATE PREPARE … 语句</strong>，这样可以释放执行中使用的所有<strong>数据库资源（如游标）</strong>，不仅如此，如果一个session的预处理<strong>语句过多</strong>，可能会达到max_prepared_stmt_count的上限值</p>
<h4 id="8-5-5-预处理优点"><a href="#8-5-5-预处理优点" class="headerlink" title="==8.5.5 预处理优点=="></a>==8.5.5 预处理优点==</h4><ul>
<li>预处理的执行效率相对于一般的sql执行操作，<strong>效率比较高</strong>,因为第二次执行只需要发送查询的参数，而不是整个语句</li>
<li>由于每次执行预处理语句时仅需发送参数的数据，从而减少了<strong>网络通信量</strong></li>
<li>使用PAREPARE STATEMENT可以<strong>减少每次执行SQL的语法分析</strong></li>
<li>预处理可以<strong>防止sql注入</strong>，因为预处理将sql语句与数据分开发送</li>
</ul>
<h2 id="9-mysql-主从复制"><a href="#9-mysql-主从复制" class="headerlink" title="9.mysql 主从复制"></a>9.mysql 主从复制</h2><p>.</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/undefined/NIO/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>java.io中最为核心的一个概念是流（stream），面向流编程。Java中，一个流要么是输入流，要么是输出流，不可能同时既是输入流同时又是输出流。</p>
<p>java.nio中拥有3个核心概念：Selector、Channel和Buffer。在java.nio中，我们是面向块（block）或缓冲区（buffer）编程。Buffer本身就是一块内存，底层实现上实际是一个数组。数据的读写都是通过Buffer来实现。</p>
<p>Java中提供7种原生数据类型都各自对应的Buffer类型。如IntBuffer、LongBuffer、ByteBuffer及CharBuffer等。但是没有BooleanBuffer类型。</p>
<p>Channel指的是可以向其写入数据或从中读取数据的对象，它类似于java.io中的Stream。所有数据的读写都是通过Buffer来进行的，永远不会出现直接向Channel写入数据或直接从Channel中读取数据的情况。</p>
<p>和Stream不同的是，Channel是双向的，一个流只可能是InputStream或OutputStream，Channel打开后则可以进行读取、写入或读写。</p>
<p>由于Channel是双向的，因此它能够更好的反映出底层操作系统的真实情况；在Linux系统中，底层操作系统的通道就是双向的。</p>
<blockquote>
<p>提示：Channel和Buffer总是在一起use的。</p>
</blockquote>
<p>NIO Buffer中3个重要状态属性的含义</p>
<pre><code>1. postion 2. limit 3. capacity

    0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity
</code></pre><p>通过NIO读取文件涉及到的3个步骤：</p>
<pre><code>1. 从FileInputStream获取到FileChannel对象。

2. 创建Buffer。

3. 将数据从Channel读取到Buffer中。
</code></pre><p>flip()方法作用</p>
<pre><code>1. 将limit值设置为当前的position

2. 将position设置为0
</code></pre><p>clear()方法</p>
<pre><code>1. 将limit值设置为capacity

2. 将position值设置为0
</code></pre><p>compact()方法</p>
<pre><code>1. 将所有未读的数据复制到buffer起始位置处

2. 将position设为最后一个未读元素的后面

3. 将limit设置为capacity

4. 现在buffer准备好，但是不会覆盖未读的数据
</code></pre><hr>
<h3 id="DirectBuffer-零拷贝"><a href="#DirectBuffer-零拷贝" class="headerlink" title="DirectBuffer | 零拷贝"></a>DirectBuffer | 零拷贝</h3><p>DirectByteBuffer 自身是（Java）堆上面对象，它背后真正承载数据的buffer是在（Java）堆外（native memory）中的。这是malloc()方法分配出来的内存，是用户态的。</p>
<h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><h4 id="Scattering-Gathering"><a href="#Scattering-Gathering" class="headerlink" title="Scattering | Gathering"></a>Scattering | Gathering</h4><h3 id="NIO-创建客户端"><a href="#NIO-创建客户端" class="headerlink" title="NIO 创建客户端"></a>NIO 创建客户端</h3><p>Java在创建客户端时</p>
<pre><code>1. 首先调用静态工厂方法SocketChannel.open()来创建一个新的 java.nio.channels.SocketChannel对象。该方法的参数是：java.net.SocketAddress对象，只是连接的主机和端口。

2. 通道以阻塞模式打开
</code></pre><h4 id="NIO零拷贝"><a href="#NIO零拷贝" class="headerlink" title="NIO零拷贝"></a>NIO零拷贝</h4><h5 id="传统的IO操作（OIO）"><a href="#传统的IO操作（OIO）" class="headerlink" title="传统的IO操作（OIO）"></a>传统的IO操作（OIO）</h5><p>内核空间 | 用户空间 | 硬件</p>
<p>1.读操作</p>
<p>Java虚拟机开始读操作，告知用户空间开始读操作，从而用户空间切换到内核空间，然后内核空间从硬件读取数据到内核空间的缓冲区，然后内核空间的数据原封不动拷贝到用户空间的缓存区中，然后在用户空间执行数据操作。</p>
<p>2.写操作</p>
<p>Java虚拟机调用write操作，将数据从用户空间拷贝到内核空间的缓存区，然后再由内核空间的缓存区拷贝到硬件。完成数据操作。</p>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p>零拷贝，没有从内核空间与用户空间的数据相互缓存。</p>
<p>内核空间收到用户空间的sendfile()操作，然后内核空间向硬件要数据，然后硬件将数据传送给内核空间的缓存区。然后写数据到目标socket的缓存区。然后返回sendfile()信息。</p>
<p>用户空间内存映射到内核空间，只在内核空间进行数据操作。</p>
<hr>
<h3 id="Reactor模式（反应器模式）"><a href="#Reactor模式（反应器模式）" class="headerlink" title="Reactor模式（反应器模式）"></a>Reactor模式（反应器模式）</h3><p>类似的模式 Proactor模式</p>
<p>Netty整体架构是Reactor模式的完整体现。</p>
<p>Reactor设计模式会设立一些服务请求，处理由一个或多个客户端并发发送的的处理请求。</p>
<h4 id="多线程IO致命缺陷"><a href="#多线程IO致命缺陷" class="headerlink" title="多线程IO致命缺陷"></a>多线程IO致命缺陷</h4><p>在最原始的网络编程思路就是服务器用一个while循环，不断监听端口是否有新的套接字连接，如果有，那么就调用一个处理函数处理。</p>
<pre><code>while(true){
    socket = accept();
    handle(socket);
}
</code></pre><p>这种方法的最大问题是无法并发，效率太低。如果当前的请求没有处理完，那么后面的请求只能被阻塞，服务器的吞吐量太低。然后在之后，想到了使用多线程，也就是很经典的connection per thread，每一个连接用一个线程处理。</p>
<pre><code>class BasicModel implements Runnable {
    public void run() {
        try {
            ServerSocket ss =
                    new ServerSocket(SystemConfig.SOCKET_SERVER_PORT);
            while (!Thread.interrupted())
                new Thread(new Handler(ss.accept())).start();
            //创建新线程来handle
            // or, single-threaded, or a thread pool
        } catch (IOException ex) { /* ... */ }
    }

    static class Handler implements Runnable {
        final Socket socket;
        Handler(Socket s) { socket = s; }
        public void run() {
            try {
                byte[] input = new byte[SystemConfig.INPUT_SIZE];
                socket.getInputStream().read(input);
                byte[] output = process(input);
                socket.getOutputStream().write(output);
            } catch (IOException ex) { /* ... */ }
        }
        private byte[] process(byte[] input) {
            byte[] output=null;
            /* ... */
            return output;
        }
    }
}
</code></pre><p>在上面对于每一个请求都分配一个线程，每个线程都独自处理上面的流程。</p>
<h5 id="1-多线程并发模式的优点"><a href="#1-多线程并发模式的优点" class="headerlink" title="1. 多线程并发模式的优点"></a>1. 多线程并发模式的优点</h5><p>在一定程度上极大地提高了服务器的吞吐量，因为之前的请求在read阻塞以后，不会影响到后续的请求，因为他们在不同的线程中。</p>
<h5 id="2-多线程并发模式的缺点"><a href="#2-多线程并发模式的缺点" class="headerlink" title="2. 多线程并发模式的缺点"></a>2. 多线程并发模式的缺点</h5><p>在于资源要求太高，系统中创建线程是需要比较高的系统资源的，如果连接数太高，系统无法承受，而且线程的反复创建-销毁也需要代价。</p>
<p>改进的方案便是：采用基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。使用Reactor模式，对线程的数量进行控制，一个线程处理大量的事件。</p>
<h4 id="Dispatch-Notifier-模式"><a href="#Dispatch-Notifier-模式" class="headerlink" title="Dispatch | Notifier 模式"></a>Dispatch | Notifier 模式</h4><p>在Java的NIO模式的Selector网络通讯就是一个简单的Reactor模型，是Reactor模型的朴素原型。</p>
<p>客户端连接到Reactor对象，然后Reactor对象派发客户端的请求到各个处理线程。Reactor本身不做任何操作，只是做一个中间商派发处理客户端各种请求。</p>
<blockquote>
<p>提示：实际上Reactor模式是基于Java NIO的，在它的基础上抽象出来两个组件：Reactor和Handler两个组件。</p>
</blockquote>
<blockquote>
<blockquote>
<p>Reactor 负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler处理。新的事件包括连接建立就绪、读就绪、写就绪等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Handler 负责将自身（handler）与事件绑定，负责事件的处理，完成Channel的读入，完成处理业务逻辑后负责将结果写出channel。</p>
</blockquote>
</blockquote>
<h4 id="1-Reactor1-Setup"><a href="#1-Reactor1-Setup" class="headerlink" title="1. Reactor1 - Setup"></a>1. Reactor1 - Setup</h4><pre><code>class Reactor implements Runnable {
    final Selector selector;
    final ServerSocketChannel serverSocketChannel;

    Reactor(int port) throws IOException {
        selector = Selector.open();
        serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().bind(new InetSocketAddress(port));
        serverSocketChannel.configureBlocking(false);//非阻塞
        SelectionKey sk = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//注册到selector上并处于等待客户端连接

        sk.attach(new Acceptor());//向其附加上任意的对象
    }
}
</code></pre><h4 id="2-Reactor2-Dispatch-Loop"><a href="#2-Reactor2-Dispatch-Loop" class="headerlink" title="2. Reactor2 - Dispatch Loop"></a>2. Reactor2 - Dispatch Loop</h4><pre><code>//thread
public void run(){
    try{
        while(!Thread.interrupted()){
            selector.select();
            Set selected = selector.selectedKeys();
            Iterator it = selected.iterator();
            while(it.hasNext()){
                dispatch((SelectionKey)(it.next()));//分发
                selected.clear();//处理的selector要清除掉
            }
        }
    }catch(IOException e){

    }
}

void dispatch(SelectionKey k){
    Runnable r = (Runnable) k.attachement();//获取之前attach()方法添加的对象
    if(r != null){
        r.run();
    }
}
</code></pre><h4 id="3-Reactor3-Acceptor"><a href="#3-Reactor3-Acceptor" class="headerlink" title="3. Reactor3 - Acceptor"></a>3. Reactor3 - Acceptor</h4><pre><code>class Acceptor implements Runnable {
    public void run(){
        try{
            SocketChannel c = serverSocketChannel.accept();
            if(c != null){
                new Handler(selector, c);//自定义handler或netty提供的
            }
        }catch(Exception e){

        }
    }
}
</code></pre><h4 id="4-Reactor4-Handler-Setup"><a href="#4-Reactor4-Handler-Setup" class="headerlink" title="4. Reactor4 - Handler Setup"></a>4. Reactor4 - Handler Setup</h4><pre><code>final class Handler implements Runnable {
    final SocketChannel socket;
    final SelectionKey sk;
    ByteBuffer input = ByteBuffer.allocate(MAXIN);
    ByteBuffer output = ByteBuffer.allocate(MAXOUT);

    static final int READING = 0, SENDING = 1;
    int state = READING;

    Handler(Selector sel, SocketChannel c){
        socket = c;
        c.configureBlocking(false);
        sk = socket.register(sel, 0);
        sk.attach(this);
        sk.interestOps(SelectionKey.OP_READ);
        sel.wakeup();
    }
}
</code></pre><h4 id="5-Reactor5-Request-handing"><a href="#5-Reactor5-Request-handing" class="headerlink" title="5. Reactor5 - Request handing"></a>5. Reactor5 - Request handing</h4><pre><code>public void run(){
    try{
        if(state == READING) read();
        else if(state == SENDING) send();
    }catch(IOException e){

    }
}

void read(){
    socket.read(input);
    if(inputIsComplete()){
        process();
        state = SENDING;
        sk.interestOps(SelectionKey.OP_WRITE);
    }
}

void send(){
    socket.write(output);
    if(outputIsComplete()){
        sk.cancel();
    }
}
</code></pre><h4 id="Reactor编程的优缺点"><a href="#Reactor编程的优缺点" class="headerlink" title="Reactor编程的优缺点"></a>Reactor编程的优缺点</h4><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><pre><code>1. 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的。

2. 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销

3. 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源

4. 可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性
</code></pre><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><pre><code>1. 相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。
</code></pre><hr>
<h4 id="BossGrouo-WorkerGroup-监听过程"><a href="#BossGrouo-WorkerGroup-监听过程" class="headerlink" title="BossGrouo | WorkerGroup 监听过程"></a>BossGrouo | WorkerGroup 监听过程</h4><pre><code>1. 首先存在多个客户端等待连接

2. 然后BossGroup监听OP_ACCEPT事件，一旦该事件被监听到之后就会将其注册到Selector中，并返回SelectionKey（包含了Selector的属性）集合，然后SelectionKey本身包装了SocketChannel对象（是与客户端真正建立连接的对象）

3. 对于netty对象而言，又会将SocketChannel对象包装成NioSocketChannel对象

4. 接着将NioSocketChannel注册到Worker当中的Selector选择器上面，而此选择器本身却是监听了READ事件本身的。那么接下来客户端有什么请求，就会直接跟workerGroup打交道。
</code></pre>]]></content>
      <categories>
        <category>Java NIO</category>
      </categories>
      <tags>
        <tag>Java NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-Apache</title>
    <url>/undefined/Nginx-Apache/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Nginx-Apache"><a href="#Nginx-Apache" class="headerlink" title="Nginx-Apache"></a>Nginx-Apache</h2><p>[TOC]</p>
<h3 id="Apache较Nginx的优点"><a href="#Apache较Nginx的优点" class="headerlink" title="Apache较Nginx的优点"></a>Apache较Nginx的优点</h3><pre><code>1. rewrite功能比Nginx强大

2. 动态页面，Nginx处理动态请求是鸡肋，移动动态请求要Apache去做，Nginx只适合于静态和反向

3. 模块较于Nginx多
</code></pre><h3 id="Nginx较Apache优点"><a href="#Nginx较Apache优点" class="headerlink" title="Nginx较Apache优点"></a>Nginx较Apache优点</h3><pre><code>1. 轻量级，较Apache占用更少的内存及资源，支持更多的并发连接，体现更高的效率

2. 抗并发，Nginx处理请求是异步非阻塞的，Apache是阻塞型的，在高并发下Nginx能保持低资源低消耗高性能

3. Nginx本身就是一个反向代理服务器

4. 负载均衡能力突出
</code></pre><blockquote>
<p>Apache与Nginx核心区别：Apache是同步多线程模型，一个连接对应一个进程。Nginx是异步的，多个连接可以对应一个进程。</p>
</blockquote>
]]></content>
      <categories>
        <category>Nginx-Apache</category>
      </categories>
      <tags>
        <tag>Nginx-Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/undefined/Netty/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>[TOC]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>官方定义，它是一个异步的，基于时间Client/Server的网络框架，目标是提供一种简单、快速构建网络应用的方式，同时保证高吞吐量、低延时、高可靠性。</p>
<blockquote>
<p>提示：Netty其实就是一个NIO框架，它适用于服务器通讯相关的多种应用场景，主要还是针对于TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。</p>
</blockquote>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO，非阻塞IO，在JAVA中NIO的核心就是Selector机制。简单而言，创建一个Socket Channel，并将其注册到一个Selector上（多路复用器），这个Selector将会“关注”Channel上发生的IO读写事件，并在事件发生（数据就绪）后执行相关的处理逻辑。对于阻塞IO，它需要在read()、write()操作上阻塞而直到数据操作完毕，但是NIO则不需要，只有当Selector检测到此Channel上有事件时才会触发调用read、write操作。</p>
<blockquote>
<p>提示：NIO本身不是严格意义上的异步IO，最大的原因是因为Selector本身是阻塞的（selector需要通过线程阻塞的方式（其select方法）获取底层通道的事件变更，然后获取SelectionKey列表）。</p>
</blockquote>
<blockquote>
<blockquote>
<p>总结：我觉得最好的学习方式就是学好netty包里面的所有example代码。</p>
</blockquote>
</blockquote>
<h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>通道，一个逻辑通道，维护Socket上IO的write、read、connect等相关操作。我们可以看到Bootstrap、ServerBootstrap初始化之后都需要在channel(Channel channel)方法中指定内部需要创建的channel类型。</p>
<blockquote>
<p>提示：Channel中所有的操作均是异步的，IO操作都会返回一个ChannelFuture实例</p>
</blockquote>
<p> Channel接口中还包含了一个子接口：Unsafe；这个Unsafe和JDK自带的Unsafe没有关系，Netty中的Unsafe只是框架内部使用，主要用来操作底层的Socket，比如connect、close、read、write；即Channel接口中有关底层Socket操作的，将会有Unsafe来操作javaChannel()即可。</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>ChannelFuture表示Channel IO异步操作的结果。IO调用方法立即返回，但此时并不表示IO实际操作已经实际执行结束，只是返回一个ChannelFuture实例，具体执行的结果状态可以通过检测Future才能得到。</p>
<pre><code>boolean isDone()：操作是否完成，completed 还是 uncompleted

boolean isCanclled()：如果Future已经完成，则判断操作是否被取消。

boolean isSuccess()：同上。

Throwable cause()：如果执行失败，此处可以获取导致失败的exception信息。

ChannelFuture await()：等待，直到异步操作执行完毕，内部基于wait实现。

ChannelFuture sync()：等待，直到异步操作执行完毕，核心思想同await。我们得到Future实例后，可以使用sync()方法来阻塞当前线程，直到异步操作执行完毕。和await的区别为，如果异步操作失败，那么将会重新抛出异常（将上述cause()方法中的异常抛出）。await和sync一样，当异步操作执行完毕后，通过notifyAll()唤醒。

ChannelFuture addListener(GenericFutureListener listener)：向Future添加一个listener，当异步操作执行完毕后（无论成败），会依次调用listener的operationCompleted方法。
</code></pre><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>我们可以简单的认为EventLoopGroup是一个线程池调度服务，这和我们常用的FixedThreadPool在设计思想上没有太大区别；在Netty中比较常用的子类就是NioEventLoopGroup，它继承了ScheduledExecutorService。我们在创建NioEventLoopGroup时，可以指定线程池的容量，默认为：CPU处理器个数 * 2。</p>
<p>在NioEventLoop创建实例时会同时创建一个Selector，即每个NioEventLoop都持有一个Selector实例。由此可见，NioEventLoopGroup的线程池容量，就是线程的个数，也是Bootstrap中持有的Selector的数量。</p>
<p>每个NioEventLoop实例内部Thread负责select多个Channel的IO事件（NIO Selector.select），如果某个Channel有事件发生，则在内部线程中直接使用此Channel的Unsafe实例进行底层实际的IO操作。简单而言，就是让每个NioEventLoop管理一组Channel。</p>
<p>在ServerBootstrap中，创建两个NioEventLoopGroup，其中“bossGroup”为Acceptor 线程池，这个线程池只需要一个线程（大于1，事实上没有意义），它主要是负责accept客户端链接，并创建SocketChannel，此后从“workerGroup”线程池（reactor）中以轮询的方式(next)取出一个NioEventLoop实例，并将此Channel注册到NioEventLoop的selector上，此后将由此selector负责监测Channel上的读写事件（并由此NioEventLoop线程负责执行）。</p>
<p>由此可见，对于ServerBootstrap而言，bossGroup中的一个线程的selector只关注SelectionKey.OPT_ACCEPT事件。</p>
<h4 id="EventLoop-线程模型"><a href="#EventLoop-线程模型" class="headerlink" title="EventLoop | 线程模型"></a>EventLoop | 线程模型</h4><h3 id="ChannelHandler-Pipeline"><a href="#ChannelHandler-Pipeline" class="headerlink" title="ChannelHandler | Pipeline"></a>ChannelHandler | Pipeline</h3><pre><code>@Sharable 表示一个ChannelHandler可以被多个Channel安全的共享
</code></pre><p>在Netty中，从Socket通道中read数据进入Netty Handler的方向为inbound，从Netty handler向Socket通道write数据的方向为outbound。</p>
<h4 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h4><h5 id="void-channelRegistered-ChannelHandlerContext-ctx"><a href="#void-channelRegistered-ChannelHandlerContext-ctx" class="headerlink" title="void channelRegistered(ChannelHandlerContext ctx)"></a>void channelRegistered(ChannelHandlerContext ctx)</h5><p>当channel注册成功后执行，即channel绑定到NioEventLoop上，且将Channel注册到selector之后执行。</p>
<h5 id="void-channelActive-ChannelHandlerContext-ctx"><a href="#void-channelActive-ChannelHandlerContext-ctx" class="headerlink" title="void channelActive(ChannelHandlerContext ctx)"></a>void channelActive(ChannelHandlerContext ctx)</h5><p>channel注册首次成功后执行，即channelRegistered方法执行后调用。</p>
<h5 id="void-channelRead-ChannelHandlerContext-ctx-Object-msg"><a href="#void-channelRead-ChannelHandlerContext-ctx-Object-msg" class="headerlink" title="void channelRead(ChannelHandlerContext ctx,Object msg)"></a>void channelRead(ChannelHandlerContext ctx,Object msg)</h5><p>socket将已经读取到数据传递给handler，此方法在NIO中READ事件触发后并读取到任意字节数据后被fire</p>
<h5 id="void-channelReadComplete-ChannelHandlerContext-ctx"><a href="#void-channelReadComplete-ChannelHandlerContext-ctx" class="headerlink" title="void channelReadComplete(ChannelHandlerContext ctx)"></a>void channelReadComplete(ChannelHandlerContext ctx)</h5><p>read操作结束后调用；read数据首先被添加到Bytebuf中，如果这个Bytebuf已满，则会终止read操作，调用此方法。</p>
<h4 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h4><h5 id="void-read-ChannelHandlerContext-ctx"><a href="#void-read-ChannelHandlerContext-ctx" class="headerlink" title="void read(ChannelHandlerContext ctx)"></a>void read(ChannelHandlerContext ctx)</h5><p>…</p>
<blockquote>
<p>总结：Channel创建后，初始化其pipeline，当Channel注册到Selector后（包括绑定到NioEventLoop线程），执行ChannelInitializer这个特殊的handler并将开发者指定的其他多个handler添加到pipeline中；当NioEventLoop线程中，selector检测到NIO事件后，将会依次执行此Channel pipeline中的相应的fire方法（比如fireChannelRead()）,那么fire方法将会从head或者tail这两个特殊的handler开始，依次调用pipeline中其他handler的实际方法（比如channelRead()）。</p>
</blockquote>
<blockquote>
<p>注意：pipeline中的某个handler认为操作需要继续传递下去，那么在此handler的实际业务执行完毕之后要通过调用ChannelHandlerContext相应的fire方法，将事件继续传递给下一个handler；如果没有调用fire方法，那么此事件将会被终止。</p>
</blockquote>
<hr>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>该协议是完全重新设计的协议，旨在为了Web上的双向数据传输问题提供一个解决方案，可以让客户端与服务器之间在任意时刻传输消息。此要求它们能够异步处理消息回执。</p>
<h3 id="添加WebSocket支持"><a href="#添加WebSocket支持" class="headerlink" title="添加WebSocket支持"></a>添加WebSocket支持</h3><p>在从标准的HTTP或HTTPS协议切换到WebSocket时，将会使用一种称为升级握手的机制。因此在使用WebSocket应用程序将始终以HTTP/S作为开始，然后再执行升级。</p>
<p>我们应用程序将采用下面的约定：如果被请求的URL以/ws结尾，那我们将会把该协议升级为WebSocket。否则服务器将使用基本的HTTP/S。</p>
<p>在连接完成升级之后，所有数据传输都将使用WebSocket进行。</p>
<blockquote>
<p>WEBSOCKET帧 WebSocket以帧的方式进行传输数据，每一帧代表消息的一部分。一个完整的消息可能包含许多帧。</p>
</blockquote>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>RMI:remote method invocation 只针对Java</p>
<pre><code>client 

server
</code></pre><p>序列化与反序列化：或叫做编码与解码。</p>
<p>RPC Remote Procedure Call 远程过程调用 很多RPC框架是跨语言的。</p>
<pre><code>1. 定义一个接口说明文件：描述了对象（结构体）、对象成员、接口方法等一系列信息。

2. 通过RPC框架所提供的编译器，将接口说明文件编译成具体的语言文件。

3. 在客户端与服务器端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用远程方法。
</code></pre><blockquote>
<p>提示：在idea引入protobuf的时候注意pc上安装的protobuf版本号与gradle引入的版本号的一致性。</p>
</blockquote>
<h5 id="protobuf工程中使用git作为版本控制系统："><a href="#protobuf工程中使用git作为版本控制系统：" class="headerlink" title="protobuf工程中使用git作为版本控制系统："></a>protobuf工程中使用git作为版本控制系统：</h5><pre><code>1. git submodule git仓库里面的一个仓库

    这一命令可以关联到一个新的git仓库，是专门用来存放protobuf项目的。

    在原先的工程里面生成了一个protobuf工程，在新生成的protoc编译之后的文件放在对一个的仓库下面

2. git subtree 类似于git submodule

    这一命令是将这一仓库pull到该项目，但是是在合并而不是分成两个
</code></pre><h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h2><h3 id="Thrift-传输格式"><a href="#Thrift-传输格式" class="headerlink" title="Thrift 传输格式"></a>Thrift 传输格式</h3><pre><code>1. TBinaryProtocol 二进制格式

2. TCompactProtocol 压缩格式

3. TJSONProtocol JSON格式

4. TSimpleJSONProtocol 提供JSON只写协议，生成的文件很容易通过脚本语言解析

5. TDebugProtocol 使用易懂的可读文本格式，以便于debug
</code></pre><h3 id="Thrift-数据传输方式"><a href="#Thrift-数据传输方式" class="headerlink" title="Thrift 数据传输方式"></a>Thrift 数据传输方式</h3><pre><code>1. TSocket 阻塞式socket

2. TFramedTransport 以frame为单位进行传输，非阻塞式服务中使用

3. TFileTransport 以文本形式进行传输

4. TMemoryTransport 将内存用于IO，Java实现时内部实际使用了简单的ByteArrayOutputStream。

5. TZlibTransport 使用zlib进行压缩，与其它传输方式联合使用。当前无Java实现。
</code></pre><h3 id="Thrift-支持的服务类型"><a href="#Thrift-支持的服务类型" class="headerlink" title="Thrift 支持的服务类型"></a>Thrift 支持的服务类型</h3><pre><code>1. TSimpleServer 简单的单线程服务模型，常用于测试

2. TThreadPoolServer 多线程服务模型，使用标准的阻塞IO

3. TNonblockingServer 多线程服务模型，使用非阻塞IO(需要使用TFramedTransport数据传输方式)

4. THsHaServer THsHa引入了线程池去处理，其模型将读写任务放到线程池去处理。Half-sync/Half-async的处理模式：Half-aysnc是在处理IO事件上(accept/read/write io) 异步处理。 | Half-sync用于handler对rpc的同步处理。
</code></pre><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><a href="https://www.grpc.io/" target="_blank" rel="noopener">gRPC官方</a> <a href="https://github.com/grpc/grpc-java" target="_blank" rel="noopener">gRPC仓库</a> <a href="https://developers.google.cn/protocol-buffers" target="_blank" rel="noopener">Protobuf官网</a></p>
<p>RPC（远程过程调用）框架实际上是提供了一套机制，使得应用程序之间可以进行通信，同时遵循Server/Client模型。在我们使用的时候，客户端调用Server端的接口就像是调用本地的函数一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3959253-76284b64125a8673.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="RPC通信"></p>
<h3 id="gRPC-Restful"><a href="#gRPC-Restful" class="headerlink" title="gRPC | Restful"></a>gRPC | Restful</h3><p>gRPC和Restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而Restful api则不一定)。不过gRPC还是有些特有的优势。</p>
<pre><code>1. gRPC通过Protobuf定义接口，更加严格的接口约束。

2. Protobuf可以将数据序列化为二进制编码，从而大幅度减少需要传输的数据量，大幅度的提高性能。

3. gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）

4. 对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑gRPC服务，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。
</code></pre><blockquote>
<p>提示：我们不会单独的使用gRPC，而是将gRPC作为一个部件进行使用，这是因为在生产环境中，我们面对高并发的情况下，需要使用分布式系统去处理，而gRPC并没有提供分布式系统相关的一些组件，而且真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等必要的组件。</p>
</blockquote>
<h3 id="gRPC-开发的通用步骤"><a href="#gRPC-开发的通用步骤" class="headerlink" title="gRPC 开发的通用步骤"></a>gRPC 开发的通用步骤</h3><pre><code>1. 编写Protobuf来定义接口和数据类型

2. 编写gRPC Server端程序

3. 编写gRPC Client端程序
</code></pre><h3 id="proto3"><a href="#proto3" class="headerlink" title="proto3"></a>proto3</h3><h3 id="回调钩子"><a href="#回调钩子" class="headerlink" title="回调钩子"></a>回调钩子</h3><p>注册一个关闭Java虚拟机的钩子。Java虚拟机关闭响应两种类型的事件。</p>
<pre><code>1. 程序执行完之后正常的退出。

2. 用户主动中断或者系统事件导致的退出。

更多的看源码。

Runtime.getRuntime().addShutdownHook(new Thread(
    ()-&gt;{
        System.out.println(&quot;close jvm&quot;);
        GrpcServer.this.stop();
    }
));
</code></pre><blockquote>
<p>提示：回调钩子的作用在于在JVM关闭之前先关闭 GrpcServer.this.stop(); 。</p>
</blockquote>
<h3 id="gRPC-流式调用处理"><a href="#gRPC-流式调用处理" class="headerlink" title="gRPC 流式调用处理"></a>gRPC 流式调用处理</h3><blockquote>
<p>提示：gRPC的四种通信方式（1. 一般的RPC调用，一个请求对象，一个返回对象。2. 服务端流式RPC，一个请求对象，服务端可以传回多个结果对象。3. 客户端流式RPC，客户端传入多个请求，服务器返回一个响应结果。4. 双向流式RPC，结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象。）。</p>
</blockquote>
<pre><code>syntax = &quot;proto3&quot;;

package com.proto.xidian.edu.cn;

option java_package = &quot;com.proto.xidian.edu.cn&quot;;
option java_outer_classname = &quot;StudentProto&quot;;
option java_multiple_files = true;

service StudentService {
    rpc GetRealNameByUsername (MyRequest) returns (MyResponse) {}

//    rpc GetStudentsByAge(int32) returns (stream StudentResponse) {}

//    rpc GetStudentsByAge(StudentRequest) returns (stream StudentResponse) {}

    rpc GetStudentsWrapperByAges(stream StudentRequest ) returns (StudentResponseList) {}

}

message MyRequest {
    string username = 1;
}

message MyResponse {
    string realname = 2;
}

message StudentResponse {
    string name = 1;
    int32 age = 2;
    string city = 3;
}

message StudentRequest {
    int32 age = 1;
}

message StudentResponseList {
    repeated StudentResponse studentResponse = 1;
}
</code></pre><p>在处理过程中主要在返回stream类型的结果类型。在客户端发出一个请求之后，服务器返回的类型是tream（实际上就是一个迭代器）。</p>
<blockquote>
<p>提示：在编写.proto文件之后利用gradle构建工具对项目进行build操作，得到新生成的文件。</p>
</blockquote>
<h5 id="错误-error"><a href="#错误-error" class="headerlink" title="错误 error"></a>错误 error</h5><blockquote>
<p>  What went wrong:<br>    Some problems were found with the configuration of task ‘:generateProto’.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Value ‘directory ‘D:\projects\SSM_practice\netty_lecture\build/extracted-protos/main’’ specified for property ‘$2’ cannot be converted to a file.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Value ‘main Proto source’ specified for property ‘$1’ cannot be converted to a file.</p>
</blockquote>
</blockquote>
<p>解决：将Protobuf-Gradle-plugin版本更新到0.8.4或更高版本。</p>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><h3 id="gradlew"><a href="#gradlew" class="headerlink" title="gradlew"></a>gradlew</h3><p>gradlew 等价于gradle wrapper。使用者在本地pc上没有安装gradle工具的前提下，会自动构建项目。</p>
<h2 id="EventLoopGroup-1"><a href="#EventLoopGroup-1" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><pre><code>1. 在一个EventLoopGroup中可能会包含一个或多个EventGroup。

2. 一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定。

3. 所有由EventLoop所处理的各种IO事件都将在它所关联的那个Thread上进行处理。

4. 一个Channel在它的整个生命周期中只会注册在一个EventLoop上。

5. 一个EventLoop在运行过程中，会被分配给一个或多个Channel。
</code></pre><p>在Nettt中，Channel的实现一定是线程安全的。基于此，我们可以存储一个Channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用Channel相应的方法，即便当时有很多线程都在使用它也不会出现多线程问题，而且消息一定会按照顺序发送出去。</p>
<blockquote>
<p>重要结论：我们在业务开发过程中，不要将长时间执行的耗时任务放入到EventLoop的执行队列中，因为它将会一直阻塞该线程所对应的所有Channel上的其它执行任务，如果我们需要进行阻塞调用或耗时的操作（通常在开发中很常见），那么我们需要使用一个专门的EventExecutor（业务线程池）。</p>
</blockquote>
<pre><code>业务线程池（EventExecutor）通常的两种实现方式：

    1. 在ChannelHandler的回调方法中，使用自己定义的业务线程池，这样就可以实现异步调用。

    2. 借助Netty提供的向ChannelPipeline添加ChannelHandler时调用的addLast()方法来传递EventExecutor。
</code></pre><blockquote>
<p>说明：默认情况下（调用addLast(handler)），ChannelHandler中回调方法都是由IO线程所执行，如果调用了 ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler… handlers);方法，那么ChannelHandler中的回调方法就是由参数中的group线程组所执行的。</p>
</blockquote>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>JDK所提供的Future只能通过手工方式检查执行结果，而这个操作是会阻塞的。Netty则对ChannelFuture进行了增强，通过ChannelFutureListener以回调的方式来获取执行结果，去除了手工检查阻塞的操作。值得注意的是：ChannelFutureListener的operationComplete()方法是由IO线程执行的，因此要注意的是不要在这里执行耗时操作，否则需要通过另外的线程或线程池来执行。</p>
<h2 id="Channel-ChannelHandler-ChannelHandlerContext"><a href="#Channel-ChannelHandler-ChannelHandlerContext" class="headerlink" title="Channel | ChannelHandler | ChannelHandlerContext"></a>Channel | ChannelHandler | ChannelHandlerContext</h2><p>在Netty中有两种发送消息的方式，可以直接写到Channel中，也可以写到与ChannelHandler所关联的那个ChannelHandlerContext中。对于前一种方式来说，消息会从ChannelPipeline的末尾开始流动，而对于后一种方式来说，消息将从ChannelHandlerContext的下一个ChannelHandler开始流动。</p>
<p>结论：</p>
<pre><code>1. ChannelHandlerContext与ChannelHandler之间的关联绑定关系是永远都不会发生改变的，因此对其进行缓冲是没有任何问题的。

2. 对于与Channel的同名方法来说，ChannelHandlerContext的方法将会产生更短的事件流，所以我们应该在可能的情况下利用这个特性来提升应用的性能。
</code></pre><h2 id="Netty-提供的3种缓冲区类型"><a href="#Netty-提供的3种缓冲区类型" class="headerlink" title="Netty 提供的3种缓冲区类型"></a>Netty 提供的3种缓冲区类型</h2><pre><code>1. Heap Buffer (堆缓冲区)

    这是最常用的类型，ByteBuf将数据存储到JVM的堆空间中，并且将实际的数据存放到byte array中来实现。

    优点：由于数据存放在JVM的堆中，因此可以快速的创建与释放，并且他提供了直接访问内部字节数组的方法。

    缺点：每次读写数据时，都需要先将数据复制到直接缓冲区中再进行网络传输。

2. Direct Buffer (直接缓冲区)

    在堆之外直接分配内存空间，直接缓冲区并不会占用堆的容量空间，因为它是有操作系统在本地内存中进行的数据分配。

    优点：在使用Socket进行数据传递时，性能非常好，因为数据直接位于操作系统的本地内存中，所以不需要从JVM将数据复制到直接缓冲区中，性能很好。

    缺点：因为Direct Buffer是直接在操作系统内存中的，所以内存空间的分配与释放要比堆空间更加复杂，而且速度要慢一些。

    这里Netty提供内存池来解决这个问题。DirectBuf可以放在内存池里面。直接缓冲区并不支持通过字节数组的方式来访问数据。
</code></pre><blockquote>
<p>提示：对于后端的业务消息的编解码来说，推荐使用HeapByteBuf。对于IO通信线程在读写缓冲区时，推荐使用DirectByteBuf。</p>
</blockquote>
<pre><code>3. Composite Buffer (复合缓冲区)
</code></pre><h2 id="JDK的ByteBuffer与Netty的ByteBuf之间的差异"><a href="#JDK的ByteBuffer与Netty的ByteBuf之间的差异" class="headerlink" title="JDK的ByteBuffer与Netty的ByteBuf之间的差异"></a>JDK的ByteBuffer与Netty的ByteBuf之间的差异</h2><pre><code>1. Netty的ByteBuf采用了读写分离的策略（readerIndex | writerIndex），一个初始化（里面尚未有任何数据）的ByteBuf的readerIndex | writerIndex值都为0。

2. 当读索引与写索引处于同一个位置时，如果我们继续读取，就会抛出异常IndexOutBoundsException。

3. 对于ByteBuf的任何读写操作都会分别单独维护读索引和写索引。maxCapacity最大容量默认的限制就是Integer.MAX_VALUE。
</code></pre><h3 id="JDK的ByteBuffer的缺点"><a href="#JDK的ByteBuffer的缺点" class="headerlink" title="JDK的ByteBuffer的缺点"></a>JDK的ByteBuffer的缺点</h3><pre><code>1. final byte[] hb;这是JDK的ByteBuffer对象中用于存储数据的对象声明。可以看到，字节数组被声明为final的，也就是长度是固定不变的。一旦分配好之后就不能动态扩容和收缩。而且当待存储的数据字节很大时就很有可能抛出IndexOutBoundsException异常。如果要预防这个异常的抛出，那就需要在存储之前完全确定好待存储的字节大小。如果ByteBuffer的空间不足，我们只有一种解决方案：创建一个全新的ByteBuffer对象，然后再将之前的ByteBuffer中的数据复制过去，这些操作都需要我们自发完成。

2. ByteBuffer只使用一个position指针来表示位置信息，在进行读写切换的时候需要调用flip()方法或rewind()方法，使用起来不方便。
</code></pre><h3 id="Netty的ByteBuf的优点"><a href="#Netty的ByteBuf的优点" class="headerlink" title="Netty的ByteBuf的优点"></a>Netty的ByteBuf的优点</h3><pre><code>1. 存储字节的数组是动态的，其最大值默认是Integer.MAX_VALUE。这里的动态性是体现在write()方法中的，write()方法在执行时会判断
</code></pre><blockquote>
<p>提示：自旋锁，不断占用CPU进行自旋，直到条件满足跳出死循环为止。</p>
</blockquote>
<pre><code>//自旋锁的应用
for (;;) {
    int refCnt = this.refCnt;
    final int nextCnt = refCnt + increment;

    if (nextCnt &lt;= increment) {
        throw new IllegalReferenceCountException(refCnt, increment);
    }
    //判断或跳出
    if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
        break;
    }
}
</code></pre><h2 id="AtomicIntegerFieldUpdater-要点总结"><a href="#AtomicIntegerFieldUpdater-要点总结" class="headerlink" title="AtomicIntegerFieldUpdater 要点总结"></a>AtomicIntegerFieldUpdater 要点总结</h2><pre><code>1. 更新器更新的必须是int类型变量，不能是其包装类型。

2. 更新器更新的必须是volatile类型变量，确保线程之间共享变量时的立即可见性。

3. 待更新的变量不能是static的，必须要是实例变量。因为Unsafe.objectFieldOffset()方法不支持静态变量（CAS操作本质上是通过对象实例的偏移量来直接进行赋值）。

4. 更新器只能修改它可见范围内的变量，因为更新器是通过反射来得到这变量，如果变量不可见就会报错。
</code></pre><blockquote>
<p>提示：如果要更新的变量是包装类型的话，可以使用AtomicReferenceFieldUpdater来进行更新。</p>
</blockquote>
<h2 id="Netty-处理器概念"><a href="#Netty-处理器概念" class="headerlink" title="Netty 处理器概念"></a>Netty 处理器概念</h2><pre><code>1. Netty处理分类：入站处理器 | 出站处理器。

2. 入站处理器的顶层是ChannelInBoundHandler，出站处理器的顶层是ChannelOutBoundHandler。

3. 数据处理时常用的各种编解码器本质上都是处理器。

4. 编解码器：无论我们向网络中写入的数据是什么类型（int | char | String | 二进制等），数据在网络中传递时，其都是以字节流形式呈现的。

    编码：将数据由原本形式转换为字节流的操作称为编码（encode）。

    解码：将字节流转换成它原本的数据形式或其它格式称为解码（decode）。

    编解码统一称为codec。

5. 编码（从程序到网络 - 本质上是一种出站处理器（ChannelOutBoundHandler））

6. 解码（从网络到程序 - 本质上是一种入站处理器（ChannelInBoundHandler））

7. 在Netty中，编码器通常以XXXEncoder命名。解码器通常以XXXDecoder命名。
</code></pre><h2 id="TCP-粘包与拆包"><a href="#TCP-粘包与拆包" class="headerlink" title="TCP 粘包与拆包"></a>TCP 粘包与拆包</h2><p>粘包表示将多条数据粘在一起。拆包的概念与粘包相反，是将多条数据拆分开来。</p>
<h2 id="关于Netty编解码器的结论"><a href="#关于Netty编解码器的结论" class="headerlink" title="关于Netty编解码器的结论"></a>关于Netty编解码器的结论</h2><pre><code>1. 无论是编码器还是解码器，其所接受的消息类型必须要与待处理的参数类型一致，否则该编码器或解码器并不会执行。

2. 
</code></pre>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/undefined/Python/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>[TOC]</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h4><p>Python 中的标识符是区分大小写的。以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。</p>
<p>以双下划线开头的 <strong>foo 代表类的私有成员，以双下划线开头和结尾的 </strong>foo__ 代表 Python 里特殊方法专用的标识，如 <strong>init</strong>() 代表类的构造函数。</p>
<h4 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h4><p>在python代码块中，不使用大括号{}来控制类，函数以及其它逻辑判断，用缩进来写模块。</p>
<blockquote>
<p>提示：缩进的空白数量是可变的，但是所有代码块语句包含相同的缩进空白数量，需要严格执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 学习</title>
    <url>/undefined/Mybatis-1/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Mybatis-FD"><a href="#Mybatis-FD" class="headerlink" title="Mybatis - FD"></a>Mybatis - FD</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="1-原生态JDBC程序存在问题"><a href="#1-原生态JDBC程序存在问题" class="headerlink" title="1.原生态JDBC程序存在问题"></a>1.原生态JDBC程序存在问题</h4><pre><code>public static void main(String[] args) {
    //设置连接为null
    Connection connection = null;
    //设置预处理状态为null
    PreparedStatement preparedStatement = null;
    //设置结果集为null
    ResultSet resultSet = null;
    //检查异常并抛出异常
        try {
            //1、加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //2、通过驱动管理类获取数据库链接
            connection =  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;);
            //3、定义sql语句 ?表示占位符
            String sql = &quot;select * from user where username = ?&quot;;
            //4、获取预处理statement
            preparedStatement = connection.prepareStatement(sql);
            //5、设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值
            preparedStatement.setString(1, &quot;Aaron&quot;);
            //6、向数据库发出sql执行查询，查询出结果集
            resultSet =  preparedStatement.executeQuery();
            //7、遍历查询结果集
            while(resultSet.next()){
                System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            //8、释放资源
            if(resultSet!=null){
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(preparedStatement!=null){
                try {
                    preparedStatement.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(connection!=null){
                try {
                    connection.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
</code></pre><blockquote>
<p>总结：1.JDBC在使用过程中数据库连接会频繁开启和关闭，会严重影响到数据库的性能。2.在程序中存在硬编码，数据库部分以及SQL执行部分。</p>
</blockquote>
<h2 id="Mybatis-框架原理"><a href="#Mybatis-框架原理" class="headerlink" title="Mybatis 框架原理"></a>Mybatis 框架原理</h2><pre><code>1.mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息。映射文件配置了SQL执行相关的信息。

2.mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂(sqlSessionFactory)。

3.通过SqlSessionFactory(会话工厂)，可以创建SqlSession即会话。Mybatis是通过SqlSession来操作数据库的。

4.SqlSession(会话)其本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。

5.Executor执行器要处理的SQL信息是封装到一个底层对象 MappedStatement 中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括Java的简单类型、HashMap集合对象、POJO对象类型。
</code></pre><hr>
<h2 id="Mybatis-入门程序"><a href="#Mybatis-入门程序" class="headerlink" title="Mybatis 入门程序"></a>Mybatis 入门程序</h2><h4 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h4><pre><code>1.创建数据表
2.添加相关依赖文件
3.添加log4j.properties文件(因为mybatis使用的日志包是log4j(在classpath路径下创建该文件))

    # Global logging configuration
    log4j.rootLogger=DEBUG, stdout
    # Console output...
    log4j.appender.stdout=org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
</code></pre><blockquote>
<p>注意：日志级别在开发阶段设置成DEBUG，在生产阶段设置成INFO或者ERROR。</p>
</blockquote>
<pre><code>4.编程步骤
    1.创建PO类，根据需求创建
        Public class User {
            private int id;
            private String username;// 用户姓名
            private String sex;// 性别
            private Date birthday;// 生日
            private String address;// 地址
            //以及一系列的get/set方法
            }
</code></pre><blockquote>
<p>注意：创建的po类属性名称应该和数据库表中的列名一致，如果表中的列名带有下划线，那么PO类中对应的属性名要采用驼峰式命名。驼峰式命名：骆驼式命名法就是当变量名或函数名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。</p>
</blockquote>
<pre><code>    2.创建全局配置文件SqlMapConfig.xml(是在classpath路径下创建配置文件)
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
        &lt;configuration&gt;
        &lt;!-- 配置mybatis的环境信息 --&gt;
        &lt;environments default=&quot;development&quot;&gt;
            &lt;environment id=&quot;development&quot;&gt;
                &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
                &lt;!-- 配置数据源，采用dbcp连接池 --&gt;
                &lt;dataSource type=&quot;POOLED&quot;&gt;
                    &lt;!—驱动和URL设置--&gt;
                    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
                    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
                &lt;/dataSource&gt;
            &lt;/environment&gt;
        &lt;/environments&gt;
        &lt;/configuration&gt;

    3.编写映射文件(xxxMapper.xml(mapper接口的实现类))
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper    
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

    4.加载映射文件，在SqlMapConfig.xml中进行加载
        &lt;!-- 加载mapper --&gt;
        &lt;mappers&gt;
            &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;
        &lt;/mappers&gt;

    5.编写测试程序，即编写Java代码，连接并操作数据库
        public class MybatisFirst {

        @Test
        public void findUserByIdTest() throws Exception{
            //1、读取配置文件
            String resource = &quot;SqlMapConfig.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            //2、根据配置文件创建SqlSessionFactory
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //3、SqlSessionFactory创建SqlSession
            SqlSession sqlSession = sqlSessionFactory.openSession();
            //4、SqlSession执行statement，并返回映射结果
            //第一个参数：statement的id，建议：namespace.statementId（确保唯一）
            //第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致
            User user = sqlSession.selectOne(&quot;findUserById&quot;, 1);
            //打印输出结果集
            System.out.println(user);
            //5、关闭SqlSession
            sqlSession.close();
        }
    }

5.mybatis.xml配置文件

    1.SqlSession 说明

        1.SqlSessionFactoryBuider
            通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory，将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例模式管理，在创建SqlSessionFactory的时候，只需要new一次SqlSessionFactoryBuilder即可。

        2.SqlSessionFactory
            通过SqlSessionFactory创建SqlSession，使用单例模式来管理SqlSessionFactory（工厂一旦创建，只使用一个实例）。

        3.SqlSession
            SqlSession是一个面向用户的接口，其提供了很多操作数据库的方法，同时其是线程不安全的，其最佳的应用场合是方法体内，将其定义为局部变量来使用。

    2.mybatis.xml配置文件

        &lt;!-- 3.配置SqlSessionFactory spring和MyBatis整合，不需要在mybatis的配置文件中写每个entity的映射文件 --&gt;
        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;!--1.配置数据源--&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;!--2.指定mybatis的全局配置文件--&gt;
            &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;
            &lt;!-- 自动扫描mapper.xml文件 --&gt;
            &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:sqlmapper/*.xml&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;

        &lt;!--批量配置mapper代理类，默认bean的id为类名首字母小写--&gt;
        &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;!--1.配置扫描包--&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.edu.xidian.c2.mapper&quot; /&gt;
            &lt;!--2.只有一个sqlSessionFactory时，默认不需要配置SqlSessionFactory,单独配置也可以--&gt;
            &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
</code></pre><blockquote>
<p>总结：1.首先读取配置文件，然后通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。<br>2.通过SqlSessionFactory创建SqlSession，然后调用SqlSession的操作数据库的方法。<br>3.最后关闭SqlSession。</p>
</blockquote>
<hr>
<blockquote>
<p>小结</p>
<blockquote>
<p>1.parameterType 指定输入参数的Java类型，可以填写别名或Java类的全限定名。</p>
<blockquote>
<p>2.resultType 指定输出结果的Java类型，可以填写别名或Java类的全限定名。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>#{}和${}
    #{}：相当于预处理中的占位符？。

    #{}里面的参数表示接收java输入参数的名称。

    #{}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，#{}里面可以是value，也可以是其他。

    #{}可以防止SQL注入。

    ${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。

    ${}会引起SQL注入，所以要谨慎使用。

    ${}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，${}里面只能是value。

selectOne：只能查询0或1条记录，大于1条记录的话，会报错
selectList：可以查询0或N条记录
</code></pre><hr>
<h2 id="Mybatis-开发DAO"><a href="#Mybatis-开发DAO" class="headerlink" title="Mybatis 开发DAO"></a>Mybatis 开发DAO</h2><p>我们知道，mybatis在项目开发中主要使用的地方就是开发DAO(数据访问层)。所以开发方式有两种。1.原始的DAO开发方式。2.Mapper代理开发方式。</p>
<h4 id="1-原始DAO开发方式"><a href="#1-原始DAO开发方式" class="headerlink" title="1.原始DAO开发方式"></a>1.原始DAO开发方式</h4><pre><code>实现步骤：
    1.根据需求创建po类
      这一步骤的实现所对应的属性名要与数据库中的属性名相对应
    2.编写全局配置文件
      这一步骤的实现是配置数据源等信息
    3.根据需求编写映射文件
      实现实体类与数据库之间的数据操作
    4.加载映射文件
    5.编写dao接口
        public interface UserDao {
            //根据用户ID来查询用户信息
            public User findUserById(int id);
            //根据用户名称来模糊查询用户信息列表
            public List&lt;User&gt; findUsersByName(String username);
            //添加用户
            public void insertUser(User user);
        }

    6.编写dao实现类
        public class UserDaoImpl implements UserDao {

            //注入SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;
            //使用构造方法来初始化SqlSessionFactory
            public UserDaoImpl(SqlSessionFactory sqlSessionFactory){
                this.sqlSessionFactory = sqlSessionFactory;
            }

            @Override
            public User findUserById(int id) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                //返回结果集
                return sqlSession.selectOne(&quot;test.findUserById&quot;, id);
            }

            @Override
            public List&lt;User&gt; findUsersByName(String username) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                return sqlSession.selectList(&quot;test.findUsersByName&quot;, username);
            }

            @Override
            public void insertUser(User user) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                sqlSession.insert(&quot;test.insertUser&quot;, user);
            }

        }

    7.编写测试代码
        public class UserDaoTest {

            //声明全局的SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;

            @Before
            //此方法在测试方法执行之前执行，spring开发方式
            public void setUp() throws Exception {
                // 1、读取配置文件
                String resource = &quot;SqlMapConfig.xml&quot;;
                InputStream inputStream = Resources.getResourceAsStream(resource);
                // 2、根据配置文件创建SqlSessionFactory
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            }

            @Test
            public void testFindUserById() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                User user = userDao.findUserById(1);

                System.out.println(user);
            }

            @Test
            public void testFindUsersByName() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                List&lt;User&gt; list = userDao.findUsersByName(&quot;小明&quot;);

                System.out.println(list);
            }

            @Test
            public void testInsertUser() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //构造User对象
                User user = new User();
                user.setUsername(&quot;东哥3&quot;);
                user.setAddress(&quot;清河宝盛西里3&quot;);

                //调用UserDao对象的方法
                userDao.insertUser(user);

                System.out.println(user.getId());
            }

        }
</code></pre><h4 id="2-mapper开发代理方式"><a href="#2-mapper开发代理方式" class="headerlink" title="2.mapper开发代理方式"></a>2.mapper开发代理方式</h4><p>使用Mapper代理的开发方式，我们只需要编写mapper接口，然后mybatis会自动为mapper接口生成动态代理实现类。</p>
<pre><code>1.mapper接口的全限定名要和mapper映射文件的namespace的值相同。
2.mapper接口的方法名称要和mapper映射文件中的statement的id相同。
3.mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。
4.mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致。
</code></pre><blockquote>
<p>提示：statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上，向数据库发送要执行的SQL语句，Statement对象用于执行不带参数的简单SQL语句。</p>
</blockquote>
<h2 id="Mybatis-映射文件"><a href="#Mybatis-映射文件" class="headerlink" title="Mybatis 映射文件"></a>Mybatis 映射文件</h2><pre><code>1.输入映射
    ParameterType

2.输出映射
    resultType

3.高级映射
    resultMap
</code></pre><h2 id="mybatis-高级映射"><a href="#mybatis-高级映射" class="headerlink" title="mybatis 高级映射"></a>mybatis 高级映射</h2><pre><code>1.mybatis框架执行过程：
  1.配置mybatis的配置文件(mybatis-config.xml)（名称不固定）。

  2.通过配置文件(mybatis-config.xml)，加载mybatis运行环境，创建SqlSessionFactory会话工厂,SqlSessionFactory在实际使用时按单例方式。

  3.通过SqlSessionFactory创建SqlSession，SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。

  4.调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。

  5.释放资源，关闭SqlSession

2.mybatis开发dao的方法
  1.使用原始的dao的方法
    这样需要编写dao接口和实现类，需要在dao实现类注入一个SqlSessionFactory工厂。

  2.mapper代理开发方法(推荐)
    0.编写mapper接口(dao接口)
      注意：在编写mapper.xml(映射文件)和mapper.java(接口)需要遵循开发规范

    1.mapper.xml中的namespace就是mapper.java的类的全路径名

    2.mapper.xml中statement的id值和mapper.java中方法名一致(如：insert/delete/update中的id值)

    3.mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法数据参数类型一致(parameterType类型与对应的接口方法参数类型一致)

    4.mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致(resultMap：定义出参，调用已经定义的&lt;resultMap&gt;&lt;/resultMap&gt;映射管理器的id值 

    resultType：定义出参，匹配普通Java类型或自定义pojo类型(出参类型若不指定，将为语句默认类型))
</code></pre><blockquote>
<p>注意：全局配置文件(mybatis-config.xml)可以配置properties属性、别名、mapper加载等。</p>
</blockquote>
<pre><code>3.输入映射
  1.parameterType：指定输入参数类型可以是简单类型、POJO、HashMap，而对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展。

4.输出映射
  1.resultType：查询到的列名和resultType指定的POJO的属性名一致，这样才能映射成功。
    作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中
    场合：

  2.resultMap：可以通过resultMap完成高级映射，如果查询到的列名和映射的POJO的属性名不一致时，通过resultMap设置别名和属性名之间的对应关系(映射关系)，可以完成映射。

    association
    作用：将关联查询信息映射到一个pojo对象中
    场合：为了方便查询关联信息可以使用association将关联 订单信息 映射为 用户对象 的pojo属性中。association适用于一对一查询。
</code></pre><blockquote>
<p>注意：使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap</p>
</blockquote>
<pre><code>collection
作用：将关联查询信息映射到一个list集合中
场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，而如果使用resultType无法将查询结果映射到list集合中。collection适用于一对多和多对多的查询。
</code></pre><blockquote>
<p>扩展：映射管理器<code>resultMap</code>：是<code>mybatis</code>中强大的工具，使用其可以进行 实体类之间 的映射，并且管理 结果和实体类 之间的映射关系。</p>
</blockquote>
<pre><code>resultMap映射管理器需要配置的属性：

    &lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;&lt;/resutlMap&gt;   
        id=&quot; &quot;:表示这个映射管理器的唯一标识，外部通过该值引用
        type = &quot; &quot;:表示需要映射的实体类

resultMap映射管理器需要配置的参数：

    &lt;id column = &quot; &quot; property= &quot; &quot; /&gt; 
        &lt;id&gt;标签指的是：结果集中结果唯一的列column(column：指定唯一标识用户信息的数据列)和实体属性property(property:映射到user实体类的哪个属性)的映射关系
            注意：&lt;id&gt;标签管理的列未必是主键列，需要根据具体需求指定

    &lt;result column= &quot; &quot; property=&quot; &quot; /&gt;  
        &lt;result&gt;标签指的是：结果集中普通列column和实体属性property的映射关系

resultMap映射管理器需要维护的关系：所谓关系维护是值在 主表查询时将其关联子表的结果也查询出来
</code></pre><hr>
<pre><code>resultMap元素中，允许有如下直接子元素：
    1.constructor：类在实例化时，用来注入结果到构造方法中,作用与result相同，同时可以标识出用这个字段值可以区分其他对象实例
        arg：注入到构造方法的一个普通结果
        idArg：ID参数，标记结果作为ID，可以帮助提高整体效能

    2.result：将数据表中的字段注入到Java对象属性中

    3.association：关联(一对一的关系)，表示在resultMap映射器中，通过&lt;association&gt;&lt;/association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来。

      作用：将关联查询的信息映射到一个POJO中
      &lt;association property=&quot;&quot; javaType=&quot;&quot;&gt;
          property：对象属性的名称，被维护实体在宿主实体(POJO)中的属性名
           javaType：对象属性的类型，被维护实体的类型
           column：所对应的外键字段名称
           select：使用另一个查询封装的结果

    4.collection：集合(一对多/多对多关系的维护)，对关联查询到的多条记录映射到集合对象中。

      作用：将关联查询用户信息映射到一个list集合中
      &lt;collection property=&quot;&quot; ofType=&quot;&quot;&gt;
      property=&quot;&quot; 将查询到的多条记录映射到相应的POJO类上对应的属性中
      ofType=&quot;&quot; 指定映射到List集合的pojo类型

    5.discriminator：使用结果集决定使用哪个个结果映射
</code></pre><blockquote>
<p>拓展：sql片段标签<sql>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用。</sql></p>
</blockquote>
<pre><code>注意：需要配置的属性，id=&quot;&quot; 表示需要改sql语句片段的唯一标识 引用：通过&lt;include refid=&quot;&quot;/&gt;标签引用，refid=&quot;&quot;中的值指向需要引用的&lt;sql&gt;中的id=&quot;&quot;属性。
</code></pre><blockquote>
<p>注意：在resultMap中应该注意两点</p>
</blockquote>
<pre><code>1.关联关系的维护可以根据实体类之间的实际情况进行嵌套维护

2.出现重复列名的处理，在实际操作过程中，查询到的结果可能会出现相同的列名，这样会对映射到实体属性带来影响甚至报错，所以可以通过对列取别名的方式来处理
</code></pre><p>5.高级映射<br>  1.将关联查询的列映射到一个POJO属性中(一对一)<br>  2.将关联查询的列映射到一个List<pojo>中(一对多)</pojo></p>
<hr>
<h2 id="mybatis动态sql语句"><a href="#mybatis动态sql语句" class="headerlink" title="mybatis动态sql语句"></a>mybatis动态sql语句</h2><p>6.常用的动态语句标签(通过动态sql标签可以进行条件判断，条件遍历等操作从而能够满足结果中的需要)</p>
<pre><code>&lt;where&gt;：这一标签的使用可以代替sql语句中的where关键字，一般放置在条件查询的最外层 
   where后面跟查询条件，简化sql语句中判断条件的书写 此中，mybatis会智能的将首个and或or给忽略

&lt;if&gt;：这一标签配置属性test=&quot;条件字符串&quot;，判断是否满足条件

&lt;set&gt;：这一标签常用于&lt;update&gt;更新语句中，替代sql的set关键字，特别是在联合&lt;if&gt;进行判断是否符合条件时，可以有效方式当某个参数为空或者不合法是错误的更新到数据库中
 mybatis set标签的使用：sql语句中的最后一个逗号会被set标记自动忽略

&lt;trim&gt;：在mapper.xml中对statement的定义，可以使用&lt;trim&gt;标签来填充和隐藏sql语句。
    功能：1.如果标签体中有SQL语句，就把修饰后的SQL语句拼接到之前的SQL语句上，如果标签体中没有SQL语句，那么这标签相当于不存在。2.这四个属性的默认值都是空字符串。

      trim属性 prefix：前缀   suffix：后缀 

      &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;,&quot; suffixOverrides=&quot;,&quot;&gt;

      属性：
        1.prefix=&quot;(&quot; 在trim标签定义的内容前填充对应内容
        2.suffix=&quot;)&quot; 在trim标签定义的内容后填充对应内容

        3.prefixOverrides=&quot;,&quot;  在trim定义中，隐藏头部对应的内容。这个属性指定一个字符串，这个字符串一定是SQL语句的前缀，如果不是前缀，这个属性不起作用。会用prefix属性指定的字符串替换掉这个属性指定的字符串。

        4.suffixOverrides=&quot;,&quot; 在trim定义的中，隐藏尾部对应的内容。这个属性指定一个字符串，这个字符串位一定是SQL语句的后缀，如果不是后缀，这个属性不起作用。其会用suffix属性指定的字符串替换这个属性指定的字符串。

mysql对查询结果排序：从表中查询出来的数据，可能是无序的，或者其排列顺序表示用户期望的，使用order by对查询结果进行排序。

    SELECT 字段名1，字段名2，... FROM 表名 ORDER BY 字段名1 [ASC|DESC]，字段名2[ASC|DESC],...

    参数说明：
        1.字段名1，字段名2,...：表示对查询结果排序的依据
        2.参数ASC：表示按照升序进行排序
        3.参数DESC：表示按照降序的方式进行排序
        4.默认情况下是按照ASC方式进行升序排序
</code></pre><blockquote>
<p>注意：当按照执行字段进行升序排序时，如果其中的某条记录的字段值是null时，则这条记录会在第一条显示，因为null值会被认为是最小值。</p>
</blockquote>
<pre><code>标签组：
  &lt;choose&gt;
    &lt;when&gt; //此元素的作用与Java中的switch效果差不多
    &lt;/when&gt;
    &lt;otherwise&gt;
    &lt;/otherwise&gt;
  &lt;/choose&gt; 
  也是一个用于条件判断的标签组，和&lt;if&gt;的不同之处在于条件从&lt;choose&gt;进入，去匹配&lt;when&gt;中的添加，一旦匹配马上结束，若到找不到匹配项，将执行&lt;otherwise&gt;中的语句；可以理解为&lt;if&gt;是 &amp;&amp; 关系 &lt;choose&gt;是 || 关系

  &lt;foreach&gt;标签：遍历集合类型的条件(在实现 mybatis in 语句查询时特别有用)
  属性：collection=&quot;array/list&quot; 是数组类型还是集合类型
        item=&quot; &quot; 参数名
    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;  开始符号，分隔符号，结束符号
    index=&quot;&quot; 结束下标位置，不配置该参数时，默认为全部遍历
</code></pre><blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>MySQL JOIN语法
    join用于多表中字段之间的联系(...FROM table1(左表) INNER|LEFT|RIGHT JOIN table2(右表) ON condition)
大致功能：
    1.INNER JOIN（内连接取两表的交集）：取得两个表中存在连接匹配关系的记录(产生一组同时符合A和B的数据)。
    2.LEFT JOIN（左连接）：返回左表中所有的行，即在右表中没有匹配的记录。
    3.RIGHT JOIN（右连接）：返回右表中所有的行，即在左表中没有匹配的记录。
    4.OUTER JOIN(外连接)：求两个集合的并集。
    5.FULL JOIN：在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。


条件ON与Where的执行顺序
    ON：用来决定如何从B表中检索数据行
        如：A LEFT JOIN B ON 条件表达式 ON条件用来决定如何从B表中检索数据行，如果在B表中没有任何一行数据匹配ON的条件，将会额外生成一行所有列都为null的数据，在匹配阶段，where子句的条件不会使用吗，仅在匹配阶段完成以后，WHERE子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。
</code></pre><hr>
<h2 id="mybatis高级查询"><a href="#mybatis高级查询" class="headerlink" title="mybatis高级查询"></a>mybatis高级查询</h2><p>1.关联查询<br>  在查询一个结果的时候，查询出其他关联的结果集</p>
<p>2.子查询<br>  关联查询一般可以使用子查询来实现，但是一般情况下子查询的效率低于关联查询</p>
<p>3.集合查询<br>  集合查询是关联查询的一种，只不过它是一对多而已</p>
<p>4.mapper.xml源码分析</p>
<pre><code>1.namespace：对应mapper接口(类似dao接口)
2.resultMap：
  1.id：
</code></pre><p>5.一对一查询(resultType 实现)</p>
<p>使用resultType来进行一对一结果映射，查询出的列的个数和映射的属性的个数要一致。而且映射的属性要存在与一个大的对象中，它是一种平铺式的映射，即数据库查询出多少条记录，则映射成多少个对象。</p>
<pre><code>一对一查询(resultMap 实现)

使用resultMap来进行一对一结果映射，它是将关联对象添加到主信息的对象中，具体说是一种对象嵌套另一种对象的一种映射方式。

&lt;resultMap type=&quot;mybatis.po.OrdersExt&quot; id=&quot;OrdersAndUserRstMap&quot;&gt;
    &lt;!-- 订单信息 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
    &lt;!-- 对象嵌套映射 --&gt;
    &lt;!-- association：一对一关联映射 --&gt;
    &lt;!-- property：关联信息查询的结果将要映射的扩展类中的对象属性名称 --&gt;
    &lt;!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --&gt;
    //association：表示在resultMap映射器中，通过&lt;association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来
    &lt;association property=&quot;user&quot; javaType=&quot;mybatis.po.User&quot;&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;/association&gt;
</code></pre><blockquote>
<p>总结：在一对一映射结果时，使用<code>resultType</code>更加简单方便，如果有特殊要求(对象嵌套对象)时，需要使用<code>resultMap</code>进行映射，关联查询出其关联信息。</p>
</blockquote>
<p>6.一对多查询</p>
<pre><code>1.多对一的查询引入association，进行联合查询

     &lt;resultMap id=&quot;resultUserArticleList&quot; type=&quot;Article&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
            &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
            &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;
            &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
                    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
                    &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
                    &lt;result property=&quot;userAddress&quot; column=&quot;userAddress&quot; /&gt;            
            &lt;/association&gt;        
        &lt;/resultMap&gt;

    &lt;select id=&quot;getUserArticles&quot; parameterType=&quot;int&quot; resultMap=&quot;resultUserArticleList&quot;&gt;
           select user.id,user.userName,user.userAddress,article.id aid,article.title,article.content from user,article where user.id=article.userid and user.id=#{id}
    &lt;/select&gt;
</code></pre><blockquote>
<p>总结：在上述配置之后，将select语句与resultMap对应的映射结合起来，可以看出，用association来得到关联的用户，得到的所有文章都是同一个用户的。</p>
</blockquote>
<pre><code>2.复用已经定义好的resultMap，将association中对应的映射独立抽取出来，以至于能够达到复用的目的

    1.首先定义好一个resultMap
            &lt;resultMap type=&quot;User&quot; id=&quot;resultListUser&quot;&gt;
                &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
                &lt;result column=&quot;userName&quot; property=&quot;userName&quot; /&gt;
                &lt;result column=&quot;userAge&quot; property=&quot;userAge&quot; /&gt;
                &lt;result column=&quot;userAddress&quot; property=&quot;userAddress&quot; /&gt;
            &lt;/resultMap&gt;

    2.然后在新定义的resultMap中引用已定义的resultMap
        &lt;resultMap id=&quot;resultUserArticleList-2&quot; type=&quot;Article&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
                &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
                &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;        
                &lt;association property=&quot;user&quot; javaType=&quot;User&quot; resultMap=&quot;resultListUser&quot; /&gt;  //在这里使用association复用已经定义好的resultMap           
           &lt;/resultMap&gt;
</code></pre><p>7.多对多映射查询(只是一对多映射的特例)</p>
<pre><code>多对多映射查询只不过是一对多映射的特例，其是在一对多的基础上添加多个&lt;collection&gt;来表明多个数据表单之间的关系的。

如：

    1.定义resultMap

    &lt;!-- 查询用户即购买的商品信息的ResultMap --&gt;
    &lt;resultMap type=&quot;com.mybatis.entity.User&quot; id=&quot;userAndItemsResultMap&quot;&gt;
        &lt;!-- 用户信息 --&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!-- 订单信息
        一个用户对应多个订单，使用collection映射 
        在用户信息中关联映射商品订单信息--&gt;
        &lt;collection property=&quot;ordersList&quot; ofType=&quot;com.mybatis.entity.Orders&quot;&gt;
             &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
             &lt;result column=&quot;user_id&quot; property=&quot;userid&quot;/&gt;
            &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
            &lt;result column=&quot;createtime&quot; property=&quot;createTime&quot;/&gt;
            &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;

         &lt;!-- 订单明细
                 一个订单包括多个明细
                 在商品订单中关联映射商品订单的多个明细
              --&gt;
              &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.mybatis.entity.OrderDetail&quot;&gt;
                      &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
                     &lt;result column=&quot;items_id&quot;   property=&quot;itemsId&quot;/&gt;
                     &lt;result column=&quot;items_num&quot;  property=&quot;itemsNum&quot;/&gt;
                     &lt;result column=&quot;orders_id&quot;  property=&quot;ordersId&quot;/&gt;
                     &lt;!-- 商品信息
                          一个订单明细对应一个商品
                          然后这儿是一对一的关联映射，所以使用的association进行两者之间的映射 
                       --&gt;
                   &lt;association property=&quot;items&quot; javaType=&quot;com.mybatis.entity.Items&quot;&gt;
                       &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;
                       &lt;result column=&quot;items_name&quot; property=&quot;itemsName&quot;/&gt;
                       &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;
                       &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;
                   &lt;/association&gt;
              &lt;/collection&gt;
          &lt;/collection&gt;

    &lt;/resultMap&gt;
&lt;!-- 查询用户及用户购买的商品信息，使用resulaMap--&gt;

2.定义statement(statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上向数据库发送要执行的SQL语句，Statement用于执行不带参数的简单SQL语句)

&lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;userAndItemsResultMap&quot;&gt;
        SELECT 
               t1.*,
               t2.username,
               t2.sex,
               t2.address,
               t3.id orderdetail_id,
               t3.items_id,
               t3.items_num,
               t3.orders_id,
               t4.itemsname items_name,
               t4.detail items_detail,
               t4.price items_price
        FROM
              orders t1,
              t_user t2,
              orderdetail t3,
              items t4
        WHERE t1.user_id =  t2.id AND  t3.orders_id=t1.id AND t3.items_id = t4.id
&lt;/select&gt;
</code></pre><blockquote>
<p>扩展<br><br>为了验证上述得到的结果是否正确，可以对其进行junit测试。</p>
</blockquote>
<pre><code>public class OrdersCustomMapperTest {
    //创建会话工厂
    private SqlSessionFactory sqlSessionFactory;
    //查询订单，关联查询用户信息，使用resultType实现的测试
    @Test
    public void TestFindOrdersUser() {
        //利用会话工厂创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 创建代理对象
        OrdersCustomMapper oc = sqlSession.getMapper(OrdersCustomMapper.class);
        // 调用mapper接口中的方法
        List&lt;OrdersCustom&gt; list = oc.findOrdersUser();
        //作为验证是否输出的list是否和要查询的结果正确
        System.out.println(list);
        //关闭会话
        sqlSession.close();
}
</code></pre><hr>
<h1 id="mybatis开发总结"><a href="#mybatis开发总结" class="headerlink" title="mybatis开发总结"></a>mybatis开发总结</h1><pre><code>1.一般的查询直接返回实体类型即可，而对于关联查询，处理方式之一就是：自己构造一个resultMap，名称为Map1。然后将自己所需要的字段在新建的resultMap中做一个映射，然后将查询结果设置为新建的Map1。
  注意：在Map1中可以多映射一些字段，为空的查询默认不映射

2.在Mapper层接口，我们一般设置该方法的返回值类型是：List&lt;Map&lt;String,Object&gt;&gt; 每一个list里面放有很多的map键值对

3.#{} 表示一个占位符，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，此外，#{}可以有效防止sql注入
  ${} 表示拼接sql串，通过${}可以将parameterType传入的内容拼接在sql中不进行jdbc类型转换

4.mybatis解决JDBC编程问题
  1.在SqlMapConfig.xml中配置数据库连接池管理数据库连接可以解决因为数据库频繁创建、释放连接而影响系统性能的问题

  2.模糊查询，resultType：表示是List的泛型类型 ${value} 固定写法只能写value表示拼接字符串
</code></pre><hr>
<h2 id="Mybatis整合Spring"><a href="#Mybatis整合Spring" class="headerlink" title="Mybatis整合Spring"></a>Mybatis整合Spring</h2><p>1.整合思路：</p>
<pre><code>1.数据源信息交给Spring管理
2.SqlSessionFactory交给Spring进行单例管理
3.由Spring来管理原始DAO的实现类或者Mapper代理的代理类
</code></pre><h4 id="2-1-具体整合步骤1："><a href="#2-1-具体整合步骤1：" class="headerlink" title="2.1 具体整合步骤1："></a>2.1 具体整合步骤1：</h4><pre><code>1.Mybatis
  1.在配置文件文件夹(config)下创建SqlMapConfig.xml
  2.配置属性文件(db.properties/log4j.properties)

注意：mybatis的配置文件中的数据源配置去掉，由spring进行管理配置。

2.Spring
  1.在配置文件文件夹(config)下创建application.xml
    1.加载Java的配置文件
    &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;
    2.创建数据源
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    //将数据库的驱动(driverClassName)、URL、username、password、maxActive、maxIdle属性值配置完

    3.配置SqlSessionFactory
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        //1.指定mybatis的全局配置文件路径
        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;&gt;
        //2.配置数据源
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3.整合代码
  1.原始DAO开发方式
    1.映射文件(User.xml)
    2.DAO接口代码以及DAO的实现类代码
    3.在application.xml中配置UserDao的实现类
        &lt;bean id=&quot;userDao&quot; class=&quot;xxx.xx.xxx.UserDaoImpl&quot;&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/proerty&gt;
        &lt;/bean&gt;
    4.编写测试代码

  2.mapper代理的方式
    1.映射文件(UserMapper.xml)
    2.Mapper接口
    3.配置mapper代理类
    1.单个mapper代理类的配置
        &lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
            //设置代理类接口
            &lt;property name=&quot;mapperInterface&quot; value=&quot;com.xx.xxx.xx.UserMapper&quot;&gt;&lt;/property&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;    
        &lt;/bean&gt;
    2.批量设置mapper代理类

              &lt;!--批量配置mapper代理类，默认bean的id为类名首字母小写--&gt;
            //通过MapperScannerConfigurer批量扫描创建代理对象
            &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
                &lt;!--配置扫描包--&gt;
                &lt;property name=&quot;basePackage&quot; value=&quot;cn.edu.xidian.c2.mapper&quot; /&gt;
                &lt;!--只有一个sqlSessionFactory时，默认不需要配置SqlSessionFactory,单独配置也可以--&gt;
                &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
</code></pre><hr>
<h4 id="2-2-具体整合步骤2："><a href="#2-2-具体整合步骤2：" class="headerlink" title="2.2 具体整合步骤2："></a>2.2 具体整合步骤2：</h4><pre><code>1.Maven引入需要的jar包(添加依赖 基本的依赖)

2.Spring与Mybatis的整合

  1.建立JDBC属性文件(jdbc.properties 文件编码改为utf-8)
  2.建立spring-mybatis.xml配置文件(用来完成spring和mybatis整合 主要是：自动扫描、自动注入、配置数据库)

3.Log4j的配置

  配置LOG4j的目的是为了更方便测试，使用日志来输出信息，然后所有的项目基本上都是这样一个基本的配置

  1.建立log4j.properties配置文件

4.JUnit测试

  1.创建测试用表
  2.利用MyBatis Generator自动创建代码 这个根据表自动创建实体类、mybatis映射文件、DAO接口

    使用MyBatis Generator自动创建代码 

  3.建立Service接口和实现类

  4.建立测试类

5.整合SpringMVC(springmvc的配置文件单独放，然后在web.xml文件中配置整合)

  1.配置springmvc.xml(主要是自动扫描控制器、视图模式、注解启动这三个的配置)
  2.配置web.xml文件 这里对spring-mybatis.xml配置文件的引入以及配置springmvc的servlet
</code></pre><hr>
<h2 id="Mybatis的逆向工程"><a href="#Mybatis的逆向工程" class="headerlink" title="Mybatis的逆向工程"></a>Mybatis的逆向工程</h2><p>概念：Mybatis提供来一个逆向工程工具，通过逆向工程，可以帮助程序员根据数据表单表来生成po类、mapper映射文件、mapper接口。<br>      就是通过数据库中的单表自动生成Java代码。</p>
<p>具体笔记见mybatis教案</p>
<h4 id="1-逆向工程使用步骤："><a href="#1-逆向工程使用步骤：" class="headerlink" title="1.逆向工程使用步骤："></a>1.逆向工程使用步骤：</h4><pre><code>1.创建generator配置文件
  generator.xml文件内容可以从逆向工程的jar包下的docs目录下的index.html文件中找到相关的源代码

2.使用java类来执行逆向工程

  public class Generator {
    public static void main(String[] args)  throws Exception{
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        File configFile = new File(&quot;config/generator.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    }

}

3.把生成的代码拷贝到项目中
  如果正式项目中已经有po类所在的包了，那么就只需要拷贝po类到指定包下就可以。如果正式项目中没有po包，那么就把逆向工程中整个po类的包拷贝过去。
Mapper.xml和mapper.java的拷贝与po类一样


4.在正式项目中使用逆向工程生成的代码

  public class ItemsMapperTest {

// spring上下文
private ApplicationContext ctx;

@Before
public void setUp() throws Exception {
    // 读取spring的上下文，然后封装到ctx
    ctx = new ClassPathXmlApplicationContext(
            &quot;spring/applicationContext.xml&quot;);
}

@Test
public void testSelectByExample() {
    ItemsMapper mapper = (ItemsMapper) ctx.getBean(&quot;itemsMapper&quot;);

    ItemsExample example = new ItemsExample();
    //使用它进行参数封装传递
    Criteria criteria = example.createCriteria();
    //设置参数
    criteria.andNameEqualTo(&quot;背包&quot;);

    List&lt;Items&gt; list = mapper.selectByExample(example);

    System.out.println(list);
}
</code></pre><p>}</p>
<pre><code>注意：
1.mapper.xml文件已经存在时，如果进行重新生成mapper.xml文件，内容不会被覆盖，而是进行mapper.xml文件内容的追加，结果会导致mybatis解析失败
解决方法：删除原来已经生成的mapper.xml文件再进行生成

2.mybatis自动生成的po以及mapper.java文件不是追加而是直接覆盖，所以不会出现此问题。
</code></pre><hr>
<h2 id="Mybatis-的查询缓存"><a href="#Mybatis-的查询缓存" class="headerlink" title="Mybatis 的查询缓存"></a>Mybatis 的查询缓存</h2><h4 id="1-mybatis缓存分析"><a href="#1-mybatis缓存分析" class="headerlink" title="1.mybatis缓存分析"></a>1.mybatis缓存分析</h4><p>mybatis提供查询缓存，如果缓存中有数据就不用从数据库中获取，用于减轻数据压力，提高系统性能。</p>
<pre><code>一级缓存：SqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)用于存储缓存数据，不同的sqlSession之间的缓存数据区域(HashMap)互相不影响。

二级缓存：mapper级别的缓存，多个SqlSession去操作同一个mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

注意：mybatis默认支持一级缓存

应用：在开发项目过程中，将mybatis与spring进行整合开发，事务控制在service中，一个service方法中包括很多mapper方法调用。
</code></pre><blockquote>
<p>注意：mybatis默认没有开启二级缓存</p>
</blockquote>
<h4 id="2-mybatis-开启二级缓存"><a href="#2-mybatis-开启二级缓存" class="headerlink" title="2.mybatis 开启二级缓存"></a>2.mybatis 开启二级缓存</h4><pre><code>1.在核心配置文件SqlMapConfig.xml中添加开启二级缓存总开关
  &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;

2.在UserMapper映射文件中开启二级缓存（开启mapper下的namespace的二级缓存，默认使用mybatis提供的PerpetualCache）
  &lt;cache&gt;&lt;/cache&gt;

3.实现序列化(因为二级缓存的数据不一定都是存储在内存中的，所以需要给缓存的对象执行序列化，如果该类存在父类，也需要给父类实现序列化)
</code></pre><h4 id="3-mybatis-禁用二级缓存"><a href="#3-mybatis-禁用二级缓存" class="headerlink" title="3.mybatis 禁用二级缓存"></a>3.mybatis 禁用二级缓存</h4><pre><code>在statement中设置userCache=false禁用当前select语句的二级缓存，每次查询都要去数据库中查询，默认情况下是true，该statement使用二级缓存。

&lt;select id=&quot;findUserById&quot;  parameterType=&quot;int&quot;  resultType=&quot;cn.itcast.mybatis.po.User&quot;  useCache=&quot;true&quot;&gt;
        SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre><h4 id="4-mybatis刷新二级缓存"><a href="#4-mybatis刷新二级缓存" class="headerlink" title="4.mybatis刷新二级缓存"></a>4.mybatis刷新二级缓存</h4><pre><code>见mybatis教案
</code></pre><hr>
<h4 id="5-mybatis-延迟加载"><a href="#5-mybatis-延迟加载" class="headerlink" title="5.mybatis 延迟加载"></a>5.mybatis 延迟加载</h4><pre><code>见mybatis教案
</code></pre><hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h4 id="1-Spring-MVC"><a href="#1-Spring-MVC" class="headerlink" title="1.Spring MVC"></a>1.Spring MVC</h4><pre><code>作用于WEB层，相当于Controller，用来处理用户请求。例：用户在地址栏输入http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法(虽然中间可能会包含很多业务，但是这些都不是SpringMVC来处理)
最终将结果返回给用户，并且返回相应的页面(可以只返回json/xml等格式数据)

总结：SpringMVC只负责跟用户打交道，做前面和后面的活，中间的实现过程等业务不是它负责。
</code></pre><h4 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2.Spring"></a>2.Spring</h4><pre><code>最常见，经常用到的是IOC容器，其可以装载bean(Java中的类，也包括service dao里面的)有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。
</code></pre><h4 id="3-mybatis"><a href="#3-mybatis" class="headerlink" title="3.mybatis"></a>3.mybatis</h4><pre><code>1.能够自由控制SQL
2.可以使用xml的方式来组织管理我们的SQL
</code></pre><hr>
<p>1.SSM整合</p>
<pre><code>1.Java各种对象的区分

PO 持久对象(entity) PO每个属性基本上都对应数据库表里面的某个字段，完全是一个符合Java Bean规范的Java对象，没有增强别的属性和方法。持久对象是由&lt;insert&gt;&lt;/insert&gt;数据库创建，由数据库&lt;delete&gt;&lt;/delete&gt;删除的。基本上持久对象生命周期和数据库密切相关。

VO 值对象 通常用于业务层(Service层)之间的数据传输，与PO一样只包含数据,此外应该抽象出业务对象。表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。

DTO 数据传输对象 是一种设计模式之间传输数据的软件应用系统 作用仅在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。

POJO 简单的Java对象 实际上可以理解POJO为简单的实体类 方便开发者使用数据库中的数据表
</code></pre><hr>
<h2 id="DTO-数据传输对象（起到数据封装与隔离的作用）"><a href="#DTO-数据传输对象（起到数据封装与隔离的作用）" class="headerlink" title="DTO 数据传输对象（起到数据封装与隔离的作用）"></a>DTO 数据传输对象（起到数据封装与隔离的作用）</h2><p>在实际的项目中，DTO分为两层传输</p>
<pre><code>1.Service层向Controller层，这一层的DTO封装Service执行结果给Controller简化业务数据，只提取部分业务相关字段或补充处理相关字段，不同业务可能有不同的此类dto，具有业务相关性。

2.Controller层向WEB前端，这一层DTO封装Controller执行结果，返回前端WEB，请求返回实体封装类，适用于所有ajax请求返回的类型实体，无业务相关性。
</code></pre><hr>
<h2 id="SSM整合知识点概括"><a href="#SSM整合知识点概括" class="headerlink" title="SSM整合知识点概括"></a>SSM整合知识点概括</h2><pre><code>1.Controller方法返回值(指定返回到哪个页面，指定返回到页面的数据)

    1)ModelAndView 

        modelAndView.addObject(&quot;itemList&quot;, list); 指定返回页面的数据

        modelAndView.setViewName(&quot;itemList&quot;);     指定返回的页面

    2)String(推荐使用)

        返回普通字符串,就是页面去掉扩展名的名称, 返回给页面数据通过Model来完成

        返回的字符串以forward:开头为请求转发

        返回的字符串以redirect:开头为重定向

    3)返回void(使用它破坏了springMvc的结构,所以不建议使用)

        可以使用request.setAttribut(因为我们写的是服务端，所以使用request对象向view中传输数据) 来给页面返回数据

        可以使用request.getRquestDispatcher().forward()来指定返回的页面

        如果controller返回值为void则不走springMvc的组件,所以要写页面的完整路径名称

    相对路径:相对于当前目录,也就是在当前类的目录下,这时候可以使用相对路径跳转

    绝对路径:从项目名后开始.
</code></pre><blockquote>
<p>注意：在springMvc中不管是forward还是redirect后面凡是以/开头的为绝对路径,不以/开头的为相对路径。</p>
</blockquote>
<pre><code>例如:
    forward:/items/itemEdit.action 为绝对路径

    forward:itemEdit.action为相对路径
</code></pre><hr>
<pre><code>2.架构级别异常处理

    此异常编写是实现全局异常处理器接口，目的主要为了防止项目上线后给用户抛500等异常信息,所以需要在架构级别上整体处理.hold住异常

    1.首先自定义全局异常处理器实现HandlerExceptionResolver接口
        public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {//....

    2.在spirngMvc.xml中配置生效
</code></pre><hr>
<pre><code>3.上传图片

    1)在tomcat中配置虚拟图片服务器

    2)导入fileupload的jar包

    3)在springMvc.xml中配置上传组件

    4)在页面上编写上传域,更改form标签的类型

    5)在controller方法中可以使用MultiPartFile接口接收上传的图片

    6)将文件名保存到数据库,将图片保存到磁盘中
</code></pre><hr>
<pre><code>4.JSON数据交互

    1.首先在pom.xml中配置好需要的jar包(jackson的jar包)

    2.@Requestbody:将页面传到controller中的json格式字符串自动转换成java的pojo对象
      @ResponseBody:将java中pojo对象自动转换成json格式字符串返回给页面
</code></pre><hr>
<pre><code>5.RestFul风格支持

    此风格就是对URL的命名标准，此标准要求URL中只能有名词，要求URL中不能用?传参

    传参数：
        页面：${pageContext.request.contextPath}/items/itemEdit/${item.id}
        方法：@RequestMapping(&quot;/itemEdit/{id}&quot;)
        方法：@PathVariable(&quot;id&quot;) Integer id
</code></pre><hr>
<pre><code>6.拦截器

    作用：拦截请求，一般在登录的时候用得比较多
    1.需要编写自定义拦截器类,实现HandlerInterceptor接口
        public class AuthorizedInterceptor implements HandlerInterceptor {//......
    2.在spirngMvc.xml中配置拦截器生效
</code></pre><hr>
<pre><code>7.登录权限验证

    1)编写登录的Controller，编写跳转到登录页面，编写登录验证方法
    2)编写登录页面
    3)编写拦截器
</code></pre><blockquote>
<p>总结：随意访问一个页面，拦截器会拦截请求，会验证session是否有登录信息。如果已经登录，放。如果未登录，跳转到登录页面<br>          在登录页面输入用户名、密码，点击登录按钮，拦截器会拦截请求，如果登录路径在Controller方法中判断用户名和密码正确则将登录信息方法session中。</p>
</blockquote>
<hr>
<p>更新时间：2018/09/22</p>
<h2 id="Mybatis-项目开发经验"><a href="#Mybatis-项目开发经验" class="headerlink" title="Mybatis - 项目开发经验"></a>Mybatis - 项目开发经验</h2><h4 id="1-mybatis中selectkey的作用"><a href="#1-mybatis中selectkey的作用" class="headerlink" title="1.mybatis中selectkey的作用"></a>1.mybatis中selectkey的作用</h4><blockquote>
<blockquote>
<p><code>selectkey</code>在mybatis中是为了解决<code>insert</code>数据时不支持主键自动生成的问题，<code>selectkey</code>可以很随意的设置生成主键的方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在<code>selectkey</code>中的属性有：<br><code>1.keyProperty</code>：selectkey语句结果应该被设置的目标属性,指定存放生成主键的属性<br><code>2.resultType</code>：结果的类型，mybatis允许任何简单的类型用作主键的类型,包括字符串。<br>3.<code>order</code>：可以被设置为 <code>BEFORE</code> 或 <code>AFTER</code>。如果设置为 <code>BEFORE</code>,那么它会首先选择主键,设置 <code>keyProperty</code> 然后执行插入语句。如果设置为 <code>AFTER</code>,那么先执行插入语句,然后是 <code>selectKey</code> 元素-这和，如 Oracle 数据库相似,可以在插入语句中嵌入序列调用。所以<code>order</code>指定了查询主键的sql与insert的执行顺序，只要不是自增主键，<code>order</code>都设置为<code>before</code>。<br>4.<code>statementType</code>：MyBatis 支持 <code>STATEMENT PREPARED</code>和<code>CALLABLE</code> 语句的映射类型,分别代表 <code>reparedStatement</code> 和<code>CallableStatement</code> 类型。<br>4.<code>last_insert_id</code>：mysql的函数，配合insert语句一起使用。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：selectkey需要注意order属性，比如在mysql一类的自动增长类型的数据库中，order需要设置为after才能够取得正确的值。</p>
</blockquote>
<hr>
<h2 id="Mybatis-案例"><a href="#Mybatis-案例" class="headerlink" title="Mybatis - 案例"></a>Mybatis - 案例</h2><pre><code>package cn.edu.xidian.tjxt.dao;

import cn.edu.xidian.tjxt.vo.BodyCheckInfoVo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Logger;

@Repository
public class BodyCheckInfoDao {
    public static final Logger LOG = Logger.getLogger(String.valueOf(BodyCheckInfoDao.class));
    private JdbcTemplate jdbcTemplate;
    @Autowired
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate = jdbcTemplate;
    }
    //查看列是否存在函数
//    public boolean isColumnExist(ResultSet rs, String columnName) {
//        try {
//            if (rs.findColumn(columnName) &gt; 0 ) {
//                return true;
//            }
//        }
//        catch (SQLException e) {
//            return false;
//        }
//        return false;
//    }

    /**
     * 方法：bodyCheckInfoResultMap
     * 作用：数据库信息返回，controller中调用
     */
    public void bodyCheckInfoResultMap(ResultSet resultSet, BodyCheckInfoVo bodyCheckInfoVo) throws SQLException{
        bodyCheckInfoVo.setStudentId(resultSet.getInt(&quot;id&quot;));
        bodyCheckInfoVo.setName(resultSet.getString(&quot;name&quot;));
        bodyCheckInfoVo.setSex(resultSet.getString(&quot;sex&quot;));
        bodyCheckInfoVo.setStudentNum(resultSet.getString(&quot;student_num&quot;));//学生学号
        bodyCheckInfoVo.setIdNum(resultSet.getString(&quot;id_num&quot;));//学生身份证号
        bodyCheckInfoVo.setCheckTime(resultSet.getDate(&quot;check_time&quot;));//体检时间

//        bodyCheckInfoVo.setTuberculosis(resultSet.getString(&quot;tuberculosis&quot;));//肺结核检查结果，因为数据库中肺结核一栏为null值
        bodyCheckInfoVo.setListSubmit(resultSet.getInt(&quot;list_submit&quot;));//是否提交体检表单

        bodyCheckInfoVo.setPpdCheck(resultSet.getString(&quot;ppd_check&quot;));//ppd检查结果
        bodyCheckInfoVo.setKidney(resultSet.getString(&quot;kidney&quot;));//肾功检查结果
        bodyCheckInfoVo.setLiverFunction(resultSet.getString(&quot;liver_function&quot;));//肝功检查结果
        bodyCheckInfoVo.setBodyCheck(resultSet.getString(&quot;body_check&quot;));//体检结果

        bodyCheckInfoVo.setHepatitisBCheck(resultSet.getString(&quot;hepatitis_b_check&quot;));//乙肝检查结果
        bodyCheckInfoVo.setHemorrhagic1(resultSet.getString(&quot;hemorrhagic1&quot;));//出血热一
        bodyCheckInfoVo.setHemorrhagic2(resultSet.getString(&quot;hemorrhagic2&quot;));//出血热二
        bodyCheckInfoVo.setHemorrhagic3(resultSet.getString(&quot;hemorrhagic3&quot;));//出血热三

        bodyCheckInfoVo.setMeasles(resultSet.getString(&quot;measles&quot;));//麻腮风检查结果
        bodyCheckInfoVo.setHepatitisB1(resultSet.getString(&quot;hepatitis_b1&quot;));//乙肝一检查结果
        bodyCheckInfoVo.setHepatitisB2(resultSet.getString(&quot;hepatitis_b2&quot;));//乙肝二检查结果
        bodyCheckInfoVo.setHepatitisB3(resultSet.getString(&quot;hepatitis_b3&quot;));//乙肝三检查结果
        bodyCheckInfoVo.setHepatitisA1(resultSet.getString(&quot;hepatitis_a1&quot;));//甲肝一检查结果
        bodyCheckInfoVo.setHepatitisA2(resultSet.getString(&quot;hepatitis_a2&quot;));//甲肝二检查结果

    }

    //sql语句通过姓名、学号以及身份证号三者联合查询
    private static final String FIND_BODY_CHECK_INFOS = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE student_num = ? AND name = ? AND id_num LIKE ? &quot;;

    //sql语句
    private static final String FIND_BODY_CHECK_INFO_BY_ID_NUM_SQL = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE id_num LIKE ?&quot;;
    private static final String FIND_BODY_CHECK_INFO_BY_STUDENT_NUM =  &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE student_num = ? &quot;;
    private static final String FIND_BODY_CHECK_INFO_BY_NOTICE_NUM = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE notice_num = ? &quot;;
    private static final String FIND_BODY_CHECK_INFO_BY_NAME = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE name = ?&quot;;

    //通过三个变量联合查询，得到的结果认为只有一个
    public BodyCheckInfoVo findBodyCheckInfos(String studentNum,String name,String idNum){
        if (studentNum == null || studentNum.equals(&quot;&quot;)) return null;
        if (name == null || name.equals(&quot;&quot;)) return null;
        if (idNum == null || idNum.equals(&quot;&quot;)) return null;
        if (idNum.length() != 6) return null;
        final BodyCheckInfoVo bodyCheckInfoVos = new BodyCheckInfoVo();
        jdbcTemplate.query(FIND_BODY_CHECK_INFOS, new Object[]{studentNum,name,&quot;%&quot;+idNum},
                new RowCallbackHandler() {
                    @Override
                    public void processRow(ResultSet resultSet) throws SQLException {
                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVos);
                    }
                });
        if(bodyCheckInfoVos.getStudentId() == null) return null;
        return bodyCheckInfoVos;
    }

    //通过身份证号码查询，可能有多条信息，所以用返回List
//    public List&lt;BodyCheckInfoVo&gt; findBodyCheckInfoVoByIdNum(String idNum) {
//        if (idNum.length() != 6) return null;
//        if (idNum == null || idNum.equals(&quot;&quot;)) return null;
//            return jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_ID_NUM_SQL, new Object[]{&quot;%&quot; + idNum}, new RowMapper&lt;BodyCheckInfoVo&gt;() {
//                public BodyCheckInfoVo mapRow(ResultSet resultSet, int i) throws SQLException {
//                    BodyCheckInfoVo bodyCheckInfoVo = new BodyCheckInfoVo();
//                    bodyCheckInfoResultMap(resultSet, bodyCheckInfoVo);
//                    return bodyCheckInfoVo;
//                }
//            });
//    }

    //通过学号查询，可能有多条信息(留级保留学号的情况)，所以用返回List
//    public List&lt;BodyCheckInfoVo&gt; findBodyCheckInfoVoByStudentNum(String studentNum) {
//        if(studentNum == null || studentNum.equals(&quot;&quot;)) return null;
//        return jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_STUDENT_NUM, new Object[]{studentNum},
//                new RowMapper&lt;BodyCheckInfoVo&gt;() {
//                    public BodyCheckInfoVo mapRow(ResultSet resultSet,int i) throws SQLException {
//                        BodyCheckInfoVo bodyCheckInfoVo = new BodyCheckInfoVo();
//                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVo);
//                        return  bodyCheckInfoVo;
//                    }
//                });
//    }

    //通过通知书号码查询，认为只有一个
//    public BodyCheckInfoVo findBodyCheckInfoVoByNoticeNum(String noticeNum) {
//        if(noticeNum == null || noticeNum.equals(&quot;&quot;)) return null;
//        final BodyCheckInfoVo bodyCheckInfoVo= new BodyCheckInfoVo();
//        jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_NOTICE_NUM, new Object[]{noticeNum},
//                new RowCallbackHandler() {
//                    @Override
//                    public void processRow(ResultSet resultSet) throws SQLException {
//                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVo);
//                    }
//                });
//        if(bodyCheckInfoVo.getStudentId() == null) return null;
//        return bodyCheckInfoVo;
//    }

    //新增查询方式
    //通过学生姓名查询学生体检信息,因为可能有重名的情况，所以返回用List
//    public List&lt;BodyCheckInfoVo&gt; findBodyCheckInfoVoByName(String name) {
//        if(name == null || name.equals(&quot;&quot;)) return null;
//        return jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_NAME, new Object[]{name},
//                new RowMapper&lt;BodyCheckInfoVo&gt;() {
//                    public BodyCheckInfoVo mapRow(ResultSet resultSet,int i) throws SQLException{
//                        BodyCheckInfoVo bodyCheckInfoVo = new BodyCheckInfoVo();
//                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVo);
//                        return  bodyCheckInfoVo;
//                    }
//                });
//    }
}
</code></pre>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/undefined/Nginx/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1.正向代理</p>
<p>如果将局域网外的Internet想象成一个巨大的资源库，则局域网内的客户端要访问Internet需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<p>2.反向代理</p>
<p>客户端对代理无感知，因为客户端不需要任何配置都可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的代理服务器地址，隐藏了真是服务器IP地址。</p>
<p>3.负载均衡</p>
<p>反向代理服务器将客户端请求平均分担到各个服务器中。</p>
<p>4.动静分离</p>
<p>这里为了加快网站的解析速度，可以将动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
<p>在服务器Tomcat中部署动态资源，然后在专门的静态资源服务器中部署静态资源。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="1-安装编译工具和库文件"><a href="#1-安装编译工具和库文件" class="headerlink" title="1. 安装编译工具和库文件"></a>1. 安装编译工具和库文件</h4><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel
</code></pre><h4 id="2-安装PCRE"><a href="#2-安装PCRE" class="headerlink" title="2. 安装PCRE"></a>2. 安装PCRE</h4><p>pcre作用让Nginx支持rewrite功能。</p>
<pre><code>1. wget http://...
2. 解压目录 tar -zxvf pcre...
3. 进入安装包
4. 编译安装 ./configure make &amp;&amp; make install
5. 查看pcre版本
</code></pre><h4 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3. 安装Nginx"></a>3. 安装Nginx</h4><pre><code>1. 获取资源 wget http://....
2. 解压目录 tar -zxvf nginx..
3. 进入安装目录
4. 编译安装 
    ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35 make &amp;&amp; make install
5. 查看版本号
    /usr/local/webserver/nginx/sbin/nginx -v
</code></pre><h4 id="4-Nginx配置"><a href="#4-Nginx配置" class="headerlink" title="4. Nginx配置"></a>4. Nginx配置</h4><pre><code>1. 创建Nginx运行使用的用户www

    /usr/sbin/groupadd www 

    /usr/sbin/useradd -g www www

2. 配置ngin.conf

3. 检查配置是否正确

    /usr/local/webserver/nginx/sbin/nginx -t

4. 启动Nginx

    /usr/local/webserver/nginx/sbin/nginx
</code></pre><blockquote>
<p>提示：在上面所有的配置文件配置完成之后，如果在浏览器中访问不了网页，可能是因为Linux的防火墙开着，关闭防火墙便能够访问。在关闭防火墙之后还需要开放端口号才能够访问。</p>
</blockquote>
<pre><code>centos7防火墙：

    开启：systemctl start firewalld.service
    关闭：systemctl stop firewalld.service
    重启：systemctl restart firewalld.service

    systemctl status firewalld 查看firewalld状态

    firewall-cmd --zone=public --add-port=8080/tcp --permanent 开启端口号

    sudo firewall-cmd --add-port=8001/tcp --permanent 设置端口号8001

    sudo firewall-cmd --add-port=8080/tcp --permanent 设置端口号8080

    firewall-cmd --reload 重启防火墙

    firewall-cmd --list-all 查看防火墙列表

    ...
</code></pre><h4 id="5-Nginx常用命令"><a href="#5-Nginx常用命令" class="headerlink" title="5. Nginx常用命令"></a>5. Nginx常用命令</h4><blockquote>
<p>提示：在我们使用Nginx操作命令前提条件是我们必须进入Nginx的目录。</p>
</blockquote>
<pre><code>1. 查看Nginx版本号

    在/sbin/目录下使用 ./nginx -v 命令

2. 启动Nginx

    ./nginx

3. 关闭Nginx  

    ./nginx -s stop

4. 重新加载Nginx

    ./nginx -s reload
</code></pre><blockquote>
<p>提示：命令 ps -ef | grep nginx 查看Nginx进程。</p>
</blockquote>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="1-全局块"><a href="#1-全局块" class="headerlink" title="1. 全局块"></a>1. 全局块</h4><p>配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</p>
<p>从配置文件开始到events之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令。</p>
<h4 id="2-events块"><a href="#2-events块" class="headerlink" title="2. events块"></a>2. events块</h4><p>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</p>
<p>在该块中的配置指令主要影响Nginx服务器与用户的网络连接。</p>
<h4 id="3-HTTP块"><a href="#3-HTTP块" class="headerlink" title="3. HTTP块"></a>3. HTTP块</h4><p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p>
<p>该部分是Nginx中配置最为频繁的部分，代理、缓存和日志定义等绝大多数的功能和第三方的模块配置都在这里。</p>
<blockquote>
<p>注意：http块也可以包括http全局块、server块。</p>
</blockquote>
<h5 id="3-1-http全局块"><a href="#3-1-http全局块" class="headerlink" title="3.1 http全局块"></a>3.1 http全局块</h5><p>在http全局配置的指令包括文件引入、mime-type定义、日志自定义、连接超时时间、单链接请求数量上限等。</p>
<h5 id="3-2-server块"><a href="#3-2-server块" class="headerlink" title="3.2 server块"></a>3.2 server块</h5><p>配置虚拟主机的相关参数，一个http中可以有多个server。每个server块就相当于一个虚拟主机。</p>
<p>该块和虚拟主机有密切关系，虚拟主机从用户角度看和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p>
<p>每个server又可以分为全局server块以及可以同时包括多个location块。</p>
<ol>
<li>全局server块</li>
</ol>
<p>最常见的配置是本虚拟主机的监听配置和本虚拟主机的名称和IP配置。</p>
<ol start="2">
<li>location块</li>
</ol>
<p>一个server块可以配置多个location块，该块的主要作用是基于Nginx服务器接收到请求字符串，对虚拟主机名称（IP别名）之外的字符串进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，或其它第三方模块的配置。</p>
<h5 id="配置请求的路由，以及各种页面的处理情况"><a href="#配置请求的路由，以及各种页面的处理情况" class="headerlink" title="配置请求的路由，以及各种页面的处理情况"></a>配置请求的路由，以及各种页面的处理情况</h5><pre><code>########### 每个指令必须有分号结束。#################
#user administrator administrators;  #配置用户或者组，默认为nobody nobody。
#worker_processes 2;  #允许生成的进程数，默认为1
#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址
error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
events {
    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    worker_connections  1024;    #最大连接数，默认为512
}
http {
    include       mime.types;   #文件扩展名与文件类型映射表
    default_type  application/octet-stream; #默认文件类型，默认为text/plain
    #access_log off; #取消服务日志    
    log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; #自定义格式
    access_log log/access.log myFormat;  #combined为日志格式的默认值
    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。

    upstream mysvr {   
      server 127.0.0.1:7878;
      server 192.168.10.121:3333 backup;  #热备
    }

    error_page 404 https://www.baidu.com; #错误页

    server {
        keepalive_requests 120; #单连接请求上限次数。
        listen       4545;   #监听端口
        server_name  127.0.0.1;   #监听地址       
        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
           #root path;  #根目录
           #index vv.txt;  #设置默认页
           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表
           deny 127.0.0.1;  #拒绝的ip
           allow 172.18.5.54; #允许的ip           
        } 
    }
}

上面是nginx的基本配置，需要注意的有以下几点：

1、几个常见配置项：

 1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；
 2.$remote_user ：用来记录客户端用户名称；
 3.$time_local ： 用来记录访问时间与时区；
 4.$request ： 用来记录请求的url与http协议；
 5.$status ： 用来记录请求状态；成功是200；
 6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；
 7.$http_referer ：用来记录从那个页面链接访问过来的；
 8.$http_user_agent ：记录客户端浏览器的相关信息；

2、惊群现象：一个网路连接到来，多个睡眠的进程被同事叫醒，但只有一个进程能获得链接，这样会影响系统性能。
3、每个指令必须有分号结束。
</code></pre><h3 id="第2章-Nginx反向代理配置"><a href="#第2章-Nginx反向代理配置" class="headerlink" title="第2章 Nginx反向代理配置"></a>第2章 Nginx反向代理配置</h3><pre><code>1. 在Windows系统的hosts文件中进行域名和IP对应关系的配置。

2. 在Nginx中进行请求转发的配置（反向代理配置）

3. 访问网站
</code></pre><h4 id="2-1-Nginx实现反向代理"><a href="#2-1-Nginx实现反向代理" class="headerlink" title="2.1 Nginx实现反向代理"></a>2.1 Nginx实现反向代理</h4><ol>
<li>效果</li>
</ol>
<p>在使用Nginx反向代理，根据访问的路径不同跳转到不同的端口的服务中。</p>
<pre><code>1. Nginx的监听端口为 9001。

2. 访问http://localhost:9001/edu/ 跳转到localhost:8008/
3. 访问http://localhost:9001/vod/ 跳转到localhost:8089/
</code></pre><ol start="2">
<li><p>准备工作</p>
<ol>
<li><p>准备两个Tomcat服务器，一个8080端口，一个8081端口。</p>
<p> 提示：如果这里配置了两个tomcat但只有一个能访问，并且配置文件server.xml文件中三个端口号没有冲突的情况下，那么可能是配置的端口号没有开放对外访问。此时应该设置设置防火墙的开放端口号。</p>
</li>
<li><p>创建文件夹以及测试文件放到tomcat的目录下。</p>
<p> 在tomcat目录的webapps目录下创建将要访问的文件和文件夹。</p>
</li>
</ol>
</li>
<li><p>具体配置</p>
<ol>
<li><p>找到Nginx的配置文件，然后在里面做反向代理配置</p>
<p> server {</p>
<pre><code>listen       9001;
server_name  192.168.8.122;

location ~ /edu/ {
    proxy_pass: http://127.0.0.1:8080;
}

location ~ /vod/ {
    proxy_pass: http://127.0.0.1:8089;
}
</code></pre><p> }</p>
</li>
<li><p>开放对外访问的端口号</p>
<ol>
<li><p>查看已经开放端口号</p>
</li>
<li><p>增加开放端口号</p>
</li>
<li><p>测试增加开放端口号是否能访问</p>
<p>提示：如果有些时候在配置好之后还是无法访问，可以重启一下tomcat，可能是之前的配置没有生效，重启之后让之前的配置生效。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>配置nginx.conf配置文件的反向代理设置之后，重启Nginx</p>
</li>
</ol>
<h4 id="2-2-Nginx实现负载均衡"><a href="#2-2-Nginx实现负载均衡" class="headerlink" title="2.2 Nginx实现负载均衡"></a>2.2 Nginx实现负载均衡</h4><ol>
<li>实现效果</li>
</ol>
<p>浏览器输入地址<a href="http://192.168.8.122/edu/a.html。负载均衡效果，平均分配到8080和8089端口中去。" target="_blank" rel="noopener">http://192.168.8.122/edu/a.html。负载均衡效果，平均分配到8080和8089端口中去。</a></p>
<ol start="2">
<li><p>准备工作</p>
<ol>
<li><p>准备两台tomcat服务器，一台8080，一台8089。</p>
</li>
<li><p>在两台tomcat里面webapps目录下创建名称为edu的文件夹，在edu文件夹下创建页面a.html，用于测试。</p>
</li>
</ol>
</li>
<li><p>在Nginx的配置文件中进行负载均衡的配置</p>
</li>
</ol>
<h4 id="2-3-Nginx实现动静分离"><a href="#2-3-Nginx实现动静分离" class="headerlink" title="2.3 Nginx实现动静分离"></a>2.3 Nginx实现动静分离</h4><ol>
<li><p>准备工作</p>
<ol>
<li><p>在Linux中准备静态资源</p>
</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="2-4-Nginx高可用集群"><a href="#2-4-Nginx高可用集群" class="headerlink" title="2.4 Nginx高可用集群"></a>2.4 Nginx高可用集群</h4><ol>
<li><p>在Linux中配置两个ip</p>
<ol>
<li><p>在/etc/sysconfig/network-scripts/目录下修改ifcfg-ens2文件</p>
<p> IPADDR1=…//加入新的ip</p>
</li>
<li><p>重启更新网络服务</p>
<p> systemctl restart network</p>
</li>
<li><p>查看是否配置成功</p>
<p> ip addr </p>
<p> 提示：这里使用ipconfig命令查看不了新配置的IP。</p>
</li>
</ol>
</li>
</ol>
<p>高可用，在Nginx宕机的情况下，整个服务还能够正常运行。</p>
<pre><code>1. 在这里配置的时候需要两台Nginx服务器

2. 需要keepalived

3. 需要虚拟IP
</code></pre><ol>
<li><p>准备工作</p>
<ol>
<li><p>需要两个服务器</p>
</li>
<li><p>在两台服务器上安装Nginx</p>
</li>
<li><p>在两台服务器上安装keepalived</p>
<ol>
<li><p>在两台服务器上使用命令 yum 进行安装</p>
<p> yum install keepalived -y</p>
</li>
<li><p>在安装完成之后，在etc目录里面生成目录keepalived，有文件keepalived.conf</p>
</li>
</ol>
</li>
<li><p>完成高可用配置（主从配置）</p>
<ol>
<li><p>修改/etc/keepalived/keepalived.conf配置文件</p>
</li>
<li><p>在/usr/local/src添加检测脚本</p>
</li>
<li><p>启动两台服务器上的Nginx和keepalived</p>
<ol>
<li><p>启动Nginx ./nginx</p>
</li>
<li><p>启动keepalived systemctl start keepalived.service</p>
</li>
</ol>
</li>
<li><p>测试</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Nginx的原理"><a href="#Nginx的原理" class="headerlink" title="Nginx的原理"></a>Nginx的原理</h3><h4 id="多个worker和一个master机制的优势"><a href="#多个worker和一个master机制的优势" class="headerlink" title="多个worker和一个master机制的优势"></a>多个worker和一个master机制的优势</h4><ol>
<li><p>可以使用 nginx -s reload 命令进行热部署操作</p>
</li>
<li><p>对于每个worker进程来说，独立的进程不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，会方便很多。然后独立进程，进程之间不会相互影响，一个进程结束之后，其它进程还在工作，服务不会中断。</p>
</li>
<li><p>合适数量的worker的数量设置，Nginx与Redis类似，都采用了IO多路复用机制，每个worker都是一个独立的进程，每个进程只有一个主线程，通过异步非阻塞的方式处理请求。所以worker的数量和服务器CPU核心数相等最好。</p>
</li>
</ol>
<h4 id="连接数-worker-connection"><a href="#连接数-worker-connection" class="headerlink" title="连接数 worker_connection"></a>连接数 worker_connection</h4><pre><code>1. 发送请求占用了worker的几个连接数（2或者4个）

2. Nginx有1个master和4个worker，每个worker支持最大的连接数为1024，支持最大的并发数是多少?

    普通的静态访问最大并发数是：

        worker_connections * worker_process / 2

    如果是HTTP作为反向代理来说，支持最大并发数量是：

        worker_connections * worker_process / 4
</code></pre><h3 id="第3章-Nginx的基本配置和优化"><a href="#第3章-Nginx的基本配置和优化" class="headerlink" title="第3章 Nginx的基本配置和优化"></a>第3章 Nginx的基本配置和优化</h3><h4 id="3-2-Nginx的虚拟主机配置"><a href="#3-2-Nginx的虚拟主机配置" class="headerlink" title="3.2 Nginx的虚拟主机配置"></a>3.2 Nginx的虚拟主机配置</h4><p>虚拟主机，将服务器上的主机分成一台台“虚拟”主机，每台虚拟主机都可以是一台独立的网站，同一台服务器的虚拟主机之间是独立的。</p>
<blockquote>
<p>提示：Nginx可以配置多种类型的虚拟主机。1.基于IP的虚拟主机。2.基于域名的虚拟主机。3.基于端口的虚拟主机。</p>
</blockquote>
<h5 id="3-2-1-基于IP的虚拟主机"><a href="#3-2-1-基于IP的虚拟主机" class="headerlink" title="3.2.1 基于IP的虚拟主机"></a>3.2.1 基于IP的虚拟主机</h5><pre><code>http
{
    #第一个虚拟主机
    server
    {
        listen  ...:..;
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    #第一个虚拟主机
    server
    {
        listen  ...:..;
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    ...

}
</code></pre><blockquote>
<p>提示：从上面配置文件我们可以得到一段server{}文件表示一个虚拟主机。如果需要配置多段虚拟主机，那么配置多段server{}即可。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：如果需要在eth0网卡设备上添加两个IP别名 192.168.8.122 | 192.168.2.132 可以通过 ifconfig | route 命令操作。</p>
</blockquote>
</blockquote>
<h5 id="3-2-2-配置基于域名的虚拟主机"><a href="#3-2-2-配置基于域名的虚拟主机" class="headerlink" title="3.2.2 配置基于域名的虚拟主机"></a>3.2.2 配置基于域名的虚拟主机</h5><p>基于域名的虚拟主机配置最常见的虚拟主机配置，只需要配置DNS服务器，然后将主机名映射到正确的IP地址，然后配置Nginx服务器，令其识别不同的主机名便可。</p>
<pre><code>http
{
    #第一个虚拟主机
    server
    {
        #监听的端口
        listen  80;
        #主机名字
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件，顺序从左到右
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    #第一个虚拟主机
    server
    {
        listen  ...:..;
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    ...

}
</code></pre><h4 id="3-3-Nginx日志文件配置与切割"><a href="#3-3-Nginx日志文件配置与切割" class="headerlink" title="3.3 Nginx日志文件配置与切割"></a>3.3 Nginx日志文件配置与切割</h4><p>在虚拟主机开始的配置文件中配置的时候，就已经使用了access_log进行了日志记录。这里再说Nginx日志记录，与日志记录的指令包括：log_format用来设置日志的格式。access_log用来设置日志文件的存放路径、格式和缓存大小。</p>
<p>日志文件的切割最常见的就是按照天数切割。具体配置。</p>
<h4 id="3-4-Nginx的压缩输出配置"><a href="#3-4-Nginx的压缩输出配置" class="headerlink" title="3.4 Nginx的压缩输出配置"></a>3.4 Nginx的压缩输出配置</h4><p>经过gzip压缩之后页面大小可以变为原来的0.3左右，这样浏览器访问速度将会更快。</p>
<h4 id="3-5-Nginx的自动列目录配置"><a href="#3-5-Nginx的自动列目录配置" class="headerlink" title="3.5 Nginx的自动列目录配置"></a>3.5 Nginx的自动列目录配置</h4><pre><code>location / {
    autoindex on;
}
</code></pre><h4 id="3-6-Nginx浏览器本地缓存设置"><a href="#3-6-Nginx浏览器本地缓存设置" class="headerlink" title="3.6 Nginx浏览器本地缓存设置"></a>3.6 Nginx浏览器本地缓存设置</h4><p>浏览器缓存可以通过 expires 指令输出 header 头来实现。</p>
<pre><code>expires [time|epoch|off]
</code></pre><hr>
<h3 id="第6章-Nginx-HTTP负载均衡和反向代理的配置与优化"><a href="#第6章-Nginx-HTTP负载均衡和反向代理的配置与优化" class="headerlink" title="第6章 Nginx HTTP负载均衡和反向代理的配置与优化"></a>第6章 Nginx HTTP负载均衡和反向代理的配置与优化</h3><p>负载均衡，多台服务器之间协同工作，提高计算机系统处理能力和计算强度，满足当前业务需求。在多个设备之间实现合理业务分配的方法。是多个服务器之间组成一个服务器集合，每台服务器都具有等价的地位，都可以单独的对外提供服务而无需其它服务的辅助。</p>
<p>反向代理，以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络的服务器，将从服务器上得到的结果返回给Internet上请求的客户端。</p>
<h4 id="6-1-Nginx代理服务设置"><a href="#6-1-Nginx代理服务设置" class="headerlink" title="6.1 Nginx代理服务设置"></a>6.1 Nginx代理服务设置</h4><pre><code>1. 设置404页面导向地址

    error_page 404 https://...;#错误页
    proxy_intercept_errors on; #如果被代理服务器返回的状态码为400或大于400，设置的error_page配置起作用，默认为off

2. 如果我们的代理只允许接受get、post请求方法一种

    proxy_method get; #支持客户端的请求方法 post/get

3. 设置支持的HTTP协议版本

    proxy_http_version 1.0; #Nginx服务器提供代理服务的HTTP协议版本

4. 解决负载均衡采用轮询方式时，有一台服务器挂掉导致客户端一直等待的问题。

    proxy_connect_timeout 1;  #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
    proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。
    proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。
    proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。

5. 如果upstream指令配置了一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺序交由下一组服务器处理

    proxy_next_upstream timeout; #反向代理upstream中设置的服务器组出现故障时，被代理服务器返回的状态值。


6. 如果需要通过HTTP获取用户的真实ip而非代理ip作设置

    proxy_set_header Host $host; #
    proxy_set_header X-Real-IP $remote_addr; #将源ip赋值给x-real-ip，这样可以在程序中$X-Real-IP来获取源ip
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #在Nginx作为代理服务器时，设置的ip列表会将经过的机器ip代理机器ip都记录下来
</code></pre><h4 id="6-2-Web负载均衡方法"><a href="#6-2-Web负载均衡方法" class="headerlink" title="6.2 Web负载均衡方法"></a>6.2 Web负载均衡方法</h4><pre><code>1. 手动选择方式

    如我们在网页上下载的时候让我们选择电信1、电信2、连通1、连通2等方式

2. DNS轮询方式

    很多域名注册商都对同一主机名添加多条A记录，这就是DNS轮询，DNS将解析请求按照A记录的顺序随机分配到不同的IP上，从而完成了负载均衡。

    缺点：

        1.可靠性低


        2.负载分配不均衡

            DNS负载均衡采用的是简单的轮询负载方法，不能区分服务器的差异，不能反映服务器当前的情况。

3. 四/七层负载均衡

    1. 四层负载均衡：基于IP+端口的负载均衡，通过虚拟IP+端口接收请求，然后再分配到真实的服务器

        主要通过报文中的目标地址和端口，再加上负载均衡设置的服务器选择方式，决定最终的内部服务器。

    2. 七层负载均衡：基于URL等应用层信息的负载均衡，通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器

        或称为内容交换，主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

    3. 二层负载均衡：基于MAC地址，通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址。

    4. 三层负载均衡：基于IP地址，通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址。

    5. 四到七层负载均衡：表示在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。

         1. 负载均衡器通常称为四层交换机或七层交换机

            1. 四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。

            2. 七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。
</code></pre><h5 id="6-2-1-Nginx负载均衡详解"><a href="#6-2-1-Nginx负载均衡详解" class="headerlink" title="6.2.1 Nginx负载均衡详解"></a>6.2.1 Nginx负载均衡详解</h5><p>Upstream配置是写一组被代理的服务器地址，然后配置负载均衡的算法，这里被代理的服务器地址有两种写法：</p>
<pre><code>1. 
    upstream mysvr {
        server 192.168.1.12:2050;
        server 192.168.1.8:1204;
    }
    server {
        ...
        location ~*^.+$ {
            proxy_pass http://mysvr; #请求转向mysvr定义的服务器列表
        }
    }

    1. 热备：当一台服务器发生事故时，才启用第二台服务器提供服务。

        upstream mysvr {
            server 127.0.0.1:5252;
            server 192.168.10.125:5524 backup; #热备
        }

    2. 轮询：Nginx默认就是轮询其权重都默认为1，服务器处理在多个之间转换，如果后端服务器down掉，能自动剔除

        upstream mysvr {
            server 127.0.0.1:2525;
            server 192.168.25.25:1245;
        }

    3. 加权轮询：根据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置则默认是1。权重越大分配到的访问越多。

        upstream mysvr {
            server 127.0.0.1:2525 weight=1;
            server 192.168.52.2 weight=2;
        }

    4. ip_hash：Nginx会让相同的客户端ip请求相同的服务器（每个访客固定访问一个后端服务器）。

        upstream mysvr {
            server 127.0.0.1:1245
            server 192.168.12.145:1246
            ip_hash;
        }

    5. Nginx负载均衡配置状态参数

        1. down 表示当前的server暂时不参与负载均衡

        2. backup 预留的备份机器

        3. max_fails 允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream模块定义的错误

        4. fail_timeout 在经理max_fails次失败之后，暂停服务的时间

            upstream mysvr { 
                server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;
                server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    
            }

        5. fair 按照服务器的响应时间来分配请求，响应时间短的优先分配
</code></pre><h4 id="6-3-Nginx负载均衡与反向代理"><a href="#6-3-Nginx负载均衡与反向代理" class="headerlink" title="6.3 Nginx负载均衡与反向代理"></a>6.3 Nginx负载均衡与反向代理</h4><p>upstream指令用于设置一组可以在 proxy_pass 和 fastcgi_pass 指令中使用的代理服务器，默认的负载均衡方式为轮询。upstream模块中的server指令用于指定后端服务器的名称和参数，名称可以是ip、域名、端口号后socket。</p>
<p>在server{…}虚拟主机内，通过 proxy_pass 和 fastcgi_pass 指令设置进行反向代理的 upstream 服务器集群。</p>
<pre><code>proxy_set_header指令用于在反向代理的后端web服务器发起请求时添加指定的header头信息。

在后端web服务器有多个 基于域名的虚拟主机 时，要通过添加Header头信息Host，用于指定请求的域名，这样后端web服务器才能识别该反向代理访问请求由哪一个虚拟主机来处理。

在使用反向代理之后，后端web服务器不能通过 $_SERVER[&quot;REMOTE_ADDR&quot;] 变量来获取用户的真是ip，获取到的将是Nginx负载均衡服务器的ip。需要添加Nginx反向代理时的头信息 X-Forwarded-For得到真实的ip。
</code></pre><h5 id="6-3-2-Nginx负载均衡与反向代理实现动、静态网页分离"><a href="#6-3-2-Nginx负载均衡与反向代理实现动、静态网页分离" class="headerlink" title="6.3.2 Nginx负载均衡与反向代理实现动、静态网页分离"></a>6.3.2 Nginx负载均衡与反向代理实现动、静态网页分离</h5><p>动、静态分离就是让动态Java等程序网页去访问JavaWeb服务器，让缓存页、图片、JavaScript、CSS、Flash去访问squid等缓存服务器。</p>
<p>通过location指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使得浏览器缓存过期时间，减少与服务器之前的请求和流量。具体的expires定义：给一个资源设置一个过期时间，也就是无需去服务器验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。</p>
<h4 id="6-4-Nginx负载均衡的HTTP-upstream模块"><a href="#6-4-Nginx负载均衡的HTTP-upstream模块" class="headerlink" title="6.4 Nginx负载均衡的HTTP upstream模块"></a>6.4 Nginx负载均衡的HTTP upstream模块</h4><p>upstream提供一个简单方法来实现轮询和客户端ip之间的后端服务器负载均衡，并可以对后端服务器进行健康检查。</p>
<h5 id="6-4-1-ip-hash指令"><a href="#6-4-1-ip-hash指令" class="headerlink" title="6.4.1 ip_hash指令"></a>6.4.1 ip_hash指令</h5><p>ip_hash指令能够将客户端ip的请求通过哈希算法定位到同一个后端服务器，也就是说当再访问此ip下的其它URL时，还是会定位到该服务器上。</p>
<p>ip_hash指定无法保证后端服务器的负载均衡。</p>
<p>如果后端服务器有时需要从Nginx负载均衡（已使用ip_hash）中摘除一段时间，需要标记其为down，而不是直接从配置文件中删掉或注释掉该后端服务器的信息。</p>
<h5 id="6-4-2-server指令"><a href="#6-4-2-server指令" class="headerlink" title="6.4.2 server指令"></a>6.4.2 server指令</h5><p>该指令用于指定后端服务器的名称和参数，服务器的名称可以是一个域名、ip地址、端口号或者socket。</p>
<pre><code>参数：

    1. weight 权重，权重数值越高，被分配到的客户端请求数越多。默认为1

    2. max_fails 在fail_timeout指定时间内对后端服务器请求失败的次数。

    3. fail_timeout 在经过max_fails次数后，暂停的时间。

    4. down 标记服务器永久离线。

    5. backup 仅在非backup服务器全部繁忙或死机才启用。
</code></pre><h5 id="6-4-3-upstream指令"><a href="#6-4-3-upstream指令" class="headerlink" title="6.4.3 upstream指令"></a>6.4.3 upstream指令</h5><p>设置一组可以在 proxy_pass 和 fastcgi_pass 指令中使用的代理服务器，默认的负载均衡方式是轮询。</p>
<h4 id="6-5-Nginx负载均衡服务器的双机高可用"><a href="#6-5-Nginx负载均衡服务器的双机高可用" class="headerlink" title="6.5 Nginx负载均衡服务器的双机高可用"></a>6.5 Nginx负载均衡服务器的双机高可用</h4><p>在Web服务器集群当做一个城池的话，那么负载均衡服务器相当于城门，城门破了，那么服务就不能正常提供。</p>
<ol>
<li><p>双机高可用的方式目前有两种：</p>
<ol>
<li><p>一台主服务器加一台从服务器，在主服务器宕机之后，从服务器接管主服务器的虚拟IP继续提供服务  </p>
</li>
<li><p>两台负载均衡服务器都处于活动状态，各自绑定一个公网虚拟IP，提供负载均衡服务</p>
</li>
</ol>
</li>
</ol>
<h3 id="第7章-Nginx的rewrite规则"><a href="#第7章-Nginx的rewrite规则" class="headerlink" title="第7章 Nginx的rewrite规则"></a>第7章 Nginx的rewrite规则</h3><p>Rewrite主要功能是实现URL的重写，Nginx的rewrite规则采用PCRE。通过rewrite规则，可以实现规范的URL，根据变量来做URL转向及选择配置。</p>
<h4 id="7-2-Nginx-Rewrite相关指令"><a href="#7-2-Nginx-Rewrite相关指令" class="headerlink" title="7.2 Nginx Rewrite相关指令"></a>7.2 Nginx Rewrite相关指令</h4><pre><code>1. break指令

2. if指令，该指令不支持嵌套和多个条件&amp;&amp;和||处理

    ~ 表区分大小写字母匹配
    ~* 表示不区分大小写字母匹配

    !~ 和!~* 作用相反，表示不匹配

    -f 和 !-f 判断文件是否存在

    -d 和 !-d 判断目录是否存在

    -e 和 !-e 判断文件或目录是否存在

    -x 和 !-x 判断文件是否可执行

3. return

4. rewrite指令，该指令根据表达式来重定向URI或者修改字符串

5. set指令，用于定义一个变量并赋值。
</code></pre><h3 id="第9章-Nginx的Web缓存服务与新浪的开源NCACHE模块"><a href="#第9章-Nginx的Web缓存服务与新浪的开源NCACHE模块" class="headerlink" title="第9章 Nginx的Web缓存服务与新浪的开源NCACHE模块"></a>第9章 Nginx的Web缓存服务与新浪的开源NCACHE模块</h3><p>Web缓存服务中，最著名的数Squid。</p>
<h4 id="9-2-Nginx的Web缓存服务"><a href="#9-2-Nginx的Web缓存服务" class="headerlink" title="9.2 Nginx的Web缓存服务"></a>9.2 Nginx的Web缓存服务</h4><h5 id="9-2-1-proxy-cache相关指令集"><a href="#9-2-1-proxy-cache相关指令集" class="headerlink" title="9.2.1 proxy_cache相关指令集"></a>9.2.1 proxy_cache相关指令集</h5><pre><code>1. proxy_cache 该指令用于设置哪个缓存区将被使用。

2. proxy_cache_path 设置缓存文件的存放路径

    该指令只能在http标签内配置

3. proxy_cache_methods 用于设置缓存哪些http方法，默认缓存http get/head方法，不缓存http post方法

4. proxy_cache_min_use 该指令用于设置缓存的最小使用次数，默认1

5. proxy_cache_valid 用于对不同返回状态码URL设置不同缓存时间

6. proxy_cache_key 设置Web缓存的key值
</code></pre><h5 id="9-2-3-fastcgi-cache相关指令集"><a href="#9-2-3-fastcgi-cache相关指令集" class="headerlink" title="9.2.3 fastcgi_cache相关指令集"></a>9.2.3 fastcgi_cache相关指令集</h5><pre><code>1. fastcgi_cache 该指令用于设置哪个缓存区将被使用

2. fastcgi_cache_path 设置缓存文件存放路径

    只能在http标签内使用

3. fastcgi_cache_methods 设置缓存哪些http方法，默认http get/head方法，不缓存http post方法

4. fastcgi_cache_min_use 设置缓存的最小使用次数，默认值是1

5. fastcgi_cache_valid 对不同返回状态码的URL设置不同的缓存时间

6. fastcgi_cache_key 设置Web缓存的key值
</code></pre><h4 id="9-3-基于Nginx的NCACHE缓存-新浪开源"><a href="#9-3-基于Nginx的NCACHE缓存-新浪开源" class="headerlink" title="9.3 基于Nginx的NCACHE缓存-新浪开源"></a>9.3 基于Nginx的NCACHE缓存-新浪开源</h4><h3 id="第12章-Nginx的核心模块"><a href="#第12章-Nginx的核心模块" class="headerlink" title="第12章 Nginx的核心模块"></a>第12章 Nginx的核心模块</h3><p>Nginx的模块分为核心模块、标准HTTP模块、可选HTTP模块、邮件模块、第三方模块和补丁。</p>
<p>核心模块包括：1.主模块 2.事件模块</p>
<h4 id="12-1-主模块指令"><a href="#12-1-主模块指令" class="headerlink" title="12.1 主模块指令"></a>12.1 主模块指令</h4><pre><code>1. daemon 在生产环境不使用daemon | master_process指令，其只用于开发调试 
2. env 定义变量集合

3. debug_points 调试器内设置断点

4. error_log 错误日志记录

    级别：

        main部分：error

        http部分：crit

        server部分：crit

5. lock_file Nginx可采用异步互斥进行访问控制

6. master_process 开发调试

7. pid pid文件内记录当前Nginx主进程id好

8. ssl_engine 设置首选的ssl引擎

9. user 指定Nginx Worker进程的用户和组，默认的用户名和组名都是nobody。

10. worker_rlimit_core 指定每个Nginx进程的最大core文件大小

11. worker_rlimit_nofile 指定Nginx进程可以打开的最大文件描述符数量

...
</code></pre><h4 id="12-3-事件模块指令"><a href="#12-3-事件模块指令" class="headerlink" title="12.3 事件模块指令"></a>12.3 事件模块指令</h4><pre><code>1. accept_mutex 连接互斥锁进行顺序的accept()调用

2. accept_mutex_delay 
</code></pre><h3 id="第13章-Nginx的标准HTTP模块"><a href="#第13章-Nginx的标准HTTP模块" class="headerlink" title="第13章 Nginx的标准HTTP模块"></a>第13章 Nginx的标准HTTP模块</h3><p>HTTP模块在编译Nginx时自动编译进来，除非使用configure命令禁止编译这些模块。</p>
<h4 id="13-1-HTTP核心模块"><a href="#13-1-HTTP核心模块" class="headerlink" title="13.1 HTTP核心模块"></a>13.1 HTTP核心模块</h4><h5 id="13-2-HTTP-Upstream模块"><a href="#13-2-HTTP-Upstream模块" class="headerlink" title="13.2 HTTP Upstream模块"></a>13.2 HTTP Upstream模块</h5><p>HTTP Upstream 模块是与反向代理、负载均衡相关的模块，包含ip_hash | server | upstream等指令。</p>
<h4 id="13-3-HTTP-Access模块"><a href="#13-3-HTTP-Access模块" class="headerlink" title="13.3 HTTP Access模块"></a>13.3 HTTP Access模块</h4><pre><code>1. allow 允许指定的ip或ip段地址访问虚拟主机或目录

2. deny 拒绝..
</code></pre><h4 id="13-4-HTTP-Auth-Basic模块"><a href="#13-4-HTTP-Auth-Basic模块" class="headerlink" title="13.4 HTTP Auth Basic模块"></a>13.4 HTTP Auth Basic模块</h4><p>该模块采用基于HTTP基本身份验证的用户名和密码登录方式，来保护虚拟主机和目录。</p>
<pre><code>1. auth_basic 指定弹出登录框中提示的名称
</code></pre><h4 id="13-10-geo模块"><a href="#13-10-geo模块" class="headerlink" title="13.10 geo模块"></a>13.10 geo模块</h4><p>geo模块主要负责做全局负载均衡，可以根据不同的客户端ip访问到不同的服务器。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/Redis%20-%20Java%20%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis与Jedis"><a href="#Redis与Jedis" class="headerlink" title="Redis与Jedis"></a>Redis与Jedis</h2><p>在这整个过程中，Redis起到缓存的作用，首先是客户端向Redis服务器中请求获取数据，如果在Redis中存在相应的数据，则直接返回，否则将请求发送到数据库中获取数据，此时数据库返回客户端请求的数据并且更新Redis服务器中的数据，以便后面的操作请求到相同的数据的时候不用再向数据库请求数据，Redis服务器可以直接返回。</p>
<blockquote>
<p>注意：在数据库中的信息更改的时候，也需要同步更新Redis服务器中的数据信息，不然的话客户端会取到没有更新的数据。</p>
</blockquote>
<p>Jedis是Java版的Redis客户端，用来服务Redis的操作。</p>
<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><h2 id="Jedis基本通用配置及使用"><a href="#Jedis基本通用配置及使用" class="headerlink" title="Jedis基本通用配置及使用"></a>Jedis基本通用配置及使用</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 分布式锁</title>
    <url>/undefined/Redis%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis-分布式"><a href="#Redis-分布式" class="headerlink" title="Redis - 分布式"></a>Redis - 分布式</h2><p>[TOC]</p>
<h3 id="分布式锁-多JVM"><a href="#分布式锁-多JVM" class="headerlink" title="分布式锁(多JVM)"></a>分布式锁(多JVM)</h3><p>控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li><p>互斥性：保证同一时间只有一个客户端可以拿到锁，也就是可以对共享资源进行操作</p>
</li>
<li><p>安全性：只有加锁的服务才能有解锁权限，也就是不能让a加的锁，bcd都可以解锁，如果都能解锁那分布式锁就没啥意义了</p>
<p>  可能出现的情况就是a去查询发现持有锁，就在准备解锁，这时候忽然a持有的锁过期了，然后b去获得锁，因为a锁过期，b拿到锁，这时候a继续执行第二步进行解锁如果不加校验，就将b持有的锁就给删除了</p>
</li>
<li><p>避免死锁：出现死锁就会导致后续的任何服务都拿不到锁,不能再对共享资源进行任何操作了</p>
</li>
<li><p>保证加锁与解锁操作是原子性操作</p>
<p>  这个其实属于是实现分布式锁的问题，假设a用redis实现分布式锁，假设加锁操作，操作步骤分为两步：1. 设置key set（key，value）。2. 给key设置过期时间，假设现在a刚实现set后，程序崩了就导致了没给key设置过期时间就导致key一直存在就发生了死锁。</p>
</li>
</ul>
<h4 id="为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件："><a href="#为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：" class="headerlink" title="为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件："></a>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</h4><ul>
<li><p>互斥性：在任意时刻，只有一个客户端能持有锁</p>
</li>
<li><p>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</p>
</li>
<li><p>具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁</p>
</li>
<li><p>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解</p>
</li>
</ul>
<h4 id="如何实现分布式锁"><a href="#如何实现分布式锁" class="headerlink" title="如何实现分布式锁?"></a>如何实现分布式锁?</h4><h5 id="使用redis实现分布式锁"><a href="#使用redis实现分布式锁" class="headerlink" title="使用redis实现分布式锁"></a>使用redis实现分布式锁</h5><pre><code>set key value ex time nx
</code></pre><h5 id="set-多参数，高版本jedis使用"><a href="#set-多参数，高版本jedis使用" class="headerlink" title="set()多参数，高版本jedis使用"></a>set()多参数，高版本jedis使用</h5><pre><code>public class RedisTool {
      private static final String LOCK_SUCCESS = &quot;OK&quot;;
      private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;
      private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;
      /**
      \* 尝试获取分布式锁
      \* @param jedis Redis客户
      \* @param lockKey 锁
      \* @param requestId 请求标识
      \* @param expireTime 超期时间
      \* @return 是否获取成功
      */
      public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {
      String result = **jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);**
      if (LOCK_SUCCESS.equals(result)) {
          return true;
      }
      return false;
      }
}
</code></pre><ul>
<li><p>第一个为key，我们使用key来当锁，因为key是唯一的。</p>
</li>
<li><p>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</p>
</li>
<li><p>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</p>
</li>
<li><p>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</p>
</li>
<li><p>第五个为time，与第四个参数相呼应，代表key的过期时间</p>
</li>
</ul>
<p>set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">   Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">     <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">         jedis.expire(lockKey, expireTime);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法</span><br></pre></td></tr></table></figure>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>; </span><br><span class="line">      <span class="comment">/****</span></span><br><span class="line"><span class="comment">       *** 释放分布式锁**</span></span><br><span class="line"><span class="comment">       *** <span class="doctag">@param</span> jedis Redis客户端**</span></span><br><span class="line"><span class="comment">       *** <span class="doctag">@param</span> lockKey 锁**</span></span><br><span class="line"><span class="comment">       *** <span class="doctag">@param</span> requestId 请求标识**</span></span><br><span class="line"><span class="comment">       *** <span class="doctag">@return</span> 是否释放成功**</span></span><br><span class="line"><span class="comment">       ***/</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁</span></span><br><span class="line">          String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">         Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</span></span><br></pre></td></tr></table></figure>
<h5 id="错误解锁"><a href="#错误解锁" class="headerlink" title="错误解锁"></a>错误解锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;       </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在问题：问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景?答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了</p>
</blockquote>
<h4 id="setnx-过期时间依旧存在问题"><a href="#setnx-过期时间依旧存在问题" class="headerlink" title="setnx + 过期时间依旧存在问题"></a>setnx + 过期时间依旧存在问题</h4><p>在高并发场景下，会出现误删不是自己的锁，删除掉别人的锁，出现一个锁永久性失效的问题</p>
<p>使用uuid解决，判断clientId跟redis中那把锁的value值是否一致，一致的话，才能进行删除锁。但还会出现有多个线程执行同一个代码块，对超时的锁进行续命，那么可以尝试使用==Redisson==实现分布式锁，这是Redis官方提供的Java组件。</p>
<ul>
<li><p>引入依赖</p>
</li>
<li><p>在启动类中注入 redisson 的bean，可以在配置文件中添加redis的连接地址、参数，然后在代码中引入配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(RedissonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function">Redisson <span class="title">redissonSentinel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//支持单机，主从，哨兵，集群等模式</span></span><br><span class="line">		<span class="comment">//此为哨兵模式</span></span><br><span class="line">		Config config = <span class="keyword">new</span> Config();</span><br><span class="line">		config.useSentinelServers()</span><br><span class="line">				.setMasterName(<span class="string">"mymaster"</span>)</span><br><span class="line">				.addSentinelAddress(<span class="string">"redis://192.168.1.1:26379"</span>)</span><br><span class="line">				.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">		<span class="keyword">return</span> (Redisson)Redisson.create(config);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在redis中，设置一个库存数量为100</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//设置一个key，aaa商品的库存数量为100</span></span><br><span class="line">	stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>,<span class="string">"100"</span>);</span><br><span class="line">	Assert.assertEquals(<span class="string">"100"</span>, stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String lockKey = <span class="string">"testRedisson"</span>;<span class="comment">//分布式锁的key</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistributed</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//执行的业务代码</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">55</span>; i++)&#123;</span><br><span class="line">		RLock lock = redisson.getLock(lockKey);</span><br><span class="line">		lock.lock(<span class="number">60</span>, TimeUnit.SECONDS); <span class="comment">//设置60秒自动释放锁  （默认是30秒自动过期）</span></span><br><span class="line">		<span class="keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>).toString());</span><br><span class="line">		<span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>,(stock-<span class="number">1</span>)+<span class="string">""</span>);</span><br><span class="line">			System.out.println(<span class="string">"test2_:lockkey:"</span>+lockKey+<span class="string">",stock:"</span>+(stock-<span class="number">1</span>)+<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/Redis%20-%20%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="Redis-面试总结"><a href="#Redis-面试总结" class="headerlink" title="Redis - 面试总结"></a>Redis - 面试总结</h3><p>[TOC]</p>
<h4 id="为什么要用redis而不用map做缓存"><a href="#为什么要用redis而不用map做缓存" class="headerlink" title="为什么要用redis而不用map做缓存?"></a>为什么要用redis而不用map做缓存?</h4><p>Java实现的Map是本地缓存，如果有多台实例(机器)的话，每个实例都需要各自保存一份缓存，缓存不具有一致性</p>
<p>Redis实现的是分布式缓存，如果有多台实例(机器)的话，每个实例都共享一份缓存，缓存具有一致性。</p>
<p>Java实现的Map不是专业做缓存的，JVM内存太大容易挂掉。一般用做于容器来存储临时数据，缓存的数据随着JVM销毁而结束。Map所存储的数据结构，缓存过期机制等等是需要程序员自己手写的。</p>
<p>Redis是专业做缓存的，可以用几十个G内存来做缓存。Redis一般用作于缓存，可以将缓存数据保存在硬盘中，Redis重启了后可以将其恢复。原生提供丰富的数据结构、缓存过期机制等简单好用的功能。</p>
<h4 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存?"></a>为什么要用缓存?</h4><p>如果网站出现了性能问题(访问时间慢)，按经验来说，一般是由于数据库撑不住了。因为一般数据库的读写都是要经过磁盘的，而磁盘的速度可以说是相当慢的(相对内存来说)。</p>
<h4 id="如何解决缓存雪崩？"><a href="#如何解决缓存雪崩？" class="headerlink" title="如何解决缓存雪崩？"></a>如何解决缓存雪崩？</h4><p>对于==“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”==这种情况，非常好解决：</p>
<pre><code>解决方法：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
</code></pre><p>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：</p>
<pre><code>事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。

事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)

事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。
</code></pre><h4 id="如何解决缓存穿透"><a href="#如何解决缓存穿透" class="headerlink" title="如何解决缓存穿透?"></a>如何解决缓存穿透?</h4><p>缓存穿透，表示每次请求的id都是数据库中不存在的数，这就会导致缓存没作用，请求全部查询数据库，但是数据库中没有这个值，所以每次返回null值回来。</p>
<p>缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</p>
<p>解决：</p>
<pre><code>1. 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层。

2. 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。

    提示：这种情况我们一般会将空对象设置一个较短的过期时间。
</code></pre><h4 id="数据库与缓存双写一致"><a href="#数据库与缓存双写一致" class="headerlink" title="数据库与缓存双写一致?"></a>数据库与缓存双写一致?</h4><p>读操作，如果从数据库查询不到数据则不写入缓存。一般的读操作有一个固定套路：</p>
<pre><code>1. 如果我们的数据在缓存里边有，那么就直接取缓存的。

2. 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。

3. 最后将数据返回给请求
</code></pre><blockquote>
<p>缓存与数据库双写一致问题：如果仅仅只是查询的话，缓存的数据和数据库的数据是没有问题的，但是当更新的时候很可能造成数据库和缓存的数据不一致</p>
</blockquote>
<p>从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p>
<p>除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。</p>
<p>在进行更新操作的时候，一般有两种选择：1. 先操作数据库，后操作缓存。2. 先操作缓存，后操作数据库。</p>
<blockquote>
<p>我们需要明确的是，无论我们选择更新操作的哪一个，都希望两个操作同时成功或失败，所以这就演变为一个==分布式事务问题。==</p>
</blockquote>
<h5 id="1-操作缓存"><a href="#1-操作缓存" class="headerlink" title="1. 操作缓存"></a>1. 操作缓存</h5><pre><code>1. 更新缓存

2. 删除缓存
</code></pre><p>一般都是采用删除缓存的缓存策略，原因：</p>
<pre><code>1. 在高并发环境下，无论是先操作数据库还是后操作数据库，如果加上更新缓存，那就更容易导致数据库与缓存数据不一致问题。

2. 如果每次更新了数据库，都要更新缓存，倒不如直接删除缓存数据，等再次读取时，缓存里没有，那再去数据库找，然后将数据写入缓存里面。
</code></pre><h5 id="2-先更新数据库，再删除缓存"><a href="#2-先更新数据库，再删除缓存" class="headerlink" title="2. 先更新数据库，再删除缓存"></a>2. 先更新数据库，再删除缓存</h5><pre><code>1. 在正常情况下，先操纵数据库，成功

2. 再删除缓存，成功
</code></pre><p>如果原子性被破坏：</p>
<pre><code>1. 第1步成功（操作数据库），第2步失败（删除缓存），会导致数据库里是新数据，缓存中是旧数据

2. 如果第一步失败，可以直接返回错误（Exception），不会出现数据不一致
</code></pre><blockquote>
<p>删除缓存失败的解决思路：1. 将需要删除的key发送到消息队列中。2. 自己消费消息，获得需要删除的key。3. 不断重试删除操作，直到成功。</p>
</blockquote>
<h5 id="3-先删除缓存，再更新数据库"><a href="#3-先删除缓存，再更新数据库" class="headerlink" title="3. 先删除缓存，再更新数据库"></a>3. 先删除缓存，再更新数据库</h5><p>将缓存数据删除，更新数据库，然后后期读操作的时候，查询缓存里面没有对应的数据则从数据库读取，再将数据写入缓存。</p>
<h5 id="4-并发情况下解决数据库与缓存不一致的思路"><a href="#4-并发情况下解决数据库与缓存不一致的思路" class="headerlink" title="4. 并发情况下解决数据库与缓存不一致的思路"></a>4. 并发情况下解决数据库与缓存不一致的思路</h5><p>将删除缓存、修改数据库、读取缓存等的操作积压到队列里面，实现串行化。</p>
<h4 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构?"></a>Redis 数据结构?</h4><ul>
<li>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。</li>
<li>如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</li>
<li>如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</li>
</ul>
<hr>
<h4 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁?"></a>Redis分布式锁?</h4><p>概念：分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。</p>
<p>条件：</p>
<pre><code>互斥性：在任意一个时刻，只有一个客户端持有锁。

无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。

容错：只要大部分Redis节点都活着，客户端就可以获取和释放锁
</code></pre><p>分布式锁的实现：</p>
<pre><code>数据库

Memcached（add命令）

Redis（setnx命令）

Zookeeper（临时节点）
...
</code></pre><p>先拿命令setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放</p>
<h4 id="如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样"><a href="#如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样?"></a>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样?</h4><ul>
<li>按照逻辑来说这个锁就永远得不到释放了</li>
<li>我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的</li>
</ul>
<hr>
<h4 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来?"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来?</h4><p>使用keys指令可以扫出指定模式的key列表。</p>
<h4 id="如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题"><a href="#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题" class="headerlink" title="如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题?"></a>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题?</h4><ul>
<li>这个时候你要回答redis关键的一个特性：==redis是单线程的。== keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，==scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，== 在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</li>
</ul>
<hr>
<h4 id="使用过Redis做异步队列么，你是怎么用的"><a href="#使用过Redis做异步队列么，你是怎么用的" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的?"></a>使用过Redis做异步队列么，你是怎么用的?</h4><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<h4 id="可不可以不用sleep呢"><a href="#可不可以不用sleep呢" class="headerlink" title="可不可以不用sleep呢?"></a>可不可以不用sleep呢?</h4><p>list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h4 id="能不能生产一次消费多次呢"><a href="#能不能生产一次消费多次呢" class="headerlink" title="能不能生产一次消费多次呢?"></a>能不能生产一次消费多次呢?</h4><p>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
<h4 id="pub-sub有什么缺点"><a href="#pub-sub有什么缺点" class="headerlink" title="pub/sub有什么缺点?"></a>pub/sub有什么缺点?</h4><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq,kafka等。</p>
<h4 id="redis如何实现延时队列"><a href="#redis如何实现延时队列" class="headerlink" title="redis如何实现延时队列?"></a>redis如何实现延时队列?</h4><p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p>
<h4 id="如果有大量的key需要设置同一时间过期，一般需要注意什么"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么?"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么?</h4><ul>
<li>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。==一般需要在时间上加一个随机值，使得过期时间分散一些。==</li>
</ul>
<h4 id="Redis如何做持久化的"><a href="#Redis如何做持久化的" class="headerlink" title="Redis如何做持久化的?"></a>Redis如何做持久化的?</h4><ul>
<li>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</li>
</ul>
<h4 id="如果突然机器掉电会怎样"><a href="#如果突然机器掉电会怎样" class="headerlink" title="如果突然机器掉电会怎样?"></a>如果突然机器掉电会怎样?</h4><ul>
<li>取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</li>
</ul>
<h4 id="bgsave的原理是什么"><a href="#bgsave的原理是什么" class="headerlink" title="bgsave的原理是什么?"></a>bgsave的原理是什么?</h4><ul>
<li>fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li>
</ul>
<h4 id="Pipeline有什么好处，为什么要用pipeline"><a href="#Pipeline有什么好处，为什么要用pipeline" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline?"></a>Pipeline有什么好处，为什么要用pipeline?</h4><ul>
<li>可以将多次IO往返的时间缩减为一次，==前提是pipeline执行的指令之间没有因果相关性。==使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是==pipeline批次指令的数目。==</li>
</ul>
<h4 id="Redis的同步机制了解么"><a href="#Redis的同步机制了解么" class="headerlink" title="Redis的同步机制了解么?"></a>Redis的同步机制了解么?</h4><ul>
<li>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
<h4 id="是否使用过Redis集群，集群的原理是什么"><a href="#是否使用过Redis集群，集群的原理是什么" class="headerlink" title="是否使用过Redis集群，集群的原理是什么?"></a>是否使用过Redis集群，集群的原理是什么?</h4><ul>
<li>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</li>
<li>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li>
</ul>
<h4 id="使用Redis有哪些好处"><a href="#使用Redis有哪些好处" class="headerlink" title="使用Redis有哪些好处?"></a>使用Redis有哪些好处?</h4><ul>
<li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li>
</ul>
<h4 id="redis相比memcached有哪些优势"><a href="#redis相比memcached有哪些优势" class="headerlink" title="redis相比memcached有哪些优势?"></a>redis相比memcached有哪些优势?</h4><ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
</ul>
<h4 id="redis常见性能问题和解决方案："><a href="#redis常见性能问题和解决方案：" class="headerlink" title="redis常见性能问题和解决方案："></a>redis常见性能问题和解决方案：</h4><ul>
<li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。</li>
<li>写内存快照时，save命令调度rdbSave函数，会阻塞主线程的工作；</li>
<li>AOF在重写的时候会占大量的CPU和内存资源。如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。</li>
<li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li>
</ul>
<h4 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据?"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据?</h4><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。<br>redis 提供 6种数据淘汰策略：</p>
<pre><code>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据
</code></pre><p>由maxmemory-policy 参数设置淘汰策略：</p>
<pre><code>CONFIG SET maxmemory-policy volatile-lru      #淘汰有过时期的最近最好使用数据
</code></pre><h4 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h4><ul>
<li><p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中,每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。从过期字典中随机 20 个 key，删除这 20 个 key 中已经过期的 key，如果过期的 key 比率超过 1/4，那就重复步骤 1。</p>
</li>
<li><p>同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</p>
</li>
</ul>
<h4 id="从库的过期策略"><a href="#从库的过期策略" class="headerlink" title="从库的过期策略"></a>从库的过期策略</h4><ul>
<li>从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令 来删除过期的 key</li>
<li>因为指令同步是异步进行的，所以主库过期的 key 的 del 指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/Redis%20%E6%8C%87%E5%8D%97%20-%20Windows/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="Redis在Windows环境"><a href="#Redis在Windows环境" class="headerlink" title="Redis在Windows环境"></a>Redis在Windows环境</h4><p>打开cmd命令窗口，安装和注册redis到window服务，注意安装和启动服务这两个操作需要在解压Redis的根目录执行，这里才有Redis环境</p>
<p>安装命令：redis-server.exe –service-install redis.windows.conf –loglevel verbose</p>
<p>启动服务命令：redis-server.exe  –service-start</p>
<p>关闭服务命令：redis-server.exe  –service-stop</p>
<p>安装和注册服务，启动服务启动后我们都可以看到 successfully的字样，说明我们配置成功了，下面我们去window-service查看本地服务，如下图，Redis已存在和启动</p>
<p>我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功</p>
<p>然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功</p>
<p>修改redis.windows.conf和 redis.windows-service.conf文件找到requirepass这一行加上自己的密码即可</p>
<p>进入客户端调用界面输入auth 密码，如果正切则返回OK，然后利用config get requirepass可以得到redis的密码，得到密码前需要</p>
<p>用密码登录验证成功后才可以执行得到密码的命令</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet 续</title>
    <url>/undefined/Servlet%20-%20%E7%BB%AD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>开发步骤：</p>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器</li>
</ul>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html" target="_blank" rel="noopener">Servlet API Documentation</a></p>
</blockquote>
<p>生命周期相关方法(life-cycle methods)</p>
<p>Servlet的生命周期通过<code>java.servlet.Servlet</code>接口中的<code>init()</code>、<code>service()</code>、和<code>destroy()</code>方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。（见文末【参考链接】）</p>
<h2 id="手动编写第一个servlet"><a href="#手动编写第一个servlet" class="headerlink" title="手动编写第一个servlet"></a>手动编写第一个servlet</h2><p>1.在tomcat中新建一个web应用<code>hello</code>，在web应用中新建一个<code>WEB-INF/classes</code>目录</p>
<p>2.在<code>classes</code>目录新建一个<code>FirstServlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span><span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"hello servlet!!!"</span>.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编译，<code>javac -cp %CATALINA_HOME%/lib/servlet-api.jar  -d . FirstServlet.java</code>,命令行手动编译参考<a href="http://www.iitshare.com/under-the-cmd-compile-the-java.html" target="_blank" rel="noopener">这里</a></p>
<p>4.在<code>WEB-INF</code>目录中新建一个<code>web.xml</code>文件，配置servlet的对外访问路径</p>
<p>5.启动tomcat访问</p>
<h2 id="servlet的调用过程和生命周期"><a href="#servlet的调用过程和生命周期" class="headerlink" title="servlet的调用过程和生命周期"></a>servlet的调用过程和生命周期</h2><p>时序图</p>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaweb_servlet-lifecycle.png" alt="servlet的调用过程和生命周期"></p>
<h2 id="servlet开发的一些细节"><a href="#servlet开发的一些细节" class="headerlink" title="servlet开发的一些细节"></a>servlet开发的一些细节</h2><ul>
<li><strong>标签</strong>:<code>&lt;servlet&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>；<code>&lt;servlet-mapping&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code></li>
<li><strong>映射</strong>:<code>web.xml</code>中一个<code>&lt;servlet&gt;</code>可对应多个<code>&lt;servlet-mapping&gt;</code></li>
<li><strong>通配符</strong>:<code>&lt;servlet-mapping&gt;</code>的<code>&lt;url-pattern&gt;</code>可以使用通配符，两种固定格式：<code>*.扩展名</code>；以<code>/</code>开头，以<code>/*</code>结尾</li>
</ul>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaweb_servlet-url%E5%8C%B9%E9%85%8D.png" alt="javaweb_servlet-url匹配.png"></p>
<ul>
<li><strong>对象</strong>:servlet由servlet引擎调用，不能独立运行。客户端多次请求，服务器只创建一个servlet实例，之后驻留内存中继续服务直至web容器退出才销毁它。</li>
<li><strong>请求</strong>:服务器针对客户端的每一次请求都会创建新的<code>request</code>和<code>response</code>对象(它们的生命周期很短)，传给<code>service</code>方法。</li>
<li><strong>加载</strong>:servlet实例的创建和<code>init</code>方法的调用是在第一次请求时，而非服务器启动时，除非在<code>&lt;servlet&gt;</code>标签配置<code>&lt;load-on-start-up&gt;</code>,数字越小优先级越高</li>
<li><strong>缺省</strong>:映射路径为正斜杠<code>/</code>，则为当前web应用的缺省servlet,不匹配的都交给缺省</li>
<li><strong>线程安全</strong>:访问同一资源会引发线程安全问题; <code>SingleThreadModel</code>标记接口(已弃用)</li>
<li><strong>ServletConfig</strong>:在<code>&lt;servlet&gt;</code>标签配置<code>&lt;init-param&gt;</code>，通过<code>getServletConfig</code>方法获得配置。可配置输出字符集，读哪个配置文件等等。</li>
<li><strong>ServletContext</strong>:代表当前web应用，含有一些web应用全局性方法，实现web资源共享、servlet转发等。通过<code>ServletConfig.getServletContext</code>方法获得，在<code>&lt;context-param&gt;</code>标签配置。</li>
</ul>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>API:<a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/ServletContext.html" target="_blank" rel="noopener">Interface ServletContext</a></p>
<p>概念</p>
<p>一个web应用所有servlet共享同一个ServletContext对象，可实现数据共享。ServletContext被称为context<strong>域</strong>对象。</p>
<p>域：作用范围；context域：整个应用程序范围。</p>
<p>ServletContext域：</p>
<ol>
<li>这是一个容器</li>
<li>说明了这个容器的作用范围，也就是应用程序范围</li>
</ol>
<p>转发:客户机一次请求；重定向：客户机两次请求</p>
<p>作用</p>
<ul>
<li>获取web应用的初始化参数</li>
<li>实现servlet转发</li>
<li>利用ServletContext对象读取资源文件<ul>
<li>获得文件路径</li>
<li>读取资源文件的三种方式</li>
<li>.properties文件（属性文件）</li>
</ul>
</li>
</ul>
<p>配置文件：properties文件和xml文件；数据有关系使用xml文件，没有关系则使用properties文件。</p>
<p>1.通过<code>ServletContext</code>的<code>getResourceAsStream</code>方法，读取properties文件</p>
<p>模板代码(注意文件位置不同写路径会不同)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/org/iot/servlet/db.properties"</span>);</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();<span class="comment">//map</span></span><br><span class="line">properties.load(in);</span><br></pre></td></tr></table></figure>
<p>2.通过<code>servletContext</code>的<code>getRealPath</code>方法得到资源的绝对路径，再通过传统方式(<code>FileInputStream</code>)读取</p>
<p>3.通过类装载器去读，<code>ClassLoader</code>的<code>getResourceAsStream</code>(如果读取资源文件的程序不是servlet)，文件不能太大。<strong>只装载一次</strong>，所以如要读到更新后的数据，通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据（用<code>getResource</code>得到path，再用<code>FileInputStream</code>）</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://blog.csdn.net/evankaka/article/details/46673051" target="_blank" rel="noopener">servlet和Jsp生命周期解读</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SSO</title>
    <url>/undefined/Single%20Sign%20On/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单点登录(SSO)是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<h2 id="SSO的实现方式"><a href="#SSO的实现方式" class="headerlink" title="SSO的实现方式"></a>SSO的实现方式</h2><h4 id="1-以Cookie作为凭证媒介"><a href="#1-以Cookie作为凭证媒介" class="headerlink" title="1.以Cookie作为凭证媒介"></a>1.以Cookie作为凭证媒介</h4><p>这种方式是最简单的单点登录方式，使用Cookie作为媒介，存放用户凭证。用户在登录父应用之后，返回一个加密的Cookie，当用户访问子应用的时候，携带上这个Cookie，授权应用解密Cookie并进行校验，校验通过则登录当前用户。</p>
<blockquote>
<p>提示：这种方式有两个弊端：1.首先是Cookie不安全，虽然通过加密Cookie可以保证安全性，然这是在源程序不泄露的情况下。如果Cookie加密算法泄露，攻击者可以伪造Cookie则可以伪造特定用户身份。2.其次是不能实现跨域免登。</p>
</blockquote>
<h4 id="2-通过JSONP"><a href="#2-通过JSONP" class="headerlink" title="2.通过JSONP"></a>2.通过JSONP</h4><p>对于跨域问题可以使用JSONP实现，用户在登录父应用之后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求职工带上域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。虽然这样能够解决跨域问题，但是加密算法一旦泄露，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。 </p>
<h4 id="3-通过页面重定向"><a href="#3-通过页面重定向" class="headerlink" title="3.通过页面重定向"></a>3.通过页面重定向</h4><p>通过父应用于子应用来回重定向中进行通信，实现信息的安全传递。</p>
<h4 id="4-独立登录系统"><a href="#4-独立登录系统" class="headerlink" title="4.独立登录系统"></a>4.独立登录系统</h4><p>用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p>
]]></content>
      <categories>
        <category>SSO</category>
      </categories>
      <tags>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 由来</title>
    <url>/undefined/SprinMVC%E7%9A%84%E7%94%B1%E6%9D%A5%EF%BC%9A/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>jsp发展经历了两个模型时代，jsp模型一时代是把代码都写在jsp页面上，用户访问jsp页面时，jsp页面来对数据库进行操作并返回值到jsp页面，这样第一不好维护，第二安全性不高，第三代码结构不清晰，第四重用性不高。于是就有了jsp模型二时代，人们将所有的页面请求交给一个servlet控制器来接受，然后进行分发，由该servlet来决定调用其他servlet访问数据库还是进行页面跳转，这个servelt就是MVC中的C，web.xml中配置的就是总servlet控制器，为了更好的分层，重用，降低依赖性，就有了MVC，由M层接受和绑定用户的数据，V层进行展现，C层进行控制。</p>
<p>目前主流的开发模式是四层开发模式：界面层（page）+动作处理层（action）+业务逻辑层（service）+数据访问层（dao），page层用于展现页面，action层用于捕获用户事件并调用service层处理业务逻辑，service要处理业务逻辑肯定就要对数据库进行增删改查，拼接SQL语句，然后调用dao层对数据库进行操作，但是这样一来action层对service层产生了依赖，因为要创建一个service接口的引用，service层对dao层产生了依赖，就是说实例化一个action层的对象，同时要至少实例化一个service层和至少实例化一个dao层，于是spring的IOC就可以起作用了，就可以降低各层之间的依赖。将各层做为接口对象实例配置到spring中，降低依赖。</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">web.xml</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">	&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 注册SpringMVC的核心SERVLET --&gt;</span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">			&lt;param-value&gt;classpath:/springmvc.xml&lt;/param-value&gt;</span><br><span class="line">		&lt;/init-param&gt;</span><br><span class="line">	&lt;/servlet&gt;</span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</span><br><span class="line">	&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro</title>
    <url>/undefined/Shiro/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Shiro是简洁易用的安全框架包括(Subject,securityManager,Realms)。权限管理包括：用户认证、用户授权。</p>
<h3 id="1-Subject"><a href="#1-Subject" class="headerlink" title="1.Subject"></a>1.Subject</h3><p>这里表示用户，表示Shiro可以表示一个实际的用户，也可以是第三方的服务，系统，或者Job等。在用户认证过程中，可以将subject主体理解为用户或者程序，要去访问系统的资源，系统需要对subject进行身份认证。</p>
<blockquote>
<p>注意：每个Subject实例都会绑定对应的SecurityManager。</p>
</blockquote>
<h3 id="2-SecurityManager"><a href="#2-SecurityManager" class="headerlink" title="2.SecurityManager"></a>2.SecurityManager</h3><p>是整个Shiro的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。是安全管理器，主体进行认证和授权都是通过securityManager进行的。</p>
<h4 id="2-1-authenticator"><a href="#2-1-authenticator" class="headerlink" title="2.1.authenticator"></a>2.1.authenticator</h4><p>认证器，主体进行认证最终通过authenticator进行的。</p>
<h4 id="2-2-authorizer"><a href="#2-2-authorizer" class="headerlink" title="2.2.authorizer"></a>2.2.authorizer</h4><p>授权器，主体进行授权最终通过authorizer进行的。</p>
<h4 id="2-3-sessionManager"><a href="#2-3-sessionManager" class="headerlink" title="2.3.sessionManager"></a>2.3.sessionManager</h4><p>web应用中一般是用web容器对session进行管理，shiro也提供一套session管理的方式。</p>
<h4 id="2-4-SessionDao"><a href="#2-4-SessionDao" class="headerlink" title="2.4.SessionDao"></a>2.4.SessionDao</h4><p>通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。</p>
<h4 id="2-5-cache-Manager"><a href="#2-5-cache-Manager" class="headerlink" title="2.5.cache Manager"></a>2.5.cache Manager</h4><p>缓存管理器，主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。</p>
<h4 id="2-6-realms"><a href="#2-6-realms" class="headerlink" title="2.6.realms"></a>2.6.realms</h4><p>域，领域，相当于数据源，通过realm存取认证、授权相关数据。</p>
<h4 id="2-6-1-Realms"><a href="#2-6-1-Realms" class="headerlink" title="2.6.1.Realms"></a>2.6.1.Realms</h4><p>是连接Shiro和应用程序安全数据之间的桥梁。当进行鉴权和授权的时候，Shiro会查询一个或者多个Realms。Shiro提供一些默认的Realm，例如LDAP， JDBC和INI文件中。</p>
<h4 id="2-7-cryptography"><a href="#2-7-cryptography" class="headerlink" title="2.7.cryptography"></a>2.7.cryptography</h4><p>密码管理，提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。MD5散列算法。</p>
<h2 id="详细架构"><a href="#详细架构" class="headerlink" title="详细架构"></a>详细架构</h2><h4 id="1-使用用户的登录信息创建令牌"><a href="#1-使用用户的登录信息创建令牌" class="headerlink" title="1.使用用户的登录信息创建令牌"></a>1.使用用户的登录信息创建令牌</h4><pre><code>UsernamePasswordToken token = new UsernamePasswordToken(username, password);
</code></pre><blockquote>
<p>注：token理解为用户令牌，登录的过程被抽象为shiro验证令牌是否具有合法身份以及相关权限。</p>
</blockquote>
<h4 id="2-执行登录动作"><a href="#2-执行登录动作" class="headerlink" title="2.执行登录动作"></a>2.执行登录动作</h4><pre><code>SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager
Subject subject = SecurityUtils.getSubject(); // 获取Subject单例对象
subject.login(token); // 登陆
</code></pre><blockquote>
<p>注：SecurityManager负责安全认证与授权。SecurityUtils对象本质上类似spring中的applicationContext。</p>
</blockquote>
<h4 id="3-判断用户"><a href="#3-判断用户" class="headerlink" title="3.判断用户"></a>3.判断用户</h4><p>因为Shiro本身无法知道所持有令牌的合法性，所以Realm需要设计者自行实现。最重要的一种实现方式，数据库查询。</p>
<h4 id="4-AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合"><a href="#4-AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合" class="headerlink" title="4.AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合"></a>4.AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合</h4><h2 id="实现Realm"><a href="#实现Realm" class="headerlink" title="实现Realm"></a>实现Realm</h2><h2 id="Shiro认证"><a href="#Shiro认证" class="headerlink" title="Shiro认证"></a>Shiro认证</h2><h4 id="1-导jar包"><a href="#1-导jar包" class="headerlink" title="1.导jar包"></a>1.导jar包</h4><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><blockquote>
<p>提示：或者直接导入shiro相关的全部jar包。</p>
</blockquote>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-all&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="2-认证流程"><a href="#2-认证流程" class="headerlink" title="2.认证流程"></a>2.认证流程</h4><pre><code>1.构建SecurityManager环境

    DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();

2.Subject.login() 提交认证 (主体提交认证请求)

    //0.1这里为了简单，使用SimpleAccountRealm创建简单的realm对象
    SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm();
    //0.2在执行之前给realm添加一个用户
    @Before
    public void addUser(){
        simpleAccountRealm.addAccount(&quot;Brian&quot;,&quot;Brian_3365&quot;);
    }

    //1.1设置SecurityUtils的环境
    SecurityUtils.setSecurityManager(defaultSecurityManager);
    //1.2将simpleAccountRealm设置到环境中来

    defaultSecurityManager.setRealm(simpleAccountRealm);
    //2.获取主体
    Subject subject = SecurityUtils.getSubject();

3.SecurityManager.login() 执行认证

    //3.获取登录的认证数据
    UsernamePasswordToken token = new UsernamePasswordToken(&quot;Aaron&quot;,&quot;Aaron_2254&quot;);
    //提交认证
    subject.login(token);

4.Authenticator 执行认证

    //4.执行得到 是否已经得到认证
    subject.isAuthenticated();

5.Realm 根据身份获取验证信息

    //这里可以输出查看结果
    System.out.println(&quot;是否已经得到认证：&quot;+subject.isAuthenticated());

    //5.在成功登陆之后，然后subject提供了一个登出的方法
    subject.logout();
</code></pre><hr>
<h2 id="Shiro-授权"><a href="#Shiro-授权" class="headerlink" title="Shiro 授权"></a>Shiro 授权</h2><pre><code>1.构建SecurityManager环境
2.主体授权
3.SecurityManager授权
4.Authorizer授权
5.Realm 获取角色权限数据

    //0.1这里为了简单，使用SimpleAccountRealm创建简单的realm对象
    SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm();
    //0.2在执行之前给realm添加一个用户并设置用户角色(admin)
    @Before
    public void addUser(){
        simpleAccountRealm.addAccount(&quot;Brian&quot;,&quot;Brian_3365&quot;,&quot;admin&quot;);
    }

    //1.1设置SecurityUtils的环境
    SecurityUtils.setSecurityManager(defaultSecurityManager);
    //1.2将simpleAccountRealm设置到环境中来

    defaultSecurityManager.setRealm(simpleAccountRealm);
    //2.获取主体
    Subject subject = SecurityUtils.getSubject();
    //3.获取登录的认证数据
            UsernamePasswordToken token = new UsernamePasswordToken(&quot;Aaron&quot;,&quot;Aaron_2254&quot;);
            //提交认证
            subject.login(token);
    //4.执行得到 是否已经得到认证
            subject.isAuthenticated();

    //这里可以输出查看结果
    System.out.println(&quot;是否已经得到认证：&quot;+subject.isAuthenticated());

    //检查用户角色
    subject.checkRole(&quot;admin&quot;);

    //5.在成功登陆之后，然后subject提供了一个登出的方法
    subject.logout();
</code></pre><hr>
<h2 id="Shiro-自定义Realm"><a href="#Shiro-自定义Realm" class="headerlink" title="Shiro 自定义Realm"></a>Shiro 自定义Realm</h2><h4 id="1-内置Realm"><a href="#1-内置Realm" class="headerlink" title="1.内置Realm"></a>1.内置Realm</h4><p><strong>1.1 IniRealm</strong><br></p>
<pre><code>验证：

//0.1 创建IniRealm对象
IniRealm iniRealm = new IniRealm(&quot;classpath:user.ini&quot;);
//0.2 然后在对应的路径下新建user.ini文件 （用户名 = 密码）
[users]
Aaron = Aaron_2235

//1. 构建SecurityManager环境
DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
defaultSecurityManager.setRealm(iniRealm);

//1.1设置SecurityUtils的环境
SecurityUtils.setSecurityManager(defaultSecurityManager);
//1.2将simpleAccountRealm设置到环境中来
defaultSecurityManager.setRealm(simpleAccountRealm);
//2.获取主体
Subject subject = SecurityUtils.getSubject();
//3.获取登录的认证数据
UsernamePasswordToken token = new UsernamePasswordToken(&quot;Aaron&quot;,&quot;Aaron_2254&quot;);
//提交认证
subject.login(token);

//这里可以输出查看结果
System.out.println(&quot;是否已经得到认证：&quot;+subject.isAuthenticated());

授权：

//对应路径下创建user.ini文件
[users]
Aaron = Aaron_2235,admin
[roles]
//管理员用户删除用户的权限
admin = user:delete
//然后在 验证 的代码之后由命令检验角色信息
subject.checkRole(&quot;admin&quot;);
//以及验证是否具备删除用户权限
subject.checkPermission(&quot;user:delete&quot;);
</code></pre><p><strong>1.2 JdbcRealm</strong><br></p>
<pre><code>//在最开始，需要创建一个数据源
DruidDataSource dataSource = new DruidDataSource();
{
    dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;root&quot;);
}

//0.1 创建JdbcRealm对象 其有默认的查询语句
JdbcRealm jdbcRealm = new JdbcRealm();

//0.2 jdbcRealm需要访问数据库，所以需要加入依赖

//0.3 创建jdbc的数据源
jdbcRealm.setDataSource(dataSource);
//在使用jdbcRealm权限查询的时候，需要设置权限开关
jdbcRealm.setPermissionLookupEnable(true);

//1. 构建SecurityManager环境
DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
//1.2 将jdbcRealm设置到环境中来
defaultSecurityManager.setRealm(jdbcRealm);

//1.1设置SecurityUtils的环境
SecurityUtils.setSecurityManager(defaultSecurityManager);

//2.获取主体
Subject subject = SecurityUtils.getSubject();

//3.获取登录的认证数据
UsernamePasswordToken token = new UsernamePasswordToken(&quot;Aaron&quot;,&quot;Aaron_2254&quot;);

//4.这里可以输出查看结果
System.out.println(&quot;是否已经得到认证：&quot;+subject.isAuthenticated());
</code></pre><h4 id="2-自定义Realm-安全数据源"><a href="#2-自定义Realm-安全数据源" class="headerlink" title="2.自定义Realm(安全数据源)"></a>2.自定义Realm(安全数据源)</h4><p>Shiro从Realm域获取安全数据(如用户、角色、权限)，所以SecurityManager需要验证身份，那么就需要从Realm中获取相应的用户进行比较来确定用户身份是否合法，同时也需要从Realm中得到用户相应的角色、权限进行验证用户是否能够进行操作。</p>
<pre><code>public class CustomRealm extends AuthorizingRealm{

    //此方法是用来做授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        //获取用户
        String username = (String)PrincipalCollection.getPrincipalCollection();

        //从数据库或者缓存中获取角色数据，数据库操作
        Set&lt;String&gt; roles = getRolesByUserName(username);

        Set&lt;String&gt; permissions = getPermissionsByUserName(username);

        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();

        //向其中加入相应的角色和权限
        simpleAuthorizationInfo.setStringPermissions(permissions);
        simpleAuthorizationInfo.setRoles(roles);

        //开始授权操作
        return simpleAuthorizationInfo;
    }

    private Set&lt;String&gt; getRolesByUserName(String username){
        Set&lt;String&gt; sets = new HashSet&lt;&gt;();
        sets.add(&quot;admin&quot;);
        sets.add(&quot;user&quot;);
        return sets;
    }

    private Set&lt;String&gt; getPermissionsByUserName(String username){
        Set&lt;String&gt; sets = new HashSet&lt;&gt;();
        sets.add(&quot;user:delete&quot;);
        sets.add(&quot;user:select&quot;);
        return sets;
    }

    //此方法是用来做认证
    //AuthenticationToken 主体传过来的认证信息
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {

        //这里从简(数据库)
        Map&lt;String, String&gt; userMap = new HashMap&lt;&gt;();
        {
            //userMap.put(&quot;Aaron&quot;,&quot;Aaron_2254&quot;);
            //Shiro加密实验部分
            userMap.put(&quot;Aaron&quot;,&quot;md5加密后的密文&quot;);
            //Shiro加密加盐
            userMap.put(&quot;Aaron&quot;,&quot;md5加密加盐后密文&quot;);
            super.setName(&quot;cusRealm&quot;);
        }
        //1.从主体传递的认证信息中获取用户名
        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;
        String username = token.getUsername();

        //2.通过用户名去到数据库中获取凭证
        String password = getPasswordByUserName(username);
        if(password == null ){
            return null;
        }

        //用户存在 返回对象simpleAuthenticationInfo
        SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(&quot;Aaron&quot;,password,&quot;cusRealm&quot;);

        //这里登录的主要信息：实体类对象，但是该实体类对象一定是根据token的username查询得到的

        //在这里需要将盐设置到simpleAuthenticationInfo
        simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(&quot;Aaron&quot;));

        return simpleAuthenticationInfo;
        }

        //2.1 模拟数据库
        private String getPasswordByUserName(String username){
            return userMap.get(username);
        }
    }

    //Shiro 加密设置 将明文密码改成密文密码
    public static void main(String[] args){
        Md5Hash md5Hash = new Md5Hash(&quot;Aaron_2254&quot;);
        System.out.println(md5Hash.toString());
    }

    //然后在验证信息里面使用加密后的密文
}

测试类：测试上面两个自定义的Realm是否正确。
</code></pre><hr>
<h2 id="Shiro在Controller中实现"><a href="#Shiro在Controller中实现" class="headerlink" title="Shiro在Controller中实现"></a>Shiro在Controller中实现</h2><pre><code>//这里只截取主要部分
//获取提交主体
Subject subject = SecurityUtils.getSubject();
//根据用户名获取数据库登录信息
UsernamePasswordToken token = new UsernamePasswordToken(uid,&quot;&quot;);
try {
    //提交登录信息
    subject.login(token);
} catch (AuthenticationException e) {
    LOG.error(e.getMessage());
    //返回403界面
    response.sendRedirect(&quot;/403.html&quot;);
}

...
</code></pre><hr>
<h2 id="Shiro加密"><a href="#Shiro加密" class="headerlink" title="Shiro加密"></a>Shiro加密</h2><h4 id="1-Shiro散列配置"><a href="#1-Shiro散列配置" class="headerlink" title="1.Shiro散列配置"></a>1.Shiro散列配置</h4><p><strong>1.1 HashedCredentialsMatcher</strong><br></p>
<pre><code>//0.1 自定义Realm，这里的自定义customRealm沿用上面的自定义Realm
CustomRealm customRealm = new CustomRealm();

//1. 构建SecurityManager环境
DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
//1.2 将jdbcRealm设置到环境中来
defaultSecurityManager.setRealm(jdbcRealm);

//构建加密算法
HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
//设置加密算法的名称
matcher.setHashAlgorithmName(&quot;md5&quot;);
//设置加密的次数
matcher.setHashIterations(1);

//在自定义的Realm中设置加密的matcher对象
customRealm.setCredentialsMatcher(matcher);


//1.1设置SecurityUtils的环境
SecurityUtils.setSecurityManager(defaultSecurityManager);

//2.获取主体
Subject subject = SecurityUtils.getSubject();

//3.获取登录的认证数据
UsernamePasswordToken token = new UsernamePasswordToken(&quot;Aaron&quot;,&quot;Aaron_2254&quot;);

//4.这里可以输出查看结果
System.out.println(&quot;是否已经得到认证：&quot;+subject.isAuthenticated());
</code></pre><p><strong>1.2 自定义Realm中使用散列</strong><br></p>
<pre><code>//Shiro 加密设置 将明文密码改成密文密码
public static void main(String[] args){
    Md5Hash md5Hash = new Md5Hash(&quot;Aaron_2254&quot;);
    System.out.println(md5Hash.toString());
}

//然后在验证信息里面使用加密后的密文
</code></pre><p><strong>1.3 盐的使用</strong><br></p>
<pre><code>//1.加盐表示在MD5加密的基础上加上随机数
public static void main(String[] args){
    //加密之后再加上随机数
    Md5Hash md5Hash = new Md5Hash(&quot;Aaron_2254&quot;,&quot;Aaron&quot;);
    System.out.println(md5Hash.toString());
}

//2.然后将生成的随机数加到原先的Realm认证中
SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(&quot;Aaron&quot;,password,&quot;cusRealm&quot;);
//在这里需要将盐设置到simpleAuthenticationInfo
simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(&quot;Aaron&quot;));
</code></pre><hr>
<h2 id="Shiro与SpringMVC集成"><a href="#Shiro与SpringMVC集成" class="headerlink" title="Shiro与SpringMVC集成"></a>Shiro与SpringMVC集成</h2><h2 id="Shiro实战"><a href="#Shiro实战" class="headerlink" title="Shiro实战"></a>Shiro实战</h2><h4 id="0-pom-xml"><a href="#0-pom-xml" class="headerlink" title="0.pom.xml"></a>0.pom.xml</h4><p>在原先pom.xml的基础上加上如下的shiro依赖。</p>
<pre><code>&lt;!--Shiro 相关--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;
    &lt;version&gt;1.4.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;1.4.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;
    &lt;version&gt;1.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="1-配置前端过滤器-web-xml"><a href="#1-配置前端过滤器-web-xml" class="headerlink" title="1.配置前端过滤器(web.xml)"></a>1.配置前端过滤器(web.xml)</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
    id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;
    &lt;display-name&gt;Shiro_Project&lt;/display-name&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;


    &lt;!-- 配置spring容器的路径 --&gt;
      &lt;context-param&gt;
              &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
              &lt;param-value&gt;classpath*:/spring-context-*.xml&lt;/param-value&gt;
      &lt;/context-param&gt;
      &lt;!-- 对spring开始监听 --&gt;
      &lt;listener&gt;
          &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
      &lt;/listener&gt;

    &lt;!-- 配置springmvc.xml文件的位置 --&gt;
     &lt;servlet&gt;
         &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
         &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
         &lt;init-param&gt;
             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
             &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
         &lt;/init-param&gt;
         &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
     &lt;/servlet&gt;
      &lt;servlet-mapping&gt;
         &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
         &lt;url-pattern&gt;/&lt;/url-pattern&gt;
     &lt;/servlet-mapping&gt;

    &lt;!-- shiro配置开始，这里注意拦截器的名称 --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
        &lt;async-supported&gt;true&lt;/async-supported&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;shiroFilter&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!-- shiro配置 结束 --&gt;
&lt;/web-app&gt;
</code></pre><blockquote>
<p>注意：由于项目通过Spring管理，所以所有的配置原则上都是交给Spring，那么这里的DelegatingFilterProxy的功能就是通知Spring将所有的Filter叫个ShiroFilter管理。</p>
</blockquote>
<h4 id="2-在classpath路径下编写spring-context-xml文件"><a href="#2-在classpath路径下编写spring-context-xml文件" class="headerlink" title="2.在classpath路径下编写spring-context.xml文件"></a>2.在classpath路径下编写spring-context.xml文件</h4><p>在此文件下需要配置cacheManager（缓存框架，是因为shiro的session是自己实现的）。</p>
<pre><code>&lt;!-- 缓存bean --&gt;
&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:${ehcache.file}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!--在pom.xml文件中配置该缓存的依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
  &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;
  &lt;version&gt;2.6.9&lt;/version&gt;
&lt;/dependency&gt;
   &lt;dependency&gt;
     &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
     &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;
     &lt;version&gt;1.2.3&lt;/version&gt;
   &lt;/dependency&gt;
</code></pre><h4 id="3-在classpath路径下编写spring-shiro-web-xml文件-上面文件只是补充"><a href="#3-在classpath路径下编写spring-shiro-web-xml文件-上面文件只是补充" class="headerlink" title="3.在classpath路径下编写spring-shiro-web.xml文件 上面文件只是补充"></a>3.在classpath路径下编写spring-shiro-web.xml文件 上面文件只是补充</h4><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    
                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    
                        http://www.springframework.org/schema/context    
                        http://www.springframework.org/schema/context/spring-context-3.1.xsd    
                        http://www.springframework.org/schema/mvc    
                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;

    &lt;!-- 1.缓存管理器 使用Ehcache实现 --&gt;
    &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;
        &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 2.加密算法 --&gt;
    &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;utils.RetryLimitHashedCredentialsMatcher&quot;&gt;
        &lt;constructor-arg ref=&quot;cacheManager&quot; /&gt;
        &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot; /&gt;
        &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot; /&gt;
        &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Shiro的Web过滤器，启动shiro授权注解拦截方式，这里配置shiro拦截器 --&gt;
    &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;
        &lt;!--配置SecurityManager对象，此属性非常重要--&gt;
        &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt;

        &lt;!--登录时的链接--&gt;
        &lt;property name=&quot;loginUrl&quot; value=&quot;/&quot; /&gt;
        &lt;!-- 登录成功后要跳转的连接(本例中此属性用不到,因为登录成功后的处理逻辑在LoginController里硬编码为main.jsp了) --&gt;  
        &lt;!-- &lt;property name=&quot;successUrl&quot; value=&quot;/&quot;/&gt; --&gt;  

        &lt;!--用户访问未授权的资源时所显示的链接--&gt;
        &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/&quot; /&gt;

        &lt;!--过滤器链,同时过滤器链是有顺序的,是从上往下匹配,匹配到之后就返回--&gt;
        &lt;property name=&quot;filterChainDefinitions&quot;&gt;
            &lt;!--内置的过滤规则--&gt;
            &lt;value&gt;
                /authc/admin = roles[admin]
                &lt;!--此表示需要经过认证之后才能访问相应的路径--&gt;
                /authc/** = authc
                &lt;!--此表示不需要任何认证--&gt;
                /** = anon
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- 创建SecurityManager对象，从而得到自定义用户数据匹配--&gt;
    &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;
        &lt;!--将自定义的Realm对象设置到SecurityManager环境中--&gt;
        &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 创建自定义的Realm，来作为授权和认证的realm --&gt;
    &lt;bean id=&quot;userRealm&quot; class=&quot;utils.UserRealm&quot;&gt;
        &lt;!--以及自定义比对器，比对结果与form提交是否一致--&gt;
        &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--自定义比对器的bean注入，这一比对器是自定义实现--&gt;
    &lt;bean class=&quot;cn.edu.xidian.B.authurity.CredentialMatcher&quot; id=&quot;credentialMatcher&quot;/&gt;

    &lt;!--然后上面过程中的过滤器链可以用程序实现，这样不用每次都去添加一次--&gt;
    &lt;bean class=&quot;cn.edu.xidian.B.authurity.FilterChainDefinitionMapBuilder&quot; id=&quot;filterChainDefinitionMapBuilder&quot;/&gt;
    &lt;bean id=&quot;filterChainDefinitionMap&quot; factory-bean=&quot;filterChainDefinitionMapBuilder&quot; factory-method=&quot;getMap&quot;/&gt;

    &lt;!-- 配置 Bean 后置处理器: 会自动的调用和 Spring 整合后各个组件的生命周期方法. --&gt;  
    &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>注意：filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会在继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/<strong>用户必须登录才能访问、/</strong>其他所有路径任何人都可以访问。</p>
</blockquote>
<h4 id="4-在classpath路径下配置springmvc-xml文件-没必要配置springmvc-xml文件"><a href="#4-在classpath路径下配置springmvc-xml文件-没必要配置springmvc-xml文件" class="headerlink" title="4.在classpath路径下配置springmvc.xml文件 没必要配置springmvc.xml文件"></a>4.在classpath路径下配置springmvc.xml文件 没必要配置springmvc.xml文件</h4><pre><code>&lt;!--&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;--&gt;
&lt;!--&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;--&gt;
&lt;!--    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;--&gt;
&lt;!--    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;--&gt;
&lt;!--    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;--&gt;
&lt;!--    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;--&gt;
&lt;!--    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans --&gt;
&lt;!--       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd--&gt;
&lt;!--       http://www.springframework.org/schema/context --&gt;
&lt;!--       http://www.springframework.org/schema/context/spring-context-3.0.xsd--&gt;
&lt;!--       http://www.springframework.org/schema/tx --&gt;
&lt;!--       http://www.springframework.org/schema/tx/spring-tx-3.0.xsd--&gt;
&lt;!--       http://www.springframework.org/schema/aop--&gt;
&lt;!--       http://www.springframework.org/schema/aop/spring-aop-3.0.xsd--&gt;
&lt;!--       http://www.springframework.org/schema/mvc  --&gt;
&lt;!--         http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd--&gt;
&lt;!--         http://www.springframework.org/schema/task     --&gt;
&lt;!--       http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;--&gt;

&lt;!--    &lt;context:annotation-config /&gt;--&gt;
    &lt;!-- 使用注解时必须 --&gt;
&lt;!--    &lt;mvc:annotation-driven&gt;--&gt;
&lt;!--        &lt;mvc:argument-resolvers&gt;--&gt;
&lt;!--            &lt;bean class=&quot;cn.edu.xidian.see.ext.DataTableArgumentResolver&quot;/&gt;--&gt;
&lt;!--        &lt;/mvc:argument-resolvers&gt;--&gt;
&lt;!--    &lt;/mvc:annotation-driven&gt;--&gt;

&lt;!--    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt;--&gt;

&lt;!--&lt;/beans&gt;--&gt;
</code></pre><h4 id="5-在classpath路径下配置ehcache-shiro-xml文件"><a href="#5-在classpath路径下配置ehcache-shiro-xml文件" class="headerlink" title="5.在classpath路径下配置ehcache-shiro.xml文件"></a>5.在classpath路径下配置ehcache-shiro.xml文件</h4><pre><code>&lt;ehcache updateCheck=&quot;false&quot; name=&quot;shiroCache&quot;&gt;  

    &lt;defaultCache  
            maxElementsInMemory=&quot;10000&quot;  
            eternal=&quot;false&quot;  
            timeToIdleSeconds=&quot;120&quot;  
            timeToLiveSeconds=&quot;120&quot;  
            overflowToDisk=&quot;false&quot;  
            diskPersistent=&quot;false&quot;  
            diskExpiryThreadIntervalSeconds=&quot;120&quot;  
            /&gt;  
&lt;/ehcache&gt;  
</code></pre><h4 id="6-密码规则的实现-CredentialMatcher-比对登录信息和数据库信息是否一致"><a href="#6-密码规则的实现-CredentialMatcher-比对登录信息和数据库信息是否一致" class="headerlink" title="6.密码规则的实现 - CredentialMatcher 比对登录信息和数据库信息是否一致"></a>6.密码规则的实现 - CredentialMatcher 比对登录信息和数据库信息是否一致</h4><pre><code>public class CredentialMatcher extends SimpleCredentialsMatcher {
    @Override
    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token;
        String password = new String(usernamePasswordToken.getPassword());
        String dbpassword = (String)info.getCredentials();
        return this.equals(password,dbpassword);
    }
}
</code></pre><h4 id="7-自定义过滤器链的实现-有了这一方法之后就不用在配置文件重复添加过滤链接，接配置文件的getMap"><a href="#7-自定义过滤器链的实现-有了这一方法之后就不用在配置文件重复添加过滤链接，接配置文件的getMap" class="headerlink" title="7.自定义过滤器链的实现 有了这一方法之后就不用在配置文件重复添加过滤链接，接配置文件的getMap()"></a>7.自定义过滤器链的实现 有了这一方法之后就不用在配置文件重复添加过滤链接，接配置文件的getMap()</h4><pre><code>package cn.edu.xidian.B.authurity;

public class FilterChainDefinitionMapBuilder {

    @Autowired
    private AuthoriseService authoriseService;

    private LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = null;

    public LinkedHashMap&lt;String, String&gt; getMap(){
        if (filterChainDefinitionMap == null){
            //一个线程访问完抛出之后，其它线程才能争取访问
            synchronized (this){
                if (filterChainDefinitionMap == null){
                    filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
                    setBeforeUrlPermissions();
                    List&lt;Permission&gt; permissions = authoriseService.getAllPermission();
                    for (Permission permission : permissions){
                        if (permission.getStatus() == 0){
                            //将访问的链接组装起来：perms[&quot;pname&quot;] 将之存放到链接的map集合中
                            filterChainDefinitionMap.put(permission.getPurl(), &quot;perms[\&quot;&quot; + permission.getPname() + &quot;\&quot;&quot;);
                        }
                        setAfterUrlPermissions();
                    }
                }
            }
        }
        return filterChainDefinitionMap;
    }

    //在用户登录之前以下这些链接能够在不登录的前提下访问
    private void setBeforeUrlPermissions(){
        filterChainDefinitionMap.put(&quot;/local/*&quot;,&quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/403.ftl&quot;,&quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/&quot;,&quot;anon&quot;);
    }

    //这些链接需要在用户登录之后才能访问
    private void setAfterUrlPermissions(){
        filterChainDefinitionMap.put(&quot;/*&quot;,&quot;authc&quot;);
    }
}
</code></pre><h4 id="8-自定义Realm-AuthRealm"><a href="#8-自定义Realm-AuthRealm" class="headerlink" title="8.自定义Realm AuthRealm"></a>8.自定义Realm AuthRealm</h4><pre><code>public class ShiroRealm extends AuthorizingRealm{
    @Autowired
    private UserService userService;  

    @Autowired  
    private RoleService roleService;  

    /**  
     * shiro认证  
     */  
    @Override  
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException {  

        // 这里首先通过登录信息获取登录用户名
        UsernamePasswordToken token = (UsernamePasswordToken) authcToken;  
        String loginName = token.getUsername();  

        // 判断登录时用户名是否为空或者null
        if (loginName != null &amp;&amp; !&quot;&quot;.equals(loginName)) {  

            //通过登录名来查询响应的数据库中的用户
            User user = userService.getUserByLoginName(loginName);  
            if (user != null) {  
                // 如果身份认证验证成功，返回一个AuthenticationInfo实现  
                return new SimpleAuthenticationInfo(user.getLoginName(), user.getPassword(), getName());  
            }  
        }  
        return null;  
    }  

    /**  
     * shiro授权  
     */  
    @Override  
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {  
        //PrincipalCollection 是一个身份集合，因为在shiro中同时配置多个realm，所以身份信息有多个，从而提供此集合聚合这些信息

        // 使用Shiro提供的方法获取用户名称  
        String loginName = (String) getAvailablePrincipal(principals); 

        if (loginName != null) {  
            String roleId = userService.getRoleIdByLoginName(loginName);  

            // 获取用户的权限  
            List&lt;String&gt; permTokens = roleService.getPermTokens(roleId);  

            SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();  

            if (roleId != null) {  

                // 加入用户角色
                info.addRole(roleId);   
            }  
            if (permTokens != null) { 

                // 加入用户许可标记
                info.addStringPermissions(permTokens);   
            }  
            return info;  
        }  
        return null;  
    }  
}
</code></pre><h4 id="10-Controller实现登录逻辑"><a href="#10-Controller实现登录逻辑" class="headerlink" title="10.Controller实现登录逻辑"></a>10.Controller实现登录逻辑</h4><pre><code>@Controller  
@RequestMapping(&quot;/login&quot;)  
public class LoginController {  

    @Autowired  
    private MenuService menuService;  

    @Autowired  
    private UserService userService;  

    @Autowired  
    private CompanyService companyService;  

    @RequestMapping(method = {RequestMethod.GET})  
    public String login(HttpServletRequest request) {  
        System.out.println(&quot;欢迎登陆！&quot;);  
        return &quot;/login&quot;;  
    }  

    @RequestMapping(method = {RequestMethod.POST})  
    public String loginPost(User user, RedirectAttributes redirectAttributes, HttpServletRequest request) {

        Subject currentUser = SecurityUtils.getSubject();  
        UsernamePasswordToken token = new UsernamePasswordToken(user.getLoginName(), user.getPassword(), user.isRememberMe());  
        try {  
            //用户认证  
            currentUser.login(token);  
        } catch (AuthenticationException e) {  
            System.out.println(e);  
            redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;用户名或密码错误！&quot;);  
            return &quot;redirect:/login&quot;;  
        }  
        if (currentUser.isAuthenticated()) {  
            //登录成功，保存用户相关信息  
            sessionHandle(user, request);  
            //跳转成功页面  
            return &quot;redirect:/index&quot;;  
        } else {  
            redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;用户名或密码错误！&quot;);  
            return &quot;redirect:/login&quot;;  
        }  
    }  

    private void sessionHandle(User user, HttpServletRequest request) {  
        HttpSession session = request.getSession();  
        User loginUser = userService.getUserByLoginName(user.getLoginName());  
        if(loginUser != null){  
            session.setAttribute(&quot;companyId&quot;, loginUser.getCompanyId());  
            session.setAttribute(&quot;username&quot;, loginUser.getNickName());  
            session.setAttribute(&quot;userId&quot;, loginUser.getId());  
        }  
        //menuService.updateMenuInSession(request);  
    }  
}  
</code></pre><h4 id="11-本地LocalController实现"><a href="#11-本地LocalController实现" class="headerlink" title="11.本地LocalController实现"></a>11.本地LocalController实现</h4><pre><code>package cn.edu.xidian.B.controller;

@Controller
@RequestMapping(&quot;/local&quot;)
public class LocalController {

    private static Logger LOG = Logger.getLogger(LocalController.class);

    @Autowired
    private StudentService studentService;
    @Autowired
    private TeacherService teacherService;

    @RequestMapping(&quot;/&quot;)
    public String login() {
        return &quot;local/local&quot;;
    }

    @RequestMapping(&quot;/dologin&quot;)
    public String dologin(HttpServletRequest request, HttpServletResponse response, Model model)
            throws Exception {

        HttpSession session = request.getSession();

        String uid = request.getParameter(&quot;uid&quot;);
        System.out.println(uid);

        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken(uid,&quot;&quot;);
        try {
            subject.login(token);
        } catch (AuthenticationException e) {
            LOG.error(e.getMessage());
//            response.sendRedirect(&quot;/403&quot;);
            model.addAttribute(&quot;message&quot;, &quot;登录失败，系统没有您的信息&quot;);
            return &quot;local/err&quot;;
        }
        if (uid == null) {
            model.addAttribute(&quot;message&quot;, &quot;uid 为空&quot;);
            return &quot;local/err&quot;;
        } else {
            session.setAttribute(&quot;uid&quot;, uid);
            if (studentService.findStudentBySno(uid) != null) {
                response.sendRedirect(&quot;/student/main&quot;);
                } else if (teacherService.findByStaffno(uid) != null) {
                if(teacherService.findByStaffno(uid).getType() == 2){
                    response.sendRedirect(&quot;/teacher/main&quot;);
                } else {
                    response.sendRedirect(&quot;/testteacher/main&quot;);
                }
            } else {
                model.addAttribute(&quot;message&quot;, &quot;不在表中 uid = &quot; + uid);
                return &quot;local/err&quot;;
            }
        }
        return null;
    }
}
</code></pre><h4 id="12-前台实现-在这里省略"><a href="#12-前台实现-在这里省略" class="headerlink" title="12.前台实现 在这里省略"></a>12.前台实现 在这里省略</h4><blockquote>
<p>总结：在这一系列实现之后，我们就能通过Shiro拦截认证来拦截用户的登录情况。对，还有数据库的实现，特别需要注意的是权限与用户对应，然后用户的类型与权限对应等。实践之后就会觉得，其实并没有那么简单，还是需要考虑很多情况的。</p>
</blockquote>
<hr>
<h3 id="下面是在前期学习的时候，做的一些记录"><a href="#下面是在前期学习的时候，做的一些记录" class="headerlink" title="下面是在前期学习的时候，做的一些记录"></a>下面是在前期学习的时候，做的一些记录</h3><h2 id="通过注解配置授权"><a href="#通过注解配置授权" class="headerlink" title="通过注解配置授权"></a>通过注解配置授权</h2><p>这里授权有两种方式,编程方式和注解方式。编程方式，subject.hasRole();</p>
<h4 id="1-在pom-xml中加入相关依赖"><a href="#1-在pom-xml中加入相关依赖" class="headerlink" title="1.在pom.xml中加入相关依赖"></a>1.在pom.xml中加入相关依赖</h4><pre><code>//加入aspectjweaver包
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.8.13&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="2-在springmvc-xml中增加配置"><a href="#2-在springmvc-xml中增加配置" class="headerlink" title="2.在springmvc.xml中增加配置"></a>2.在springmvc.xml中增加配置</h4><pre><code>&lt;!--开启Shiro注解--&gt;
&lt;aop:config proxy-target-class=&quot;true&quot;/&gt;
&lt;bean class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;
&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;
    &lt;!--设置Shiro的securityManager--&gt;
    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><pre><code>在Controller中使用注解@RequiresPermissions(&quot;admin:delete&quot;);测试只有admin拥有delete权限才能访问。
在Controller中使用注解@RequiresRoles(&quot;admin&quot;);测试只有是admin角色才能访问。
</code></pre><hr>
<h2 id="Shiro过滤器"><a href="#Shiro过滤器" class="headerlink" title="Shiro过滤器"></a>Shiro过滤器</h2><h4 id="1-Shiro内置过滤器"><a href="#1-Shiro内置过滤器" class="headerlink" title="1.Shiro内置过滤器"></a>1.Shiro内置过滤器</h4><p><strong>1.认证</strong><br></p>
<pre><code>anon
authBasic
authc
user
logout
</code></pre><p><strong>2.授权</strong><br></p>
<pre><code>perms
roles
ssl
port
</code></pre><h4 id="2-自定义ShiroFilter"><a href="#2-自定义ShiroFilter" class="headerlink" title="2.自定义ShiroFilter"></a>2.自定义ShiroFilter</h4><hr>
<h1 id="filterChainDefinitions-授权规则定义"><a href="#filterChainDefinitions-授权规则定义" class="headerlink" title="filterChainDefinitions - 授权规则定义"></a>filterChainDefinitions - 授权规则定义</h1><p>Shiro通过ShiroFilterFactoryBean类的filterChainDefinitions(授权规则定义)属性转换为一个filterChainDefinitionMap，转换完成后交给ShiroFilterFactoryBean保管。</p>
<pre><code>//拦截数据库url
public class FilterChainDefinitionMapBuilder {
    @Autowired
    private SysAuthoriseService sysAuthoriseService;

    private LinkedHashMap&lt;String,String&gt; filterChainDefinitionMap = null;
    public LinkedHashMap&lt;String,String&gt; getMap() {

        if(filterChainDefinitionMap == null) {
            synchronized (this) {
                if(filterChainDefinitionMap == null) {
                    filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
                    setBeforeUrlPermissions();
                    List&lt;SysPermission&gt; sysPermissions = sysAuthoriseService.getAllSysPermission();
                    for(SysPermission p : sysPermissions) {
                        if(p.getStatus() == 0)
                            filterChainDefinitionMap.put(p.getPurl(), &quot;perms[\&quot;&quot; + p.getPname() + &quot;\&quot;]&quot;);
                    }
                    setAfterUrlPermissions();
                }
            }
        }
        return filterChainDefinitionMap;
    }

    private void setBeforeUrlPermissions() {
        filterChainDefinitionMap.put(&quot;/local/*&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/403.html&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/&quot;,&quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/student/logout&quot;,&quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/teacher/logout&quot;,&quot;anon&quot;);
    }

    private void setAfterUrlPermissions() {
        //需要用户登录才能访问
        filterChainDefinitionMap.put(&quot;/*&quot;, &quot;authc&quot;);
    }
}
</code></pre><blockquote>
<p>注意：此处使用的拦截器还需要在spring.xml文件中配置。</p>
</blockquote>
<pre><code>&lt;bean class=&quot;cn.edu.xidian.see.authurity.FilterChainDefinitionMapBuilder&quot; id = &quot;filterChainDefinitionMapBuilder&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;filterChainDefinitionMap&quot; factory-bean=&quot;filterChainDefinitionMapBuilder&quot; factory-method=&quot;getMap&quot;&gt;&lt;/bean&gt;
</code></pre><hr>
<h2 id="Shiro会话-Session-管理"><a href="#Shiro会话-Session-管理" class="headerlink" title="Shiro会话(Session)管理"></a>Shiro会话(Session)管理</h2><h4 id="1-SessionManager"><a href="#1-SessionManager" class="headerlink" title="1.SessionManager"></a>1.SessionManager</h4><pre><code>//1.首先在pom.xml中加入Redis依赖
&lt;dependency&gt;
   &lt;groupId&gt;redis.clients&lt;/groupId&gt;
   &lt;artifactId&gt;jedis&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
 &lt;/dependency&gt;

//2.然后重写SessionDao
public class RedisSessionDao extends AbstractSessionDAO{
    //在重写这个SessionDao之后由增删改查等方法

}
</code></pre><hr>
<h4 id="2-SessionDAO"><a href="#2-SessionDAO" class="headerlink" title="2.SessionDAO"></a>2.SessionDAO</h4><h4 id="3-Redis实现Session共享"><a href="#3-Redis实现Session共享" class="headerlink" title="3.Redis实现Session共享"></a>3.Redis实现Session共享</h4><h4 id="4-Redis实现Session共享存在的问题"><a href="#4-Redis实现Session共享存在的问题" class="headerlink" title="4.Redis实现Session共享存在的问题"></a>4.Redis实现Session共享存在的问题</h4><hr>
]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC</title>
    <url>/undefined/Spring%20-%20IOC/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p><strong>1.IoC类型</strong><br><br>从注入方式可以将IoC划分成三种：1.构造函数注入。2.属性注入。3.接口注入。</p>
<p><strong>2.通过容器完成依赖关系的注入</strong><br></p>
<h4 id="相关Java基础"><a href="#相关Java基础" class="headerlink" title="相关Java基础"></a>相关Java基础</h4><pre><code>//通过Java反射机制以一种间接方式操控目标类
public class ReflectTest {
    public static Car initByDefaultConst() throws Throwable { 
        //1.通过类装载器获取Car类对象
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Class clazz = loader.loadClass(&quot;com.smart.reflect.Car&quot;);

        //2.获取类的默认构造器对象并通过它实例化Car
        Constructor cons = clazz.getDeclaredConstructor((Class[]) null);
        Car car = (Car) cons.newInstance();

        //3.通过反射方法设置属性
        Method setBrand = clazz.getMethod(&quot;setBrand&quot;, String.class);
        setBrand.invoke(car, &quot;宏碁&quot;);

        ...

        return car;
    }

    public static void main(String[] args) throws Throwable {
        Car car = initByDefaultConst();
        car.instroduce();
    }
}
</code></pre><h4 id="类装载器-ClassLoader"><a href="#类装载器-ClassLoader" class="headerlink" title="类装载器 ClassLoader"></a>类装载器 ClassLoader</h4><p><strong>1.类装载器工作机制</strong><br><br>类装载器是寻找类的字节码文件并构造类在JVM内部表示对象的组件。在Java中，类装载器将一个类装入JVM中的步骤：</p>
<pre><code>1.装载：查找和导入Class文件
2.链接：执行校验、准备和解析步骤。
    2.1 校验：检查载入Class文件数据的正确性。
    2.2 准备：给类的静态变量分配存储空间。
    2.3 解析：将符号引用转换成直接引用。
3.初始化：对类的静态变量、静态代码块执行初始化工作。
</code></pre><blockquote>
<p>扩展：JVM在运行时会产生3个ClassLoader：根装载器、ExtClassLoader(扩展类装载器)和AppClassLoader(应用类装载器)。</p>
</blockquote>
<p><strong>2.Java反射机制</strong><br></p>
<h4 id="BeanFactory-和-ApplicationContext"><a href="#BeanFactory-和-ApplicationContext" class="headerlink" title="BeanFactory 和 ApplicationContext"></a>BeanFactory 和 ApplicationContext</h4><p>BeanFactory使管理不同类型的Java对象成为可能，应用上下文建立在 BeanFactory 基础之上，提供更多面向应用的功能。ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以使用ApplicationContext而非底层的BeanFactory。</p>
<p><strong>1.BeanFactory</strong><br></p>
<p>Spring为BeanFactory提供多种实现。XmlBeanDefinitionReader | DefaultListableBeanFactory。下面是该接口的扩展接口的说明：</p>
<pre><code>1.ListableBeanFactory：该接口定义了访问容器中Bean的基本信息的若干方法。查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包含某一Bean等。

2.HierarchicalBeanFactory：父子级联IoC容器的接口，子容器可以通过接口方法访问父容器。

3.ConfigurableBeanFactory：增强IoC容器的可定制性。定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。

4.AutowireCapableBeanFactory：定义将容器中的Bean按某种规则进行自动装配方法。

5.SingletonBeanRegistry：定义允许在运行期间向容器注册单实例Bean的方法。

6.BeanDefinitionRefistry：Spring配置文件中每一个&lt;bean&gt;结点元素。
</code></pre><p><strong>2.初始化BeanFactory</strong><br><br>XmlBeanDefinitionReader通过Resource装载Spring配置信息并启动IoC容器，然后通过 BeanFactory#getBean(beanName)方法从IoC容器中获取Bean。Spring在DefaultSingletonBeanRegistry类中提供一个用于缓存单实例Bean的缓存器，是一个用HashMap实现的缓存器，单实例的Bean以beanName为键保存在这个HashMap中。</p>
<p><strong>3.ApplicationContext</strong><br></p>
<p>ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统加载配置文件。ApplicationContext继承HierarchicalBeanFactory和ListableBeanFactory接口。同时还扩展其它BeanFactory接口。</p>
<pre><code>1.ApplicationEventPublisher：让容器拥有发布应用上下文事件功能，包括容器启动和关闭事件。

2.MessageSource：为应用提供i18n国际化消息访问的功能。

3.ResourcePatternResolver：所有的ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能。
</code></pre><p><strong>4.WebApplicationContext类体系</strong><br></p>
<p>WebApplicationContext是专门为Web应用准备的，它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。</p>
<p><strong>5.WebApplicationContext初始化</strong><br></p>
<p>WebApplicationContext初始化和BeanFactory、ApplicationContext有区别，WebApplicationContext需要ServletContext实例，即它必须拥有Web容器的前提下才能完成启动。Spring提供用于启动WebApplicationContext的Servlet和Web容器监听器：</p>
<pre><code>1. ...ContextLoaderServlet
2. ...ContextLoaderListener
</code></pre><p>在两者内部都实现启动WebApplicationContext实例逻辑。在web.xml中配置即可。</p>
<pre><code>&lt;!--1.指定配置文件--&gt;
&lt;context-param&gt;

&lt;/context-param&gt;

&lt;!--声明Web容器监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h2 id="在IoC容器中装配Bean"><a href="#在IoC容器中装配Bean" class="headerlink" title="在IoC容器中装配Bean"></a>在IoC容器中装配Bean</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务配置</title>
    <url>/undefined/Spring%20-%20%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Spring MVC与Mybatis整合框架的事务管理方式有两种：1.声明式事务管理 2.编程式事务管理。</p>
<h4 id="1-编程式事务管理和声明式事务管理"><a href="#1-编程式事务管理和声明式事务管理" class="headerlink" title="1.编程式事务管理和声明式事务管理"></a>1.编程式事务管理和声明式事务管理</h4><blockquote>
<p>编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager，对于编程式事务管理，spring推荐使用TransactionTemplate。</p>
</blockquote>
<blockquote>
<p>声明式事务管理是建立在AOP基础上，本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。该声明式事务最大的优点就是不需要通过编程的方式管理事务，只需要在配置文件中声明，然后通过@Transactionoal注解声明便可以将事务规则应用到业务逻辑中。</p>
</blockquote>
<h4 id="2-声明式事务的两种常用方式"><a href="#2-声明式事务的两种常用方式" class="headerlink" title="2.声明式事务的两种常用方式"></a>2.声明式事务的两种常用方式</h4><p><strong>1.基于tx和aop名字空间的xml配置文件</strong><br></p>
<pre><code>&lt;!-- 事物切面配置 --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;

&lt;tx:advice id=&quot;advice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt; 
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt;
        &lt;tx:method name=&quot;insert&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;
    &lt;/tx:attributes&gt; 
&lt;/tx:advice&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;testService&quot; expression=&quot;execution (* com.baobao.service.MyBatisService.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;testService&quot;/&gt;  
&lt;/aop:config&gt;
</code></pre><blockquote>
<p>注意：因为springmvc配置文件和spring配置文件不同时加载，如果这边不进行这样的设置，那么，spring就会将所有带@Service注解的类都扫描到容器中，等到加载spring的配置文件的时候，会因为容器已经存在Service类，使得cglib将不对Service进行代理，直接导致的结果就是在spring配置文件中的事务配置不起作用。所以在spring.xml配置文件中添加不扫描controller，然后在springmvc.xml中添加不扫描service。</p>
</blockquote>
<pre><code>&lt;!-- 1.在spring.xml配置文件中添加不扫描controller --&gt;
&lt;context:component-scan base-package=&quot;cn.edu.xidian.see.*&quot;&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot;
        expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
&lt;/context:component-scan&gt;

&lt;!--2.在springmvc.xml配置文件中添加不扫描service 要扫描controller--&gt;
&lt;context:component-scan base-package=&quot;cn.edu.xidian.see.controller&quot;&gt;
    &lt;context:include-filter type=&quot;annotation&quot;
        expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot;
        expression=&quot;org.springframework.stereotype.Service&quot; /&gt;
&lt;/context:component-scan&gt;
</code></pre><p><strong>2.基于@Transactional注解</strong><br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在配置文件spring.xml中，去掉对controller的扫描</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.digitalchina.*&quot;&gt;</span><br><span class="line">　      &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</span><br><span class="line">　  &lt;/context:component-scan&gt;</span><br><span class="line">　  </span><br><span class="line">　  2.在配置文件springmvc.xml中，去掉对service的扫描，加入对controller的扫描</span><br><span class="line">　&lt;context:component-scan base-package=&quot;com.digitalchina.*&quot;&gt;</span><br><span class="line">    　&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</span><br><span class="line">    　&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot; /&gt;</span><br><span class="line">　&lt;/context:component-scan&gt;</span><br><span class="line">　</span><br><span class="line">　  3.事务的配置只有在spring.xml中才会起作用，即</span><br><span class="line">　  </span><br><span class="line">　  //该配置必须配置在 spring.xml 中才可以。</span><br><span class="line">　　&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">　　    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">　　&lt;/bean&gt;</span><br><span class="line">　　</span><br><span class="line">　　4.用事务去控制的service，不能加try-catch去捕获异常，否则不能被spring拦截到，事务就失效了。</span><br><span class="line"></span><br><span class="line">　　5.在Service实现类中增加@Transactional注解即可控制事务。</span><br></pre></td></tr></table></figure>
<h4 id="3-事务配置"><a href="#3-事务配置" class="headerlink" title="3.事务配置"></a>3.事务配置</h4><pre><code>&lt;!-- 配置事务管理 --&gt;
&lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 拦截器方式配置事物 --&gt;
&lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- 必须要有事务,没有则创建 
            事务的传播级别表示事务的控制范围，主要是父子事务之间的相互影响关系
            事务的隔离级别表示事务读写的控制范围，主要是两个事务之间的相互影响关系

            1.REQUIRED 表示当前方法已经在事务中，那么就以父事务执行，不需要创建新事务
        --&gt;
        &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;
        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;
        &lt;!-- 可以有可以没有 --&gt;
        &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
        &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!-- Spring aop事务管理 --&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;transactionPointcut&quot; expression=&quot;execution(* com.sanguo.service.impl..*Impl.*(..))&quot; /&gt;
    &lt;aop:advisor pointcut-ref=&quot;transactionPointcut&quot; advice-ref=&quot;transactionAdvice&quot;/&gt;
&lt;/aop:config&gt;
</code></pre><hr>
<h2 id="ThreadLocal-知识"><a href="#ThreadLocal-知识" class="headerlink" title="ThreadLocal 知识"></a>ThreadLocal 知识</h2><p>ThreadLocal 在Spring中发挥着重要作用，在管理request作用域的bean | 事务管理 | 任务调度 | AOP等。Java 1.2版本提供 java.lang.ThreadLocal为解决多线程程序的并发问题。ThreadLocal不是一个线程，是一个保存线程本地化对象的容器。</p>
<h4 id="ThreadLocal的接口方法"><a href="#ThreadLocal的接口方法" class="headerlink" title="ThreadLocal的接口方法"></a>ThreadLocal的接口方法</h4><pre><code>1.void set(Object value) 设置当前线程的线程局部变量的值
2.public Object get() 返回当前线程所对应的线程局部变量
3.public void remove() 将当前线程局部变量的值删除
</code></pre><blockquote>
<p>提示：在ThreadLocal类中有一个Map，用于存储每个线程的变量副本，Map中元素的键为线程对象，值为对应线程的变量副本。</p>
</blockquote>
<h4 id="ThreadLocal-与-同步机制的比较"><a href="#ThreadLocal-与-同步机制的比较" class="headerlink" title="ThreadLocal 与 同步机制的比较"></a>ThreadLocal 与 同步机制的比较</h4><p>在同步机制中通过对象的锁机制保证同一时间只有一个线程访问变量。ThreadLocal为每一个线程提供一个独立的变量副本，从而隔离了多个线程对访问数据的冲突。因为每一个线程都用有了一个变量副本。</p>
<blockquote>
<p>总结：在多线程资源共享的问题上，同步机制采用””以时间换空间”的方式，访问串行化，对象共享化。ThreadLocal采用””以空间换时间”的方式，访问并行化，对象独享化。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cache</title>
    <url>/undefined/Spring%20Cache/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<blockquote>
<p>注意：这里自定义FreeMarkerView的目的是为了放一些公共的变量到FreeMarkerView模板里面。</p>
</blockquote>
<h4 id="1-配置文件-spring-application-xml"><a href="#1-配置文件-spring-application-xml" class="headerlink" title="1.配置文件 spring-application.xml"></a>1.配置文件 spring-application.xml</h4><pre><code>&lt;!-- ********************************************************************** 
 ** FreeMaker解析器                                                      ** 
 ********************************************************************** --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
    &lt;!--&lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerView&quot; /&gt;--&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;net.mingyang.cms.util.FtlView&quot; /&gt;   
    &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt;
    &lt;property name=&quot;exposeRequestAttributes&quot; value=&quot;true&quot; /&gt;  
    &lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt;  
    &lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt;
    &lt;!-- &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; --&gt;  
    &lt;property name=&quot;order&quot; value=&quot;0&quot; /&gt;
&lt;/bean&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; 
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/views/&quot; /&gt; 
    &lt;property name=&quot;freemarkerSettings&quot;&gt; 
        &lt;props&gt; 
            &lt;prop key=&quot;template_update_delay&quot;&gt;0&lt;/prop&gt; 
            &lt;prop key=&quot;default_encoding&quot;&gt;UTF-8&lt;/prop&gt; 
            &lt;prop key=&quot;number_format&quot;&gt;0.##########&lt;/prop&gt; 
            &lt;prop key=&quot;datetime_format&quot;&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt;
            &lt;prop key=&quot;date_format&quot;&gt;yyyy-MM-dd&lt;/prop&gt; 
            &lt;prop key=&quot;classic_compatible&quot;&gt;true&lt;/prop&gt; 
            &lt;prop key=&quot;template_exception_handler&quot;&gt;ignore&lt;/prop&gt; 
        &lt;/props&gt; 
    &lt;/property&gt; 
&lt;/bean&gt;
</code></pre><h4 id="2-自定义实现类"><a href="#2-自定义实现类" class="headerlink" title="2.自定义实现类"></a>2.自定义实现类</h4><pre><code>package cn.edu.xidian.see.ext;

import org.springframework.web.servlet.view.freemarker.FreeMarkerView;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

public class FreeMarkerViewExt extends FreeMarkerView {

    private static final String CONTEXT_PATH = &quot;basePath&quot;;

    @Override
    protected void exposeHelpers(Map&lt;String, Object&gt; model, HttpServletRequest request)
            throws Exception {
        //返回项目根目录
        model.put(CONTEXT_PATH, request.getContextPath());
        super.exposeHelpers(model, request);
    }
}

//或者是这样...

package net.mingyang.cms.util;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.web.servlet.view.freemarker.FreeMarkerView;

public class FtlView extends FreeMarkerView {
    @Override
    protected void exposeHelpers(Map&lt;String, Object&gt; model,
            HttpServletRequest request) throws Exception {
        model.put(&quot;contextPath&quot;, request.getContextPath());
        super.exposeHelpers(model, request);
    }

}
</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 整合 Mybatis</title>
    <url>/undefined/Spring%20SpringMVC%20%E6%95%B4%E5%90%88%20MyBatis/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Spring-SpringMVC-整合-MyBatis"><a href="#Spring-SpringMVC-整合-MyBatis" class="headerlink" title="Spring SpringMVC 整合 MyBatis"></a>Spring SpringMVC 整合 MyBatis</h2><h4 id="整合DAO层"><a href="#整合DAO层" class="headerlink" title="整合DAO层"></a>整合DAO层</h4><p><strong>1.MyBatis全局配置文件</strong><br></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- setting配置根据需要再添加 --&gt;
    &lt;!-- 配置别名 --&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;ssm.po&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!-- mapper这里不需要配置了，因为跟spring整合后，在spring那边会进行mapper的扫描 
        但必须遵循：mapper.xml和mapper.java必须同名且在一个目录
    --&gt;
&lt;/configuration&gt;
</code></pre><blockquote>
<p>提示：这里可以看出整合过程中已经没有什么内容了，因为数据源 mapper这些都交给Spring去管理。</p>
</blockquote>
<p><strong>2.配置spring配置文件</strong><br></p>
<pre><code>//1.首先是对DAO的整合 applicationContext-dao.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd 
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!-- 加载db.properties文件中的内容 --&gt;   
    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;

    &lt;!-- 配置数据源dbcp --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;
        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 配置sqlSessionFactory --&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/sqlMapConfig.xml&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置mapper扫描器 --&gt; 
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!-- 扫描包的路径，如果需要扫描多个包，中间使用半角 逗号隔开--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;ssm.mapper&quot;/&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><blockquote>
<p>提示：这里可以看出整合DAO层的过程主要是配置数据源 sqlSessionFactory mapper扫描器，这样的话数据源 sqlSessionFatory和mapper在服务器启动时就被Spring实例化到容器中。</p>
</blockquote>
<p><strong>3.逆向工程entity类和mapper</strong><br></p>
<p>省略…</p>
<p><strong>4.配置applicationContext-service.xml</strong><br><br>如果这里使用注解就不需要配置。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd 
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

   &lt;!-- 商品管理的service --&gt;
   &lt;bean id=&quot;itemsService&quot; class=&quot;ssm.service.impl.ItemsServiceImpl&quot;/&gt;

&lt;/beans&gt;
</code></pre><p><strong>5.配置applicationContext-transaction.xml</strong><br><br>负责用来配置Spring的事务管理。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd 
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

   &lt;!-- 事务管理器 --&gt;
   &lt;!-- 对mybatis操作数据事务控制，spring使用jdbc的事务控制类 --&gt;
   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!-- 数据源dataSource在applicationContex-dao.xml中配置了 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
   &lt;/bean&gt;

   &lt;!-- 通知 --&gt;
   &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;
        &lt;/tx:attributes&gt;
   &lt;/tx:advice&gt;

   &lt;aop:config&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* ssm.service.impl.*.*(..))&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre><p><strong>6.前端控制器web.xml配置</strong><br></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;
  &lt;display-name&gt;SpringMVC_Study&lt;/display-name&gt;
  &lt;welcome-file-list&gt; 
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  &lt;!-- 配置前端控制器DispatcherServlet --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;  

  &lt;!-- 加载spring容器 --&gt;
 &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;
 &lt;/context-param&gt;
 &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
 &lt;/listener&gt;
&lt;/web-app&gt;
</code></pre><p><strong>7.配置处理器映射器 | 处理器适配器 | 视图解析器</strong><br><br>这里因为使用注解的方式配置，所以配置在springmvc.xml中。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd 
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!-- 一个配置节解决映射器和适配器的配置注解配置 --&gt; 
    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;

    &lt;!-- 扫描所有的Controller --&gt;
    &lt;context:component-scan base-package=&quot;ssm.controller&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 配置视图解析器 
        进行jsp解析，默认使用jstl标签，classpath下得有jstl的包
    --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; /&gt;
&lt;/beans&gt;
</code></pre>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码 - 主题</title>
    <url>/undefined/Spring%20%E5%AE%B9%E5%99%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Spring-容器高级主题"><a href="#Spring-容器高级主题" class="headerlink" title="Spring 容器高级主题"></a>Spring 容器高级主题</h2><h3 id="Spring容器技术内幕"><a href="#Spring容器技术内幕" class="headerlink" title="Spring容器技术内幕"></a>Spring容器技术内幕</h3><h4 id="1-内部工作机制"><a href="#1-内部工作机制" class="headerlink" title="1 内部工作机制"></a>1 内部工作机制</h4><p>Spring 的 AbstractApplication 是 ApplicationContext 的抽象实现类，该抽象实现类的 refresh() 方法定义了Spring容器在加载配置文件后的各项处理过程，这些处理过程清晰刻画Spring容器启动时所执行的各项操作。</p>
<pre><code>//refresh()方法内部定义的执行逻辑
//1. 初始化BeanFactory Spring将配置文件信息装入容器的Bean定义注册表(BeanDefinitionRegistry)中，但是此时Bean还没有初始化。
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

//2. 调用工厂后处理器 根据反射机制从 BeanDefinitionRegistry 中找出所有实现了 BeanFactoryPostProcessor 接口的Bean，并调用其 postProcessBeanFactory() 接口方法。
invokeBeanFactoryPostProcessors();

//3. 注册Bean后处理器 根据反射机制从 BeanDefinitionRegistry 找到所有实现了 BeanPostProcessor 接口的Bean，并将它们注册到容器Bean后处理器的注册表中。
registerBeanPostProcessors();

//4. 初始化消息源 初始化容器的国际化消息资源
initMessageSource();

//5. 初始化应用上下文事件广播器 初始化应用上下文事件广播器。
initApplicationEventMulticaster();

//6. 初始化其它特殊Bean：由具体子类实现
onRefresh();

//7. 注册事件监听器
registerListeners();

//8. 初始化所有单实例的Bean，使用懒加载模式的Bean例外 初始化所有Bean之后将它们放在Spring容器的缓存池中。
finishBeanFactoryInitialization(beanFactory);

//9. 完成刷新并发布容器刷新事件 创建上下文刷新事件，事件广播器负责将这些事件广播到每个注册的事件监听器中。
finishRefresh();
</code></pre><p><strong>1.1 Spring容器从加载配置文件到创建出一个完成Bean的作业流程</strong><br></p>
<pre><code>    配置文件 -- ResourceLoader装载配置文件 --&gt; Resource -- BeanDefinitionReader解析配置文件信息 --&gt; BeanDefinitionRegistry(加工前的BeanDefinition)
                                                                                                        |                           |
                                                                                                        | BeanFactoryPostProcessor  |
                                                                                                        |      对配置信息加工       |
                                                                                                BeanDefinitionRegistry      PropertyEditorRegistry
                                                                                                (加工后BeanDefinition)      (存放自定义PropertyEditor)
                                                                                                        |                               |
                                                                                                        |                               |
                                                                                InsttantiationStrategy(实例化Bean对象)      BeanWrapper(设置Bean属性)              
                                                                                                        |                       /      |
                                                                                                        |                      /       |
                                                                                                    Bean实例(没设置属性)   -&gt;   Bean实例(已设置属性)
                                                                                                                                        |
                                                                                                                                        |
                                                                                                                         BeanPostProcessor(对Bean进行加工)
                                                                                                                                        |
                                                                                                                                    bean实例


1.ResourceLoader：从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件资源。

2.BeanDefinitionReader：读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个&lt;bean&gt;解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中。

...
</code></pre><blockquote>
<p>提示：Spring组件按照所承担角色划分为：1.物料组件：Resource | BeanDefinition | PropertyEditor | Bean 等，它们是在加工流程中被加工 | 被消费的组件，就像流水线的被加工的物料一样。2.设备组件：ResourceLoader …，它们相当于在流水线上不同环节的加工设备，对物料组件进行加工处理。</p>
</blockquote>
<h4 id="2-BeanDefinition"><a href="#2-BeanDefinition" class="headerlink" title="2 BeanDefinition"></a>2 BeanDefinition</h4><p>….BeanDefinition 是配置文件 <bean> 元素标签在容器中的内部表示。Spring 通过BeanDefinition 将配置文件中的 <bean> 配置信息转换成容器的内部表示，并将这些 BeanDefinition 注册到 BeanDefinitionRegistry 中。Spring容器中的 BeanDefinitionRegistry 就像Spring配置信息的内存数据库。</bean></bean></p>
<h4 id="3-InstantiationStrategy"><a href="#3-InstantiationStrategy" class="headerlink" title="3 InstantiationStrategy"></a>3 InstantiationStrategy</h4><p>…InstantiationStrategy 负责根据BeanDefinition 对象创建一个 Bean 实例。SimpleInstantiationStrategy 是最常用的实例化策略，该策略利用Bean实现类的默认构造函数 带参构造函数或者工厂方法创建Bean实例。该组件只负责实例化Bean操作，相当于new功能，不会参与 Bean属性配置工作。属性填充交给BeanWrapper完成。</p>
<h4 id="4-BeanWrapper"><a href="#4-BeanWrapper" class="headerlink" title="4 BeanWrapper"></a>4 BeanWrapper</h4><p>…BeanWrapper是Spring框架重要组件类。BeanWrapper相当于一代理器，Spring委托BeanWrapper完成Bean属性的填充工作。</p>
<h3 id="属性编辑器"><a href="#属性编辑器" class="headerlink" title="属性编辑器"></a>属性编辑器</h3><p>任何实现了java.beans.PropertyEditor接口的类都是属性编辑器。属性编辑器的主要功能就是将外部的设置值转换为JVM内部的对象类型，所以属性编辑器就是一个类型转换器。</p>
<h3 id="引用Bean属性值"><a href="#引用Bean属性值" class="headerlink" title="引用Bean属性值"></a>引用Bean属性值</h3><h3 id="容器事件"><a href="#容器事件" class="headerlink" title="容器事件"></a>容器事件</h3><p>Spring的ApplicationContext能够发布事件并且允许注册相应的事件监听器，所以它拥有一套完善的事件发布和监听机制。</p>
<h4 id="1-Spring事件类结构"><a href="#1-Spring事件类结构" class="headerlink" title="1.Spring事件类结构"></a>1.Spring事件类结构</h4><p><strong>1.1 事件类</strong><br><br>ApplicationEvent的唯一构造函数是 ApplicationEvent(Object source) ，通过source指定事件源。其有两个子类：1.ApplicationContextEvent：容器事件，其有四个子类，分别表示容器启动、属性、关闭和停止事件。2.RequestHandlerEvent：此是一个与Web应用相关的事件，当一个HTTP请求被处理后，产生该事件。</p>
<p><strong>1.2 事件监听接口</strong><br><br>Spring的事件监听器继承自 ApplicationListener 。ApplicationListener接口只定义一个方法：onApplicationEvent(E event)，该方法接收 ApplicationEvent 事件对象，对应响应处理逻辑。</p>
<p><strong>1.3 事件广播</strong><br><br>当发生容器事件时，容器主控程序将调用事件广播器将事件通知给事件监听器注册表中的事件监听器，事件监听器分别对事件作出响应。</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 错误总结</title>
    <url>/undefined/SpringBoot%20-%20%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h5 id="1-错误：java-lang-UnsatisfiedLinkError-F-Software-Apache-Tomcat-apache-tomcat-7-0-90-bin-tcnative-1-dll-Can’t-load-AMD-64-bit-dll-on-a-IA-32-bit-platform"><a href="#1-错误：java-lang-UnsatisfiedLinkError-F-Software-Apache-Tomcat-apache-tomcat-7-0-90-bin-tcnative-1-dll-Can’t-load-AMD-64-bit-dll-on-a-IA-32-bit-platform" class="headerlink" title="1.错误：java.lang.UnsatisfiedLinkError: F:\Software\Apache-Tomcat\apache-tomcat-7.0.90\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform"></a>1.错误：java.lang.UnsatisfiedLinkError: F:\Software\Apache-Tomcat\apache-tomcat-7.0.90\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform</h5><p>解决：直接在网上下载一个 tcnative-1.dll 64位的复制到tomcat/bin目录下即可，这里是因为两者冲突造成。</p>
<h5 id="2-错误：Failed-to-configure-a-DataSource-‘url’-attribute-is-not-specified-and-no-embedded-datasource-could-be-configured"><a href="#2-错误：Failed-to-configure-a-DataSource-‘url’-attribute-is-not-specified-and-no-embedded-datasource-could-be-configured" class="headerlink" title="2.错误：Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured."></a>2.错误：Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</h5><p>解决：排除此类的autoconfig。启动以后就可以正常运行。@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})</p>
<p>…</p>
<h5 id="3-错误：Field-userMapper-in-com-shop-service-impl-UserServiceImpl-required-a-bean-of-type-‘com-shop-mapper-UserMapper’-that-could-not-be-found"><a href="#3-错误：Field-userMapper-in-com-shop-service-impl-UserServiceImpl-required-a-bean-of-type-‘com-shop-mapper-UserMapper’-that-could-not-be-found" class="headerlink" title="3.错误：Field userMapper in com.shop.service.impl.UserServiceImpl required a bean of type ‘com.shop.mapper.UserMapper’ that could not be found."></a>3.错误：Field userMapper in com.shop.service.impl.UserServiceImpl required a bean of type ‘com.shop.mapper.UserMapper’ that could not be found.</h5><p>解决：这里是因为注解未找到对一个的mapper，所以报错，去inspections取消对应的提示。</p>
<h5 id="4-新创建SQLSessionFactory"><a href="#4-新创建SQLSessionFactory" class="headerlink" title="4.新创建SQLSessionFactory"></a>4.新创建SQLSessionFactory</h5><pre><code>@Resource
private DataSource dataSource;

@Bean
public SqlSessionFactory sqlSessionFactory() throws Exception {
    SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
    sessionFactoryBean.setDataSource(dataSource);
    return sessionFactoryBean.getObject();
}
</code></pre><h4 id="SLF4J-Class-path-contains-multiple-SLF4J-bindings"><a href="#SLF4J-Class-path-contains-multiple-SLF4J-bindings" class="headerlink" title="SLF4J: Class path contains multiple SLF4J bindings."></a>SLF4J: Class path contains multiple SLF4J bindings.</h4><p>解决：表示maven棒我们引入了两个日志jar包，删掉其中一个便可。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/undefined/Spring/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Spring-FD"><a href="#Spring-FD" class="headerlink" title="Spring - FD"></a>Spring - FD</h1><p>Spring提供一种方法管理你的业务对象，主要有两个功能为我们的业务对象管理提供便捷</p>
<h4 id="Spring整合Web项目的底层原理"><a href="#Spring整合Web项目的底层原理" class="headerlink" title="Spring整合Web项目的底层原理"></a>Spring整合Web项目的底层原理</h4><p>这一过程表示在加载配置文件和创建对象过程，在服务器启动时完成。</p>
<pre><code>1.在服务器启动的时候，为每个项目创建一个ServletContext对象。
2.在ServletContext对象创建时，使用监听器可以具体到ServletContext对象在什么时候创建。
3.在使用监听器监听ServletContext对象创建时。
    4.加载spring配置文件，将配置文件对象创建。
    5.将创建出来的对象放到ServletContext域对象里(setAttribute方法)。
    6.获取对象的时候，到ServletContext域得到(getAttribute方法)。
</code></pre><ul>
<li>1.DI 依赖注入</li>
<li>2.AOP 面向切面编程</li>
</ul>
<h4 id="1-Java-Bean"><a href="#1-Java-Bean" class="headerlink" title="1.Java Bean"></a>1.Java Bean</h4><p>每一个实现Bean的规范才可以由Spring来接管，而Bean的规范是：</p>
<pre><code>1.必须是个公有类
2.有无参构造函数 
3.用公有方法暴露内部成员属性(setter/getter) 实现了这样的规范的类才叫做JavaBean(一种可重用组件)
</code></pre><h4 id="2-DI-依赖注入"><a href="#2-DI-依赖注入" class="headerlink" title="2.DI-依赖注入"></a>2.DI-依赖注入</h4><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p>
<h4 id="3-AOP-面向切面对象"><a href="#3-AOP-面向切面对象" class="headerlink" title="3.AOP-面向切面对象"></a>3.AOP-面向切面对象</h4><p>在执行某个操作前后需要输出日志，但是如果是手工加代码会非常吃力，维护也非常艰难，所以这就需要面向切面编程</p>
<hr>
<h2 id="Spring框架的主要内容"><a href="#Spring框架的主要内容" class="headerlink" title="Spring框架的主要内容"></a>Spring框架的主要内容</h2><h4 id="1-Spring框架运行环境"><a href="#1-Spring框架运行环境" class="headerlink" title="1.Spring框架运行环境"></a>1.Spring框架运行环境</h4><blockquote>
<p>核心容器(IOC)：Bean(Bean工厂/创建对象)、Core(一切的基础)、Context(上下文)、SpEL(Spring的表达式语言)</p>
</blockquote>
<blockquote>
<p>AOP：AOP、Aspects</p>
</blockquote>
<blockquote>
<p>数据访问的支持:JDBC、ORM、Transaction、JMS(Java邮件服务)</p>
</blockquote>
<blockquote>
<p>Web的支持：Spring MVC</p>
</blockquote>
<hr>
<h4 id="2-Ioc-Inversion-of-control-控制反转"><a href="#2-Ioc-Inversion-of-control-控制反转" class="headerlink" title="2.Ioc(Inversion of control)控制反转"></a>2.Ioc(Inversion of control)控制反转</h4><p>这是一种设计思想，在Java开发中，Ioc意味着将你设计好的对象交给容器控制管理，不像传统的在对象内部直接控制。</p>
<p>解释：在传统的Java程序设计中，在对象内部通过new进行创建对象，是程序主动去创建依赖对象，Ioc专门有一个容器来创建这些对象，即由Ioc容器来控制对象的创建。Ioc容器控制了对象，主要控制了外部资源的获取。</p>
<hr>
<h4 id="3-DI-Dependency-Injection-依赖注入"><a href="#3-DI-Dependency-Injection-依赖注入" class="headerlink" title="3.DI(Dependency Injection)依赖注入"></a>3.DI(Dependency Injection)依赖注入</h4><p>组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>解释：应用程序依赖于Ioc容器。应用程序需要Ioc容器来提供对象需要的外部资源。Ioc容器注入应用程序某个对象，应用程序依赖的对象。注入某个对象所需要的外部资源(对象、资源、常量数据)。</p>
<blockquote>
<p>提示：一般项目开发的模块</p>
</blockquote>
<pre><code>注意：
    DAO层、Service层、Controller层和View层详解
    1.DAO层
      主要做数据持久层的工作，负责与数据库进行联络的一些任务封装在此。
        1)设计DAO层的接口
        2)在Spring配置文件中定义此接口的实现类
        3)在模块中调用此接口来进行数据业务的处理，不需要关心此接口的具体实现类是哪个类
        注意：DAO层的数据源配置以及有关数据库连接的参数都在Spring的配置文件中进行配置

    2.Service层
      此层主要负责业务模块的逻辑应用设计
        1)首先设计接口，再设计其实现类，最后再在配置文件中配置其实现的关联，从而在应用中调用service接口来进行业务处理。
        2)service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用业务逻辑的独立性和重复利用性。

    3.Controller层
      此层负责具体的业务模块流程的控制，在此层要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行

    4.View层
      View层与控制层结合比较紧密，View层主要负责网页前台的JSP页面的表示
</code></pre><blockquote>
<p>1.首先给出Ioc(控制反转)思想程序：</p>
</blockquote>
<pre><code>1.定义DAO接口UserDao
2.定义DAO接口实现类UserDaoMysqlImpl和UserDaoOracleImpl
3.定义Service层接口UserService，实现具体的业务
4.定义Service接口的实现类UserServiceImpl,Service层的业务实现，具体要调用到已定义的Dao层的接口
</code></pre><blockquote>
<blockquote>
<p>注意：控制反转(Ioc)的设计思想，我们不需要应用程序本身来创建对象，而是将创建对象的任务交付给Ioc容器</p>
</blockquote>
</blockquote>
<hr>
<h1 id="Spring-SD"><a href="#Spring-SD" class="headerlink" title="Spring - SD"></a>Spring - SD</h1><h2 id="Spring的bean管理-xml方式"><a href="#Spring的bean管理-xml方式" class="headerlink" title="Spring的bean管理(xml方式)"></a>Spring的bean管理(xml方式)</h2><pre><code>对象创建的细节：
  1.对象创建的时间
   1)scope=&quot;prototype&quot;(默认值) 在用到对象时才创建 (多例 action对象)
   2)scope=&quot;singleton&quot; 在启动(容器初始化之前)就已经创建了对象，整个web应用只有一个单例(dao/service/工具类)
  2.是否延迟创建
   1)lazy-init=&quot;false&quot;(默认值) 不延迟创建，即在启动时就创建
   2)lazy-init=&quot;true&quot; 延迟初始化，在用到对象的时候才创建
</code></pre><h2 id="Bean实例化的方式"><a href="#Bean实例化的方式" class="headerlink" title="Bean实例化的方式"></a>Bean实例化的方式</h2><pre><code>1.在Spring里面通过配置文件创建对象

2.Bean实例化三种方式实现(创建对象的几种方式)

  1)使用类的无参数构造创建(重点)
    &lt;bean id=&quot;user&quot; class=&quot;cn.itcase.ioc.User&quot;&gt;&lt;/bean&gt;
    注意：如果类里面没有无参数构造，会出现异常，所以一般要在类里面有有参构造的前提下重写无参构造方法

  2)带参构造创建
    &lt;bean id=&quot;user2&quot; class=&quot;cn.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; type=&quot;int&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;Jack&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

  3)使用静态工厂创建
    创建静态方法，返回类对象
    &lt;!-- # 3.2 工厂类： 静态方法 --&gt;
    &lt;!-- 
        class 指定的就是工厂类型
        factory-method  一定是工厂里面的“静态方法”
     --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;cn.ObjectFactory&quot; factory-method=&quot;getStaticInstance&quot;&gt;&lt;/bean&gt;

  4)使用实例工厂创建
    创建不是静态的方法，返回类对象
        &lt;!-- 3. 工厂类创建对象 --&gt;
    &lt;!-- # 3.1 工厂类，实例方法 --&gt;
    &lt;!-- 先创建工厂 --&gt;
    &lt;bean id=&quot;factory&quot; class=&quot;cn.ObjectFactory&quot;&gt;&lt;/bean&gt;
    &lt;!-- 在创建user对象，用factory方的实例方法 --&gt;
    &lt;bean id=&quot;user4&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;
</code></pre><blockquote>
<p>注意：</p>
</blockquote>
<pre><code>Spring管理Bean

Spring容器通常理解为BeanFactory或者ApplicationContext 

在Spring的Ioc容器能够帮助我们创建对象，对象交给Spring管理之后我们不用手动去new对象
</code></pre><hr>
<h2 id="对象依赖关系"><a href="#对象依赖关系" class="headerlink" title="对象依赖关系"></a>对象依赖关系</h2><pre><code>Spring常用的几种注入方式：
    1.通过构造器

    2.通过set方法给属性注入值(最常用)
</code></pre><hr>
<h2 id="Servlet监听器"><a href="#Servlet监听器" class="headerlink" title="Servlet监听器"></a>Servlet监听器</h2><p>定义：监听器就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p>
<p>在Servlet规范中定义了多种类型的监听器，它们用于监听的事件源分别为 ServletContext, HttpSession 和 ServletRequest 这三个域对象。</p>
<pre><code>1.监听ServletContext域对象的创建和销毁
  ServletContextListener接口用于监听ServletContext对象的创建与销毁事件
      创建：服务器启动针对每一个web应用创建servletcontext
    销毁：服务器关闭前先关闭代表每一个web应用的servletContext

2.编写Servlet监听器
  1.实现一个特定的接口，并且针对相应的动作覆盖接口中相应的方法
  2.servlet监听器注册是由web容器负责，我们只需要在web.xml文件中使用&lt;listener&gt;标签配置好监听器，web容器就会自动将监听器注册到事件源中
  3.一个web.xml文件中可以配置多个servlet事件监听器，web服务器按照它们的web.xml文件中的注册顺序来加载和注册这些servlet监听器

3.监听HttpSession域对象创建与销毁
  HttpSessionListener接口用于监听HttpSession的创建和销毁
    创建：调用sessionCreated(HttpSessionEvent se)方法
    销毁：sessionDestroyed (HttpSessionEvent se)方法

4.监听HttpRequest域对象创建与销毁

    创建：用户的每一次访问都会创建一个request
    销毁：当前访问结束，request对象就会销毁
</code></pre><blockquote>
<p>注意：session域对象在每一次访问时被创建，而如果用户的session在30分钟内没有使用，服务器就会销毁session，在web.xml中也可以配置session的失效时间</p>
</blockquote>
<hr>
<h2 id="Spring注解注入详解"><a href="#Spring注解注入详解" class="headerlink" title="Spring注解注入详解"></a>Spring注解注入详解</h2><h4 id="1-Resource注解"><a href="#1-Resource注解" class="headerlink" title="1.@Resource注解"></a>1.@Resource注解</h4><p>这一注解是JSR-250标准注解，推荐使用其代替Spring专有的@Autowired注解，@Resource的作用相当于@Autowired，只不过@Autowired按 byType 自动注入，而@Resource默认按 byName 自动注入罢了。</p>
<p>@Resource有两个比较重要的属性，分别是name与type，Spring注解的name属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType<br>自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</p>
<h4 id="2-Component注解"><a href="#2-Component注解" class="headerlink" title="2.@Component注解"></a>2.@Component注解</h4><p>在对应的类上加上一个@Component注解就定义该类是Bean </p>
<h4 id="3-Scope注解"><a href="#3-Scope注解" class="headerlink" title="3.@Scope注解"></a>3.@Scope注解</h4><p>在使用XML定义bean的时候，有些时候需要通过bean的scope属性来定义一个bean的作用范围</p>
<hr>
<h2 id="Spring-Ioc快速入门"><a href="#Spring-Ioc快速入门" class="headerlink" title="Spring Ioc快速入门"></a>Spring Ioc快速入门</h2><p>  1.下载Spring的开发包</p>
<p>  2.了解Spring的目录结构 1)docs：Spring的开发文档 2)libs：Spring的开发包 3)schema：约束文档</p>
<p>  3.创建一个项目引入jar包</p>
<p>  4.引入Spring的配置文件</p>
<p>  5.编写测试类</p>
<blockquote>
<p>IOC：控制反转，将Bean创建反转给Spring容器</p>
</blockquote>
<blockquote>
<p>DI：依赖注入，在Spring创建这个类的过程中，将这个类的依赖的属性注入，设置属性值</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：两者之间的关系：依赖注入不能单独存在，需要在Ioc的基础上完成操作</p>
</blockquote>
</blockquote>
<h4 id="1-IOC底层原理"><a href="#1-IOC底层原理" class="headerlink" title="1.IOC底层原理"></a>1.IOC底层原理</h4><pre><code>1.创建xml配置文件，配置要创建的对象类

    &lt;bean id = &quot;userService&quot; class = &quot;cn.xidian.edu.*&quot;/&gt;

2.创建工厂类，使用dom4j解析配置文件和反射

    //返回UserService对象的方法
    public static UserService getService(){
        // 1.使用dom4j解析xml文件
        // 然后根据id值userService得到id值对应的class属性值
        String classValue = &quot;class属性值&quot;;
        // 2.使用反射创建类对象
        Class clazz = Class.forName(classValue);
        // 创建类对象
        UserService userService = clazz.newInstance();
        return service;
    }
</code></pre><h4 id="Spring的工厂类"><a href="#Spring的工厂类" class="headerlink" title="Spring的工厂类"></a>Spring的工厂类</h4><p><strong>1.ApplicationContext</strong></p>
<ul>
<li>ClassPathXmlApplicationContext：解析类路径下的XML</li>
<li>FileSystemXmlApplicationContext：解析本地磁盘上的XML</li>
</ul>
<blockquote>
<p>注意：BeanFactory和ApplicationContext都是Spring中的工厂，BeanFactory是Spring的老版的工厂类(第一次调用getBean方法的时候实例化类)。ApplicationContext是Spring的新版本的工厂类(在加载核心配置文件的时候，将所有的类实例化)</p>
</blockquote>
<h4 id="Spring的Bean管理-基于XML方式"><a href="#Spring的Bean管理-基于XML方式" class="headerlink" title="Spring的Bean管理(基于XML方式)"></a>Spring的Bean管理(基于XML方式)</h4><p><strong>1.Spring实例化Bean方式</strong></p>
<p><strong>1.1 无参构造方式(最常用)</strong><br></p>
<pre><code>&lt;!-- 无参数构造方法方式 --&gt;
//引入Spring的配置文件(1.引入约束 2.编写标签)
&lt;bean id=&quot;bean1&quot; class=&quot;cn.augmentum.spring.demo3.Bean1&quot;&gt;&lt;/bean&gt;
//编写测试类
public void demo1() {
    // 加载核心配置文件:
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
            &quot;applicationContext.xml&quot;);
    Bean1 bean1 = (Bean1) applicationContext.getBean(&quot;bean1&quot;);//getBean()是用来获取applicationContext.xml文件里bean的
    System.out.println(bean1);
}
</code></pre><p><strong>1.2 静态工厂实例化方式</strong><br></p>
<p>   public class Bean2Factory {<br>      public static Bean2 getBean2(){<br>          return new Bean2();<br>     }<br>   }</p>
<pre><code>配置文件:

&lt;!-- 静态工厂实例化方式 --&gt;
&lt;bean id=&quot;bean2&quot; class=&quot;cn.augmentum.spring.demo3.Bean2Factory&quot; factory-method=&quot;getBean2&quot;/&gt;

  代码:

    public void demo2() {
        // 加载核心配置文件:
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                &quot;applicationContext.xml&quot;);
        Bean2 bean2 = (Bean2) applicationContext.getBean(&quot;bean2&quot;);
        System.out.println(bean2);
    }


  实例工厂:
  public class Bean3Factory {

     public Bean3 getBean3(){
        System.out.println(&quot;实例工厂执行了...&quot;);
        return new Bean3();
     }
  }

  配置文件:
    &lt;!-- 实例工厂实例化方式 --&gt;
    &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.spring.demo3.Bean3Factory&quot;/&gt;
    &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;/&gt;

  代码:

    public void demo3() {
        // 加载核心配置文件:
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                &quot;applicationContext.xml&quot;);
        Bean3 bean3 = (Bean3) applicationContext.getBean(&quot;bean3&quot;);
        System.out.println(bean3);
    }
</code></pre><hr>
<h2 id="Spring的Bean的常用配置"><a href="#Spring的Bean的常用配置" class="headerlink" title="Spring的Bean的常用配置"></a>Spring的Bean的常用配置</h2><h4 id="1-标签的id和name属性"><a href="#1-标签的id和name属性" class="headerlink" title="1.标签的id和name属性"></a>1.<bean>标签的id和name属性</bean></h4><pre><code>id与name的区别：
  id：使用xml约束中id约束，不可以出现特殊字符
  name：出现特殊字符，如果使用name没有id，那么name可以作为id使用
</code></pre><h4 id="2-上生命周期的配置"><a href="#2-上生命周期的配置" class="headerlink" title="2.上生命周期的配置"></a>2.<bean>上生命周期的配置</bean></h4><pre><code>@Test
    /**
     * Bean的生命周期的相关配置:
     *     * init-method
     *     * destory-method :只能针对单例对象有效.必须在工厂关闭之后才会销毁对象.
     */
    public void demo1(){
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        EmployeeService employeeService = (EmployeeService) applicationContext
                .getBean(&quot;employeeService&quot;);
        employeeService.save();
        applicationContext.close();
    }
</code></pre><h4 id="3-上的作用范围的配置"><a href="#3-上的作用范围的配置" class="headerlink" title="3.上的作用范围的配置:"></a>3.<bean>上的作用范围的配置:</bean></h4><pre><code>scope属性:

 - singleton :单例的(默认)
 - prototype :多例的
 - request :WEB项目中,创建一个对象,保存到request域中
 - session :WEB项目中,创建一个对象,保存到session域中
 - globalsession :WEB项目中,特殊环境.分布式开发环境.如果没有分布式环境,相当于session
</code></pre><h4 id="4-Bean的生命周期"><a href="#4-Bean的生命周期" class="headerlink" title="4.Bean的生命周期"></a>4.Bean的生命周期</h4><hr>
<h2 id="Spring属性注入"><a href="#Spring属性注入" class="headerlink" title="Spring属性注入"></a>Spring属性注入</h2><p>属性注入：创建对象的时候，向类里面属性设置值，这一过程就是属性注入</p>
<pre><code> 1.有参构造方法的属性注入
    &lt;bean id=&quot;car&quot; class=&quot;cn.augmentum.spring.demo6.Car&quot;&gt;//创建类，然后在类中添加属性值
　　   &lt;constructor-arg name=&quot;name&quot; value=&quot;宝马&quot;/&gt;
　     &lt;constructor-arg name=&quot;price&quot; value=&quot;1000000&quot;/&gt;
    &lt;/bean&gt;

    //第一种 有参构造注入属性值(一般情况下的属性赋值方式)
    public class User{
        private String name;
        public User(String name){
            this.name=name;
        }
    }
    User user=new User(&quot;lucy&quot;);

 2.set方法的属性注入

   &lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot;&gt;//1.创建car2对象
　    &lt;property name=&quot;name&quot; value=&quot;奇瑞QQ&quot;/&gt;//2.属性注入(对象中属性的值的设定) name属性值：类里面定义的属性名称 value属性：设置具体的值
　　  &lt;property name=&quot;price&quot; value=&quot;30000&quot;/&gt;
   &lt;/bean&gt;  

    //第二种 使用set方法注入属性值(在一般情况下使用的属性赋值方式)
     public class User{
        private String name;
        public void setName(String name){
            this.name=name;
        }
    }
    User user=new User();
    user.setName(&quot;张三&quot;);

 //第三种 使用接口方式注入
 public interface Dao{
     public void delete(String name);
    }

 public class DaoImpl implements Dao{
    private String name;
    public void delete(String name){
        this.name=name;
        }
    }

注意：在spring框架中只支持前面两种方式
      1)set方法注入(重点)
      2)有参数构造注入

 3.Spring的2.5支持p名称空间注入

   p名称空间语法

    普通属性：p:name=&quot;&quot;
    对象类型属性：p:name-ref=&quot;&quot;

 4.p名称空间的使用

   1.引入p名称空间

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   2.p名称空间的注入

&lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot; p:name=&quot;长安奔奔&quot; p:price=&quot;25000&quot;/&gt;
&lt;bean id=&quot;employee&quot; class=&quot;cn.augmentum.spring.demo6.Employee&quot; p:name=&quot;马凤&quot; p:car2-ref=&quot;car2&quot;/&gt;  ref：表示引用其他bean对象    

 5.Spring3.0的SpEL的属性注入
   SpEL语法：#{SpEL}

1.属性配置
 &lt;bean id=&quot;carInfo&quot; class=&quot;cn.augmentum.spring.demo6.CarInfo&quot;&gt;
 &lt;/bean&gt;

2.属性注入
 &lt;!-- SpEL的方式的属性注入 --&gt;
&lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot;&gt;
　　&lt;property name=&quot;name&quot; value=&quot;#{carInfo.carName}&quot;/&gt;
　　&lt;property name=&quot;price&quot; value=&quot;#{carInfo.calculatorPrice()}&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;employee&quot; class=&quot;cn.augmentum.spring.demo6.Employee&quot;&gt;
　 &lt;property name=&quot;name&quot; value=&quot;涛哥&quot;/&gt;
　 &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt;
&lt;/bean&gt;

 6.Spring中数组或集合的复杂类型属性注入(在创建好类之后便要创建类的对象，此时创建对象的操作交给Spring容器，然后注入对象的属性值)

   1.注入复杂属性值，首先创建类型对象
    &lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt;
        //2.然后在创建的对象中注入属性值
        &lt;property name=&quot;arrs&quot;&gt;//加入的属性名称
　　            &lt;list&gt;
　　　　            &lt;value&gt;老马&lt;/value&gt;
　　　　            &lt;value&gt;马凤&lt;/value&gt;
　 　　             &lt;value&gt;马如花&lt;/value&gt;
　　            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;



&lt;!--List集合的属性的注入:--&gt;
&lt;property name=&quot;list&quot;&gt;
　　&lt;list&gt;
　　　　&lt;value&gt;马芙蓉&lt;/value&gt;
　　　　&lt;value&gt;马大帅&lt;/value&gt;
　　　　&lt;value&gt;马大彪&lt;/value&gt;
　　&lt;/list&gt;
&lt;/property&gt;

&lt;!--Set集合的属性的注入:--&gt;
&lt;property name=&quot;set&quot;&gt;
　　&lt;set&gt;
　　　　&lt;value&gt;马云&lt;/value&gt;
　　　　&lt;value&gt;马化腾&lt;/value&gt;
　　　　&lt;value&gt;马大哈&lt;/value&gt;
　　&lt;/set&gt;
&lt;/property&gt;

&lt;!--Map集合的属性的注入:--&gt;
&lt;property name=&quot;map&quot;&gt;
　　&lt;map&gt;
　　　　&lt;entry key=&quot;aaa&quot; value=&quot;刘能&quot;/&gt;
　　　　&lt;entry key=&quot;bbb&quot; value=&quot;赵四&quot;/&gt;
　　　  &lt;entry key=&quot;ccc&quot; value=&quot;王五&quot;/&gt;
　 &lt;/map&gt;
&lt;/property&gt;

&lt;!--Properties的属性的注入:--&gt;
&lt;property name=&quot;properties&quot;&gt;
　　&lt;props&gt;
　　　　&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
　　　　&lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;
　　&lt;/props&gt;
&lt;/property&gt;


 7.Spring中的分配置文件进行开发
   1.加载配置文件时候加载多个配置文件

   2.总配置文件中引入其他配置文件
</code></pre><h4 id="2-注入对象类型属性-重点"><a href="#2-注入对象类型属性-重点" class="headerlink" title="2.注入对象类型属性(重点)"></a>2.注入对象类型属性(重点)</h4><pre><code>1.创建service类和dao类
  1)在service得到dao对象

2.具体实现过程
    1)在service里面将dao作为类型属性
    2)生成dao类型属性的set方法

    public class UserService{
        //1.定义dao类型属性
        private UserDao userDao;
        //2.生成set方法
        public void setUserDao(UserDao userDao){
            this.userDao=userDao;
        }

    }

 3)配置文件中注入关系

    1.配置service和dao对象
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt;&lt;/bean&gt;

    2.注入dao对象 name属性值，service类里面属性名称，现在不要写value属性，因为刚写的是字符串，现在是对象，写ref属性，dao配置bean标签中id值
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
</code></pre><h4 id="3-Bean标签常用属性"><a href="#3-Bean标签常用属性" class="headerlink" title="3.Bean标签常用属性"></a>3.Bean标签常用属性</h4><pre><code>1)id属性：为后面查找类起的名称，id属性值名称任意命名，id属性值不能包含特殊字符，根据id值得到配置对象
2)class属性：创建对象所在的类的全路径
3)name属性：功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊字符
4)scope属性：
  - singleton :单例的(默认) 创建的实例是一个对象
  - prototype :多例的 创建的实例是多个对象
  - request :WEB项目中,创建一个对象,保存到request域中
  - session :WEB项目中,创建一个对象,保存到session域中
  - globalsession :WEB项目中,特殊环境.分布式开发环境.如果没有分布式环境,相当于session
</code></pre><h2 id="Spring整合Web项目原理"><a href="#Spring整合Web项目原理" class="headerlink" title="Spring整合Web项目原理"></a>Spring整合Web项目原理</h2><pre><code>1.加载Spring核心配置文件，根据配置创建对象
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
    //1)new对象,虽然这一过程功能可以实现，但是实现效率很低

2.提高这一过程实现效率的思想：将加载配置文件和创建对象的过程在服务器启动的过程完后

3.上述思想实现原理

    1)ServletContext对象
    2)监听器

    3)具体使用
      - 在服务器启动的使用，会为每个项目创建一个ServletContext对象
      - 在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候被创建
      - 使用监听器监听到ServletContext对象创建的时候
        --加载Spring配置文件，将配置文件配置对象创建
        --将创建出来的对象放到ServletContext域对象里面(setAttribute方法)
      - 获取对象的时候，到ServletContext域之中得到(getAttribute方法)
</code></pre><hr>
<h1 id="Spring-TD"><a href="#Spring-TD" class="headerlink" title="Spring - TD"></a>Spring - TD</h1><h2 id="Spring的Bean管理-注解"><a href="#Spring的Bean管理-注解" class="headerlink" title="Spring的Bean管理(注解)"></a>Spring的Bean管理(注解)</h2><blockquote>
<p>注解(程序里面的图书特殊标记，使用注解可以完成功能 写法：@注解名称(属性名称=属性值)) &gt;&gt;注解可以使用在类上面、方法上面以及属性上面</p>
</blockquote>
<h4 id="1-Spring注解开发准备"><a href="#1-Spring注解开发准备" class="headerlink" title="1.Spring注解开发准备"></a>1.Spring注解开发准备</h4><pre><code>1.导入jar包
 1.导入基本的jar包
 2.导入aop的jar包
2.创建类、创建方法

3.创建Spring配置文件，引入约束
 1.在刚开始做Ioc基本功能的时候，引入的约束是beans
 2.但是在做Spring的Ioc注解开发的时候需要引入新的约束(../spring-context.xsd)

4.开启注解扫描(到包里面扫描类、方法、属性上面是否有注解)
 &lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt;
 //另外一个开启扫描注解配置程序
 &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;//这只会扫描属性上面的注解
</code></pre><h4 id="2-注解创建对象"><a href="#2-注解创建对象" class="headerlink" title="2.注解创建对象"></a>2.注解创建对象</h4><pre><code>1.在创建对象的类上面使用注解实现
    @ Component(value=&quot;user&quot;) // &lt;bean id=&quot;user&quot; class=&quot;&quot;/&gt;
    public class User{
        //...
        }

2.创建对象有四个注解

    下面三个的让标注类的用途清晰，在后续Spring版本中对其增强
    @ Controller ：web层
    @ Service ：业务层
    @ Repository ：持久层
    @ Component 和上面的三个注解等效


3.创建对象单实例还是多实例
    @ Scope(value=&quot;prototype&quot;)
</code></pre><h4 id="3-注解注入属性"><a href="#3-注解注入属性" class="headerlink" title="3.注解注入属性"></a>3.注解注入属性</h4><pre><code>注入属性注解：
    1.@Autowired 
    2.@Resource 

1.@Autowired 
  创建service类，创建dao类，在service类中得到dao对象
  1)使用注解创建dao类与service类的对象
    @Service(value=&quot;userService&quot;)
    public class UserService{
        //...
        }

    @Component(value=&quot;userService&quot;)
    public class UserService{
        //...
        }

  2)得到dao对象(在service类里面定义dao类型属性)
    - 1.定义dao类型属性，在dao属性上面使用注解完成对象注入
    @Autowired(自动装配)
    private UserDao userDao;
    //使用注解方式的时候不需要使用set方法注入属性值

2.@Resource 
  name属性值写注解创建dao对象value值
  @Resource(name=&quot;userDao&quot;)
  private UserDao userDao;



配置文件和注解混合使用

  1.创建对象操作使用配置文件方式实现
    &lt;bean id=&quot;bookService&quot; class=&quot;cn.itcast&quot;&gt;&lt;/bean&gt;    
  2.注入属性的操作使用注解方式实现
    //得到类的对象，使用注解的方式
    @Resource(name=&quot;bookDao&quot;)
    private BookDao bookDao;

    @Resource(name=&quot;ordersDao&quot;)
    private OrdersDao ordersDao;


3.多种装配Bean方式的比较

  1.基于xml配置(适用于Bean来自第三方、使用其他命名空间)
    bean定义：&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;
    bean名称：通过id或name指定
    bean属性注入：&lt;property&gt;或者p命名空间
    生命过程/bean作用范围：init-method/destory-method 范围：scope属性

  2.基于注解配置（Bean的实现类由用户自己开发）
    bean定义：
    @Component(@Repository)
    @Service
    @Controller

    bean名称：@Component(&quot;person&quot;)

    bean属性注入：@Autowired 按类型注入
          @Qualifier 按名称注入

    生命过程：

  3.基于Java类配置
    bean注入：在方法内部编写注入代码逻辑
</code></pre><blockquote>
<p>扩展</p>
</blockquote>
<h2 id="log4j介绍"><a href="#log4j介绍" class="headerlink" title="log4j介绍"></a>log4j介绍</h2><p>1.通过log4j可以看到程序运行过程中更详细的信息(加载的配置文件、日志文件)</p>
<pre><code>log4j使用步骤：
1.导入log4j的jar包
2.复制log4j的配置文件，复制到src下面
  log4j.propertises(配置文件)

3.设置日志的级别
  log4j.rootLogger=info,stdout
    1)info：看到基本的信息
    2)debug：看到更详细的信息
</code></pre><hr>
<h2 id="Spring整合Web项目演示"><a href="#Spring整合Web项目演示" class="headerlink" title="Spring整合Web项目演示"></a>Spring整合Web项目演示</h2><pre><code>1.演示问题
1.action调用service，service里面调用dao方式，每次访问action的时候都会加载配置文件
2.解决方案
  1)在服务器启动的时候，创建对象加载配置文件
  2)底层使用监听器、ServletContext对象

3.在Spring里面不需要我们自己写代码实现，框架已经帮我们封装好了
  1)封装了一个监听器，只需要配置好监听器就行了
  2)配置监听器之前需要导入Spring整合web项目的jar包
  3)指定加载配置文件的位置

    指定Spring配置文件的位置
    &lt;context-param&gt;
        &lt;param-name&gt;..&lt;/param-name&gt;
        &lt;param-value&gt;...&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre><hr>
<h2 id="基于aspectj的注解aop"><a href="#基于aspectj的注解aop" class="headerlink" title="基于aspectj的注解aop"></a>基于aspectj的注解aop</h2><h4 id="1-使用注解方式实现aop操作"><a href="#1-使用注解方式实现aop操作" class="headerlink" title="1.使用注解方式实现aop操作"></a>1.使用注解方式实现aop操作</h4><pre><code>1.首先引入aop编程的相关jar包
2.然后在bean.xml文件中引入aop名称空间
3.其次在bean.xml文件中开启aop扫描&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;
4.然后开启aop注解方式，默认是false &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
5.开始写一个切面类
  1.@Component：加入IOC容器 @Aspect：指定当前类为切面类 
  2.在类里面指定切入点表达式，拦截那些方法，即为那些类生成代理对象(@Pointcut(&quot;execution(* com.bie.aop.UserDao.*(..))&quot;))
    注意：在类里面可以开启前置增强(@Before(&quot;pointCut()&quot;)) 开启后置增强(@After(&quot;pointCut()&quot;))
6.在写好切面类之后写执行目标对象方法(接口/接口实现类)以及最后的测试类
</code></pre><blockquote>
<p>注意：如果目标对象是有实现接口，spring会自动选择”jdk代理(动态代理)”动态代理标识：<code>class com.sun.proxy.$Proxy10</code> 如果对象没有实现接口，spring会自动调用”cglib代理”</p>
</blockquote>
<pre><code>1)创建对象
  &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;//创建Book对象，被增强类
  &lt;bean id=&quot;MyBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;//创建增强类MyBook对象
2)在Spring核心配置文件中开启aop操作
  &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt;
3)在增强类上面使用注解方式来完成增强配置
  @Aspect
  public class MyBook{
      //在方法上面使用注解完成增强配置
      @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;)
      public void before(){
          System.out.println(&quot;before.......&quot;);
      }
  }
</code></pre><hr>
<h4 id="2-Spring的jdbcTemplate操作"><a href="#2-Spring的jdbcTemplate操作" class="headerlink" title="2.Spring的jdbcTemplate操作"></a>2.Spring的jdbcTemplate操作</h4><p>  1)Spring框架一站式框架(针对JavaEE的三层，每一层都有解决技术)<br>  2)在DAO层，使用jdbcTemplate</p>
<h4 id="3-Spring对不同的持久化层技术都进行了封装"><a href="#3-Spring对不同的持久化层技术都进行了封装" class="headerlink" title="3.Spring对不同的持久化层技术都进行了封装"></a>3.Spring对不同的持久化层技术都进行了封装</h4><p>  1)jdbcTemplate对jdbc进行封装</p>
<h4 id="4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"><a href="#4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作" class="headerlink" title="4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"></a>4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作</h4><pre><code>添加
  1)导入jdbcTemplate使用的jar包(spring-jdbc-4.2.4.RELEASE.jar spring-tx-4.2.4.RELEASE.jar)
  2)创建对象，设置数据库信息(注意配置数据库的驱动)
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  3)创建jdbcTemplate对象，设置数据源
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  4)调用jdbcTemplate对象里面的方法实现操作
    1.创建sql语句
    String sql=&quot;insert into user values(?,?)&quot;;
    jdbcTemplate.update(sql,&quot;lucy&quot;,&quot;123&quot;);//调用模板中的update方法

修改
  1)设置数据库的信息
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  2)创建jdbcTemplate对象
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  3)调用jdbcTemplate对象里面的update()方法实现操作
  String sql=&quot;update user set password=? where username=?&quot;;//根据用户名修改密码
  int rows=jdbcTemplate.update(sql,&quot;1234&quot;,&quot;lucy&quot;);
  System.out.println(rows);//输出结果为1，修改成功


删除
   1)设置数据库的信息
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  2)创建jdbcTemplate对象
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  3)调用update()方法实现删除
  String sql=&quot;delete from user where username=?&quot;;
  int rows=jdbcTemplate.update(sql,&quot;lucy&quot;);
  System.out.println(rows);


查询
   1.使用jdbcTemplate实现查询操作

   2.查询的具体操作
     1)查询返回某一个值(数据库中有多少条记录)
       1.设置数据库信息

       2.创建jdbcTemplate对象

       3.调用方法得到记录数

     String sql=&quot;select count(*) from user&quot;;
       4.调用jdbcTemplate的方法
     int count=jdbcTemplate.queryForObject(sql,Integer.class);

     第一个参数，sql：返回sql语句
     第二个参数，requiredType：返回类型的class


     注意：jdbc底层实现程序
    public class testJDBC(){
    Connection conn=null;
    PreparedStatement psmt=null;
    ResultSet rs=null;
        //1.加载驱动
    try{
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.创建连接
        conn=DriverManager.getConnection(&quot;jdbc:mysql:///spring_day03&quot;,&quot;root&quot;,&quot;root&quot;);
        //3.编写sql语句
        String sql=&quot;select *from user where username=?&quot;;
        //4.预编译sql
        psmt=connt.prepareStatement(sql);
        //5.设置参数值
        psmt.setString(1,&quot;lucy&quot;);
        //6.执行sql
        rs=psmt.executeQuery();
        //7.遍历结果集
        while(rs.next()){
            //得到返回结果集
            String username=rs.getString(&quot;username&quot;);
            String password=rs.getString(&quot;password&quot;);
            //创建一个实体类，将username与password放到实体类中去
            //创建实体类的对象
            User user=new User();
            user.setUsername(username);
            user.setPassword(password);
            //输出user
            System.out.println(user);
        }
    }catch(ClassNotFoundException e){
        e.printStackTrace();
        }finally{
        try{
            rs.close();
            psmt.close();
            conn.close();
        }catch(SQLException e){
            e.printStackTrace();
            }

        }
    }

    2)查询返回对象

    1)在方法里面操作，设置数据库信息
    DriverManagerDataSource dataSource=new DriverManagerDataSource();
      dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
      dataSource.setUsername(&quot;root&quot;);
      dataSource.setPassword(&quot;root&quot;);

      2)创建jdbcTemplate对象
      JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

    3)写sql语句，根据username查询
    String sql=&quot;select *from user where username=?&quot;;

    4)调用jdbcTemplate的方法实现
    jdbcTemplate.queryForObject(String sql,RowMapper&lt;T&gt;rowMapper,Object...args)

    User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),&quot;lucy&quot;)
        第一个参数：sql语句
        第二个参数：RowMapper，接口，类似于dbutils里面的接口，需要自己写类实现接口，自己实现数据封装
        第三个参数：可变参数

    注意：在Java里面可以有多个class，但是只能有一个public

    写RowMapper类

    class MyRowMapper implements RowMapper&lt;User&gt;{
            @Override
            public User mapRow(ResultSet rs,int num) throws SQLException{
                //1.从结果集里面得到数据
                String username=rs.getString(&quot;username&quot;);
                String password=rs.getString(&quot;password&quot;);
                //2.将得到的数据封装到对象里面
                User user = new User();
                user.setUsername(username);
                user.setPassword(password);
                return user;
            }
        }

    5)输出user
    System.out.println(user);


     3)查询返回list集合

    query(String sql,RowMapper&lt;T&gt; rowMapper,Object...args):List&lt;T&gt;
       1)sql语句
       2)RowMapper接口，自己写类实现数据封装
       3)可变参数

       1)设置数据库信息
    DriverManagerDataSource dataSource=new DriverManagerDataSource();
      dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
      dataSource.setUsername(&quot;root&quot;);
      dataSource.setPassword(&quot;root&quot;);

      2)创建jdbcTemplate对象
      JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

    3)写sql语句
    String sql = &quot;select * from user&quot;;

    4)调用jdbcTemplate的方法实现
    List&lt;User&gt; list=jdbcTemplate.query(sql,new MyRowMapper());
    System.out.println(list);

    //MyRowMapper()实现与上面的一样
</code></pre><blockquote>
<p>注意：增、删、修都是使用update()方法，而查询使用的query()方法</p>
</blockquote>
<hr>
<h2 id="Spring配置连接池和dao使用jdbcTemplate"><a href="#Spring配置连接池和dao使用jdbcTemplate" class="headerlink" title="Spring配置连接池和dao使用jdbcTemplate"></a>Spring配置连接池和dao使用jdbcTemplate</h2><pre><code>1.Spring配置连接池(c3p0)
  1)导入jar包(c3p0连接池jar包c3p0-0.0.2.1.jar   mchange-commons-java-0.2.3.4.jar)

  2)创建Spring配置文件，配置连接池
1)将程序在配置文件中进行配置

&lt;!--配置c3p0连接池--&gt;
//创建连接池对象
&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3po.ComboPooledDataSource&quot;&gt;
     &lt;!--注入属性值--&gt;
     &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day03&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;


  注意：设置c3p0连接池的信息(原始方式)
    ComboPooledDataSource dataSource=new ComboPooledDataSource();
    dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUrl(&quot;jdbc:mysql:///spring_day03&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;root&quot;);


2.dao使用jdbcTemplate

1)创建Service和dao对象，在service里面注入dao对象
&lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt;&lt;/bean&gt;
     &lt;!--注入dao对象--&gt;
     &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;

2)创建jdbcTemplate对象，将模板对象注入到dao里面
//得到JdbcTemplate对象
private JdbcTemplate jdbcTemplate;
public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
    this.jdbcTemplate=jdbcTemplate;
}
&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt;
     &lt;!--注入jdbcTemplate对象--&gt;
     &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

3)在jdbcTemplate对象里面注入dataSource
private DataSource dataSource;
private SQLExceptionTranslator exceptionTranslator;
private boolean lazyInit=true;

public void setDataSource(DataSource dataSource){
    this.dataSource=dataSource;
}

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;!--将dataSource传递到模板对象里面--&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>案例：Service调用DAO，然后DAO调用jdbcTemplate，最后jdbcTemplate调用dataSource</p>
</blockquote>
<pre><code>UserService.java

public class UserServie{
    private UserDao userDao;
    public void setUserDao(UserDao userDao){
        this.userDao=userDao;
        }
    public void add(){
        userDao.add();
        }
    }

UserDao.java

public class UserDao{
    //得到JdbcTemplate对象
    private JdbcTemplate jdbcTemplate;
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate=jdbcTemplate;
        }
    //添加操作
    public void add(){
        //创建jdbcTemplate对象
        //JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
        String sql=&quot;insert into user values(?,?)&quot;;
        jdbcTemplate.update(sql,&quot;李磊&quot;,&quot;123&quot;);
        }
    }
</code></pre><p>测试类：</p>
<blockquote>
<p>扩展</p>
<blockquote>
<p>Spring JDBCTemplate 方法详解</p>
</blockquote>
</blockquote>
<pre><code>1.JDBCTemplate 主要提供以下五类方法：
    1.execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句。

    2.update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句。batchUpdate方法用于执行批处理相关语句。

    3.query方法及queryForXXX方法：用于执行查询相关语句。

    4.call方法：用于执行存储过程、函数相关语句。

2.JDBCTemplate 类支持的回调类

    1.预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句

        1.PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement

        2.CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement

    2.预编译语句设置回调：用于给预编译语句相应参数设值

        1.PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值

        2.BatchPreparedStatementSetter：；类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小

    3.自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作

        1.ConnectionCallback：通过回调获取JdbcTemplate提供的Connection，用户可在该Connection执行任何数量的操作

        2.StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作

        3.PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作

        4.CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作

    4.结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式

        1.RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。

        2.RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSetrs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。

        3.ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集。

3.使用方法
</code></pre><blockquote>
<p>1.预编译语句以及存储过程创建回调、自定义功能回调使用</p>
</blockquote>
<p>首先使用<code>PreparedStatementCreator</code>创建一个预编译语句，其次由<code>JdbcTemplate</code>通过<code>PreparedStatementCallback</code>回调传回，由用户决定如何执行该<code>PreparedStatement</code>。此处我们使用的是<code>execute</code>方法。</p>
<blockquote>
<p>2.预编译语句设值回调使用</p>
</blockquote>
<p>通过<code>JdbcTemplate</code>的<code>int update(String sql, PreparedStatementSetterpss)</code> 执行预编译<code>sql</code>，其中<code>sql</code>参数为<code>insert into test(name) values (?)</code>，该<code>sql</code> 有一个占位符需要在执行前设值。<code>PreparedStatementSetter</code> 实现就是为了设值，使用 <code>setValues(PreparedStatementpstmt)</code>回调方法设值相应的占位符位置的值。 <code>JdbcTemplate</code>也提供一种更简单的方式<code>update(String sql, Object... args)</code>来实现设值，所以只要当使用该种方式不满足需求时才应使用<code>PreparedStatementSetter</code>。</p>
<blockquote>
<p>结果集处理回调</p>
</blockquote>
<p><code>RowMapper</code>接口提供<code>mapRow(ResultSet rs, int rowNum)</code>方法将结果集的每一行转换为一个<code>Map</code>，当然可以转换为其他类，如表的对象画形式。</p>
<p><code>RowCallbackHandler</code>接口也提供方法<code>processRow(ResultSet rs)</code>，能将结果集的行转换为需要的形式。</p>
<p><code>ResultSetExtractor</code>使用回调方法<code>extractData(ResultSet rs)</code>提供给用户整个结果集，让用户决定如何处理该结果集。</p>
<blockquote>
<p>注意：我们可以使用JdbcTemplate提供更简单的queryForXXX方法，来简化开发。</p>
</blockquote>
<pre><code>//1.查询一行数据并返回int型结果  
jdbcTemplate.queryForInt(&quot;select count(*) from test&quot;);  

//2. 查询一行数据并将该行数据转换为Map返回  
jdbcTemplate.queryForMap(&quot;select * from test where name=&apos;name5&apos;&quot;);  

//3.查询一行任何类型的数据，最后一个参数指定返回结果类型  
jdbcTemplate.queryForObject(&quot;select count(*) from test&quot;, Integer.class);  

//4.查询一批数据，默认将每行数据转换为Map       
jdbcTemplate.queryForList(&quot;select * from test&quot;);  

//5.只查询一列数据列表，列类型是String类型，列名字是name  
jdbcTemplate.queryForList(&quot;select name from test where name=?&quot;, new Object[]{&quot;name5&quot;}, String.class);  

//6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上  
SqlRowSet rs = jdbcTemplate.queryForRowSet(&quot;select * from test&quot;);  
</code></pre><blockquote>
<p>总结：JDBCTemplate 提供很多方法，这其中的规律便是：第一种提供回调接口让用户决定做什么。第二种是比较简单方法(如：queryForXxx)，用于比较简单的操作。</p>
</blockquote>
<hr>
<pre><code>4.JDBCTemplate 的基本使用步骤

    1.JDBC模板依赖连接池来获取数据的连接，所以需要先构建连接池
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);

    2.创建JDBC模板
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //或者使用构造方法
        jdbcTemplate.setDataSource(dataSource);
</code></pre><blockquote>
<p>注意：1.配置JDBCTemplate的三种方式：1.在自定义的DAO实现类注入一个DataSource引用来完成JdbcTemplate的实例化，即从外部注入DataSource到DAO中，然后实例化jdbctemplate，然后将DataSource设置到jdbcTemplate对象中。2…….</p>
</blockquote>
<pre><code>3.sql语句
    //查询的sql语句
    String sql = &quot;select count(*)  from user&quot;;
    Long num = (long) jdbcTemplate.queryForObject(sql, Long.class);
    System.out.println(num);
</code></pre><blockquote>
<p>注意：Spring学习中，在new对象的时候我们应该想到IOC，在使用set方法时应该想到DI，在要切面时应该想到AOP，所以有一引用链：</p>
</blockquote>
<pre><code>1. 我们需要有DataSource，DataSource的属性可以通过注入数据库的一些配置属性添加

2. 我要有JdbcTemplate，而Template依赖与DataSource，我要以ref的方式为我的JdbcTemplate注入引用

3. 有了JdbcTemplate之后，我要有Dao，此时我应该在Dao添加一个JdbcTemplate的成员，然后以ref的方式将JdbcTemplate引入到Dao中

4. 我在Action或者是Servlet中都会调用的是Serivce，所以，我在Serivce中要添加一个Dao作为成员，然后由ref在注入Dao到Service中

DataSource --&gt; JdbcTemplate --&gt; Dao --&gt; Service --&gt; Action/Servlet

&quot;--&gt;&quot;表示将左边的对象注入到右边的对象当中

5.JDBCTemplate 的CRUD方法

    //插入程序用的是update方法，查询用的是query方法。
    //首先定义一个sql语句
    String  sql = &quot;insert into user (username,password) values(?,?)&quot;;
    //然后使用jdbctemplate方法插入数据
    jdbcTemplate.update(sql, user.getUsername(), user.getPassword());
</code></pre><blockquote>
<p>注意：<code>jdbcTemplate.update</code>适用于<code>insert/update/delete</code>操作。<br>其中：第一个参数为执行的sql。 第二个参数为参数数据 第三个参数为参数类型。</p>
</blockquote>
<pre><code>//删除
String sql = &quot;delete from user where username= ?&quot;;
jdbcTemplate.update(sql, &quot;小王&quot;);

//修改
String sql = &quot;update user set username=? where username= ?&quot;;
jdbcTemplate.update(sql,  user.getUsername() + &quot;_new&quot;, user.getUsername());

//查询
//在最开始使用比较基础的持久化工具(DBUtils)时，会针对查询结果给我们提供一些封装的接口和类，但是JdbcTemplate只给我们提供接口，并没有可用的类，所以需要我们自己实现类来进行封装。

//1.查询表的记录数
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
String sql = &quot;select count(*) from user&quot;;
Long row = jdbcTemplate.queryForObject(sql, Long.class);
System.out.println(&quot;查询出来的记录数为：&quot; + row);

//2.查询返回对象
//获得jdbcTemplate对象
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
String sql = &quot;select username, password from user where username = ?&quot;;
// 设定参数
Object[] object = {&quot;mary_new&quot;};
// 进行查询
User user = jdbcTemplate.queryForObject(sql, object,  new UserMapper());
System.out.println(user);
//注意：除此之外还需要实现结构RowMapper来新建一个映射类，且此java类应该与具体的sql语句对应。
...
    public class UserMapper implements RowMapper&lt;User&gt;{
       @Override
       public User mapRow(ResultSet resultSet, int rows) throws SQLException {
           User user = new User();
           user.setUsername(resultSet.getString(1));
           user.setPassword(resultSet.getString(2));

           return user;
       }
       ....

//3.查询并返回list集合
...
    // 获得jdbcTemplate对象
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);

    // sql语句
    String sql = &quot;select * from user&quot;;
    List&lt;User&gt; users = jdbcTemplate.query(sql, new UserMapper());

    for(User u: users) {
      System.out.println(u);
    }
    ...
</code></pre><hr>
<pre><code>6.JdbcTemplate.queryForList()方法中不同的参数：
    1.String sql;//查询用的sql语句
    2.Object[] args;//sql语句中的参数
    3.int[] argTypes;//sql语句中参数的数据类型
    4.Class elementType;//list装载结果的元数据类型
</code></pre><hr>
<blockquote>
<blockquote>
<p>扩展：</p>
</blockquote>
</blockquote>
<pre><code>1.常用注解：
1.@Transactional 事务注解，标注当前类时表示类中所有方法都进行事务处理。
  @Transactional public class TestServiceBean implements TestService {}
注意：1.@Transactional 只能被应用到public方法上,对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.

2.POJO类与VO类
    vo：1.表示viewObject 只负责封装页面传递过来的数据 2.valueObject 页面与页面之间的传递时保存值的对象。

    区别1：1.POJO是持久层所使用的，是用来封装原始数据的，而VO则主要用来在视图层活动，两个JavaBean所使用的范围不同。假如我们从数据库取出来的原始数据，我们可以通过业务层将数据进行封装，再通过VO发到页面上去。

    过程：我们获得的时候，数据是原始数据，然后通过业务层进行判断，将其所对应的参数放到VO里。即POJO里的属性主要是用来给数据库用的，而VO里的属性是纯用户显示的。
    区别2：1.POJO类，是不继承任何类(继承Object类)，不实现任何接口的，只有属性和set/get方法。

    2.VO类，实际返回给用户的视图对象，将某个指定页面&lt;组件&gt;的所有数据封装起来。
      如：用户发出请求(可能是填写表单)，表单的数据在展示层被匹配为VO。

    3.PO类，每个数据基本上都对象数据库中的某个字段，一般需要实现序列化接口，也有些时候继承一些类
</code></pre><hr>
<h2 id="SSH框架整合-Struts2-hibernate-spring4-x"><a href="#SSH框架整合-Struts2-hibernate-spring4-x" class="headerlink" title="SSH框架整合(Struts2 hibernate spring4.x)"></a>SSH框架整合(Struts2 hibernate spring4.x)</h2><pre><code>回顾SSH框架知识点
</code></pre><h4 id="Hibernate框架"><a href="#Hibernate框架" class="headerlink" title="Hibernate框架"></a>Hibernate框架</h4><pre><code>1.Hibernate核心配置文件
  - 如果单纯使用Hibernate框架，核心配置文件名称hibernate.cfg.xml和位置在src下面这是固定的
  - Hibernate和Spring进行整合的时候，hibernate核心配置文件的名称和位置是没有固定要求的


  1)ORM思想(对象关系映射 实体类与数据表之间的映射关系)
</code></pre><h4 id="Struts2框架"><a href="#Struts2框架" class="headerlink" title="Struts2框架"></a>Struts2框架</h4><pre><code>1.Action操作
  1)action创建的三种方式
    继承类 ActionSupport

  2)配置action访问路径
    - 创建struts2.xml配置文件，这个配置文件名和位置固定在src下面

  3)配置访问action的多个方法
    - 使用通配符方式配置

  4)在action获取表单提交数据
    - 获取request对象
      --  使用ServletActionContext类获取
    - 属性封装
    - 模型驱动(重点)
    - 表达式封装

  5)在action操作域对象
    - 使用ServletActionContext获取域对象

  6)配置struts2的过滤器


2.值栈
  1)向值栈放数据
- set方法
- push方法
- 定义变量，生成get方法

  2)从值栈获取数据
- 在JSP中使用struts2标签+ognl获取
- &lt;s:property&gt;
- &lt;s:iterator&gt;


3.拦截器
  1)aop和责任链模式
  2)自定义拦截器
    - 继承MethodFilterInterceptor
    - 重写类里面的方法
    - 配置拦截器和action关联
</code></pre><h4 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h4><pre><code>1.spring核心配置文件
  1)名称和位置没有固定要求
  2)在spring核心配置文件中引入schema约束

2.创建对象
  1)xml配置方式 &lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;/&gt;
  2)注解方式，四个注解

3.注入属性
  1)xml配置方式
  2)注解方式，两个注解

4.使用ServletContext对象和监听器实现
  1)在服务器启动时候，加载spring配置文件，创建连接
  2)配置spring的监听器
  3)指定spring配置文件位置
</code></pre><h2 id="SSH整合的思想"><a href="#SSH整合的思想" class="headerlink" title="SSH整合的思想"></a>SSH整合的思想</h2><pre><code>Web层：struts2框架 调用service层

Service层：Spring框架 调用DAO层

Dao层：Hibernate框架 对数据库进行crud操作
</code></pre><blockquote>
<p>注意：框架的之间的整合往往是两个框架之间的整合</p>
</blockquote>
<pre><code>1.struts2框架与Spring框架的整合
  - 将struts2的action对象创建交给Spring来进行管理
    &lt;bean id=&quot;&quot; class=&quot;&quot; acope=&quot;protype&quot;&gt;

2.Spring框架与Hibernate框架之间的整合
  - 将hibernate核心配置文件里面的数据库配置，直接写在Spring配置文件中

  - 在第一次访问的时候会很慢，是因为在第一次访问的时候要创建sessionFactory对象
    -- 解决方案：将sessionFactory对象创建交给Spring来管理

  - 在服务器启动的时候创建sessionFactory对象
</code></pre><h2 id="整合Struts2与Spring框架"><a href="#整合Struts2与Spring框架" class="headerlink" title="整合Struts2与Spring框架"></a>整合Struts2与Spring框架</h2><pre><code>将Struts2的action交给Spring管理
实现过程
1.导入Struts2的jar包
</code></pre><hr>
<h4 id="SSH框架搭建和整合-struts2-spring4-hibernate5"><a href="#SSH框架搭建和整合-struts2-spring4-hibernate5" class="headerlink" title="SSH框架搭建和整合(struts2/spring4/hibernate5)"></a>SSH框架搭建和整合(struts2/spring4/hibernate5)</h4><pre><code>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层），以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。
</code></pre><blockquote>
<p>总结：<br>    在SSH框架中使用Struts2框架作为系统的整体基础架构，负责MVC的分离。<br>    在Struts框架的模型(model)部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring做支持，支持struts和hibernate。</p>
</blockquote>
<pre><code>具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring做支持，支持struts和hibernate。
其实ssh框架最主要的本质是：“高内聚、低耦合”。
</code></pre><hr>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 配置 Redis</title>
    <url>/undefined/SpringBoot%20%E9%85%8D%E7%BD%AE%20Redis/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在Java中与redis连接的驱动有很多，目前广泛使用的是Jedis，其它的还有Lettuce/Jredis和Srp。Spring提供一种RedisConnectionFactory接口，通过此接口可以生成一个RedisConnection接口对象，而该接口对象是对Redis底层接口的封装。</p>
<h4 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h4><p>RedisTemplate是一个强大的类，首先会自动从RedisConnectionFactory工厂中获取连接，然后执行对应的Redis命令，在最后还会关闭Redis的连接。这些都被RedisTemplate封装，所以不需要关心Redis连接闭合问题。</p>
<p><strong>1.创建RedisTemplate</strong><br><br>使用Java配置文件RedisConfig创建Spring IOC容器，然后从中获取RedisTemplate对象。</p>
<pre><code>@Bean(name=&quot;redisTemplate&quot;)
public RedisTemplate&lt;Object, Object&gt; initRedisTemplate(){

    RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();

    redisTemplate.setConnectionFactory(initConnectionFactory());
    return redisTemplate;
}
</code></pre><p><strong>2.测试</strong><br></p>
<pre><code>public class RedisTest{
    public static void main(String[] args){
        ApplicationContext ctx = new AnnotationConfigApplicationContext(RedisConfig.class);

        RedisTemplate redisTemplate = ctx.getBean(RedisTemplate.class);
        redisTemplate.opsForValue().set(&quot;keyOne&quot;, &quot;valueOne&quot;);
        redisTemplate.opsForHash().put(&quot;hash&quot;, &quot;field&quot;, &quot;hashvalue&quot;);
    }
}
</code></pre><h4 id="在SpringBoot中配置和使用Redis"><a href="#在SpringBoot中配置和使用Redis" class="headerlink" title="在SpringBoot中配置和使用Redis"></a>在SpringBoot中配置和使用Redis</h4><p><strong>1.在SpringBoot中配置Redis</strong><br></p>
<pre><code>#redis属性配置
spring.redis.host=127.0.0.1
## Redis服务器连接端口
spring.redis.port=6379
## 连接超时时间（毫秒）
spring.redis.timeout=3
## Redis服务器连接密码（默认为空）
spring.redis.password=
## 连接池中的最大连接数
spring.redis.poolMaxTotal=10
## 连接池中的最大空闲连接
spring.redis.poolMaxIdle=10
## 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.poolMaxWait=3
</code></pre><blockquote>
<p>提示：在配置连接池和服务器属性之后，SpringBoot的自动装配机制会读取配置生成相关的Redis操作对象。</p>
</blockquote>
<p><strong>2.操作Redis数据类型</strong><br></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 数据校验</title>
    <url>/undefined/SpringMVC%20-%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="SpringMVC-的数据校验"><a href="#SpringMVC-的数据校验" class="headerlink" title="SpringMVC 的数据校验"></a>SpringMVC 的数据校验</h2><p>在SpringMVC中使用Hibernate的校验框架Validation。</p>
<p><strong>1.配置校验器</strong><br><br>这里直接在springmvc.xml配置文件中进行配置。</p>
<pre><code>&lt;!-- 配置校验器 --&gt;
&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;
    &lt;!-- 校验器，使用hibernate校验器 --&gt;
    &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;/&gt;
    &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下面的ValidationMessages.properties文件 --&gt;
    &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 校验错误信息配置文件 --&gt;
&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;
    &lt;!-- 资源文件名 --&gt;
    &lt;property name=&quot;basenames&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:CustomValidationMessage&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- 资源文件编码格式 --&gt;
    &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt;
    &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>注意：配置好校验器之后，需要将校验器注入到处理器适配器中，还是在springmvc.xml文件中，将配置好的validator注入进去。如下配置所示。</p>
</blockquote>
<pre><code>&lt;mvn:annotation-driven conversion-service=&quot;conversionService&quot; validator=&quot;validator&quot;/&gt;
</code></pre><p><strong>2.在entity中添加校验</strong><br></p>
<pre><code>....
</code></pre>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 配置 Shiro</title>
    <url>/undefined/SpringBoot%20%E9%85%8D%E7%BD%AE%20Shiro/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="1-添加Shiro依赖"><a href="#1-添加Shiro依赖" class="headerlink" title="1.添加Shiro依赖"></a>1.添加Shiro依赖</h4><pre><code>&lt;!-- shiro 配置 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="2-自定义Realm"><a href="#2-自定义Realm" class="headerlink" title="2.自定义Realm"></a>2.自定义Realm</h4><pre><code>package com.yyzheng.oa.shiro;

public class MyShiroRealm extends AuthorizingRealm {
    @Autowired
    private RoleService roleService;
    @Autowired
    private PermissionService permissionService;
    @Autowired
    private UserService userService;

    // 角色权限和对应权限添加
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        // 获取登录用户名
        String userName = (String)principalCollection.getPrimaryPrincipal();
        // 查询用户的角色信息
        Set&lt;String&gt; roles = getRolesByUsername(userName);
        // 查询角色的权限信息
        Set&lt;String&gt; permissions = getPermissionsByUserName(userName);
        // 设置用户的角色和权限
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        simpleAuthorizationInfo.setRoles(roles);
        simpleAuthorizationInfo.setStringPermissions(permissions);

        return simpleAuthorizationInfo;
    }

    // 根据用户名字从数据库中获取当前用户的权限数据
    private Set&lt;String&gt; getPermissionsByUserName(String userName) {
        List&lt;String&gt; list = permissionService.queryPermissionNameByUserName(userName);
        if( list != null ){
            Set&lt;String&gt; sets = new HashSet&lt;&gt;(list);
            return sets;
        }else{
            return null;
        }
    }

    // 根据用户名字从数据库中获取当前用户的角色数据
    private Set&lt;String&gt; getRolesByUsername(String userName) {
        List&lt;String&gt; list = roleService.queryRoleNameByUsername(userName);
        if( list != null ){
            Set&lt;String&gt; sets = new HashSet&lt;&gt;(list);
            return sets;
        }else{
            return null;
        }
    }

    // 认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 1.从主体传过来的信息中获取用户名
        String userName = (String)authenticationToken.getPrincipal();
        // 2.通过用户名到数据库获取凭证
        String password = getPasswordByUserName(userName);
        if( password == null ){
            return  null;
        }
        SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(userName,password,&quot;myShiroRealm&quot;);
        return simpleAuthenticationInfo;
    }

    // 通过用户名从数据库中获取当前用户的密码
    private String getPasswordByUserName(String userName) {
        User user = userService.queryUserByUserName(userName);
        if( user != null ){
            return user.getPassword();
        }else{
            return null;
        }
    }
}
</code></pre><h4 id="3-Shiro配置"><a href="#3-Shiro配置" class="headerlink" title="3.Shiro配置"></a>3.Shiro配置</h4><pre><code>@Configuration
public class ShiroConfiguration {

    // 创建自定义 realm
    @Bean
    public MyShiroRealm myShiroRealm() {
        MyShiroRealm myShiroRealm = new MyShiroRealm();
        return myShiroRealm;
    }

    // 创建 SecurityManager 对象
    @Bean
    public DefaultWebSecurityManager securityManager() {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(myShiroRealm());
        return securityManager;
    }

    // Filter工厂，设置对应的过滤条件和跳转条件
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        // 登出
        map.put(&quot;/logout&quot;, &quot;logout&quot;);
        // 对所有用户认证
        map.put(&quot;/**&quot;, &quot;authc&quot;);
        // 对登录跳转接口进行释放
        map.put(&quot;/subLogin&quot;, &quot;anon&quot;);
        map.put(&quot;/err&quot;, &quot;anon&quot;);
        // 登录
        // 注意：这里配置的 /login 是指到 @RequestMapping(value=&quot;/login&quot;)中的 /login
        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);
        // 首页
        shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);
        // 错误页面，认证不通过跳转
        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/err&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);
        return shiroFilterFactoryBean;
    }

    // 加入注解的使用，不加这个，注解不生效
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();
        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);
        return authorizationAttributeSourceAdvisor;
    }
    // 跟上面的注解配置搭配使用，有时候加了上面的配置后注解不生效，需要加入下面的配置
    @Bean
    @ConditionalOnMissingBean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator app = new DefaultAdvisorAutoProxyCreator();
        app.setProxyTargetClass(true);
        return app;
    }

}
</code></pre>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 前台JSON数据交互</title>
    <url>/undefined/SpringMVC%20%E4%B8%8E%E5%89%8D%E5%8F%B0%E7%9A%84JSON%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="SpringMVC-与前台的JSON数据交互"><a href="#SpringMVC-与前台的JSON数据交互" class="headerlink" title="SpringMVC 与前台的JSON数据交互"></a>SpringMVC 与前台的JSON数据交互</h2><p>我们知道，从前台传过来的方式有两种：1.传JSON格式的数据过来。2.在url的末尾传普通的key/value串过来。</p>
<p><strong>1.配置JSON转换器</strong><br><br>返回json需要导入 jackson-annotations.jar, jackson-core.jar, jackson-databind.jar包。</p>
<pre><code>&lt;!-- 用于将对象转换为 JSON  --&gt;  
&lt;bean id=&quot;stringConverter&quot;  
    class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;  
    &lt;property name=&quot;supportedMediaTypes&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
&lt;bean id=&quot;jsonConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;&lt;/bean&gt;  

&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;  
    &lt;property name=&quot;messageConverters&quot;&gt;  
        &lt;list&gt;  
            &lt;ref bean=&quot;stringConverter&quot; /&gt;  
            &lt;ref bean=&quot;jsonConverter&quot; /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre><blockquote>
<p>提示：但是如果使用&lt;mvc:annotation-driven /&gt;注解驱动的话就不用以上的配置了，默认已经配好了。建议使用这种，比较方便。</p>
</blockquote>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 拦截器</title>
    <url>/undefined/SpringMVC%20%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="SpringMVC-中的拦截器"><a href="#SpringMVC-中的拦截器" class="headerlink" title="SpringMVC 中的拦截器"></a>SpringMVC 中的拦截器</h2><p>Spring提供了<code>HandlerInterceptor</code>接口和<code>HandlerInterceptorAdapter</code>适配器。实现这个接口或继承此类，就可以实现自己的拦截器。接口<code>HandlerInterceptor</code>包含三个方法，每个方法的参数<code>handler</code>，用来指向下一个拦截器。此类似于Servlet开发中的Filter，用于对请求进行拦截和处理。</p>
<h4 id="1-Spring-MVC拦截器使用方法"><a href="#1-Spring-MVC拦截器使用方法" class="headerlink" title="1.Spring MVC拦截器使用方法"></a>1.Spring MVC拦截器使用方法</h4><p>1.配置文件<br><br>定义在springmvc.xml配置下的<code>&lt;mvc:interceptor&gt;</code>表示对特定的请求进行拦截。</p>
<pre><code>&lt;mvc:interceptors&gt;
&lt;!--对所有的请求进行拦截--&gt;
&lt;!--&lt;beans:beanclass=&quot;com.sunp.common.interceptor.Myinterceptor&quot;/&gt;--&gt;
    &lt;!--对特定的请求进行拦截--&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--进行拦截的路径--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt; 
        &lt;!--不进行拦截的路径--&gt;   
        &lt;mvc:exclude-mapping path=&quot;/lib/**&quot; /&gt; 
        &lt;beans:bean class=&quot;com.sunp.common.interceptor.Myinterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre><p>2.实现接口并且继承方法(同时包含多个实现类)</p>
<pre><code>public class myInterceptor implements HandlerInterceptor{
    @Override
    public boolean preHandler(HttpServletRequest request, HttpServletResponse response, Object obj)throws Exception{
    //该方法将在请求处理之前进行调用，只有该方法返回true，才会继续执行后续的Interceptor和Controller
    //当返回值为true 时就会继续调用下一个Interceptor的preHandle方法
    //如果已经是最后一个Interceptor的时候就会是调用当前请求的Controller方法
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,Object obj,Exception e)throws Exception {
    //在整个请求结束之后被调用，即就是在DispatcherServlet渲染了对应的视图之后执行(用于进行资源清理工作)
    }

    @Override
    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1,Object arg2,ModelAndView arg3) throws Exception {
    //该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行， 
    //DispatcherServlet进行视图返回渲染之前进行调用，可以在这个方法中对Controller
    //处理之后的ModelAndView 对象进行操作
    } 
}

备注：
    1.preHandle()，在Controller之前执行的预处理，可以进行编码、安全控制等处理
    2.postHandle()，在生成View之前执行的后处理，调用了Service并返回ModelAndView，但未进行页面渲染，可以修改ModelAndView
    3.afterCompletion()，最后执行的返回处理，这时已经进行了页面渲染，可以进行日志记录、释放资源等处理
</code></pre><p>所以在实现了接口之后，就可以在配置文件中进行拦截器的配置。然后其执行顺序为：preHandler -&gt; Controller -&gt; postHandler -&gt; model渲染-&gt; afterCompletion</p>
<blockquote>
<p>注意：如果配置了<code>&lt;mvc:annotation-driven/&gt;</code>，会自动注册<code>DefaultAnnotationHandlerMapping</code>与<code>AnnotationMethodHandlerAdapter</code>这两个bean。这样就不能再注入<code>interceptors</code>属性，也就无法指定拦截器了。</p>
</blockquote>
<h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h4><ul>
<li>如检测请求是否具有登录权限，如果没有直接返回到登陆页面。</li>
<li>可以记录请求信息的日志，以便进行信息监控、信息统计等。</li>
</ul>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 查缺补漏</title>
    <url>/undefined/SpringMVC%20%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h4 id="ResponseBody转换为JSON秘密"><a href="#ResponseBody转换为JSON秘密" class="headerlink" title="@ResponseBody转换为JSON秘密"></a>@ResponseBody转换为JSON秘密</h4><pre><code>1.在控制器中，其在进入控制器方法之前，遇到@ResponseBody之后，处理器就会记录这个方法的响应类型是JSON数据集。
2.在执行完控制器返回之后，处理器启用结果解析器(ResultResolver)解析此结果，轮询注册给SpringMVC的HttpMessageConverter接口的实现类。
</code></pre><h4 id="操作会话对象"><a href="#操作会话对象" class="headerlink" title="操作会话对象"></a>操作会话对象</h4><pre><code>@SessionAttribute 该注解应用于参数，将HttpSession中的属性读出，赋予控制器的参数
@SessionAttributes 用于类的注解，其会将相关数据模型的属性保存到Session中
</code></pre><h4 id="给控制器增加通知"><a href="#给控制器增加通知" class="headerlink" title="给控制器增加通知"></a>给控制器增加通知</h4><pre><code>@ControllerAdvice 定义控制器通知类

@InitBinder 定义控制器参数绑定规则

@ExceptionHandler 定义控制器发生异常后的操作

@ModelAttribute 在控制器方法执行之前，对数据模型进行操作
</code></pre><hr>
<h1 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h1><p>数据回显，表示在提交之后如果出现错误，将刚才提交的数据回显到刚才提交的页面。</p>
<h4 id="POJO数据回显方法"><a href="#POJO数据回显方法" class="headerlink" title="POJO数据回显方法"></a>POJO数据回显方法</h4><p><strong>1.SpringMVC默认对POJO数据作回显</strong><br><br>POJO数据传入controller方法后，springmvc自动将POJO数据放到request域，key等于POJO类型（首字母小写），使用@ModelAttribute指定pojo回显到页面在request中的key。</p>
<p><strong>2.@ModelAttribute将方法的返回值传到页面</strong><br><br>在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。</p>
<pre><code>//商品分类
//itemtypes表示最终将方法返回值放在request中的key
@ModelAttribute(&quot;itemtypes&quot;)
public Map&lt;String, String&gt; getItemTypes() {

    Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;();
    itemTypes.put(&quot;101&quot;, &quot;数码&quot;);
    itemTypes.put(&quot;102&quot;, &quot;母婴&quot;);

    return itemTypes;
}
</code></pre><p>然后在页面上可以得到itemTypes数据。</p>
<pre><code>&lt;td&gt;
    商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt;
    商品类型：
    &lt;select name=&quot;itemtype&quot;&gt;
        &lt;c:forEach items=&quot;${itemtypes}&quot; var=&quot;itemtype&quot;&gt;
            &lt;option value=&quot;${itemtype.key }&quot;&gt;${itemtype.value }&lt;/option&gt;
        &lt;/c:forEach&gt;
    &lt;/select&gt;
&lt;/td&gt;
</code></pre><p><strong>3.使用最简单方法使用model，可以不用@ModelAttribute</strong><br></p>
<pre><code>//可以直接使用model将提交pojo回显到页面
//model.addAttribute(&quot;items&quot;, itemsCustom);
//简单类型数据回显
//使用最简单方法使用model
model.addAttribute(&quot;id&quot;, id);
</code></pre><hr>
<h1 id="SpringMVC-JSON数据交互"><a href="#SpringMVC-JSON数据交互" class="headerlink" title="SpringMVC JSON数据交互"></a>SpringMVC JSON数据交互</h1><h4 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h4><p><strong>1.pom.xml添加依赖</strong><br></p>
<pre><code>&lt;!-- json 转换--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.7.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
    &lt;version&gt;1.9.13&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><strong>2.配置JSON转换器</strong><br></p>
<pre><code>&lt;!--注解适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;list&gt;
    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>提示：这里可以直接使用<code>&lt;mvc:annotation-driven /&gt;</code>，然后就不用再定义上面的内容。</p>
</blockquote>
<blockquote>
<blockquote>
<p>这里的前台和controller方法省略。</p>
</blockquote>
</blockquote>
<hr>
<h1 id="RESTful支持"><a href="#RESTful支持" class="headerlink" title="RESTful支持"></a>RESTful支持</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</p>
<p><strong>1.对url进行规范，写RESTful格式的url</strong><br></p>
<pre><code>1.非REST的url：http://...../queryItems.action?id=001&amp;type=T01

2.REST的url风格：http://..../items/001
</code></pre><blockquote>
<p>特点：url简洁，将参数通过url传到服务端</p>
</blockquote>
<p><strong>2.http的方法规范</strong><br><br>不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。</p>
<p><strong>3.对http的contentType规范</strong><br><br>请求时指定contentType，要json数据，设置成json格式的type。</p>
<h4 id="案例-查询商品信息，返回JSON数据"><a href="#案例-查询商品信息，返回JSON数据" class="headerlink" title="案例 - 查询商品信息，返回JSON数据"></a>案例 - 查询商品信息，返回JSON数据</h4><p><strong>1.controller</strong><br><br>定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller。输出json使用@ResponseBody将java对象输出json。</p>
<pre><code>//查询商品信息，输出json
//itemsView/{id}里边的{id}表示占位符，通过@PathVariable获取占位符中的参数，
//@PathVariable中名称要和占位符一致，形参名无需和其一致
//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称
@RequestMapping(&quot;/itemsView/{id}&quot;)
public @ResponseBody ItemsCustom itemsView(@PathVariable(&quot;id&quot;) Integer items_id)throws Exception{

    //调用service查询商品信息
    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);
    return itemsCustom;
}
</code></pre><blockquote>
<p>@RequestMapping(value=”/ itemsView/{id}”)：{×××}占位符，请求的URL可以是/viewItems/1或/viewItems/2，通过在方法中使用@PathVariable获取{×××}中的×××变量。@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。如果@RequestMapping中表示为/itemsView/{id}，id和形参名称一致，@PathVariable不用指定名称。</p>
</blockquote>
<p><strong>2.REST方法的前端控制器配置</strong><br></p>
<pre><code>&lt;!-- springmvc前端控制器，rest配置 --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p><strong>3.对静态资源的解析</strong><br><br>配置前端控制器的url-parttern中指定/，对静态资源的解析会出现问题，报404错误。在springmvc.xml中添加静态资源解析方法。</p>
<pre><code>&lt;!-- 静态资源解析
    包括 ：js、css、img、..
     --&gt;
&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;
</code></pre><blockquote>
<p>这时访问<a href="http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容。" target="_blank" rel="noopener">http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 文件上传</title>
    <url>/undefined/SpringMVC%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="SpringMVC-文件上传"><a href="#SpringMVC-文件上传" class="headerlink" title="SpringMVC 文件上传"></a>SpringMVC 文件上传</h2><p>这里SpringMVC为文件上传提供最直接的支持，这种支持是由即插即用的MultipartResolve实现。</p>
<blockquote>
<p>提示：我们在上传文件之前需要：<br><br>    1.创建虚拟目录来保存文件，此虚拟目录会对应磁盘上的一个实际的目录，在实际中肯定有一个服务器专门存储资源，然后将该路径映射成一个虚拟目录，用来在程序中指定获取文件的路径<br><br>        创建的方法：<br>            1.在tomcat的配置文件中配置一下(server.xml)。</p>
</blockquote>
<pre><code>            &lt;Context docBase=&quot;E:\BangjinHu\projects\upload\&quot; path=&quot;/file&quot; reloadable=&quot;true&quot;/&gt;

2.然后编写后台Controller方法

1.配置CommonsMultipartResolver
    SpringMVC配置文件配置支持文件上传类CommonsMultipartResolver
    //配置文件上传解析器
    //id名称必须是如此class名称后面的部分
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.CommonsMultipartResolver&quot;&gt;
        //配置文件上传解析器参数
        //上传文件的最大大小
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10240000&quot;&gt;&lt;/property&gt;
        //上传文件的编码
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;


2.控制层controller程序

    提示：上传文件的逻辑是，首先判断有没有上传文件，如果已经上传了，那么对文件重命名然后写到磁盘中。如果没有上传文件，那么应该用原来的文件。

    @Controller
    public class UploadController {

        @Resource
        HttpServletRequest request;

        /**
         * @return  返回相对路径RelativePath
         */
        public String RelPath() {
            String path = request.getContextPath();
            return request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;
        }

        /**
         * @return  返回服务器目录的真实路径
         */
        public String RealPath() {
            return request.getSession().getServletContext().getRealPath(&quot;/&quot;);
        }

        /**
         *  单文件上传
         * 
         * @param imageFile
         * @param request
         * @return
         */
        @RequestMapping(&quot;/singleUpload&quot;)    
        public String singleUpload(@RequestParam(&quot;imageFile&quot;) MultipartFile imageFile, HttpServletRequest request){

            //0.获取文件原来的名字
            String filename = imageFile.getOriginalFilename();

            //1.新建一个文件夹对象
            File dir = new File(RealPath()+&quot;upload/&quot;);

            //2.检查路径下upload文件夹是否存在
            if(!dir.exists()){              
                dir.mkdirs();
            }

            System.out.println(&quot;文件上传到:&quot;+RelPath()+&quot;upload/&quot;+ filename);

            //3.在文件夹下新建一个filename文件的文件对象,此处新建文件应该新建在确切的物理路径下
            File targetFile = new File(RealPath()+&quot;upload/&quot;+ filename);

            //4.判断真实路径下是否存在filename文件
            if(!targetFile.exists()){
                try {
                    //5.在真实路径下创建filename空文件
                    targetFile.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            try {
                //6.复制文件到真实路径下，这里的文件只是一个路径？
                imageFile.transferTo(targetFile);
            } catch (IllegalStateException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            System.out.println(&quot;真实路径:&quot;+RealPath()+&quot;upload/&quot;);
            System.out.println(&quot;相对路径:&quot;+RelPath()+&quot;upload/&quot;);

            //非安全目录下使用(可用)
            return &quot;redirect:&quot;+RelPath()+&quot;upload/&quot;+filename;   

            //重定向到真实地址(不可用)
            //return &quot;redirect:&quot;+RealPath()+&quot;upload/&quot;+filename;                 
            //return &quot;redirect:http://localhost:8080/SpringMvcTest/upload/&quot;+filename;
        }
</code></pre><hr>
<pre><code>    /**
     * 多文件上传
     * @param request
     * @return
     */
    @RequestMapping(&quot;/multiUpload&quot;)
    public String multiUpload(HttpServletRequest request){

        //1、将请求进行转义
        MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest)request;

        //2、获取同一表单提交过来的所有文件
        Map&lt;String, MultipartFile&gt; files = multipartHttpServletRequest.getFileMap();

        //3、在真实路径创建文件
        File dir = new File(RealPath()+&quot;upload/&quot;);
        if(!dir.exists()) {
            dir.mkdirs();
        }

        //4、将上传的文件的相对地址保存在一个列表中(客户端只能请求服务器的相对地址)
        List&lt;String&gt; fileList = new ArrayList&lt;String&gt;();
        for(MultipartFile file : files.values()) { 

            //5、在服务器的绝对地址下新建文件,并将上传的文件复制过去,将相对路径保存进List列表中,服务器的相对路径和绝对路径是相互映射的，客户端只能请求相对路径
            File targetFile = new File(RealPath()+&quot;upload/&quot; + file.getOriginalFilename()); 
            if(!targetFile.exists()) {
                try {
                    targetFile.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                try {
                    file.transferTo(targetFile);
                    fileList.add(RelPath()+&quot;upload/&quot;+file.getOriginalFilename());
                } catch (IllegalStateException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }else{
                //文件如果存在直接访问
                fileList.add(RelPath()+&quot;upload/&quot;+file.getOriginalFilename());
            }
        }
        System.out.println(fileList);
        request.setAttribute(&quot;files&quot;, fileList);
        return &quot;/WEB-INF/jsp/multiUploadResult.jsp&quot;;    
    }
}
</code></pre><hr>
<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><h4 id="SpringMVC对多部件类型解析"><a href="#SpringMVC对多部件类型解析" class="headerlink" title="SpringMVC对多部件类型解析"></a>SpringMVC对多部件类型解析</h4><pre><code>1.首先需要在页面form表单中提交`enctype=&quot;multipart/form-data`的数据。
2.然后需要在springmvc.xml文件中对multipart类型的数据进行解析。

    &lt;!-- 文件上传 --&gt;
    &lt;bean id=&quot;multipartResolver&quot;
          class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;
        &lt;property name=&quot;maxUploadSize&quot;&gt;
            &lt;value&gt;5242880&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

3.在pom.xml中添加文件上传的依赖

    &lt;!-- 文件上传 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.1&lt;/version&gt;
    &lt;/dependency&gt;

4.创建图片虚拟目录存储图片

    直接在tomcat的conf/server.xml文件中添加虚拟路径。
</code></pre><blockquote>
<p>注意：在图片虚拟目录中，一定将图片目录分级创建（提高i/o性能），一般我们采用按日期(年、月、日)进行分级创建。</p>
</blockquote>
<pre><code>5.上传图片的前台实现

    &lt;tr&gt;
        &lt;td&gt;商品图片&lt;/td&gt;
        &lt;td&gt;
            &lt;c:if test=&quot;${items.pic !=null}&quot;&gt;
                &lt;img src=&quot;/pic/${items.pic}&quot; width=100 height=100/&gt;
                &lt;br/&gt;
            &lt;/c:if&gt;
            &lt;input type=&quot;file&quot;  name=&quot;items_pic&quot;/&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

6.上传图片的controller实现

    //这里表示修改图片的controller方法
    @RequestMapping(&quot;/editItemsSubmit&quot;)
    public String editItemsSubmit(
            Model model,
            HttpServletRequest request,
            Integer id,
            @ModelAttribute(&quot;items&quot;)
            @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,
            BindingResult bindingResult,
            MultipartFile items_pic
    )throws Exception {
     //原始名称
    String originalFilename = items_pic.getOriginalFilename();
    //上传图片
    if(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0){

    //存储图片的物理路径
    String pic_path = &quot;D:\\tmp\\&quot;;

    //新的图片名称
    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));
    //新图片
    File newFile = new File(pic_path+newFileName);

    //将内存中的数据写入磁盘
    items_pic.transferTo(newFile);

    //将新图片名称写到itemsCustom中
    itemsCustom.setPic(newFileName);

}
</code></pre>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 文件下载</title>
    <url>/undefined/SpringMVC%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="SpringMVC-文件下载"><a href="#SpringMVC-文件下载" class="headerlink" title="SpringMVC 文件下载"></a>SpringMVC 文件下载</h2><pre><code>@Controller
public class DownloadController {

    @Resource
    HttpServletRequest request;

    @Resource
    HttpServletResponse response;

    @RequestMapping(&quot;/download&quot;)
    public String download(@RequestParam String fileName){

        //1.设置响应的文件类型和文件编码
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        try {
            //2.确保请求的编码类型为UTF-8,不然文件下载后有可能因为类型不一致出现乱码
            request.setCharacterEncoding(&quot;UTF-8&quot;);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        String ctxPath = request.getSession().getServletContext().getRealPath(&quot;/&quot;)+&quot;upload/&quot;;
        String downLoadPath = ctxPath + fileName;
        System.out.println(downLoadPath);

        try{
            long fileLength = new File(downLoadPath).length();

            //3.设置响应头文件内容,文件类型、弹出下载对话框、文件大小
            response.setContentType(&quot;application/x-msdownload&quot;);
            response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=&quot; + new String(fileName.getBytes(&quot;utf-8&quot;), &quot;ISO8859-1&quot;));
            response.setHeader(&quot;Content-Length&quot;, String.valueOf(fileLength));

            //4.新建一个输入流缓存对象,并将文件输入流对象传递进去,将文件路径传递进文件输入流对象中，这是一个逐步处理的过程
            bis = new BufferedInputStream(new FileInputStream(downLoadPath));

            //5.新建一个输出流缓存对象,将服务器响应输出流对象至于其中
            bos = new BufferedOutputStream(response.getOutputStream());

            //6.新建一个缓存
            byte[] buff = new byte[2048];

            //7.内容字节总数
            int bytesRead;              

            //8.输入到到buff缓存中,当文件为空是read()会return -1,否则返回读取的字节总数
            while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) {

                //9.将buff的字节写到响应体的输出流中，输出流持续输出到客户端
                bos.write(buff, 0, bytesRead);
            }

        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            if (bis != null)
                try {
                    //10.关闭缓存输入流对象
                    bis.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            if (bos != null)
                try {
                    //10.关闭缓存输出流对象
                    bos.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }       
            return null;    
        }
    }
</code></pre>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/undefined/SpringMVC/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="SpringMVC-解析"><a href="#SpringMVC-解析" class="headerlink" title="SpringMVC 解析"></a>SpringMVC 解析</h1><h2 id="1-什么是拦截器："><a href="#1-什么是拦截器：" class="headerlink" title="1.什么是拦截器："></a>1.什么是拦截器：</h2><p>SpringMVC提供了拦截器机制：</p>
<p>HandlerInterceptor：SpringMVC</p>
<p>​    允许在目标方法之前进行一些拦截工作，或者在目标方法之后进行一些其他的处理。</p>
<p><img src="images/1.png" alt=""></p>
<p>perHandle：在目标方法执行之前，返回boolean，return true（放行）；return false 不放行；</p>
<p>postHandle:在目标方法执行之后调用，目标方法调用之后；</p>
<p>aftercompletion：在整个请求完成之后，来到目标页面之后；资源响应之后；</p>
<h2 id="2-拦截器怎么使用："><a href="#2-拦截器怎么使用：" class="headerlink" title="2.拦截器怎么使用："></a>2.拦截器怎么使用：</h2><h4 id="1-实现HandlerInterceptor-接口-实现三个方法！"><a href="#1-实现HandlerInterceptor-接口-实现三个方法！" class="headerlink" title="1.实现HandlerInterceptor 接口 实现三个方法！"></a>1.实现HandlerInterceptor 接口 实现三个方法！</h4><p><img src="images/2.png" alt=""></p>
<h4 id="2-配置这个拦截器需要拦截那些请求"><a href="#2-配置这个拦截器需要拦截那些请求" class="headerlink" title="2.配置这个拦截器需要拦截那些请求"></a>2.配置这个拦截器需要拦截那些请求</h4><ol>
<li>拦截器是一个接口！</li>
<li>实现HandleInterceptor接口：</li>
<li>配置拦截器</li>
</ol>
<p><img src="images/3.png" alt=""></p>
<h4 id="3-拦截器的运行流程"><a href="#3-拦截器的运行流程" class="headerlink" title="3.拦截器的运行流程"></a>3.拦截器的运行流程</h4><p><img src="images/4.png" alt=""></p>
<h5 id="3-1-正常运行流程："><a href="#3-1-正常运行流程：" class="headerlink" title="3.1.正常运行流程："></a>3.1.正常运行流程：</h5><p>​    拦截器的preHandle———目标方法———拦截器的postHandle———页面———拦截器的afterCompletion</p>
<h5 id="3-2-其他流程："><a href="#3-2-其他流程：" class="headerlink" title="3.2.其他流程："></a>3.2.其他流程：</h5><pre><code>1. 只要preHandle 不放行，其他流程均完蛋。
2. 放行之后，目标方法炸了，preHandle 放行，postHandle没有执行，**但是afterCompletion执行了。**
</code></pre><h5 id="3-3-多个拦截器的流程："><a href="#3-3-多个拦截器的流程：" class="headerlink" title="3.3.多个拦截器的流程："></a>3.3.多个拦截器的流程：</h5><p>正常流程：</p>
<p><img src="images/5.png" alt=""></p>
<p>异常流程：</p>
<p>​    1）、First只要不放行，后面全都没有</p>
<p>​    2)、First 放行，但是Second 不放行。但是First 的<strong>afterCompletion还要执行。</strong></p>
<p>​    总结：==<strong>已放行的拦截器的 afterCompletion 都要执行</strong>==</p>
<p>​    <img src="images/6.png" alt=""></p>
<p>==拦截器的 preHandle 是顺序执行的，但是 postHandle 和 afterCompletion 是逆序执行的。==</p>
<h2 id="3-拦截器的源码流程"><a href="#3-拦截器的源码流程" class="headerlink" title="3.拦截器的源码流程"></a>3.拦截器的源码流程</h2><h5 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	HttpServletRequest processedRequest = request;</span><br><span class="line">	HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">		Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			processedRequest = checkMultipart(request);</span><br><span class="line">			multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">               <span class="comment">//先获取到处理器，并拿到执行链</span></span><br><span class="line">			mappedHandler = getHandler(processedRequest);</span><br><span class="line">			<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">				noHandlerFound(processedRequest, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">               <span class="comment">//在获取适配器</span></span><br><span class="line">			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">			String method = request.getMethod();</span><br><span class="line">			<span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">			<span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">				<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//执行所有拦截器的preHandle （返回false 就是 true 就直接返回了）</span></span><br><span class="line">               <span class="comment">//如果有一个拦截器返回false 那么目标方法之后都不会执行了。</span></span><br><span class="line">               <span class="comment">//直接跳到 afterCompletion 执行</span></span><br><span class="line">			<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			applyDefaultViewName(processedRequest, mv);</span><br><span class="line">			mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			dispatchException = ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			<span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">			<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">			dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">		&#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//页面渲染（如果渲染失败出现了异常，catch中也会执行afterCompletion）</span></span><br><span class="line">		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">		triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">				<span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">			<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">			<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">				cleanupMultipart(processedRequest);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PreHandle"><a href="#PreHandle" class="headerlink" title="PreHandle"></a>PreHandle</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">			HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//preHandle - true -false </span></span><br><span class="line">			<span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                   <span class="comment">//先去执行 afterCompletion </span></span><br><span class="line">				triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">//返回false</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">//记录了索引</span></span><br><span class="line">			<span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PostHandle"><a href="#PostHandle" class="headerlink" title="PostHandle"></a>PostHandle</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//逆序执行</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">			interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult"></a>processDispatchResult</h5><pre><code>private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
        @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
        @Nullable Exception exception) throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // Did the handler return a view to render?
    if (mv != null &amp;&amp; !mv.wasCleared()) {

        //页面渲染
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &apos;&quot; + getServletName() +
                    &quot;&apos;: assuming HandlerAdapter completed request handling&quot;);
        }
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }
    if (mappedHandler != null) {

        //页面正常，执行afterCompletion，即使没有走到这里afterCompletion 也会执行
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
</code></pre><h5 id="triggerAfterCompletion"><a href="#triggerAfterCompletion" class="headerlink" title="triggerAfterCompletion"></a>triggerAfterCompletion</h5><pre><code>void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)
        throws Exception {

    HandlerInterceptor[] interceptors = getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {

        //逆序执行（通过之前记录的索引），把之前所有放行的拦截器的AfterCompletion全部执行
        for (int i = this.interceptorIndex; i &gt;= 0; i--) {
            HandlerInterceptor interceptor = interceptors[i];
            try {
                interceptor.afterCompletion(request, response, this.handler, ex);
            }
            catch (Throwable ex2) {
                logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);
            }
        }
    }
}
</code></pre><p>流程总结：</p>
<p><img src="images/7.png" alt=""></p>
<p>就一句话：<strong>==所有已经放行的拦截器的afterCompletion 一定会执行==</strong></p>
<h2 id="SpringMVC的流程总结："><a href="#SpringMVC的流程总结：" class="headerlink" title="SpringMVC的流程总结："></a>SpringMVC的流程总结：</h2><p><strong>1、所有的请求，==前端控制器（DispatcherServlet），调用doDispatch==进行处理；</strong></p>
<p><strong>2、根据==HandleMapping中保存的映射信息==找到，处理当前请求的==，处理器执行链==（包含了拦截器）。</strong></p>
<p><strong>3、==根据当前处理器找到他的适配器==；</strong></p>
<p><strong>4、==拦截器的preHandle 先执行==</strong></p>
<p><strong>5、==适配器执行目标方法==</strong></p>
<p>​    1）、ModelAttribute注解标注的方法提前执行</p>
<p>​    2）、执行目标方法的时候（确定目标方法的参数）</p>
<p>​        1）有注解：</p>
<p>​        2）没注解：</p>
<p>​            1）、看看是否是Model 、Map 或者其他的</p>
<p>​            2）、如果是自定义类型</p>
<p>​                1）先从隐含模型中看有没有，如果有就从隐含模型中拿</p>
<p>​                2）如果没有，看看是否是SessionAttributes标注的属性，如果是从session中拿，拿不到抛出异常</p>
<p>​                3）如果都不是，利用反射创建对象。</p>
<p><strong>6、==拦截器的 postHandle 执行==</strong></p>
<p><strong>7、处理结果（==页面渲染流程==）</strong></p>
<p>​    <strong>1）、如果有异常使用==异常解析器==处理异常，返回ModelAndView</strong></p>
<p>​    <strong>2）、调用  ==render==  进行页面渲染</strong></p>
<p>​        1）视图解析器通过视图名得到视图对象</p>
<p>​        2）、视图对象调用 render 方法；</p>
<p>​    <strong>3）、==执行拦截器的afterCompletion==</strong>        </p>
<h2 id="SpringMVC流程图："><a href="#SpringMVC流程图：" class="headerlink" title="SpringMVC流程图："></a>SpringMVC流程图：</h2><p>​    <img src="images/8.png" alt=""></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码 - IOC</title>
    <url>/undefined/Spring%E6%BA%90%E7%A0%81%20-%20Spring%20IoC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Spring源码-Spring-IoC核心流程"><a href="#Spring源码-Spring-IoC核心流程" class="headerlink" title="Spring源码 - Spring IoC核心流程"></a>Spring源码 - Spring IoC核心流程</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>Spring IoC的初始化过程很复杂，大致过程就是读取XML文件，然后解析XML文件，最终注册到BeanFactory中去。</p>
<pre><code>xml -读取-&gt; Resource -解析-&gt; BeanDefinition -注册-&gt; BeanFactory
</code></pre><p>初始化过程完成之后，Bean就存在与BeanFactory中可以被调用。</p>
<h5 id="1-准备"><a href="#1-准备" class="headerlink" title="1 准备"></a>1 准备</h5><p><strong>1.1 详细的Spring IoC初始化过程</strong><br></p>
<pre><code>&lt;bean id=&quot;Aaron&quot; class=&quot;com.springstudy.talentshow.SuperInstrumentalist&quot;&gt;
    &lt;property name=&quot;instruments&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;piano&quot;/&gt;
            &lt;ref bean=&quot;saxophone&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>提示：加载时需要读取|解析|注册bean。</p>
</blockquote>
<p><strong>1.2 加载配置文件</strong><br></p>
<p>在调用 ClassPathXmlApplicationContext 后，先会将配置位置信息保存到 configLocations ，供后面解析使用，之后，会调用 AbstractApplicationContext 的 refresh 方法进行刷新。</p>
<pre><code>//构造器
public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException {
    super(parent);
    //保存位置信息
    this.setConfigLocations(configLocations);
    if (refresh) {
        //刷新
        this.refresh();
    }
}

public void refresh() throws BeansException, IllegalStateException {
    synchronized(this.startupShutdownMonitor) {
        this.prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
        this.prepareBeanFactory(beanFactory);

        try {
            this.postProcessBeanFactory(beanFactory);
            this.invokeBeanFactoryPostProcessors(beanFactory);
            this.registerBeanPostProcessors(beanFactory);
            this.initMessageSource();
            this.initApplicationEventMulticaster();
            this.onRefresh();
            this.registerListeners();
            this.finishBeanFactoryInitialization(beanFactory);
            this.finishRefresh();
        } catch (BeansException var9) {
            if (this.logger.isWarnEnabled()) {
                this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);
            }

            this.destroyBeans();
            this.cancelRefresh(var9);
            throw var9;
        } finally {
            this.resetCommonCaches();
        }

    }
}
</code></pre><p><strong>1.3 创建载入BeanFactory</strong><br></p>
<pre><code>protected final void refreshBeanFactory() throws BeansException {
    // ... ...
    DefaultListableBeanFactory beanFactory = createBeanFactory();
    // ... ...
    loadBeanDefinitions(beanFactory);
    // ... ...
}
</code></pre><p><strong>1.4 创建XMLBeanDefinitionReader</strong><br></p>
<pre><code>protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)
     throws BeansException, IOException {

    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    initBeanDefinitionReader(beanDefinitionReader);
    loadBeanDefinitions(beanDefinitionReader);
}
</code></pre><h5 id="2-读取"><a href="#2-读取" class="headerlink" title="2 读取"></a>2 读取</h5><p><strong>2.1 创建处理每个Resource</strong><br></p>
<pre><code>public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources)
     throws BeanDefinitionStoreException {
    // ... ...
    // 通过Location来读取Resource
    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
    int loadCount = loadBeanDefinitions(resources);
    // ... ...
}

public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
    Assert.notNull(resources, &quot;Resource array must not be null&quot;);
    int counter = 0;
    for (Resource resource : resources) {
        // 载入每一个resource
        counter += loadBeanDefinitions(resource);
    }
    return counter;
}
</code></pre><p><strong>2.2 处理xml每个元素</strong><br></p>
<pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    // ... ...
    NodeList nl = root.getChildNodes();
    for (int i = 0; i &lt; nl.getLength(); i++) {
        Node node = nl.item(i);
        if (node instanceof Element) {
            Element ele = (Element) node;
            if (delegate.isDefaultNamespace(ele)) {
                // 处理每个xml中的元素，可能是import、alias、bean
                parseDefaultElement(ele, delegate);
            }
            else {
                delegate.parseCustomElement(ele);
            }
        }
    }
    // ... ...
}
</code></pre><p><strong>2.3 解析和注册bean</strong><br></p>
<pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 将XML的元素解析为BeanDefinition存储到BeanDefinitionHolder
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // 注册 将BeanDefinition实例put到BeanFactory
            // Register the final decorated instance.
            BeanDefinitionReaderUtils.registerBeanDefinition(
                bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +
                    bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
</code></pre><h5 id="3-解析"><a href="#3-解析" class="headerlink" title="3 解析"></a>3 解析</h5><p><strong>3.1 处理每个Bean的元素</strong><br></p>
<pre><code>public AbstractBeanDefinition parseBeanDefinitionElement(
    Element ele, String beanName, BeanDefinition containingBean) {

    // ... ...
    // 创建beandefinition
    AbstractBeanDefinition bd = createBeanDefinition(className, parent);

    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

    parseMetaElements(ele, bd);
    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
    // 处理“Constructor”
    parseConstructorArgElements(ele, bd);
    // 处理“Preperty”
    parsePropertyElements(ele, bd);
    parseQualifierElements(ele, bd);
    // ... ...
}
</code></pre><p><strong>3.2 处理属性的值</strong><br></p>
<pre><code>public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {
    String elementName = (propertyName != null) ?
                    &quot;&lt;property&gt; element for property &apos;&quot; + propertyName + &quot;&apos;&quot; :
                    &quot;&lt;constructor-arg&gt; element&quot;;

    // ... ...
    if (hasRefAttribute) {
    // 处理引用
        String refName = ele.getAttribute(REF_ATTRIBUTE);
        if (!StringUtils.hasText(refName)) {
            error(elementName + &quot; contains empty &apos;ref&apos; attribute&quot;, ele);
        }
        RuntimeBeanReference ref = new RuntimeBeanReference(refName);
        ref.setSource(extractSource(ele));
        return ref;
    }
    else if (hasValueAttribute) {
    // 处理值
        TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
        valueHolder.setSource(extractSource(ele));
        return valueHolder;
    }
    else if (subElement != null) {
    // 处理子类型（比如list、map等）
        return parsePropertySubElement(subElement, bd);
    }
    // ... ...
}
</code></pre><h5 id="4-注册"><a href="#4-注册" class="headerlink" title="4 注册"></a>4 注册</h5><pre><code>public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}

public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {

    // ......

    // 将beanDefinition注册
    this.beanDefinitionMap.put(beanName, beanDefinition);

    // ......
}
</code></pre><blockquote>
<p>总结：注册的实质就是以beanName为key，以beanDefinition为value，将其put到HashMap的过程。</p>
</blockquote>
<h3 id="2-注入依赖"><a href="#2-注入依赖" class="headerlink" title="2.注入依赖"></a>2.注入依赖</h3><p>在IoC容器完成初始化之后，如果bean没有设置lazy-init属性，那么bean的实例就会在初始化IOC完成之后，及时地进行初始化。初始化时会先建立实例，然后根据配置利用反射对实例进行进一步操作。</p>
<pre><code>初始化IoC容器 -&gt; 初始化Bean -&gt; 创建Bean实例 -&gt; 注入Property
</code></pre><p>在创建Bean和注入Bean属性时，都是在doCreateBean()函数中进行的。</p>
<pre><code>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd,
    final Object[] args) {
    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        // 创建bean的实例
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }

    // ... ...

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        // 初始化bean的实例，如注入属性
        populateBean(beanName, mbd, instanceWrapper);
        if (exposedObject != null) {
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
    }

    // ... ...
}
</code></pre>]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码 - 事务概述</title>
    <url>/undefined/Spring%E6%BA%90%E7%A0%81%20-%20%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Spring源码-事务概述"><a href="#Spring源码-事务概述" class="headerlink" title="Spring源码 - 事务概述"></a>Spring源码 - 事务概述</h2><p>事务首先是一系列操作组成的工作单元，该工作单元内的操作时不可分割的，要么所有操作都做，要么所有操作都不做，这就是事务。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><h4 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h4><p>在并发操作过程中会出现如下问题：</p>
<pre><code>1.丢失更新：两个事务更新同一行数据，最后一个事务的更新会覆盖第一个事务的更新。

2.脏读：一个事务看到另一个事务未提交的更新数据。

3.不可重复读：在同一事务中，多次读取同一个数据却返回不同的结果。其它事务更改这些数据。

4.幻读：一个事务在执行过程中读取到了另一个事务已提交的插入数据；即在第一个事务开始时读取到一批数据，但此后另一个事务又插入了新数据并提交，此时第一个事务又读取这批数据但发现多了一条，即好像发生幻觉一样。
</code></pre><p>为了解决上面的问题，需要通过数据库隔离级别来解决。</p>
<pre><code>1.未提交读：最低级别，一个事务能够读取到别的事务未提交的更新数据，所以这是不安全的，可能出现丢失更新、脏读、不可重复读、幻读。

2.提交读：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不可能出现丢失更新、脏读，但可能出现不可重复读、幻读。

3.可重复读：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读。

4.序列化：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读。
</code></pre><blockquote>
<p>注意：隔离级别越高，数据库事务并发执行性能越差，能处理的操作就越少。在实际项目中采用 提交读 的事务隔离级别，其能够避免丢失更新和脏度，尽管不能避免 不可重复读和幻读，但是可以在可能出现的场合使用 悲观锁和乐观锁 来解决这些问题。</p>
</blockquote>
<h4 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h4><p>Spring 支持声明式事务和编程式事务类型。特性：Spring所有的事务管理策略类都继承自：org.springframework.transaction.PlatformTransactionManager接口。</p>
<p>…</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码 - 概述</title>
    <url>/undefined/Spring%E6%BA%90%E7%A0%81%20-%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Spring源码-概述"><a href="#Spring源码-概述" class="headerlink" title="Spring源码 - 概述"></a>Spring源码 - 概述</h2><p>Spring核心是IoC容器，所以在一开始我们需要透彻理解IoC容器，以及如何配置和使用容器，其它技术都是基于容器实现。然后是AOP编程(面向切面编程)。然后是数据库事务管理，Spring管理事务是通过AOP实现。</p>
<p><strong>核心容器包括：Core | Beans | Context | EL模块</strong><br></p>
<pre><code>1.Core模块：封装框架依赖最底层部分，包括资源访问、类型转换以及常用工具类

2.Beans模块：提供框架基础部分，包括反转控制和依赖注入其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程。所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。

3.Context模块：以Core模块和Beans模块为基础，继承Beans模块功能并添加资源绑定、数据验证、国际化、JavaEE支持、容器生命周期、事件传播等。核心接口是：ApplicationContext。

4.EL模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问以及修改数组、容器和索引器，支持算数和逻辑运算，支持从Spring容器获取Bean。
</code></pre><p><strong>AOP | Aspects模块</strong><br></p>
<pre><code>1.AOP模块：Spring AOP模块提供符合aop规范的面向方面编程的实现，提供如日志记录、权限控制等通用功能与业务逻辑分离的技术。

2.Aspects模块：提供对AspectJ的集成，AspectJ提供了比Spring AOP 更强大的功能。
</code></pre><p><strong>数据访问/集成模块：模块包括了JDBC、ORM、OXM、JMS和事务管理</strong><br></p>
<pre><code>1.事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。

2.JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。

3.ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。

4.OXM模块：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。

5.JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

6.Web/Remoting模块：Web/Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。

7.Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。

8.Web-Servlet模块：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。

9.Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持

10.Test模块：Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。
</code></pre><p><strong>典型应用场景</strong><br></p>
<pre><code>在Web应用程序应用场景中，典型的三层架构：数据模型层实现域对象；数据访问层实现数据访问；逻辑层实现业务逻辑；web层提供页面展示；所有这些层组件都由Spring进行管理，享受到Spring事务管理、AOP等好处，而且请求唯一入口就是DispachterServlet，它通过把请求映射为相应web层组件来实现相应请求功能。
</code></pre>]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/undefined/TCP/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们想要进行网络编程，首先需要服务端通过ServerSocket对某一个端口进行监听。通过accept()来判断是否有客户端与之相连，若成功连上，则通过readline()和println()函数来进行数据的发送和接收，从而实现网络编程。</p>
<h4 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h4><pre><code>HTTP协议：超文本传输协议，互联网应用最广泛的。

FTP协议：文件传输协议。

SMTP协议：简单邮件传输协议。

TCP协议（Transmission Control Protocol 传输控制协议）：面向连接的、可靠的、基于字节流的传输通信协议。

UDP协议（User Datagram Protocol用户数据报协议）：无连接的协议，在传输数据之前，客户端和服务器并不建立和维护连接，效率很快。
</code></pre><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>通信链路的端点就被称为“套接字”(英文名Socket)，是提供给应用程序的接口。这里因为Socket的底层机制复杂，Java平台提供了一些简单的API，可以更简单有效的使用Socket开发而无需了解底层机制。</p>
<p><strong>1.Socket分类</strong><br></p>
<pre><code>1.流式套接字（SOCK_ STREAM）【面向连接、可靠的数据传输服务（对应服务是TCP链接）】

2.数据报式套接字（SOCK_ DGRAM）【无连接服务（数据报似的，基于UDP）更高效】

3.原始式套接字(SOCK_ RAW)
</code></pre><blockquote>
<p>提示：基于TCP协议的Socket网络通信，用来实现双向安全连接网络通信。Socket通信模型，表示在进行网络通信时，Socket需要借助数据流来完成数据的传递工作。</p>
</blockquote>
<p><strong>2.Socket网络编程步骤</strong><br></p>
<pre><code>1.服务端
    1.创建ServerSocket(…)对象，绑定某一端口号。
    2.通过accept()侦听方法，阻塞，等待对方连接。
    3.通过输入、输出流传递信息【客户端是输出输入，服务器是输入输出】。
    4.关闭释放资源。

2.客户端
    1.创建Socket(&quot;…&quot;,…)要指定服务器的IP地址，也要指定端口号。
    2.发送请求并被accept()侦听到，并建立连接。
    3.通过输入、输出流传递信息【客户端是输出输入，服务器是输入输出】。
    4.关闭释放资源。
</code></pre><h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p><strong>1.直接传参的方式</strong><br></p>
<pre><code>1.客户端程序

    package cn.edu.xidian.see.*.Inet;
    import java.io.*;
    import java.net.Socket;
    import java.net.UnknownHostException;

    public class LogicClient {
        public static void main(String[] args) {
            //创建一个客户端的Socket
            try {
                Socket socket = new Socket(&quot;localhost&quot;,5000);
                //通过输出流发送请求
                //直接输出数据流
                String info = &quot;用户名：樱桃小丸子；密码：123456&quot;;
                OutputStream os = socket.getOutputStream();
                //打散成数据数组
                byte[] infos = info.getBytes();
                os.write(infos);
                //关闭输出流，这是一个半关闭
                socket.shutdownOutput();
                //通过输入流接收服务器给我的响应
                InputStream is = socket.getInputStream();
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String reply;
                while((reply = br.readLine())!=null){
                    System.out.println(&quot;服务器：&quot;+reply);
                }
                //释放资源
                os.close();
                socket.close();
            } catch (UnknownHostException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

2.服务端程序

    package cn.edu.xidian.see.*.Inet;
    import java.io.*;
    import java.net.ServerSocket;
    import java.net.Socket;

    public class LogicServicer {
        public static void main(String[] args) {
            try {
                //接收客户端请求
                //创建一个Socket
                ServerSocket serverSocket = new ServerSocket(5000);
                //使用accept()侦听并接收到此ServerSocket的连接
                Socket socket = serverSocket.accept();//侦听到之前都是阻塞的
                //获得输入流，获得用户的请求
                //数据流输入
                InputStream is = socket.getInputStream();
                // BufferedReader读取字符流
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String info;
                // BufferedReader的方法可以一行一行的读
                while((info = br.readLine())!=null){
                    System.out.println(&quot;客户端：&quot;+info);
                }
                //给客户端一个响应
                String reply = &quot;欢迎登陆&quot;;
                //通过输出流将响应发送回给客户端
                OutputStream os = socket.getOutputStream();
                os.write(reply.getBytes());
                //释放相应资源
                os.close();
                br.close();
                is.close();
                socket.close();
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre><p><strong>2.通过用户对象传参的方式</strong><br></p>
<pre><code>1.用户类程序

    package cn.edu.xidian.see.*.Inet.user;
    import java.io.Serializable;
    public class User implements Serializable {
        private String username;
        private String password;

        public User() {
        }

        public User(String username, String password) {
            this.username = username;
            this.password = password;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }

2.客户端程序

    package cn.edu.xidian.see.*.Inet.user;
    import java.io.*;
    import java.net.Socket;
    import java.net.UnknownHostException;

    public class LogicClient {
        public static void main(String[] args) {
            //创建一个客户端的Socket
            try {
                Socket socket = new Socket(&quot;localhost&quot;,5000);
                //通过输出流发送请求
                //将对象序列化变成输出流
                User user = new User(&quot;樱桃小丸子&quot;,&quot;123456&quot;);
                OutputStream os = socket.getOutputStream();
                ObjectOutputStream oos = new ObjectOutputStream(os);
                oos.writeObject(user);
                //关闭输出流，这是一个半关闭
                socket.shutdownOutput();
                //通过输入流接收服务器给我的响应
                InputStream is = socket.getInputStream();
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String reply;
                while((reply = br.readLine())!=null){
                    System.out.println(&quot;服务器：&quot;+reply);
                }
                //释放资源
                os.close();
                oos.close();
                socket.close();
            } catch (UnknownHostException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

3.服务端程序

    package cn.edu.xidian.see.*.Inet.user;

    import java.io.IOException;
    import java.io.InputStream;
    import java.io.ObjectInputStream;
    import java.io.OutputStream;
    import java.net.ServerSocket;
    import java.net.Socket;

    public class LogicServicer {
        public static void main(String[] args) {
            try {
                //接收客户端请求
                //创建一个Socket
                ServerSocket serverSocket = new ServerSocket(5000);
                //使用accept()侦听并接收到此ServerSocket的连接
                Socket socket = serverSocket.accept();//侦听到之前都是阻塞的
                //获得输入流，获得用户的请求
                //将对象反序列化变成输入流
                InputStream is = socket.getInputStream();
                ObjectInputStream ois = new ObjectInputStream(is);
                User user = (User)ois.readObject();
                System.out.println(&quot;客户端：&quot;+user.getUsername()+&quot;-&quot;+user.getPassword());
                //给客户端一个响应
                String reply = &quot;欢迎登陆&quot;;
                //通过输出流将响应发送回给客户端
                OutputStream os = socket.getOutputStream();
                os.write(reply.getBytes());
                //释放相应资源
                ois.close();
                os.close();
                is.close();
                socket.close();
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
</code></pre><blockquote>
<p>提示：关于如何实现多客户请求，采用多线程的方式，然后写一个专门负责监听的应用主服务程序，以及一个专门负责处理请求的线程程序。</p>
</blockquote>
<h4 id="服务器与客户端的多线程连接-服务器与客户端可以无限对话"><a href="#服务器与客户端的多线程连接-服务器与客户端可以无限对话" class="headerlink" title="服务器与客户端的多线程连接(服务器与客户端可以无限对话)"></a>服务器与客户端的多线程连接(服务器与客户端可以无限对话)</h4><pre><code>1.服务器

    1.一直监听客户请求。
    2.一旦监听到有客户请求，立即创建一个线程，开启线程。

1.1 程序实现

    package cn.edu.xidian.see.*.Inet.ThreadUser;

    import java.io.IOException;
    import java.net.ServerSocket;
    import java.net.Socket;

    public class LogicServicer {
        //一直监听客户请求
        //一旦监听到有客户请求，立即创建一个线程，开启线程
        public static void main(String[] args) {
            try {
                //接收客户端请求
                //创建一个Socket
                ServerSocket serverSocket = new ServerSocket(8848);
                System.out.println(&quot;启动服务器&quot;);
                //使用accept()侦听并接收到此ServerSocket的连接
                //一直监听客户请求
                while(true){
                    Socket socket = serverSocket.accept();//侦听到之前都是阻塞的
                    System.out.println(&quot;已连接&quot;);
                    //创建一个和该客户端响应的线程
                    LogicThread logicThread = new LogicThread(socket);
                    logicThread.start();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

2.线程

    1.接收客户请求，基于客户的一个响应(这过程在之前是服务器要做的事情)。
    2.线程构造方法中绑定客户端的Socket。

2.1 程序实现

    package cn.edu.xidian.see.*.Inet.ThreadUser;

    import java.io.*;
    import java.net.Socket;
    import java.util.Scanner;

    public class LogicThread extends Thread{
        //接收客户请求，基于客户一个响应(这在之前是服务器所需要做的事情)
        //线程构造方法中去绑定客户端的Socket

        private Socket socket;

        public LogicThread(Socket socket) {
            this.socket = socket;
        }

        //接收客户请求，基于客户的一个响应
        public void run(){
            InputStream is = null;
            BufferedReader br = null;
            PrintWriter pw = null;
            OutputStream os = null;
            try {
                Scanner sc = new Scanner(System.in);
                //获得输入流，获得用户的请求
                while (true){
                    is = socket.getInputStream();
                    br = new BufferedReader(new InputStreamReader(is));
                    System.out.println(socket.getInetAddress() + &quot;说&quot; + br.readLine());

                    //给客户端一个响应，通过输出流将响应发送回客户端
                    String reply = sc.next();
                    os = socket.getOutputStream();
                    pw = new PrintWriter(os);
                    pw.println(reply);
                    pw.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                try {
                    pw.close();
                    os.close();
                    br.close();
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

3.客户端

    1.发送请求到服务器。
    2.接收服务器的响应。

3.1 程序实现

    package cn.edu.xidian.see.*.Inet.ThreadUser;

    import java.io.*;
    import java.net.Socket;
    import java.net.UnknownHostException;
    import java.util.Scanner;

    public class LogicClient {
        //发送请求到服务器
        //接收服务器的响应
        public static void main(String[] args) {
            Scanner input = new Scanner(System.in);
            OutputStream os=null;
            PrintWriter pw=null;
            InputStream is=null;
            BufferedReader br=null;
            //创建一个客户端的Socket
            try {
                Socket socket = new Socket(&quot;localhost&quot;,8848);
                System.out.println(&quot;客户端已启动&quot;);
                //通过输出流发送请求
                while(true){
                    String info =input.next();
                    os = socket.getOutputStream();
                    pw = new PrintWriter(os);
                    pw.println(info);
                    pw.flush();
                    //通过输入流接收服务器给我的响应
                    is = socket.getInputStream();
                    br = new BufferedReader(new InputStreamReader(is));
                    System.out.println(&quot;服务器：&quot;+br.readLine());
                }
                //释放资源
            } catch (UnknownHostException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }finally{
                try {
                    os.close();
                    pw.close();
                    br.close();
                    is.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
</code></pre><h4 id="使用代理服务器"><a href="#使用代理服务器" class="headerlink" title="使用代理服务器"></a>使用代理服务器</h4><p><strong>1.代理的作用</strong><br></p>
<pre><code>1.出于安全原因防止远程主机了解到本地网络配置的秘密细节。

2.为了通过滤出站请求，限制可以浏览的网络。

3.出于性能考虑，运行多个用户从本地缓存获取同样的一些经常访问的文档，而不是重复从远程主机下载。
</code></pre>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/undefined/UDP/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>[TOC]</p>
<h3 id="基于UDP协议的Socket编程"><a href="#基于UDP协议的Socket编程" class="headerlink" title="基于UDP协议的Socket编程"></a>基于UDP协议的Socket编程</h3><h4 id="1-基于UDP协议的Socket网络编程步骤"><a href="#1-基于UDP协议的Socket网络编程步骤" class="headerlink" title="1. 基于UDP协议的Socket网络编程步骤"></a>1. 基于UDP协议的Socket网络编程步骤</h4><pre><code>1.利用 DatagramPacket 对象封装数据报

    DatagramPacket类将数据字节填充到UDP数据包中，是数据报

2.利用 DatagramSocket 对象发送数据报

    DatagramSocket类收发数据报。

3.利用 DatagramSocket 对象接收数据报

4.利用 DatagramPacket 对象处理数据报
</code></pre><blockquote>
<p>提示：DatagramPacket类，封装了数据报的数据、数据长度、目标地址和目标端口。DatagramSocket类，接收和发送DatagramPacket对象封装好的数据报。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：UDP的这种职责划分与TCP使用的Socket与ServerSocket不一样。1. UDP没有两台主机间唯一连接的概念。一个Socket会收发所有指向指定端口的数据，不需要知道对方是哪一个远程主机。一个 DatagramSocket 可以从多个独立主机收发数据。与TCP不一样的是，UDP的Socket不专用与一个连接。</p>
</blockquote>
</blockquote>
<h4 id="2-基于UDP协议的Socket通信"><a href="#2-基于UDP协议的Socket通信" class="headerlink" title="2. 基于UDP协议的Socket通信"></a>2. 基于UDP协议的Socket通信</h4><p>这一过程可以类比与快递礼物的收发过程，礼物-数据，包裹-DatagramPacket，快递点-DatagramSocket，寄礼物-send()，收礼物-receive()。</p>
<h5 id="2-1-基于UDP协议的Socket通信-服务端"><a href="#2-1-基于UDP协议的Socket通信-服务端" class="headerlink" title="2.1 基于UDP协议的Socket通信(服务端)"></a>2.1 基于UDP协议的Socket通信(服务端)</h5><pre><code>package cn.edu.xidian.see.*.Inet.UDPSocket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketAddress;
import java.net.SocketException;

public class LogicServicer {
    public static void main(String[] args) {
        byte[] infos = new byte[1024];
        DatagramPacket dp = new DatagramPacket(infos,infos.length);
        //快递点
        DatagramSocket socket=null;
        try {
            socket = new DatagramSocket(5000);
            //在快递点取礼物
            socket.receive(dp);
            //拆礼物
            String info = new String(dp.getData(),0,dp.getData().length);
            System.out.println(&quot;客户端说：&quot;+info);
            //给客户端一个响应
            String reply =&quot;一件羽绒服&quot;;
            byte[] reply2 = reply.getBytes();
            //客户端地址
            SocketAddress sa = dp.getSocketAddress();
            //打开一个包裹
            DatagramPacket dp1 = new DatagramPacket(reply2,reply2.length,sa);
            //寄出去
            socket.send(dp1);
        } catch (SocketException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            socket.close();
        }
    }
}
</code></pre><h5 id="2-2-基于UDP协议的Socket通信-客户端"><a href="#2-2-基于UDP协议的Socket通信-客户端" class="headerlink" title="2.2 基于UDP协议的Socket通信(客户端)"></a>2.2 基于UDP协议的Socket通信(客户端)</h5><pre><code>package cn.edu.xidian.see.*.Inet.UDPSocket;

import java.io.IOException;
import java.net.*;

public class LogicClient {
    public static void main(String[] args) {
        //买礼物
        String info=&quot;心形巧克力！&quot;;
        byte[] infos = info.getBytes();
        //对方地址和邮编（端口号）
        InetAddress ia;
        //快递点
        DatagramSocket socket = null;
        try {
            //localhost = 127.0.0.1 回环地址
            ia = InetAddress.getByName(&quot;localhost&quot;);
            //包裹包装礼物
            DatagramPacket dp = new DatagramPacket(infos, infos.length, ia, 5000);
            socket = new DatagramSocket();
            //通过快递点往外寄出礼物
            try {
                socket.send(dp);
            } catch (IOException e) {
                e.printStackTrace();
            }
            //接收服务器的响应
            byte[] replys = new byte[1024];
            DatagramPacket dp1 = new DatagramPacket(replys,replys.length);
            socket.receive(dp1);
            String reply = new String(dp1.getData(),0,dp.getData().length);
            System.out.println(&quot;服务器的响应：&quot;+reply);
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (SocketException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            socket.close();
        }
    }
}
</code></pre><h3 id="DatagramPacket-类"><a href="#DatagramPacket-类" class="headerlink" title="DatagramPacket 类"></a>DatagramPacket 类</h3><h3 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h3><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>DatagramChannel类用与非阻塞UDP应用程序，与SocketChannel和ServerSocketChannel用于非阻塞TCP应用程序一样。类似于SocketChannel和ServerSocketChannel，DatagramChannel是SelectableChannel的子类，可以注册到一个Selector。</p>
<p>在UDP中，一个数据报Socket可以处理多个客户端的输入和输出请求。而DatagramChannel类所增加的就是能够以非阻塞的方式做到这一点。这样的话如果网络没有立即准备好收发数据，这些方法可以迅速返回。</p>
<h4 id="1-打开socket"><a href="#1-打开socket" class="headerlink" title="1. 打开socket"></a>1. 打开socket</h4><pre><code>//1. 创建通道
DatagramChannel channel = DatagramChannel.open();

//2. 监听通道的地址
SocketAddress address = new InetSocketAddress(3122);

//3. 监听连接
DatagramSocket socket = channel.socket();

//4. 绑定端口
socket.bind(address);
</code></pre><h4 id="2-接收"><a href="#2-接收" class="headerlink" title="2. 接收"></a>2. 接收</h4><p>receive()方法从通道读取一个数据报包，放在一个ByteBuffer中。返回这个包的主机地址。</p>
<pre><code>public SocketAddress receive(ByteBuffer dst) throws IOException;
</code></pre><p>如果通道是阻塞的话，上面方法在读取到包之前不会返回。如果通道是非阻塞的话，没有包可以在读取的情况下该方法立即返回null。</p>
<h4 id="3-发送"><a href="#3-发送" class="headerlink" title="3. 发送"></a>3. 发送</h4><p>send()方法将一个数据报从ByteBuffer写入通道，要写到第二个参数指定的地址。</p>
<pre><code>public int send(ByteBuffer src, SocketAddress target) throws IOException;
</code></pre><blockquote>
<p>注意：如果希望向多个客户端发送相同的数据，可以重用源ByteBuffer。不过在之前需要将其回倒（rewind/flip()）。</p>
</blockquote>
<h4 id="4-连接"><a href="#4-连接" class="headerlink" title="4. 连接"></a>4. 连接</h4><p>我们在打开一个数据通道之后，能够通过connect()方法将它连接到一个特定的远程地址。</p>
<pre><code>SocketAddress address = new InetSocketAddress();
channel.connect(address);
</code></pre><h4 id="5-读取"><a href="#5-读取" class="headerlink" title="5. 读取"></a>5. 读取</h4><h4 id="6-写入"><a href="#6-写入" class="headerlink" title="6. 写入"></a>6. 写入</h4><p>选择TCP通道与选择数据报通道之间有一个主要区别。因为数据报通道实际上是无连接的（尽管有connect()方法），所以需要注意传输何时结束何时关闭。</p>
<h4 id="7-关闭"><a href="#7-关闭" class="headerlink" title="7. 关闭"></a>7. 关闭</h4><p>在结束操作时关闭通道，释放其占用的端口和其它资源。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>URLConnection</title>
    <url>/undefined/URLConnection/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>URLConnection类是抽象类，表示指向URL指定资源的活动连接。URLConnection 可以检查服务器发送的首部，并相应的做出响应。它可以设置客户端请求使用的首部字段。</p>
<h4 id="读取服务器数据"><a href="#读取服务器数据" class="headerlink" title="读取服务器数据"></a>读取服务器数据</h4><p>URLConnection对象从一个URL获取数据的步骤：</p>
<pre><code>1. 构造一个URL对象

2. 调用这个URL对象的openConnection()方法，获取对应URL的URLConnection对象

3. 调用这个URLConnection的getInputStream()方法

4. 使用通常的流api读取输入流
</code></pre><blockquote>
<p>提示：URL类的openStream()方法只是从它自己的URLConnection对象返回一个InputStream。输出也是如此。</p>
</blockquote>
<blockquote>
<blockquote>
<p>URL类于URLConnection类的区别：1. URLConnection类提供对HTTP首部的访问。 2. URLConnection可以配置发送给服务器的请求参数。 3. URLConnection除了读取服务器数据外，还可以向服务器写入数据。</p>
</blockquote>
</blockquote>
<h4 id="读取首部"><a href="#读取首部" class="headerlink" title="读取首部"></a>读取首部</h4><p>HTTP服务器每个响应前面的首部中提供大量信息。</p>
<h4 id="向服务器写入数据"><a href="#向服务器写入数据" class="headerlink" title="向服务器写入数据"></a>向服务器写入数据</h4><p>向URLConnection写入数据。getOutputStream()方法返回一个OutputStream，可以用来写入数据传给服务器。</p>
<pre><code>public OutputStream getOutputStream();
</code></pre><p>由于URLConnection默认情况下不允许输出，所以在请求输出流之前必须调用setDoOutput(true)。将一个 http URL 的 doOutput()方法设置为true时，请求方法由get变成post。</p>
<h4 id="HTTPURLConnection"><a href="#HTTPURLConnection" class="headerlink" title="HTTPURLConnection"></a>HTTPURLConnection</h4>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>word - util</title>
    <url>/undefined/WordUtil/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>这个工具的目的在于下载.doc文档</p>
<pre><code>package cn.edu.xidian.see.util;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.InputStream;

/**
 * Windows Word
 * Created by llq on 2017/2/21.
 */
public class WordUtil {

    public static void download(HttpServletResponse response, InputStream in,
                                String downloadFileName) throws Exception {
        BufferedInputStream bis;
        BufferedOutputStream bos;

        response.reset();
        response.setContentType(&quot;application/msword;charset=utf-8&quot;);
        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;
                + new String((downloadFileName + &quot;.doc&quot;).getBytes(), &quot;iso-8859-1&quot;));
        ServletOutputStream out = response.getOutputStream();

        bis = new BufferedInputStream(in);
        bos = new BufferedOutputStream(out);
        byte[] buff = new byte[1024];
        int readlen = 0;
        while ((readlen = bis.read(buff, 0, buff.length)) != -1) {
            bos.write(buff, 0, readlen);
        }

        bis.close();
        bos.close();
    }

}
</code></pre>]]></content>
      <categories>
        <category>util</category>
      </categories>
      <tags>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/undefined/ZooKeeper/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>zookeeper是开源的分布式协调服务，其设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单的接口提供给用户使用。</p>
<blockquote>
<p>原语，操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<p>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<p>Zookeeper 一个最常用的使用场景就是 ==用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)==。</p>
<p>服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo架构中 Zookeeper 就担任了注册中心这一角色。</p>
<h3 id="ZooKeeper-功能"><a href="#ZooKeeper-功能" class="headerlink" title="ZooKeeper 功能"></a>ZooKeeper 功能</h3><p>在项目中，主要使用ZooKeeper作为Dubbo的注册中心（Dubbo官方推荐使用ZooKeeper注册中心）。</p>
<h3 id="ZooKeeper-的典型应用场景-发布订阅功能的作用"><a href="#ZooKeeper-的典型应用场景-发布订阅功能的作用" class="headerlink" title="==ZooKeeper 的典型应用场景 发布订阅功能的作用=="></a>==ZooKeeper 的典型应用场景 发布订阅功能的作用==</h3><p>我们知道ZK的典型应用场景之一就是“发布订阅服务”。利用“发布订阅服务”实现两种常见的功能：</p>
<pre><code>1. 作为配置中心

2. 作为Dubbo的注册中心，也就是发布订阅中心
</code></pre><h4 id="1-作为配置中心"><a href="#1-作为配置中心" class="headerlink" title="1. 作为配置中心"></a>1. 作为配置中心</h4><p>很多时候我们相同的程序可能部署在多台机器上提升性能，不同的程序也可能有相同的配置文件。如果我们每次修改配置文件，都要一个一个机器修改的话，那么必定非常麻烦。</p>
<p>我们可以考虑把应用配置放到 ZooKeeper 上去，也就是保存在 Zookeeper 的某个目录节点中，我们对指定的节点设置一个 Watcher 监听 。</p>
<p>这样做的好处就是：一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后可以从 Zookeeper 获取新的配置信息应用到系统中就好。</p>
<p>ZooKeeper 中利用 Watcher 机制实现分布式通知功能，Zookeeper 允许 ==客户端向服务端注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知==来实现分布式的通知功能。</p>
<h4 id="2-作为-Dubbo-的注册中心"><a href="#2-作为-Dubbo-的注册中心" class="headerlink" title="2. 作为 Dubbo 的注册中心"></a>2. 作为 Dubbo 的注册中心</h4><p>Zookeeper 一个非常==常用的使用场景就是用于担任服务生产者和服务消费者的注册中心提供发布订阅服务==。</p>
<p>服务生产者将自己提供的服务注册到 Zookeeper 的一个或一系列节点上去，服务的消费者在进行服务调用的时候先到 Zookeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</p>
<h3 id="ZooKeeper-工作机制"><a href="#ZooKeeper-工作机制" class="headerlink" title="ZooKeeper 工作机制"></a>ZooKeeper 工作机制</h3><p>ZooKeeper从设计模式角度理解是一个基于观察者模式的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦数据的状态发生变化，ZooKeeper将负责通知已经在ZooKeeper上注册的那些观察者做出相应的反应。</p>
<pre><code>1. 服务端启动时去zookeeper集群注册信息（创建都是临时节点）

2. 客户端获取当前在线服务器列表，并且注册监听

3. 服务器节点下线

4. 集群通知客户端服务器节点上下线事件通知

5. 重新获取服务器列表，并注册监听
</code></pre><blockquote>
<p>提示：ZooKeeper等于文件系统和通知机制。</p>
</blockquote>
<h3 id="ZooKeeper-特点"><a href="#ZooKeeper-特点" class="headerlink" title="ZooKeeper 特点"></a>ZooKeeper 特点</h3><ul>
<li>一个领导者，多个跟随者组成的集群</li>
<li>集群中只要有半数以上的节点存活，ZooKeeper就能够正常服务</li>
<li>全局数据一致，每个Server保存一份相同的数据副本，客户端无论连接到哪个Server，数据都是一致的</li>
<li>更新请求顺序进行，来自同一个客户端的更新请求按其发送顺序依次执行</li>
<li>数据更新原子性，一个数据更新要么成功，要么失败</li>
<li>实时性，在一定时间范围之内，客户端能读到最新数据</li>
<li></li>
<li><p>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</p>
</li>
<li>原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li>单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li>可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h3 id="ZooKeeper-数据结构"><a href="#ZooKeeper-数据结构" class="headerlink" title="ZooKeeper 数据结构"></a>ZooKeeper 数据结构</h3><p>ZooKeeper数据模型的结构与Unix文件系统类似，整体可以看做是一棵树，每个节点称作ZNode。每个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p>
<h3 id="zookeeper-数据模型和常见命令"><a href="#zookeeper-数据模型和常见命令" class="headerlink" title="zookeeper 数据模型和常见命令"></a>zookeeper 数据模型和常见命令</h3><p>ZNode（数据节点）是 ZooKeeper 中数据的最小单元，每个ZNode上都可以保存数据，同时还是可以有子节点（这就像树结构一样）。</p>
<p>节点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用斜杠”/“进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。</p>
<p>在ZooKeeper数据模型中，不得不提的概念就是 ==事务ID== 。事务的ACID四大特性等。</p>
<p>在Zookeeper中，事务是指能够改变 ZooKeeper 服务器状态的操作，我们也称之为事务操作或更新操作，一般包括数据节点创建与删除、数据节点内容更新和客户端会话创建与失效等操作</p>
<p>==对于每一个事务请求，ZooKeeper 都会为其分配一个全局唯一的事务ID，用 ZXID 来表示，通常是一个64位的数字。== 每一个ZXID对应一次更新操作，==从这些 ZXID 中可以间接地识别出Zookeeper处理这些更新操作请求的全局顺序==。</p>
<h4 id="ZNode（数据节点）的结构"><a href="#ZNode（数据节点）的结构" class="headerlink" title="ZNode（数据节点）的结构"></a>ZNode（数据节点）的结构</h4><p>每个ZNode节点都由两部分组成：</p>
<pre><code>1. stat：状态信息

2. data：数据内容
</code></pre><h5 id="1-stat类（状态信息的各个字段说明）"><a href="#1-stat类（状态信息的各个字段说明）" class="headerlink" title="1. stat类（状态信息的各个字段说明）"></a>1. stat类（状态信息的各个字段说明）</h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sDvmSABenhfp0ZJVbCah4VEIJRkbBrMgia6cHYcxTAK7kHCd1pXH8iaVPucmAvd2LzsUibjQ5oM0Z4rQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>提供的服务包括，统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<h4 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h4><p>在分布式环境中，经常需要对应用/服务进行统一命名，便于识别。</p>
<h4 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h4><p>在ZooKeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。</p>
<h3 id="ZooKeeper-概念总结"><a href="#ZooKeeper-概念总结" class="headerlink" title="ZooKeeper 概念总结"></a>ZooKeeper 概念总结</h3><p>==ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。==</p>
<p>==为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。==</p>
<p>==ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。==</p>
<p>==ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）==</p>
<p>==ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。==</p>
<p>ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提供数据节点监听服务。</p>
<h4 id="2-会话（Session）"><a href="#2-会话（Session）" class="headerlink" title="2. 会话（Session）"></a>2. 会话（Session）</h4><p>Session 指的是 ZooKeeper 服务器与客户端会话，在 在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。</p>
<p>==通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 =</p>
<p>==Session的 sessionTimeout值 用来设置一个客户端会话的超时时间。== 当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，==只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。==</p>
<p>==在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。==</p>
<h4 id="3-ZNode"><a href="#3-ZNode" class="headerlink" title="3. ZNode"></a>3. ZNode</h4><p>==在说分布式时候，我们通常说的节点是指组成集群的每一台机器。== 然在ZooKeeper中，==节点分为两类，1. 同样是构成集群的机器，机器节点。2. 数据模型的数据单元，数据节点ZNode。==</p>
<p>Zookeeper 将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>
<p>在Zookeeper中，==node可以分为 持久节点 和 临时节点 两类==。所谓==持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上==。而==临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除==。</p>
<p>另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p>
<h4 id="4-版本"><a href="#4-版本" class="headerlink" title="4. 版本"></a>4. 版本</h4><p>在之前我们知道，ZooKeeper的每个ZNode上都会存储数据，对应每个ZNode，ZooKeeper都会为其维护一个叫做Stat的数据结构，==Stat中记录了这个ZNode的三个数据版本，分别是 version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和aversion（当前ZNode的ACL版本）。==</p>
<h4 id="5-Watcher"><a href="#5-Watcher" class="headerlink" title="5. Watcher"></a>5. Watcher</h4><p>==Watcher（事件监听器），是ZooKeeper的重要特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。==</p>
<h4 id="6-ACL"><a href="#6-ACL" class="headerlink" title="6. ACL"></a>6. ACL</h4><p>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下5种权限。</p>
<pre><code>1. CREATE 创建子节点权限

2. READ 获取节点数据和子节点列表的权限

3. WRITE 更新节点数据的权限

4. DELETE 删除子节点的权限

5. ADMIN 设置节点ACL的权限
</code></pre><blockquote>
<p>注意：CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。</p>
</blockquote>
<h3 id="ZooKeeper-设计目标"><a href="#ZooKeeper-设计目标" class="headerlink" title="ZooKeeper 设计目标"></a>ZooKeeper 设计目标</h3><h4 id="1-简单的数据模型"><a href="#1-简单的数据模型" class="headerlink" title="1. 简单的数据模型"></a>1. 简单的数据模型</h4><p>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。</p>
<p>名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录。</p>
<p>与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</p>
<h4 id="2-可构建集群"><a href="#2-可构建集群" class="headerlink" title="2. 可构建集群"></a>2. 可构建集群</h4><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。 </p>
<p>客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</p>
<blockquote>
<p>提示：集群之间通过 ==Zab协议== 来保持数据的一致性。</p>
</blockquote>
<h4 id="3-顺序访问"><a href="#3-顺序访问" class="headerlink" title="3. 顺序访问"></a>3. 顺序访问</h4><p>==对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用ZooKeeper这个特性来实现更高层次的同步原语。这个编号也叫做时间戳（zxid）。==</p>
<h4 id="4-高性能"><a href="#4-高性能" class="headerlink" title="4. 高性能"></a>4. 高性能</h4><p>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</p>
<h3 id="ZooKeeper-集群角色"><a href="#ZooKeeper-集群角色" class="headerlink" title="ZooKeeper 集群角色"></a>ZooKeeper 集群角色</h3><p>==最典型的集群模式：Master/Slave（主备模式）==，在这种模式种，通常Master服务器作为主服务器提供写服务，其它的Slave服务器从主服务器中通过异步复制的方式获取Master服务器最新的数据提供读服务。</p>
<p>==在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色。==</p>
<p>==ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务==。</p>
<p>==除了 Leader 外，Follower 和 Observer 都只能提供读服务。== Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/ce590587caccd26adf46e2060b2107aa.jpg" alt="image"></p>
<p>==当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。这个过程大致如下：==</p>
<pre><code>1. Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。

2. Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。

3. Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准 leader 才会成为真正的 leader。

4. Broadcast（广播阶段）：到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。
</code></pre><h2 id="ZooKeeper内部原理"><a href="#ZooKeeper内部原理" class="headerlink" title="ZooKeeper内部原理"></a>ZooKeeper内部原理</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><ul>
<li>半数机制，集群中半数以上机器存活，集群可用。所以ZooKeeper适合安装奇数台服务器。</li>
<li>ZooKeeper虽然在配置文件中并没有指定Master和Slave，但是ZooKeeper工作时，是由一个节点为Leader，其它为Follower，Leader是通过内部的选举机制临时产生的。</li>
<li></li>
</ul>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>持久型，客户端与服务器断开连接后，创建的节点不删除</li>
<li>短暂，客户端与服务器断开连接后，创建的节点自己删除</li>
<li></li>
</ul>
<ol>
<li>持久化目录节点，在客户端与ZooKeeper断开连接之后，该节点依旧存在。</li>
<li>持久化顺序编号目录节点，客户端与ZooKeeper断开连接后，该节点依旧存在，只是ZooKeeper给该节点名称进行顺序编号。</li>
</ol>
<blockquote>
<p>说明：创建ZNode时设置顺序标识，ZNode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。</p>
</blockquote>
<blockquote>
<p>注意：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</p>
</blockquote>
<ol start="3">
<li>临时目录节点，客户端与ZooKeeper断开连接后，该节点被删除 </li>
<li>临时顺序编号目录节点，客户端与ZooKeeper断开连接后，该节点被删除，只是ZooKeeper给该节点名称进行顺序编号。</li>
</ol>
<h3 id="Zab协议-Paxos算法"><a href="#Zab协议-Paxos算法" class="headerlink" title="Zab协议 | Paxos算法"></a>Zab协议 | Paxos算法</h3><p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但 ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h4 id="1-ZAB-协议"><a href="#1-ZAB-协议" class="headerlink" title="1. ZAB 协议"></a>1. ZAB 协议</h4><p>==ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。==</p>
<h4 id="2-ZAB-协议两种基本的模式（崩溃恢复和消息广播）"><a href="#2-ZAB-协议两种基本的模式（崩溃恢复和消息广播）" class="headerlink" title="2. ZAB 协议两种基本的模式（崩溃恢复和消息广播）"></a>2. ZAB 协议两种基本的模式（崩溃恢复和消息广播）</h4><p>在整个服务框架启动过程中或是当 Leader 服务器出现故障情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。</p>
<p>在选举产生新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成 状态同步 之后，ZAB协议就会退出恢复模式。</p>
<blockquote>
<p>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p>
</blockquote>
<p>==当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式。==</p>
<p>当一台服务器启动后加入集群，如果已经存在Leader服务器进行消息广播，那么新加入服务器会自觉进入数据恢复模式，找到Leader服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>
<blockquote>
<p>ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。</p>
</blockquote>
<p>Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p>
<hr>
<h2 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h2><h3 id="本地模式安装部署"><a href="#本地模式安装部署" class="headerlink" title="本地模式安装部署"></a>本地模式安装部署</h3><h3 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h3><h2 id="ZooKeeper实战"><a href="#ZooKeeper实战" class="headerlink" title="ZooKeeper实战"></a>ZooKeeper实战</h2><h3 id="分布式安装部署"><a href="#分布式安装部署" class="headerlink" title="分布式安装部署"></a>分布式安装部署</h3><h3 id="测试-ZooKeeper-中的常见操作"><a href="#测试-ZooKeeper-中的常见操作" class="headerlink" title="测试 ZooKeeper 中的常见操作"></a>测试 ZooKeeper 中的常见操作</h3><h4 id="1-连接-ZooKeeper-服务"><a href="#1-连接-ZooKeeper-服务" class="headerlink" title="1. 连接 ZooKeeper 服务"></a>1. 连接 ZooKeeper 服务</h4><pre><code>./zkCli.sh -server 127.0.0.1:2181
</code></pre><h4 id="2-常看常用命令（help命令）"><a href="#2-常看常用命令（help命令）" class="headerlink" title="2. 常看常用命令（help命令）"></a>2. 常看常用命令（help命令）</h4><pre><code>help
</code></pre><h4 id="3-其它命令"><a href="#3-其它命令" class="headerlink" title="3. 其它命令"></a>3. 其它命令</h4><pre><code>1. ls 

2. stat 查看节点状态

3. ls2 查看节点信息与状态

4. delete 删除节点，如果需要删除某一个节点，那么此节点必须没子节点才行

5. set 更新节点数据内容

6. get 获取指定节点的数据内容和节点的状态
</code></pre>]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis generator 详细配置</title>
    <url>/undefined/mybatis%20generator%20%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;!-- 配置生成器 --&gt;
&lt;generatorConfiguration&gt;
&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项
    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        
    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.
    注意，两个属性只能选址一个;
    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用
&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;
 --&gt;

 &lt;!-- 在MBG工作的时候，需要额外加载的依赖包
     location属性指明加载jar/zip包的全路径
&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;
  --&gt;

&lt;!-- 
    context:生成一组对象的环境 
    id:必选，上下文id，用于在生成错误时提示
    defaultModelType:指定生成对象的样式
        1，conditional：类似hierarchical；
        2，flat：所有内容（主键，blob）等全部生成在一个对象中；
        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)
    targetRuntime:
        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；
        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；
    introspectedColumnImpl：类全限定名，用于扩展MBG
--&gt;
&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;

    &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；
        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖
     --&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;
    &lt;!-- 生成的Java文件的编码 --&gt;
    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;!-- 格式化java代码 --&gt;
    &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
    &lt;!-- 格式化XML代码 --&gt;
    &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;

    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

    &lt;!-- 必须要有的，使用这个配置链接数据库
        @TODO:是否可以扩展
     --&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;
        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;
    &lt;/jdbcConnection&gt;

    &lt;!-- java类型处理器 
        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；
        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； 
    --&gt;
    &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
        &lt;!-- 
            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型
            false：默认,
                scale&gt;0;length&gt;18：使用BigDecimal;
                scale=0;length[10,18]：使用Long；
                scale=0;length[5,9]：使用Integer；
                scale=0;length&lt;5：使用Short；
         --&gt;
        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;


    &lt;!-- java模型创建器，是必须要的元素
        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类
        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；
        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录
     --&gt;
    &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!--  for MyBatis3/MyBatis3Simple
            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
         --&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- for MyBatis3 / MyBatis3Simple
            是否创建一个不可变的类，如果为true，
            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类
         --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 设置一个根对象，
            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项
            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：
                1，属性名相同，类型相同，有相同的getter/setter方法；
         --&gt;
        &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;

        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
    &lt;/javaModelGenerator&gt;


    &lt;!-- 生成SQL map的XML文件生成器，
        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），
            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置
        targetPackage/targetProject:同javaModelGenerator
     --&gt;
    &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;


    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 
        targetPackage/targetProject:同javaModelGenerator
        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：
            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；
            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；
            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；
        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER
    --&gt;
    &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
         --&gt;
    &lt;/javaClientGenerator&gt;

    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素
        选择的table会生成一下文件：
        1，SQL map文件
        2，生成一个主键类；
        3，除了BLOB和主键的其他字段的类；
        4，包含BLOB的类；
        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；
        6，Mapper接口（可选）
        tableName（必要）：要生成对象的表名；
        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会
            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：
            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；
            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；
            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；
            4，否则，使用指定的大小写格式查询；
        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；
        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；
        可选：
        1，schema：数据库的schema；
        2，catalog：数据库的catalog；
        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName
        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；
        5，enableInsert（默认true）：指定是否生成insert语句；
        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；
        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；
        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；
        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；
        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；
        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；
        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；
        13，modelType：参考context元素的defaultModelType，相当于覆盖；
        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）
        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性
        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；
     --&gt;
    &lt;table tableName=&quot;userinfo&quot; &gt;

        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;
        &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;
        &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 
        &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog 
        &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema 
        &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename 
        &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；
            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；
         --&gt;
        &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;

        &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;
        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;


        &lt;!-- generatedKey用于生成生成主键的方法，
            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选
            column:主键的列名；
            sqlStatement：要生成的selectKey语句，有以下可选项：
                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1
                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()
                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()
                Informix  :相当于selectKey的SQL为：select dbinfo(&apos;sqlca.sqlerrd1&apos;) from systables where tabid=1
                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()
                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()
                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY
                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性
        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 
            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，
            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；
            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是
            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；
            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，
            如果使用了columnOverride元素，该属性无效；
        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;
         --&gt;


         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；
             column:要重新设置的列名；
             注意，一个table元素中可以有多个columnOverride元素哈~
          --&gt;
         &lt;columnOverride column=&quot;username&quot;&gt;
             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;
             &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;

             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名
             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- jdbcType用于指定该列的JDBC类型 
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名
                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler
                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
             --&gt;

             &lt;!-- 参考table元素的delimitAllColumns配置，默认为false
             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;
              --&gt;
         &lt;/columnOverride&gt;

         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 
             column:指定要忽略的列的名字；
             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false
             注意，一个table元素中可以有多个ignoreColumn元素
         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;
         --&gt;
    &lt;/table&gt;

&lt;/context&gt;

&lt;/generatorConfiguration&gt;
</code></pre><hr>
<h4 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h4><pre><code>1.xml文件

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;mysqlgenerator&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
        &lt;jdbcConnection connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/hisen&quot;
                        driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        password=&quot;root&quot;
                        userId=&quot;hisen&quot;/&gt;
        &lt;!--生成Model(实体类，与数据库字段对应的bean)类存放位置--&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.hisen.entity&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
        &lt;/javaModelGenerator&gt;
        &lt;!--生成映射(xxxmapper.xml)文件存放位置--&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/sqlMapGenerator&gt;
        &lt;!--生成Dao类存放位置--&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.hisen.mapper&quot;
                             targetProject=&quot;src/main/java&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/javaClientGenerator&gt;

        &lt;table tableName=&quot;appointment&quot;/&gt;
        &lt;table tableName=&quot;user&quot;/&gt;
        &lt;table tableName=&quot;user_info&quot;/&gt;

    &lt;/context&gt;

&lt;/generatorConfiguration&gt;
</code></pre><blockquote>
<p>提示：这里需要特别注意<table tablename="">，这个对应着数据库中的数据表的。想生成哪个就这个数据表名称填上去。</table></p>
</blockquote>
<pre><code>2.pom.xml

&lt;plugin&gt;
  &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.5&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;configuration&gt;
    &lt;overwrite&gt;true&lt;/overwrite&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 注解</title>
    <url>/undefined/mybatis-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Mybatis框架基于注解"><a href="#Mybatis框架基于注解" class="headerlink" title="Mybatis框架基于注解"></a>Mybatis框架基于注解</h2><p>在mybatis框架下基于注解方式实现对现有数据的增删改查操作。</p>
<p>[TOC]</p>
<h4 id="1-建立配置文件-conf-xml"><a href="#1-建立配置文件-conf-xml" class="headerlink" title="1.建立配置文件(conf.xml)"></a>1.建立配置文件(conf.xml)</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 
    environments:开发模式
    work:工作模式
    default=&quot;development&quot;，id=&quot;development&quot;，两个的属性值必须一致
     --&gt;    
     &lt;environments default=&quot;development&quot;&gt;
         &lt;environment id=&quot;development&quot;&gt;
             &lt;transactionManager type=&quot;JDBC&quot;/&gt;
             &lt;dataSource type=&quot;POOLED&quot;&gt;
                 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                 &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;
                 &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                 &lt;property name=&quot;password&quot; value=&quot;lxn123&quot;/&gt;
             &lt;/dataSource&gt;    
         &lt;/environment&gt;
     &lt;/environments&gt;

     &lt;!-- 在配置文件中 关联包下的 接口类--&gt;
     &lt;mappers&gt;
         &lt;mapper class=&quot;com.atguigu.mybatis.test3.UserMapper&quot;/&gt;
     &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><h4 id="2-建立接口"><a href="#2-建立接口" class="headerlink" title="2.建立接口"></a>2.建立接口</h4><p>因为这是基于注解的方式实现，所以在定义方法上配置应用的注解，注解中含有sql语句，需要提示的是这个接口不需要类去实现它。</p>
<pre><code>package com.atguigu.mybatis.test3;

import java.util.List;

import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.Update;

import com.atguigu.mybatis.test.User;

public interface UserMapper {

    /*
     * 这是基于注解的映射方式，实现对数据的增删改查，将sql语句直接写在注解的括号中
     * 这是一个接口，其不需要类去实现它
     * 下边分别是插入，删除，修改，查询一个记录，查询所有的记录
     * */

    @Insert(&quot;insert into users(name,age) values(#{name},#{age})&quot;)
    public void insertT(User user);

    @Delete(&quot;delete from users where id=#{id}&quot;)
    public void deleteById(int id);

    @Update(&quot;update users set name=#{name},age=#{age} where id=#{id}&quot;)
    public void updateT(User user);

    @Select(&quot;select * from users where id=#{id}&quot;)
    public User getUser(int id);

    @Select(&quot;select * from users&quot;)
    public List&lt;User&gt; getAllUsers();
}
</code></pre><h4 id="3-主体-entity"><a href="#3-主体-entity" class="headerlink" title="3.主体(entity)"></a>3.主体(entity)</h4><p>这里的案例写的是一个用户User，包括了用户的id/name/age等几个属性，然后需要给出实现它的getter/setter方法以及toString()方法。</p>
<h4 id="4-创建MybatisUtils类-加载和构建sqlSession"><a href="#4-创建MybatisUtils类-加载和构建sqlSession" class="headerlink" title="4.创建MybatisUtils类(加载和构建sqlSession)"></a>4.创建MybatisUtils类(加载和构建sqlSession)</h4><pre><code>package com.atguigu.mybatis.test;

import java.io.InputStream;

import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class MybatisUtils {
    public static SqlSessionFactory getFactory(){
        String resource=&quot;conf.xml&quot;;

        //加载mybatis 的配置文件（它也加载关联的映射文件）
        InputStream is=MybatisUtils.class.getClassLoader().getResourceAsStream(resource);

        //构建sqlSession 的工厂
        SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(is);
        return factory;
    }
}
</code></pre><h4 id="5-测试类文件"><a href="#5-测试类文件" class="headerlink" title="5.测试类文件"></a>5.测试类文件</h4><p>这些测试类文件表示分别测试在实现过程中的数据的增删改查等操作。</p>
<pre><code>package com.atguigu.mybatis.test3;

import java.util.List;

import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.junit.Test;

import com.atguigu.mybatis.test.MybatisUtils;
import com.atguigu.mybatis.test.User;

public class UserMapperTest {

    @Test
    //插入数据
    public void testInsert(){
        SqlSessionFactory factory=MybatisUtils.getFactory();
        SqlSession session=factory.openSession(true);
        //使用反射的方法
        UserMapper mapper=session.getMapper(UserMapper.class);
        mapper.insertT(new User(-1, &quot;p&quot;, 4));

        session.close();
    }

    @Test
    //删除数据
    public void testDelete(){
        SqlSessionFactory factory=MybatisUtils.getFactory();
        SqlSession session=factory.openSession(true);
        UserMapper mapper=session.getMapper(UserMapper.class);
        mapper.deleteById(1);
        session.close();
    }

    @Test
    //修改数据
    public void testUpdate(){
        SqlSessionFactory factory=MybatisUtils.getFactory();
        SqlSession session=factory.openSession(true);
        UserMapper mapper=session.getMapper(UserMapper.class);
        mapper.updateT(new User(2, &quot;jjjjj&quot;, 232));
        session.close();
    }

    @Test
    //获取一条数据
    public void testGetUser(){
        SqlSessionFactory factory=MybatisUtils.getFactory();
        SqlSession session=factory.openSession(true);
        UserMapper mapper=session.getMapper(UserMapper.class);
        User user=mapper.getUser(2);
        session.close();
        System.out.println(user);
    }

    @Test
    //获取所有数据
    public void testGetAllUsers(){
        SqlSessionFactory factory=MybatisUtils.getFactory();
        SqlSession session=factory.openSession(true);
        UserMapper mapper=session.getMapper(UserMapper.class);
        List&lt;User&gt; users=mapper.getAllUsers();

        session.close();
        System.out.println(users);
    }
}
</code></pre>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Response Request</title>
    <url>/undefined/request%20response/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-response"><a href="#1-response" class="headerlink" title="1.response"></a>1.response</h2><h4 id="1-输出数据"><a href="#1-输出数据" class="headerlink" title="1.输出数据"></a>1.输出数据</h4><p>程序以什么码表输出，就需要控制浏览器以什么码表打开，所以有两种方式控制浏览器以什么码表打开页面：</p>
<pre><code>1.response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;);//设置网页显示打开的的编码方式
2.response.setContentType(&quot;text/html;charset=utf-8&quot;);//默认调用setHeader和setCharacterEncoding
</code></pre><blockquote>
<p>注意：使用HTML技术中的<meta>标签可以模拟一个http响应头 <code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</code></p>
<blockquote>
<p>注意：response可以使用setCharacterEncoding方法设置码表。字符流输出：PrintWritet-&gt;response-&gt;浏览器,response-&gt;浏览器默认使用iso-8859编码。</p>
</blockquote>
</blockquote>
<h4 id="2-文件下载"><a href="#2-文件下载" class="headerlink" title="2.文件下载"></a>2.文件下载</h4><p>1.首先使用ServerContext的getRealPath()方法，然后再使用InputStream和OutputStream流类文件进行文件下载操作，同时需要注意，当下载文件是中文名，那么需要经过URL编码URLEncoding.encode进行编码。</p>
<h4 id="3-随机图片"><a href="#3-随机图片" class="headerlink" title="3.随机图片"></a>3.随机图片</h4><p>1.使用BufferedImage在内存生成图片，再使用ImageIO输出。2.画图使用Graphics,旋转使用Graphics2D。3.汉字的区间：\u4e00-\u9fa5 。</p>
<h4 id="4-刷新与缓存"><a href="#4-刷新与缓存" class="headerlink" title="4.刷新与缓存"></a>4.刷新与缓存</h4><pre><code>1.刷新：使用刷新操作，一般我们不在servlet里加refresh头，而是在jsp中加入&lt;meta&gt;头模拟。
2.缓存：加入expires头，当前时间+要缓存的时长
</code></pre><h4 id="5-请求重定向"><a href="#5-请求重定向" class="headerlink" title="5.请求重定向"></a>5.请求重定向</h4><pre><code>1.重定向：只需要设置状态码和 location 头，或者直接使用response的setRedirect方法，向服务器两次请求。浏览器会改变地址栏，一般使用于登录、购物等场景。

2.转发:调用ServletContex对象的getRequestDispatcher方法，再调用forward方法。向服务器一次请求，浏览器地址栏不变。
</code></pre><blockquote>
<p>注意：1.getOutputStream和getWriter方法跟别用于输出二进制数据、输出文本数据的ServletOutputStream、Printwriter对象，这两个方法相互排斥，只能调用其中一个，否则抛IllegalStateException异常。2.response的输出流会自己关闭。Servlet的service方法结束后，Servlet引擎会检查并调用close方法关闭该输出流对象。</p>
</blockquote>
<h2 id="2-request"><a href="#2-request" class="headerlink" title="2.request"></a>2.request</h2><h4 id="1-两个名词解释："><a href="#1-两个名词解释：" class="headerlink" title="1.两个名词解释："></a>1.两个名词解释：</h4><pre><code>1.URI:标识某个资源
2.URL:标识互联网上某个资源
</code></pre><h4 id="2-方法："><a href="#2-方法：" class="headerlink" title="2.方法："></a>2.方法：</h4><pre><code>1.getRequestURI用于权限拦截，访问统计
2.getRemoteAddr用于得到客户机IP地址
3.getMethod得到客户机请求方式
</code></pre><h4 id="3-request对象获取数据的四种方式："><a href="#3-request对象获取数据的四种方式：" class="headerlink" title="3.request对象获取数据的四种方式："></a>3.request对象获取数据的四种方式：</h4><pre><code>1.getParameter
2.getParameterNames
3.getParameterValues
4.getParameterMap(可结合JavaBean使用) (getInputStream用于文件上传)
</code></pre><h4 id="4-中文乱码："><a href="#4-中文乱码：" class="headerlink" title="4.中文乱码："></a>4.中文乱码：</h4><p>URL后面如果有中文数据，需要编码后再提交。表单提交的数据使用的码表和该页面的码表一致，而getParameter方法默认使用ISO-8859码表。</p>
<p>解决方案：</p>
<pre><code>1.对于post提交的数据，在获取数据前要使用request对象的setCharacterEncoding设置码表。
2.对于get提交的数据，只能手工解决。先对数据调用getBytes(&quot;ISO-8859-1&quot;)获取二进制字节，再用特定码表构建字符串。
3.超链提交的中文，解决办法同get提交的数据。
</code></pre><p>或者可以通过改服务器配置来解决乱码问题，但一般不建议使用。</p>
<pre><code>1.URIEncoding:改tomcat的配置文件conf/server.xml的连接器&lt;Connector&gt;中的URIEncoding属性

2.useBodyEncodingForURI:将conf/server.xml的连接器&lt;Connector&gt;中的useBodyEncodingForURI置为true
</code></pre><h4 id="5-请求转发-应用场景：mvc设计模式"><a href="#5-请求转发-应用场景：mvc设计模式" class="headerlink" title="5.请求转发(应用场景：mvc设计模式)"></a>5.请求转发(应用场景：mvc设计模式)</h4><pre><code>model : javabean;
view : jsp;
controller : servlet
</code></pre><blockquote>
<p>使用request域对象把数据带给转发资源。调用request对象的getRequestDispatcher方法，再调用forward方法。一次请求，浏览器地址栏不变。</p>
</blockquote>
<p><strong>forward 细节</strong></p>
<pre><code>1.不能在关闭输出流后再调用转发，也不能调用两次，否则会抛出异常。
2.跳转之前会清空response中的数据。即数据只是写入到缓冲区而没真正输出到客户端，则可调用forward方法，原来写入到缓冲区的内容被清空，但响应头字段信息保持。
3.include方法可以用于包含一些公共页面(一般不在servlet中包含)
</code></pre><h4 id="6-地址的写法"><a href="#6-地址的写法" class="headerlink" title="6.地址的写法"></a>6.地址的写法</h4><p>以斜杠/开头。如果是给服务器用，则/代表当前web应用；如果给浏览器用，则/代表网站。</p>
<p>例子:目录结构如下</p>
<pre><code>mail---------------------------Web应用所在目录
           |----form1.html
           |----WEB-INF目录
                    |---------classes目录
                    |---------lib目录
                    |---------web.xml

request.getRequestDispatcher(&quot;/form1.html&quot;)
response.sendRedirect(&quot;mail/form1.html&quot;)
this.getServletContext().getRealPath(&quot;/form1.html&quot;)
this.getServletContext().getResourceAsStream(&quot;/form1.html&quot;)
&lt;a href=&quot;/mail/form1.html&quot;&gt;
&lt;form action=&quot;/mail/form1.html&quot;&gt;
其中，1,3,4是给服务器用;2,5,6是浏览器用
</code></pre><h4 id="7-防盗链"><a href="#7-防盗链" class="headerlink" title="7.防盗链"></a>7.防盗链</h4><p>读取referer请求头，不合要求则重定向。</p>
]]></content>
      <categories>
        <category>Response Request</category>
      </categories>
      <tags>
        <tag>Response Request</tag>
      </tags>
  </entry>
  <entry>
    <title>thymeleaf 模板</title>
    <url>/undefined/thymeleaf%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="thymeleaf-模板"><a href="#thymeleaf-模板" class="headerlink" title="thymeleaf 模板"></a>thymeleaf 模板</h2><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre><code>1.引入标签：首先要在html标签里引入 xmlns:th=&quot;http://www.thymeleaf.org&quot; 才能使用th:*这样的语法。

2.获取变量值：通过在标签内部，使用 ${} 来取值，对于javaBean的话，使用 变量名.属性名 来获取，跟EL表达式一样
</code></pre><p>　　注意：只有写在标签内部才会生效，例如： th：text=“hello” 的意思是使用hello来代替p之前的内容，p里原来的值是为了给前端开发展示用的，这样做容易实现前后端分离。<br>　　<br>　　3.引入URL：thymeleaf对于引入URL是采用@{…}来获取的。例如：  <a th:href="@{http://www.baidu.com}">绝对路径</a> 是访问绝对路径下的URL， <a th:href="@{/}">相对路径</a>     是访问相对路径下的URL。<a th:href="@{css/bootstrap.min.css}">  是引入默认的static下的css文件夹下的bootstrap文件，类似的标签有: th:href 和 th:src 。<br>　　<br>　　4.字符串替换：<span th:text="'Welcome to our application, ' + ${user.name} + '!'"></span> 或者 <span th:text="|Welcome to our application, ${user.name}!|"></span>       都可以实现替换。注意：|…|中只能包含变量表达式${…}，不能包含其他常量、条件表达式等。<br>　　<br>　　5.循环：th：each是对于结果可以进行遍历的数据集。如：　<br>　　<br>　　    <tr th:each="prod : ${prods}"><br>　　        <td th:text="${prod.name}">Onions</td><br>　　        <td th:text="${prod.price}">2.41</td><br>　　    </tr>
　　    </a></p>
<h4 id="thymeleaf模版引擎"><a href="#thymeleaf模版引擎" class="headerlink" title="thymeleaf模版引擎"></a>thymeleaf模版引擎</h4><pre><code>表达式:
    ${java变量名称}  获取变量值
    @{路径}  :  自动添加context-path ,  自动加上工程名称
    ~{common/文件名 :: 要引入的内容ID}   ,代码片段表达式

属性:
    th:text : 输出文本到标签体内
    th:class: 动态修改样式
    th:href : 路径

条件表达式:
    th:if=&quot;${条件}&quot;  若条件成立,则显示当前元素,否则不显示

    th:switch=&quot;${值}&quot;
        th:case=&quot;xx&quot; 输出
        th:case=&quot;yy&quot; 输出
        th:case=&quot;*&quot;  默认处理方式

    三元运算符:
        ${条件} ? 条件成立 : 条件不成立

循环表达式:
    th:each=&quot;变量名 : ${集合}&quot;

    遍历页码: #numbers.sequence(起始值,结束值)

${history.red.split(&apos;,&apos;)[0]}
</code></pre><hr>
<h4 id="thymeleaf-案例"><a href="#thymeleaf-案例" class="headerlink" title="thymeleaf 案例"></a>thymeleaf 案例</h4><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; th:src=&quot;@{https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js}&quot;&gt;&lt;/script&gt;
    &lt;link th:href=&quot;@{https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css}&quot; rel=&quot;stylesheet&quot;/&gt;
    &lt;link th:href=&quot;@{/css/page.css}&quot; rel=&quot;stylesheet&quot;/&gt;
    &lt;link rel=&quot;icon&quot; th:href=&quot;@{/images/favicon.ico}&quot; type=&quot;image/x-icon&quot;/&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;用户管理&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div class=&quot;contentDiv&quot;&gt;

    &lt;h5&gt;用户管理&lt;/h5&gt;
    &lt;legend&gt;
        &lt;strong&gt;用户管理&lt;/strong&gt;
    &lt;/legend&gt;

    &lt;form th:action=&quot;&quot; method=&quot;post&quot; class=&quot;form-horizontal&quot;&gt;

        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;${user.id}&quot;/&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;username&quot; class=&quot;col-sm-2 control-label&quot;&gt;用户名:&lt;/label&gt;
            &lt;div class=&quot;col-xs-4&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot; th:value=&quot;${user.username}&quot;
                       th:field=&quot;*{user.username}&quot;/&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;book_writer&quot; class=&quot;col-sm-2 control-label&quot;&gt;作者:&lt;/label&gt;
            &lt;div class=&quot;col-xs-4&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;book_writer&quot; name=&quot;writer&quot; th:value=&quot;${book.writer}&quot;
                       th:field=&quot;*{book.writer}&quot;/&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;book_introduction&quot; class=&quot;col-sm-2 control-label&quot;&gt;简介:&lt;/label&gt;
            &lt;div class=&quot;col-xs-4&quot;&gt;
                &lt;textarea class=&quot;form-control&quot; id=&quot;book_introduction&quot; rows=&quot;3&quot; name=&quot;introduction&quot;
                          th:value=&quot;${book.introduction}&quot; th:field=&quot;*{book.introduction}&quot;&gt;&lt;/textarea&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt;
                &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&amp;nbsp;&amp;nbsp;
                &lt;input class=&quot;btn&quot; type=&quot;button&quot; value=&quot;返回&quot; onclick=&quot;history.back()&quot;/&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot; xmls:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
  &lt;script type=&quot;text/javascript&quot; th:src=&quot;@{https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js}&quot;&gt;&lt;/script&gt;
  &lt;link href=&quot;@{https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css}&quot; rel=&quot;stylesheet&quot;&gt;
  &lt;link th:href=&quot;@{/css/page.css}&quot; rel=&quot;stylesheet&quot;/&gt;
  &lt;link rel=&quot;icon&quot; th:href=&quot;@{/images/favicon.ico}&quot; type=&quot;image/x-icon&quot;/&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;用户列表&lt;/title&gt;
&lt;/head&gt;

&lt;body class=&quot;contentDiv&quot;&gt;
    &lt;h5&gt;用户列表&lt;/h5&gt;
    &lt;table class=&quot;table table-hover table-condensed&quot;&gt;
        &lt;legend&gt;
            &lt;strong&gt;用户列表&lt;/strong&gt;
        &lt;/legend&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;编号&lt;/th&gt;
            &lt;th&gt;账户&lt;/th&gt;
            &lt;th&gt;地址&lt;/th&gt;
            &lt;th&gt;电话&lt;/th&gt;
            &lt;th&gt;姓名&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr th:each=&quot;user: ${userList}&quot;&gt;
                &lt;th scope=&quot;row&quot; th:text=&quot;${user.id}&quot;/&gt;
                &lt;td th:text=&quot;${user.account}&quot;&gt;&lt;/td&gt;
                &lt;td th:text=&quot;${user.address}&quot;&gt;&lt;/td&gt;
                &lt;td th:text=&quot;${user.phone}&quot;&gt;&lt;/td&gt;
                &lt;td th:text=&quot;${user.userName}&quot;&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;div&gt;&lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot; role=&quot;button&quot;&gt;新增用户&lt;/a&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
      <categories>
        <category>thymeleaf 模板</category>
      </categories>
      <tags>
        <tag>thymeleaf 模板</tag>
      </tags>
  </entry>
  <entry>
    <title>WebService</title>
    <url>/undefined/webservice/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="1-WebService概念"><a href="#1-WebService概念" class="headerlink" title="1.WebService概念"></a>1.WebService概念</h4><p>WebService 是web服务，它是一种跨编程语言和跨操作系统平台的远程调用技术即跨平台远程调用技术。采用标准SOAP(Simple Object Access Protocol)协议传输，soap属于w3c标准。Soap协议是基于http的应用层协议，soap协议传输是xml数据。采用wsdl作为描述语言即webservice使用说明书，wsdl属w3c标准。xml是webservice的跨平台的基础，XML主要的优点在于它既与平台无关，又与厂商无关。XSD，W3C为webservice制定了一套传输数据类型，使用xml进行描述，即XSD(XML Schema Datatypes)，任何编程语言写的webservice接口在发送数据时都要转换成webservice标准的XSD发送。当前非SOAP协议的webService以轻量为首要目标，比如http rest方式也是webservice的一种方式，或者直接使用http自定义数据协议，比如http传输json数据，http传输xml数据等。</p>
<h4 id="2-WebService-三要素"><a href="#2-WebService-三要素" class="headerlink" title="2.WebService 三要素"></a>2.WebService 三要素</h4><pre><code>1.soap
SOAP指简单对象访问协议(Simple Object Access Protocal)是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息，简单理解为soap=http+xml。Soap协议版本主要使用soap1.1/soap1.2。SOAP不是webservice的专有协议，其他应用协议也使用soap传输数据，例如SMTP、tr069等。

2.wsdl
WSDL 是基于 XML 的用于描述Web Service及其函数、参数和返回值。通俗理解Wsdl是webservice的使用说明书。

3.UDDI
UDDI 是一种目录服务，通过它，企业可注册并搜索 Web services。企业将自己提供的Web Service注册在UDDI，也可以使用别的企业在UDDI注册的web service服务，从而达到资源共享。UDDI旨在将全球的webservcie资源进行共享，促进全球经济合作。
</code></pre><h4 id="3-WebService开发规范"><a href="#3-WebService开发规范" class="headerlink" title="3.WebService开发规范"></a>3.WebService开发规范</h4><p>JAVA 中共有三种 WebService 开发规范，分别是JAX-WS（JAX-RPC）、JAXM&amp;SAAJ、JAX-RS。</p>
<pre><code>1.JAX-WS
</code></pre>]]></content>
      <categories>
        <category>WebService</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title>创新型模式 - 总结</title>
    <url>/undefined/%E5%88%9B%E6%96%B0%E5%9E%8B%E6%A8%A1%E5%BC%8F%20-%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>创新型模式的主要特点是将对象的创建和使用分离，根据对象的创建和组合方式的不同。创新型模式隐藏对象的创建细节，对象的创建由相关的工厂来完成，使用者不需要关心对象的创建细节。</p>
<p>单例模式是为了保证全局使用的是同一对象，一方面考虑安全性，另一方面考虑节省资源。</p>
<p>建造者模式专门对付属性很多的那种类，为了保证程序更优美。</p>
<p>抽象工厂模式有产品族的概念，如果各个产品存在兼容性问题的话就使用抽象工厂模式。</p>
]]></content>
      <categories>
        <category>创新型模式</category>
      </categories>
      <tags>
        <tag>创新型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 数据库</title>
    <url>/undefined/%E5%89%91%E6%8C%87Offer%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="剑指Offer-数据库"><a href="#剑指Offer-数据库" class="headerlink" title="剑指Offer - 数据库"></a>剑指Offer - 数据库</h2><p>[TOC]</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><blockquote>
<p>问题：如何设计一个关系型数据库。这里将整个数据库划分成两个部分：</p>
</blockquote>
<pre><code>1.存储，相当于OS的文件系统，存储数据

2.程序实例，包括存储管理/缓存机制/SQL解析模块/日志管理/权限划分/异常容灾机制/索引管理和锁管理，这些对程序进行管理。
</code></pre><a id="more"></a>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>问题：索引使用的理由，快速检索数据，索引是根据字典中的索引复现出来的。</p>
</blockquote>
<blockquote>
<p>问题：什么样的信息能够成为索引，如主键等。</p>
</blockquote>
<blockquote>
<p>问题：索引的数据结构</p>
</blockquote>
<pre><code>1.生成索引，建立二叉树进行二分查找

2.生成索引，建立B-Tree结构进行查找

    B-Tree定义：

        1.根节点至少包括两个孩子

        2.树中每个节点最多包含有m个孩子（m &gt;= 2）

        3.除根节点和叶子节点之外，其它每个节点至少有ceil(m/2)个孩子 ceil-向上取整

        4.所有叶子节点位于同一层

        5.节点之间的限制...

3.生成索引，建立B+-Tree结构进行查找

    B+-Tree定义：

        B+树是B树的变体，定义与B树相同，除了：

            1.非叶子节点的子树指针与关键字个数相同

            2.非叶子节点的子树指针p[i],指向关键字值[k[i], k[i+1]]的子树

            3.非叶子节点仅用来索引，数据都保存在叶子节点中

            4.所有叶子节点均有一个链指针指向下一个叶子节点

    结论：B+树更适合用来做存储索引：1.B+树的磁盘读写代价更低。2.B+树的查询效率更加稳定。3.B+树更有利于对数据库的扫描。4.

4.生成索引，建立哈希结构进行查找

    缺点：

        1.仅仅能满足 = IN， 不能使用范围查询

        2.无法被用来避免数据的排序操作

        3.不能利用部分索引键查询

        4.不能避免表扫描

        5.遇到大量的hash值相等的情况后性能并不一定就会比B树索引高


5.BitMap 索引神器
</code></pre><blockquote>
<p>问题：密集索引和稀疏索引的区别</p>
</blockquote>
<pre><code>1.密集索引文件中的每个搜索码值都对应一个索引值

2.稀疏索引文件只为索引码的某些值建立索引项


InnoDB

    1.如果一个主键被定义，则该主键则作为密集索引

    2.如果没有主键被定义，则该表的第一个唯一非空索引则作为密集索引

    3.如果不满足上面的条件，InnoDB会生成一个隐藏的主键（密集索引）

    4.非主键索引储存相关键位和其对应的主键值，包含两次查找
</code></pre><blockquote>
<p>问题：如何定位和优化慢查询SQL</p>
</blockquote>
<pre><code>1.根据慢日志定位慢查询sql

    1.在mysql中显示慢查询参数

        show variables like %quer%;

    2.在mysql中显示慢查询状态

        show status like %slow_queries%

    3.设置慢查询日志记录开关

        set global slow_query_log = on;

    4.设置慢查询等待时间，超出该时间则会被记录

        set global long_query_time =1;(ls) 需要重新连接或者在配置文件中设置

2.使用explain等工具分析sql

    关键字段：

        type：在index或all就表明该语句需要优化

        extra：

            1.using filesort

                不会用到表里的任何索引，而是借助于mysql外部的一些方式做排序，这样会远慢于所以的排序方式

            2.using temporary

                mysql在排序时候使用临时表，常见于order by和分组查询 group by

            注意：出现上面连个需要优化sql语句

3.修改sql，或尽量让sql走索引

    或者给字段加索引

4.
</code></pre><blockquote>
<p>问题：联合索引的最左匹配原则的成因</p>
</blockquote>
<pre><code>1.最左匹配原则是一个非常重要的原则，mysql会一直向右匹配直到遇到范围查询（&gt; | &lt; | between | like）就停止匹配。

    如：a = 3 and b = 4 and c &gt; 5 adn d = 6

        1.如果这里建立的是(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的所以则都可以用到

2.=和IN可以乱序。

    如：a=1 and b = 2 and c = 3 

        1.建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮助我们优化成索引可以识别的形式。
</code></pre><blockquote>
<p>成因：因为mysql主要是根据从左到右的顺序进行order的，如果左边第一个用不到的话，第二个就不会走索引</p>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h4><pre><code>1.按锁的粒度划分

    表级锁 | 行级锁 | 页级锁


2.按锁级别划分

    共享锁 | 排它锁

3.加锁方式

    自动锁 | 显示锁

4.操作划分

    DML锁 | DDL锁

5.按使用方式划分

    乐观锁 | 悲观锁
</code></pre><blockquote>
<p>问题：MyISAM与InnoDB关于锁方面的区别</p>
</blockquote>
<pre><code>1.MyISAM默认用的是表级锁，不支持行级锁

    MyISAM适合的场景：

        1.频繁执行全表count语句

        2.对数据进行增删改的频率不高，查询非常频繁

        3.没有事务

2.InnoDB默认用的是行级锁，也支持表级锁

    InnoDB适合的场景：

        1.数据的增删改查都相当频繁

        2.可靠性要求比较高，要求支持事务

        3.
</code></pre><blockquote>
<p>问题：数据库事务的四大特性</p>
</blockquote>
<pre><code>ACID
</code></pre><blockquote>
<p>问题：事务隔离级别以及各级别下的并发访问问题</p>
</blockquote>
<h4 id="事务并发访问引起的问题以及如何避免"><a href="#事务并发访问引起的问题以及如何避免" class="headerlink" title="事务并发访问引起的问题以及如何避免"></a>事务并发访问引起的问题以及如何避免</h4><blockquote>
<blockquote>
<p>问题1：更新丢失，mysql所有事务隔离级别在数据库层面上均可避免</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>问题2：脏读，read-committed事务隔离级别以上可避免</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>问题3：不可重复读，repeatable-read事务隔离级别以上可以避免</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>问题4：幻读，serializable事务隔离级别可避免</p>
</blockquote>
</blockquote>
<blockquote>
<p>问题：InnoDB可重复读隔离级别下如何避免幻读</p>
</blockquote>
<pre><code>表象：快照读（非阻塞读）伪MVCC

    当前读：表示加了锁的增删改查语句

        select .. lock in share mode 共享锁

        select .. for update 排它锁

        update

        delete 

        insert

    快照读：不加锁的非阻塞读

        select

内在：next-key锁（行锁 + gap锁）

    行锁：

        对单个行上锁

    Gap锁：

        在rr级别和serialable级别下默认支持Gap锁

            对主键索引或者唯一索引的时候

                如果where条件全部命中，则不会用Gap锁，只会加记录锁

                如果where条件部分命中或者全不命中则会加Gap锁

        提示：Gap锁会用在非唯一索引或者不走索引的当前读中
</code></pre><blockquote>
<p>问题：RC RR级别下的InnoDB的非阻塞读如何实现</p>
</blockquote>
<pre><code>1.数据行里的 DB_TRX_ID | DB_ROLL_PTR DB_ROW_ID 字段

2.UNDO日志

3.read view
</code></pre><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>1.GROUP BY

    1.满足SELECT子句中的列名必须为分组列或列函数

    2.列函数对于GROUP BY子句定义的每个组各返回一个结果

    3.如果用到GROUP BY语句，那么在SELECT语句中选出的列要么是GROUP BY里面用到的列，要么是带有如SUM MIN等列函数的列

2.HAVING

    1.通常与GROUP BY 子句一起使用

    2.WHERE 过滤行，HAVING过滤组

    3.在同一sql中，出现的顺序是：WHERE &gt; GROUP BY &gt; HAVING

        如：查询平均成绩大于60的同学的学号和平均成绩

            SELECT student_id, AVG(score) FROM student GROUP BY student_id HAVING AVG(score)&gt;60

    提示：如果没有GROUP BY子句，那么HAVING与WHERE的作用是一样的

        如：查询没有学完所有课程的同学的学号、姓名

            SELECT 
                stu.student_id, stu.name FROM student stu, score s 
            WHERE
                stu.student_id = s.student_id
            GROUP BY
                s.student_id
            HAVING
                count(*) &lt; (
                    SELECT COUNT(*) FROM course
                )
</code></pre><h3 id="理论范式"><a href="#理论范式" class="headerlink" title="理论范式"></a>理论范式</h3>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - Redis</title>
    <url>/undefined/%E5%89%91%E6%8C%87Offer%20-%20Redis/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="剑指Offer-Redis"><a href="#剑指Offer-Redis" class="headerlink" title="剑指Offer - Redis"></a>剑指Offer - Redis</h2><p>[TOC]</p>
<blockquote>
<p>问题1：Redis查询速度快的原因（100000+QPS(每秒内查询次数)）</p>
</blockquote>
<pre><code>1.完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高

2.数据结构简单，对数据操作也简单

3.采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例

4.使用多路IO复用模型，非阻塞IO

    多路IO复用模型

        Redis采用的IO多路复用函数：epoll | kqueue | evport | select

            1.因地制宜

            2.优先选择时间复杂度为O(1)的IO多路复用函数作为底层实现

            3.以时间复杂度为O(N)的select作为保底

            4.基于react设计模式监听IO事件
</code></pre><blockquote>
<p>问题2：Redis常用数据类型</p>
</blockquote>
<pre><code>1.String 最基本的数据类型，二进制安全

2.HASH String元素组成的字典，适合用于存储对象

3.LIST 列表，按照String元素插入顺序排序

4.SET String元素组成的无序集合，通过hash表实现，不允许重复

5.Sorted Set 通过分数来为集合中的成员进行从小到大的排序
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/undefined/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%A3%E6%9E%90%20-%20%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="单例模式-解析"><a href="#单例模式-解析" class="headerlink" title="单例模式 - 解析"></a>单例模式 - 解析</h2><h4 id="多线程debug"><a href="#多线程debug" class="headerlink" title="多线程debug"></a>多线程debug</h4><h4 id="序列化和反序列化破坏单例模式"><a href="#序列化和反序列化破坏单例模式" class="headerlink" title="序列化和反序列化破坏单例模式"></a>序列化和反序列化破坏单例模式</h4><p>在通过序列化之后拿到的对象和反序列化之后拿到的对象不一致的问题。</p>
<p>在类中加入resolveRead()方法，避免在反序列化和序列化过程中文件被破坏。</p>
<h4 id="基于ThreadLocal的单例写法"><a href="#基于ThreadLocal的单例写法" class="headerlink" title="基于ThreadLocal的单例写法"></a>基于ThreadLocal的单例写法</h4><h4 id="JDK源码分析"><a href="#JDK源码分析" class="headerlink" title="JDK源码分析"></a>JDK源码分析</h4><ul>
<li>Runtime 属于恶汉式单例模式</li>
<li>Desktop </li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/undefined/%E5%90%84%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A0%91/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>最早的平衡二叉树之一，应用相对于其它数据结构较少。Windows对进程地址空间的管理就用到AVL树。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>平衡二叉树，如map和set都用红黑树实现。</p>
<p>红黑树是对2-3查找树的改进，它能用一种统一的方式完成所有变换。</p>
<blockquote>
<p>注意：遵守以下约束的才能叫做 红黑树</p>
</blockquote>
<pre><code>1、红黑树是二叉搜索树

2、根节点是黑色

3、每个叶子节点都是黑色的空节点（NIL节点）

4、每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）

5、从任一节点到其它每个叶子节点的所有路径都包含相同数目的黑色节点（每一条树链上的黑色节点数量（黑高）必须相等）
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<h3 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B/B+树"></a>B/B+树</h3><p>用在磁盘文件组织、数据索引和数据库索引。</p>
<h3 id="Trie树（字典树）"><a href="#Trie树（字典树）" class="headerlink" title="Trie树（字典树）"></a>Trie树（字典树）</h3><p>用在统计和排序大量字符串。</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图解HTTP</title>
    <url>/undefined/%E5%9B%BE%E8%A7%A3HTTP/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h2><p>[TOC]</p>
<h4 id="1-4-与HTTP关系密切的协议：IP-TCP和DNS"><a href="#1-4-与HTTP关系密切的协议：IP-TCP和DNS" class="headerlink" title="1.4 与HTTP关系密切的协议：IP TCP和DNS"></a>1.4 与HTTP关系密切的协议：IP TCP和DNS</h4><p>IP协议的作用是将各个数据包传送给对方，其中两个重要的条件是IP地址和MAC地址。</p>
<p>提示：IP地址指明了节点被分配到的地址。MAC地址指网卡所属的固定地址。使用ARP协议凭借MAC地址进行通信。<br><a id="more"></a></p>
<blockquote>
<p>提示：ARP协议，是一种用以解析地址的协议，根据通信方的IP地址可以反查出对应的MAC地址。</p>
</blockquote>
<blockquote>
<p>路由选择，在中转数据包发送到目标的过程中所需要经过的路由。</p>
</blockquote>
<p>TCP协议是一个提供可靠的字节流服务，将大块数据分割成以报文段(segment)为单位的数据包进行管理。</p>
<blockquote>
<p>TCP协议采用三次握手策略，1.发送端会发送一个带SYN标志的数据包给对方。2.接收端接收到之后，回传一个带有SYN/ACK标志的数据包以表示确认收到。3.最后发送方回传一个带ACK标志的数据包，表握手结束。</p>
</blockquote>
<h4 id="1-5-负责域名解析的DNS服务"><a href="#1-5-负责域名解析的DNS服务" class="headerlink" title="1.5 负责域名解析的DNS服务"></a>1.5 负责域名解析的DNS服务</h4><h4 id="1-6-总结-HTTP请求过程"><a href="#1-6-总结-HTTP请求过程" class="headerlink" title="1.6 总结 HTTP请求过程"></a>1.6 总结 HTTP请求过程</h4><pre><code>1.客户端发送网站（www.baidu.com）的域名到DNS，DNS返回对应的IP地址。

2.HTTP协议负责生成针对目标Web服务器的http请求报文。

3.TCP协议为了方便通信，将HTTP报文分割成报文段。

4.IP协议搜索对方的地址，一边中转一边传送。

5.TCP协议从对方那里接收到的报文段重组。

6.HTTP对服务器请求的内容处理。
</code></pre><h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><h4 id="2-5-告知服务器意图的HTTP方法"><a href="#2-5-告知服务器意图的HTTP方法" class="headerlink" title="2.5 告知服务器意图的HTTP方法"></a>2.5 告知服务器意图的HTTP方法</h4><p><strong>1.GET 获取资源</strong><br></p>
<p>指定的资源经服务器解析后返回响应的内容。即，如果请求的资源是文本，那就原样返回。如果是像CGI那样的程序，则返回经过执行后的输出结果。</p>
<p><strong>2.POST 传输实体主体</strong><br></p>
<p>POST和GET类似，但是POST的主要目的不是获取响应的主体内容。</p>
<p><strong>3.PUT 传输文件</strong><br></p>
<p>PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。</p>
<p><strong>4.HEAD 获得报文首部</strong><br></p>
<p>和GET方法一样，只是不返回报文主体部分。</p>
<p><strong>5.DELETE 删除文件</strong><br></p>
<p><strong>6.OPTIONS 询问支持的方法</strong><br></p>
<p><strong>7.TRACE 追踪路径</strong><br></p>
<p>将之前请求的请求通信环返回给客户端。</p>
<p><strong>8.CONNECT 要求用隧道协议连接代理</strong><br></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>图解TCP/IP</title>
    <url>/undefined/%E5%9B%BE%E8%A7%A3TCP%20IP/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="图解TCP-IP"><a href="#图解TCP-IP" class="headerlink" title="图解TCP/IP"></a>图解TCP/IP</h1><p>[TOC]</p>
<h2 id="第5章-IP协议相关技术"><a href="#第5章-IP协议相关技术" class="headerlink" title="第5章 IP协议相关技术"></a>第5章 IP协议相关技术</h2><h3 id="5-2-DNS"><a href="#5-2-DNS" class="headerlink" title="5.2 DNS"></a>5.2 DNS</h3><p>TCP/IP在一开始的时候就有一个主机识别码，为每一台主机赋值唯一的主机名，在进行网络通信时可以直接利用主机识别码进行通信，在这样的基础上需要需要系统将主机名转换为具体IP地址，需要使用到hosts文件。</p>
<p>发展到后面的DNS则不需要再向hosts报告，直接通过DNS进行域名与ip地址之间的切换。</p>
<h3 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h3><a id="more"></a>
<p>ARP协议是解决地址问题的协议，以目标IP为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。</p>
<blockquote>
<p>提示：ARP协议只适用于IPv4地址，IPv6使用ICMPv6代替。</p>
</blockquote>
<h4 id="5-3-4-RARP"><a href="#5-3-4-RARP" class="headerlink" title="5.3.4 RARP"></a>5.3.4 RARP</h4><p>RARP协议表示从MAC地址定位IP地址的一种协议。</p>
<blockquote>
<p>提示：在平时可以通过个人电脑设置IP地址，或通过DHCP自动分配获取IP地址。</p>
</blockquote>
<h3 id="5-4-ICMP"><a href="#5-4-ICMP" class="headerlink" title="5.4 ICMP"></a>5.4 ICMP</h3><p>ICMP协议的主要作用是确认IP包是否发送成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。</p>
<h4 id="5-4-4-ICMPv6"><a href="#5-4-4-ICMPv6" class="headerlink" title="5.4.4 ICMPv6"></a>5.4.4 ICMPv6</h4><h3 id="5-5-DHCP"><a href="#5-5-DHCP" class="headerlink" title="5.5 DHCP"></a>5.5 DHCP</h3><p>实现自动设置IP地址、统一管理IP地址分配</p>
<h3 id="5-6-NAT"><a href="#5-6-NAT" class="headerlink" title="5.6 NAT"></a>5.6 NAT</h3><p>NAT是用于在本地网络中使用私有地址，</p>
<h3 id="5-7-IP隧道"><a href="#5-7-IP隧道" class="headerlink" title="5.7 IP隧道"></a>5.7 IP隧道</h3><p>网络A、B之间使用IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A、B之间将无法正常使用通信，所有此时需要采用IP隧道功能。</p>
<p>IP隧道可以将那些从网络A发过来的IPv6包统和为一个数据，再为之追加一个IPv4的首部以后转发给网络C。</p>
]]></content>
      <categories>
        <category>图解TCP/IP</category>
      </categories>
      <tags>
        <tag>图解TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程与并发</title>
    <url>/undefined/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%20-%20%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="多线程与并发-面试"><a href="#多线程与并发-面试" class="headerlink" title="多线程与并发 - 面试"></a>多线程与并发 - 面试</h2><h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><h4 id="1-主线程等待法"><a href="#1-主线程等待法" class="headerlink" title="1.主线程等待法"></a>1.主线程等待法</h4><h4 id="2-Thread类的join-阻塞当前线程以等待子线程处理完毕"><a href="#2-Thread类的join-阻塞当前线程以等待子线程处理完毕" class="headerlink" title="2.Thread类的join()阻塞当前线程以等待子线程处理完毕"></a>2.Thread类的join()阻塞当前线程以等待子线程处理完毕</h4><h4 id="3-通过Callable接口实现，通过-FutureTask-或-线程池获取"><a href="#3-通过Callable接口实现，通过-FutureTask-或-线程池获取" class="headerlink" title="3.通过Callable接口实现，通过 FutureTask 或 线程池获取"></a>3.通过Callable接口实现，通过 FutureTask 或 线程池获取</h4><h3 id="sleep-方法与wait-方法区别"><a href="#sleep-方法与wait-方法区别" class="headerlink" title="sleep()方法与wait()方法区别"></a>sleep()方法与wait()方法区别</h3><pre><code>1.sleep()是Threadk类的方法，wait()是Object类中定义的方法

2.sleep()方法可以在任意地方使用

3.wait()方法只能在synchronized方法或synchronized块中使用

最主要本地区别：

    1.Thread.sleep()只会让出CPU，不会导致锁行为的改变

    2.Object.wait()不仅让出CPU，还会释放已经占有的同步资源锁
</code></pre><a id="more"></a>      
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><pre><code>1.互斥性

2.可见性

注意：synchronized锁的不是代码，锁的都是对象

分类：

    1.获取对象锁

        1.同步代码块

        2.同步非静态方法

    2.获取类锁

        1.同步代码块

        2.同步静态方法

    总结：对象锁和类锁

        1.有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块

        2.若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块会被阻塞

        3....
</code></pre><h4 id="J-U-C知识点"><a href="#J-U-C知识点" class="headerlink" title="J.U.C知识点"></a>J.U.C知识点</h4><p>java.util.concurrent，提供并发编程的解决方案。</p>
<pre><code>1.CAS是java.util.concurrent.atomic包的基础

2.AQS是java.util.concurrent.locks包以及一些常用类如：Semophore ReentrantLock等类的基础
</code></pre><h5 id="J-U-C包的分类"><a href="#J-U-C包的分类" class="headerlink" title="J.U.C包的分类"></a>J.U.C包的分类</h5><pre><code>1.线程执行器executor

2.锁locks

3.原子变量类atomic

4.并发工具类tools

    1.闭锁 CountDownLatch

        内部有一个计数器（cnt），每调用一次则减1，直到为0之后回到主线程继续

        让主线程等待一组事件发生后继续执行，而这里的事件是指CountDownLatch里的countDown()方法

    2.栅栏 CyclicBarrier

        内部有一个计数器（cnt），每调用一次则减1，直到为0之后回到主线程继续

        阻塞当前线程，等待其它线程，所有线程必须同时到达栅栏位置后，才能继续执行

        所有线程到达栅栏处，可以触发执行另外一个预先设置的线程


    3.信号量Semaphore

        控制某个资源可以同时被访问的线程个数

    4.交换器 Exchanger

        两个线程到达同步点后，相互交换数据

        注意：Exchanger只能作用于两个线程

5.并发集合collections

    BlockingQueue 提供可阻塞的入队和出队操作，主要用于生产者和消费者模式，在多线程场景下生产者线程在队尾添加元素，而消费者在队列头部消费元素，通过此种方式能够达到将任务的生产和消费进行隔离。

    线程安全：

        1.ArrayBlockingQueue 一个由数组结构组成的有界阻塞队列

        2.LinkedBlockingQueue 一个由链表结构组成的有界/无界阻塞队列

        3.PriorityBlockingQueue 一个支持优先级排序的无界阻塞队列

        ...
</code></pre><h4 id="Java的IO机制"><a href="#Java的IO机制" class="headerlink" title="Java的IO机制"></a>Java的IO机制</h4><blockquote>
<p>问题1：Java BIO NIO AIO的区别</p>
</blockquote>
<p>BIO (Block IO) 表示传统的IO：传统的InputStream OutputStream Reader Writer，该模式是基于流模式实现的</p>
<p>NonBlock-IO(NIO) 构建多路复用的、同步非阻塞的IO操作</p>
]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程与并发</tag>
      </tags>
  </entry>
  <entry>
    <title>字节码</title>
    <url>/undefined/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>[toc]</p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><pre><code>1. javap 路径（.class文件） 能够反编译出Java文件的字节码

2. javap -c 路径 打印出.class文件的详细信息

3. javap -verbose .class文件的路径 反编译的文件内容
</code></pre><h4 id="javap-verbose-命令"><a href="#javap-verbose-命令" class="headerlink" title="javap -verbose 命令"></a>javap -verbose 命令</h4><p>在使用 javap -verbose 命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类变量与成员变量等信息。</p>
<h5 id="Java字节码整体结构"><a href="#Java字节码整体结构" class="headerlink" title="Java字节码整体结构"></a>Java字节码整体结构</h5><pre><code>ClassFile {
    u4          magic;
    u2          minor_version;
    u2          major_version;
    u2          constant_pool_count;
    cp_info     constant_pool[constant_pool_count - 1];
    u2          access_flags;
    u2          this_class;
    u2          super_class;
    u2          interfaces_count;
    u2          interfaces[interfaces_count];
    u2          fields_count;
    field_info  fields[fields_count];
    u2          methods_count;
    method_info methods[methods_count];
    u2          attributes_count;
    attribute_info  attributes[attributes_count];
}

1. 魔数，所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE。

2. 版本号，在魔数之后的4个字节为版本信息，前两个字节表示minor version（次版本号），后两个字节表示major version（主版本号）。这里的版本号为 00 00 00 34，换算成十进制，表示次版本号为0，主版本号为52。所以该文件的版本号为：1.8.0。通过java -version命令验证。
</code></pre><a id="more"></a>
<pre><code>3. 常量池（constant pool），紧接着在主版本号之后的就是常量池的入口。一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用。字面量如文本字符串，Java中声明为final的常量值等。而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。

4. 常量池的总体结构，Java类所对应的常量池主要由 常量池数量 与 常量池数组 这两部分共同构成。常量池数量紧跟在主版本号后面，占据两个字节。常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同元素的类型、结构都是不同的，长度当然也就不同。但是每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据一个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。
</code></pre><blockquote>
<p>提示：常量池数组中元素的个数 = 常量池数 - 1 (其中0暂时不使用)。目的是满足某些常量池索引值的数据在特定情况下需要表达“不引用任何一个常量池”的含义：根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量表中，该常量就对应null值，所以常量池的索引从1而非0开始。</p>
</blockquote>
<pre><code>6. 在JVM规范中，每个变量/字段都要描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：B-byte C-char D-double F-float I-int J-long S-short Z-boolean V-void L-对象类型。如：Ljava/lang/String。

7. 对于数组类型来说，每一个维度使用一个前置的 [ 来表示，如int[]被记录为 [I，String[][]被记录为 [[Ljava/lang/String。

8. 用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()内。如方法：String getA(int id, String)的描述符是：(I, Ljava/lang/String;) Ljava/lang/String;

9. 访问修饰符，访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract。如果是类，是否被声明为final。

10. 类名称

11. 父类名称

12. 接口

13. 字段表，字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。


14. 类的方法

    methods_count: u2

        类型            名称                数量
        u2              access_flags        1
        u2              name_index          1
        u2              descriptor_index    1
        u2              attributes_count    1
        attribute_info  attributes          attributes_count

        方法表结构（前三个字段和field_info一样）

            method_info{
                u2 access_flags;
                u2 name_index;
                u2 descriptor_index;
                u2 attributes_count;
                attribute_info attributes[attributes_count];
            }

            方法中每个属性都是一个attribute_info结构

                attribute_info {
                    u2 attribute_name_index;
                    u4 attribute_length;
                    u1 info[attribute_length];
                }

                code结构（code attribute的作用是保存该方法的结构）

                    Code_attribute {
                        u2      attribute_name_index;
                        u4      attribute_length;
                        u2      max_stack;
                        u2      max_locals;
                        u4      code_length;
                        u1      code[code_length];
                        u2      exception_table_length;
                        {
                            u2      stack_pc;
                            u2      end_pc;
                            u2      handler_pc;
                            u2      catch_type;
                        } exception_table[exception_table_length];
                        u2      attributes_count;
                        attribute_info attributes[attribute_length];
                    }

                    1. atrribute_length 表示attribute所包含的字节数，不包含attribute_name_index和attribute_length字段

                    2. max_stack 表示这个方法运行的任何时刻所能达到的操作数栈的最大深度

                    3. max_locals 表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量

                    4. code_length 表示该方法所包含的字节码的字节数以及具体的指令码，具体字节码表示该方法在调用时，虚拟机所执行的字节码

                    5. exception_table 表示存放的是处理异常的信息

                    6. 每个exception_table表项是由 stack_pc | end_pc | handler_pc | catch_pc 组成

15. 当前类附加属性
</code></pre><blockquote>
<p>提示：Class字节码中有两种数据类型：1. 字节数据直接量：这是基本的数据类型。共细分为 u1 | u2 | u4 | u8 四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据。 2. 表（数组）：表是由多个基本数据或其它表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在组成表的成分所在的位置和顺序都是已经严格定义好的。</p>
</blockquote>
<blockquote>
<p>提示：IDEA中字节码查看插件：jclasslib view 。</p>
</blockquote>
<blockquote>
<p>提示：在使用 javap -verbose 命令不能够打印出类中的私有成员方法。需要在 javap -verbose -p 后面加上-p的属性才会打印出对应的private属性方法。</p>
</blockquote>
<h4 id="分析private方法下的synchronized关键字生成的字节码"><a href="#分析private方法下的synchronized关键字生成的字节码" class="headerlink" title="分析private方法下的synchronized关键字生成的字节码"></a>分析private方法下的synchronized关键字生成的字节码</h4><pre><code>//1. 在private属性下未使用synchronized的字节码
private void setX(int);
descriptor: (I)V
flags: ACC_PRIVATE
Code:
  stack=2, locals=2, args_size=2
     0: aload_0
     1: iload_1
     2: putfield      #4                  // Field x:I
     5: return
  LineNumberTable:
    line 12: 0
    line 13: 5
  LocalVariableTable:
    Start  Length  Slot  Name   Signature
        0       6     0  this   Lcom/jvm/xidian/edu/cn/bytecode/Test2;
        0       6     1     x   I

//2. 在private方法中定义了synchronized的字节码
private synchronized void setX(int);
descriptor: (I)V
flags: ACC_PRIVATE, ACC_SYNCHRONIZED
Code:
  stack=2, locals=2, args_size=2
     0: aload_0
     1: iload_1
     2: putfield      #4                  // Field x:I
     5: return
  LineNumberTable:
    line 12: 0
    line 13: 5
  LocalVariableTable:
    Start  Length  Slot  Name   Signature
        0       6     0  this   Lcom/jvm/xidian/edu/cn/bytecode/Test2;
        0       6     1     x   I
</code></pre><p>在synchronized关键字不位于方法内部时，没有锁的释放和进入。monitorenter | monitorexit。</p>
<h4 id="Class文件结构中常量池中11种数据类型的结构总表"><a href="#Class文件结构中常量池中11种数据类型的结构总表" class="headerlink" title="Class文件结构中常量池中11种数据类型的结构总表"></a>Class文件结构中常量池中11种数据类型的结构总表</h4><p><img src="https://img-blog.csdn.net/20180413104433349?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzc1MjEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Class文件常量池中11种数据结构类型"></p>
<p><img src="https://img-blog.csdn.net/20180413104450619?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzc1MjEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Class文件常量池中11种数据结构类型"></p>
<p>根据上面的两个表格可以确定字节码之间的关系。</p>
<h4 id="Java字节码整体结构-1"><a href="#Java字节码整体结构-1" class="headerlink" title="Java字节码整体结构"></a>Java字节码整体结构</h4><pre><code>1. magic number 2个字节

2. version 2+2个字节

3. constant pool 2+n个字节

4. access flags 2个字节

5. this class name 2个字节

6. super class name 2个字节

7. interfaces 2+n个字节

8. fields 2+n个字节

9. methods 2+n个字节

10 attributes 2+n个字节
</code></pre><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><blockquote>
<p>提示：对于Java类中的每个实例方法（非static方法），其在编译后所生成的字节码中，方法参数的数量总是会比源代码中方法参数的数量多一个（this），它位于方法的第一个参数的位置上。这样我们可以在Java的实例方法中使用this去访问当前对象的属性以及其它方法。这个操作是在编译期间完成的，即由javac编译器在编译的时候将对this的访问转化为一个普通实例方法参数的访问，接下来在运行期间，由JVM在调用实例方法时，自动向实例方法传入该this参数。所以在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。</p>
</blockquote>
<pre><code>Java字节码对于异常的处理方式：

    1. 统一采用异常表的方式来对异常进行处理。

    2. 在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，而是采用特定的指令的方式。

    3. 当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面。即：程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码。
</code></pre><h4 id="栈帧（stack-frame）"><a href="#栈帧（stack-frame）" class="headerlink" title="栈帧（stack frame）"></a>栈帧（stack frame）</h4><p>栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构。栈帧本身是一种数据结构，封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈等信息。</p>
<pre><code>符号引用与直接引用

    1. 有些符号引用是在类加载阶段或是第一次使用时就会转换为直接引用，这种转换叫做静态解析。另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，体现了Java的多态性。


方法调用

    1. invokeinterface 调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口的哪个对象的特定方法。

    2. invokestatic 调用静态方法

    3. invokespecial 调用自己的私有方法、构造方法（&lt;init&gt;）以及父类的方法

    4. invokevirtual 调用虚方法，运行期动态查找的过程

    5. invokedynamic 动态调用方法

静态解析的4种情形

    1. 静态方法

    2. 父类方法

    3. 构造方法

    4. 私有方法（无法被重写）

以上四类方法称作非虚方法，它们在类加载阶段就可以将符号引用转换为直接引用。
</code></pre><h4 id="方法的静态分派"><a href="#方法的静态分派" class="headerlink" title="方法的静态分派"></a>方法的静态分派</h4><p>方法重载是一种静态行为，在编译期就可以完全确定。</p>
<h4 id="方法的动态分派"><a href="#方法的动态分派" class="headerlink" title="方法的动态分派"></a>方法的动态分派</h4><p>方法的动态分派涉及到一个重要的概念：方法接受者。invokevirtual字节码指令的多态查找流程。</p>
<h4 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h4><p>在比较方法重载（overload）与方法重写（overwrite）我们可以得到这两者的区别：</p>
<pre><code>1. 方法重载是静态的，是编译期行为。方法重写是动态的，是运行期行为。
</code></pre><p>针对方法调用动态分配的过程，虚拟机会在类的方法区建立一个虚方法表的数据结构（virtual method table, vtable），针对invokeinterface指令来说，虚拟机会建立一个叫做接口方法表的数据结构（interface method table, itable）。</p>
<p>现代JVM在执行Java程序的时候，通过都会将解释执行与编译执行二者结合起来进行。</p>
<pre><code>1. 解释执行：通过解释器来读取字节码，遇到相应的指令就去执行该指令。

2. 编译执行：通过即时编译器（Just In Time，JIT）将字节码转换为本地机器码来执行。现代JVM会根据代码热点来生成相应的本地机器码。
</code></pre><h4 id="基于栈的指令集与基于寄存器的指令集之间的关系"><a href="#基于栈的指令集与基于寄存器的指令集之间的关系" class="headerlink" title="基于栈的指令集与基于寄存器的指令集之间的关系"></a>基于栈的指令集与基于寄存器的指令集之间的关系</h4><pre><code>1. JVM执行指令时所采取的方式是基于栈的指令集。

2. 基于栈的指令集主要的操作有入栈与出栈两种方式。

3. 基于栈的指令集的优势在于它可以在不同平台之间移植，而基于寄存器的指令集是与硬件架构紧密关联的，无法做到移植。  

4. 基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多。基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机可以采用一些优化手段，但是总体来说，基于栈的指令集的执行速度要慢一些。
</code></pre>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E5%AE%9E%E7%8E%B0AOP%E5%B0%81%E8%A3%85%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="实现AOP功能的封装与配置的小框架"><a href="#实现AOP功能的封装与配置的小框架" class="headerlink" title="实现AOP功能的封装与配置的小框架"></a>实现AOP功能的封装与配置的小框架</h2><p>本文通过是动态代理实现的AOP功能的封装与配置的小框架.加深对动态代理和AOP编程的理解</p>
<a id="more"></a>
<h4 id="1-设计"><a href="#1-设计" class="headerlink" title="1.设计"></a>1.设计</h4><p>根据配置文件的键xxx对应的值(类全名)创建相应类的对象。当且仅当xxx对应的值为com.iot.proxy.aopframework.ProxyFactoryBean时，则生成相应的动态代理类对象。代理对象的目标类和通知实现类分别由xxx.target和xxx.advice配置。</p>
<h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><pre><code>config.propertiest位于aopframework包下

xxx代表要加载的类
xxx.advice代表通知接口的某个实现类
xxx.target代表委托类
#xxx=java.util.ArrayList
xxx=com.iot.proxy.aopframework.ProxyFactoryBean
xxx.advice=com.iot.proxy.MyAdvice
xxx.target=java.util.ArrayList
</code></pre><p>包:com.iot.proxy.aopframework,有如下几个类/接口：</p>
<pre><code>BeanFactory,用于读取配置文件，根据配置创建相应的对象
ProxyFactoryBean,用于生成代理对象，含有两个私有属性:目标和通知
Advice,通知接口，用于把切面的代码以对象的形式传递给InvocationHandler的的invoke方法
MyAdvice,Advice接口的一个实现类，打印执行方法前的时间及执行耗时
AopFrameWorkTest，测试效果
</code></pre><h4 id="3-实现程序"><a href="#3-实现程序" class="headerlink" title="3.实现程序"></a>3.实现程序</h4><p>1.Advice接口</p>
<pre><code>package com.iot.proxy.aopframework;

import java.lang.reflect.Method;
/**
 * Created by brian on 2016/2/2.
 */
public interface Advice {
    void beforeMethod(Method method);
    void aftereMethod(Method method);
}
MyAdvice类
package com.iot.proxy.aopframework;

import java.lang.reflect.Method;

/**
 * Created by brian on 2016/2/2.
 */
public class MyAdvice implements Advice{
    long beginTime = 0 ;
    @Override
    public void beforeMethod(Method method) {
        System.out.println(method.getName()+&quot; before at &quot;+beginTime);
        beginTime = System.currentTimeMillis();
    }

    @Override
    public void aftereMethod(Method method) {
        long endTime = System.currentTimeMillis();
        System.out.println(method.getName()+&quot; cost total &quot;+ (endTime-beginTime));
    }
}
</code></pre><p>2.BeanFactory类</p>
<pre><code>package com.iot.proxy.aopframework;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * Created by brian on 2016/2/2.
 */
public class BeanFactory {
    Properties properties = new Properties();
    public BeanFactory(InputStream inputStream){
        try {
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public  Object getBean(String name){
        String className = properties.getProperty(name);
        Object bean = null;
        try {
            Class clazz = Class.forName(className);
            bean = clazz.newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        if (bean instanceof ProxyFactoryBean){
            ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean)bean;
            Advice advice = null;
            Object target = null;
            try {
                advice = (Advice) Class.forName(properties.getProperty(name+&quot;.advice&quot;)).newInstance();
                target = Class.forName(properties.getProperty(name+&quot;.target&quot;)).newInstance();
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }

            proxyFactoryBean.setAdvice(advice);
            proxyFactoryBean.setTarget(target);
            Object proxy = ((ProxyFactoryBean) bean).getProxy();
            return proxy;
        }
        return bean;
    }
}
</code></pre><hr>
<blockquote>
<p>提示：<code>instanceof</code>是一个二元运算符，它的作用是判断一个引用类型的变量所指向对象是否是一个类(或接口、抽象类、父类)的实例，即它左边的对象是否是它右边的类的实例，该运算符返回boolean类型的数据。</p>
</blockquote>
<hr>
<blockquote>
<p>提示：关键字strictfp是strict float point缩写，指的是精确浮点数，用来确保浮点数运算的准确性。</p>
</blockquote>
<hr>
<p>3.ProxyFactoryBean类</p>
<pre><code>package com.iot.proxy.aopframework;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * Created by brian on 2016/2/3.
 */
public class ProxyFactoryBean {
    private Object target;
    private Advice advice;

    public Object getProxy(){
        Object proxy = Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        advice.beforeMethod(method);
                        Object retVal = method.invoke(target,args);
                        advice.aftereMethod(method);
                        return retVal;
                    }
                }
        );
        return proxy;
    }

    public Object getTarget() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    public Advice getAdvice() {
        return advice;
    }

    public void setAdvice(Advice advice) {
        this.advice = advice;
    }
}
</code></pre><p>4.AopFrameWorkTest类</p>
<pre><code>package com.iot.proxy.aopframework;

import java.io.InputStream;
import java.util.Collection;

/**
 * Created by brian on 2016/2/3.
 */
public class AopFrameWorkTest {
    public static void main(String[] args) {
        InputStream inputStream = AopFrameWorkTest.class.getResourceAsStream(&quot;config.properties&quot;);
        Object bean = new BeanFactory(inputStream).getBean(&quot;xxx&quot;);
        System.out.println(bean.getClass().getName());
        ((Collection) bean).clear();
    }
}
</code></pre><h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4.输出"></a>4.输出</h4><p>1.配置xxx=com.iot.proxy.aopframework.ProxyFactoryBean输出为：</p>
<pre><code>com.sun.proxy.$Proxy0
clear before at 0
clear cost total 0
</code></pre><p>2.配置xxx=java.util.ArrayList输出为：</p>
<pre><code>java.util.ArrayList
</code></pre><blockquote>
<p>总结：可以看出，只改变配置文件，就可改变代码的运行结果，从而达到灵活的效果。</p>
</blockquote>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器Socket</title>
    <url>/undefined/%E6%9C%8D%E5%8A%A1%E5%99%A8Sokcet/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="服务器-Sokcet"><a href="#服务器-Sokcet" class="headerlink" title="服务器 Sokcet"></a>服务器 Sokcet</h2><p>[TOC]</p>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>ServerSocket类包括了编写服务器所需要的全部内容。包括创建新ServerSocket对象的构造函数、在指定端口监听连接方法、配置各个服务器Sokcet选项的方法。<br><a id="more"></a><br>在Java中服务器程序的基本生命周期：</p>
<pre><code>1. ServerSocket()构造函数在特定端口构造新的ServerSocket

2. ServerSocket使用其 accept() 方法监听该端口的入站连接。accept()会一直阻塞直到一个客户端尝试建立连接，此时accept()将返回一个客户端和服务器的Socket对象。

3. 根据服务器的类型，调用Socket的getInputStream 和 getOutputStream() 方法，获得与客户端通信的输入输出流。

4. 服务器与客户端根据已协商的协议交互，直到关闭连接

5. 服务器或客户端关闭连接

6. 服务器返回步骤2，等待客户端连接
</code></pre><p>在server.accept()方法连接上之后会作为一个java.net.Socket对象返回。</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件</title>
    <url>/undefined/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>消息中间件，也可以叫做中央消息队列或者是消息队列（区别于本地消息队列，本地消息队列指的是JVM内的队列实现），是一种独立的队列系统，消息中间件经常用来解决内部服务之间的异步调用问题。</p>
<p>请求服务方把请求队列放到队列中即可返回，然后等待服务提供方去队列中获取请求进行处理，之后通过回调等机制把结果返回给请求服务方。<br><a id="more"></a></p>
<blockquote>
<p>提示：异步调用只是消息中间件一个非常常见的应用场景。</p>
</blockquote>
<blockquote>
<blockquote>
<p>常用的消息队列应用场景还包括以下几个方面：</p>
</blockquote>
</blockquote>
<pre><code>解耦：一个业务的非核心流程需要依赖其他系统，但结果并不重要，有通知即可。

最终一致性：指的是两个系统的状态保持一致，可以有一定的延迟，只要最终达到一致性即可。经常用在解决分布式事务上。

广播：消息队列最基本的功能。生产者只负责生产消息，订阅者接收消息。

错峰和流控：
</code></pre><p>当前使用较多的消息队列有ActiveMQ（性能差，不推荐使用）、RabbitMQ、RocketMQ、Kafka等等。</p>
<p>我们之前提到的Redis数据库也可以实现消息队列（不过不推荐），Redis本身设计就不是用来做消息队列的。</p>
<h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>ActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE 1.4规范的JMSProvider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗</p>
<blockquote>
<p>提示：AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>
</blockquote>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Kafka是一个分布式的、可分区的、可复制的、基于发布/订阅的消息系统（现在官方的描述是“一个分布式流平台”）,Kafka主要用于大数据领域,当然在分布式系统中也有应用。目前市面上流行的消息队列RocketMQ就是阿里借鉴Kafka的原理、用Java开发而得。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/undefined/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMybatis%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="深入浅出Mybatis技术原理与实战"><a href="#深入浅出Mybatis技术原理与实战" class="headerlink" title="深入浅出Mybatis技术原理与实战"></a>深入浅出Mybatis技术原理与实战</h1><p>[TOC]</p>
<h2 id="第2章-Mybatis入门"><a href="#第2章-Mybatis入门" class="headerlink" title="第2章 Mybatis入门"></a>第2章 Mybatis入门</h2><h3 id="2-2-Mybatis基本构成"><a href="#2-2-Mybatis基本构成" class="headerlink" title="2.2 Mybatis基本构成"></a>2.2 Mybatis基本构成</h3><pre><code>1. SqlSessionFactoryBuilder：构造器，它会根据配置信息或者代码来生成SqlSessionFactory（工厂接口）。

2. SqlSessionFactory：依靠工厂来生成SqlSession（会话）。两种方式创建：xml配置和Java实现。

3. SqlSession：是一个既可以发送sql去执行并返回结果，也可以获取Mapper的接口。类似于一个JDBC的connection对象。

4. SQL Mapper：它是Mybatis新设计的组件，它是由一个Java接口和XML文件构成的，需要给出对应的SQL和映射规则。
</code></pre>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC1-10%E7%AB%A0%20SpringMVC%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第2章-常用的协议与标准"><a href="#第2章-常用的协议与标准" class="headerlink" title="第2章 常用的协议与标准"></a>第2章 常用的协议与标准</h1><p>在JavaWeb中常用的协议包括DNS协议，TCP/IP协议，HTTP协议和JavaWeb开发中的Servlet。</p>
<h2 id="2-1-DNS协议"><a href="#2-1-DNS协议" class="headerlink" title="2.1 DNS协议"></a>2.1 DNS协议</h2><p>该协议的作用是将域名解析为IP。我们将域名发过去，然后域名服务器就能够给我们返回相应的IP，在win中可以使用命令 nslookup 命令查看DNS解析的结果。</p>
<h2 id="2-2-TCP-IP协议与Socket"><a href="#2-2-TCP-IP协议与Socket" class="headerlink" title="2.2 TCP/IP协议与Socket"></a>2.2 TCP/IP协议与Socket</h2><p>IP协议是用来查找地址的，对应着网际互联层，其只负责找到地址。TCP协议是用来规范传输规则的，对应着传输层，完成货物的传输工作。TCP在传输之前会进行三次沟通（三次握手），传完数据断开的时候要进行四次沟通（四次挥手）。</p>
<p>…</p>
<h2 id="2-3-HTTP协议"><a href="#2-3-HTTP协议" class="headerlink" title="2.3 HTTP协议"></a>2.3 HTTP协议</h2><p>该协议是应用层的协议，在TCP/IP协议接收到数据之后需要通过HTTP协议来解析才可以使用。我们应该理解HTTP协议中的报文结构。在HTTP协议中的报文分为请求报文（request message）和响应报文（response message）两种类型，这两种类型包含三部分：首行、头部、主体。</p>
<p>…</p>
<h2 id="2-4-Servlet与JavaWeb开发"><a href="#2-4-Servlet与JavaWeb开发" class="headerlink" title="2.4 Servlet与JavaWeb开发"></a>2.4 Servlet与JavaWeb开发</h2><p>Servlet是J2EE标准的一部分，是JavaWeb的开发标准。Servlet的作用是对接收到的数据进行处理并生成要返回给客户端的结果。</p>
<hr>
<h1 id="第3章-DNS的设置"><a href="#第3章-DNS的设置" class="headerlink" title="第3章 DNS的设置"></a>第3章 DNS的设置</h1><p>在这里介绍DNS的设置，主要包括DNS解析、Win7设置DNS服务器以及win设置本机域名和IP对应关系。</p>
<h2 id="3-1-DNS解析"><a href="#3-1-DNS解析" class="headerlink" title="3.1 DNS解析"></a>3.1 DNS解析</h2><p>DNS解析是将相应的域名解析为对应的IP地址。</p>
<p><strong>解析的内容</strong><br></p>
<pre><code>记录类型：
    A：A记录表示将域名解析到IP（一个域名可以有多条A记录）
    CNAME：该记录是将域名解析到另一域名（表作为另一个域名的别名）

主机记录：
    WWW BBS等，就是域名前面的部分，如果要解析顶级域名，也就是前面没有内容则使用@代替

解析线路：
    通过这一设置可以将不同线路的用户解析到不同的服务器。如：将联通用户解析到一个服务器，将电信用户解析到另一个服务器。

记录值：
    解析的目标值，如：A记录就是IP，CNAME记录就是对应的目标域名。

TTL：
    本地DNS服务器缓存解析结果的时间
</code></pre><blockquote>
<p>提示：一个域名可以添加多条解析记录</p>
</blockquote>
<h2 id="3-2-win7设置DNS服务器"><a href="#3-2-win7设置DNS服务器" class="headerlink" title="3.2 win7设置DNS服务器"></a>3.2 win7设置DNS服务器</h2><p>该设置是将网络属性中的ipv4属性的首选DNS服务器的ip设置为：114.114.114.114</p>
<h2 id="3-3-win设置本机域名与ip的对应关系"><a href="#3-3-win设置本机域名与ip的对应关系" class="headerlink" title="3.3 win设置本机域名与ip的对应关系"></a>3.3 win设置本机域名与ip的对应关系</h2><p>通过hosts设置</p>
<hr>
<h1 id="第4章-Java中Socket的用法"><a href="#第4章-Java中Socket的用法" class="headerlink" title="第4章 Java中Socket的用法"></a>第4章 Java中Socket的用法</h1><p>Java中的Socket可以分为普通Socket与NioSocket两种。</p>
<h2 id="4-1-普通Socket用法"><a href="#4-1-普通Socket用法" class="headerlink" title="4.1 普通Socket用法"></a>4.1 普通Socket用法</h2><p>Java中的网络通信通过Socket实现，Socket分为ServerSocket与Socket两大类，ServerSocket用于服务端，可以通过accept方法监听请求，监听请求后返回Socket，Socket用于具体完成数据传输，客户端直接使用Socket发起请求并传输数据。</p>
<p><strong>ServerSocket的使用</strong><br></p>
<pre><code>1.创建ServerSocket
2.调用创建出来的ServerSocket的accept方法进行监听（accept方法是阻塞方法，在调用accept方法之后，程序会停下来等待连接请求）
3.在accept方法获取请求后，用返回的Socket创建Reader和Writer来接收和发送数据
</code></pre><p><strong>Socket的使用</strong><br></p>
<pre><code>1.创建Socket （这里讲目标主机的地址和端口号传入即可）
</code></pre><p>…</p>
<h2 id="4-2-NioSocket的用法"><a href="#4-2-NioSocket的用法" class="headerlink" title="4.2 NioSocket的用法"></a>4.2 NioSocket的用法</h2><p>在Java1.4之后增加了新的io模式（nio - new IO），在底层采用新的处理方式，极大的提高了io的效率。nio提供相应的工具：ServerSocketChannel和SocketChannel，它们分别对应原来的ServerSocket和Socket。在这里我们如果要理解NioSocket的使用需要先理解：Buffer、Channel和Selector。</p>
<p><strong>NioSocket的使用</strong><br></p>
<pre><code>1.首先创建ServerSocketChannel，然后注册Selector，接下来用Selector接收请求处理。
2.ServerSocketChannel可以使用自己的静态工厂方法open创建
</code></pre><hr>
<h1 id="第6章-详解Servlet"><a href="#第6章-详解Servlet" class="headerlink" title="第6章 详解Servlet"></a>第6章 详解Servlet</h1><p>Servlet的结构图包括：</p>
<pre><code>HttpServlet
     |
    GenericServlet
    /\
ServletConfig Servlet
</code></pre><hr>
<h1 id="第8章-SpringMVC体验"><a href="#第8章-SpringMVC体验" class="headerlink" title="第8章 SpringMVC体验"></a>第8章 SpringMVC体验</h1><h2 id="8-1-SpringMVC简单配置"><a href="#8-1-SpringMVC简单配置" class="headerlink" title="8.1 SpringMVC简单配置"></a>8.1 SpringMVC简单配置</h2><pre><code>1.在web.xml中配置Servlet
2.创建Spring MVC的xml文件
3.创建Controller和view
</code></pre><blockquote>
<p>提示：<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a> 是SpringMVC提供的一键式配制方法，配置此标签之后SpringMVC会帮助我们自动做一些注册组件之类的事情。配置 <a href="context:component-scan/" target="_blank" rel="noopener">context:component-scan/</a> 标签类扫描通过注释配置的类。 通过配置 <a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a> 标签设置只扫描@Controller标签。 如果没有配置ViewResolver，SpringMVC自动使用默认的InternalResourceViewResolver作为ViewResolver，prefix和suffix都为空。</p>
</blockquote>
<hr>
<h1 id="第9章-创建SpringMVC之器"><a href="#第9章-创建SpringMVC之器" class="headerlink" title="第9章 创建SpringMVC之器"></a>第9章 创建SpringMVC之器</h1><p>本章介绍SpringMVC自身的创建过程，SpringMVC中的Servlet包括：HttpServletBean | FrameworkServlet | DispatcherServlet。HttpServletBean继承HTTPServlet，作用是将Servlet中配置的参数设置到相应的属性。FrameworkServlet初始化了WebApplicationContext。DispatcherServlet初始化了自身的9个组件。</p>
<hr>
<h1 id="第10章-Spring-mvc之用"><a href="#第10章-Spring-mvc之用" class="headerlink" title="第10章 Spring mvc之用"></a>第10章 Spring mvc之用</h1><h2 id="10-1-HttpServletBean"><a href="#10-1-HttpServletBean" class="headerlink" title="10.1 HttpServletBean"></a>10.1 HttpServletBean</h2><p>HttpServletBean主要参与创建工作，没有涉及请求处理。</p>
<h2 id="10-2-FrameworkServlet"><a href="#10-2-FrameworkServlet" class="headerlink" title="10.2 FrameworkServlet"></a>10.2 FrameworkServlet</h2><p>我们知道Servlet的处理过程，首先从Servlet接口的service()方法开始，然后在HttpServlet的service()方法中根据请求类型不同将请求路由到doGet|doHead|doPost|doPut|doDelete|doOptions|doTrace七个方法，同时做了doHead|doOptions|doTrace的默认实现，其中doHead调用doGet，返回只有header没有body的response。</p>
<h2 id="10-3-DispatcherServlet"><a href="#10-3-DispatcherServlet" class="headerlink" title="10.3 DispatcherServlet"></a>10.3 DispatcherServlet</h2><blockquote>
<p>Handler | HandlerMapping | HandlerAdapter ：Handler表示用来干活的工具，如：车床等。HandlerMapping表示根据加工的需求选择什么设备加工。HandlerAdapter表示操作设备的工人，从而不同的Handler需要不同的HandlerAdapter去使用。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：这里view 和 ViewResolver类似，view用来展示数据，而ViewResolver用来查找view。</p>
</blockquote>
</blockquote>
<h2 id="10-4-doDispatch"><a href="#10-4-doDispatch" class="headerlink" title="10.4 doDispatch"></a>10.4 doDispatch</h2><p>doDispatch大概分为两个部分：处理请求和渲染页面。</p>
<hr>
<hr>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC10%E7%AB%A0%20Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h2><p>Java的线程既是工作单元，也是执行机制。所以在JDK 1.5 之后将工作单元和执行机制分离开，工作单元包括 Runnable 和 Callable ，执行机制由 Executor 框架提供。</p>
<p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<h3 id="10-1-Executor-框架简介"><a href="#10-1-Executor-框架简介" class="headerlink" title="10.1 Executor 框架简介"></a>10.1 Executor 框架简介</h3><h4 id="10-1-1-Executor-框架的两级调度模型"><a href="#10-1-1-Executor-框架的两级调度模型" class="headerlink" title="10.1.1 Executor 框架的两级调度模型"></a>10.1.1 Executor 框架的两级调度模型</h4><p>在上层，Java多线程程序通常将应用分解为若干个任务，然后使用用户级的调度器(Executor框架)将这些任务映射为固定数量的线程。</p>
<p>在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<h4 id="10-1-2-Executor-框架的结构和成员"><a href="#10-1-2-Executor-框架的结构和成员" class="headerlink" title="10.1.2 Executor 框架的结构和成员"></a>10.1.2 Executor 框架的结构和成员</h4><p><strong>1.Executor 框架的结构</strong><br></p>
<blockquote>
<p>注意：Executor框架由两个关键类实现了ExecutorService接口(ThreadPoolExecutor和ScheduledThreadPoolExecutor)。</p>
</blockquote>
<p>Executor 框架由3大部分组成：</p>
<pre><code>1.任务：包括被执行任务需要实现的接口（Runnable接口 | Callable接口）

2.任务的执行：包括任务执行机制的核心接口Executor，以及继承Executor的ExecutorService接口。

3.异步计算的结果：包括接口Future接口和实现Future接口的FutureTask类。
</code></pre><p>Executor框架包括的主要的类和接口：</p>
<pre><code>1.Executor接口：是Executor框架基础，将任务的提交与任务的执行分离开。

2.ThreadPoolExecutor线程池核心实现类：用来执行被提交的任务。

3.ScheduledThreadPoolExecutor实现类：在给定的延迟后运行命令，或者定期执行命令。

4.Future接口和实现Future接口的FutureTask类：代表异步计算的结果。

5.Runnable接口和Callable接口的实现类：可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行。
</code></pre><blockquote>
<p>任务执行过程：</p>
</blockquote>
<p>1.首先主线程创建实现 Runnable 或者 Callable 接口的任务对象。工具类Executor可将一个Runnable对象封装成一个Callable对象。<br></p>
<p>2.然后可以将Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runnable command))，或者可以将Runnable对象交给 ExecutorService执行(ExecutorService.submit(Runnable task))或ExecutorService.submit(Callable<t> task)。<br></t></p>
<p>3.最后主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel() 来取消任务执行。</p>
<p><strong>2.Executor框架成员</strong><br></p>
<p>1.ThreadPoolExecutor</p>
<p>ThreadPoolExecutor 通常使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor。</p>
<pre><code>1.FixedThreadPool

2.SingleThreadExecutor

3.CachedThreadPool
</code></pre><p>2.ScheduledThreadPoolExecutor</p>
<pre><code>1.ScheduledThreadPoolExecutor：适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。

2.SingleThreadScheduledExecutor：适用于需要单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景。
</code></pre><p>3.Future接口</p>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduleThreadPoolExecutor会向我们返回一个FutureTask对象。</p>
<p>4.Runnable接口和Callable接口</p>
<p>Runnable接口和Callable接口都可以被ThreadPoolExecutor | ScheduledThreadPoolExecutor 执行，它们之间的区别在于 Runnable 不会返回结果，而Callable可以返回结果。</p>
<h3 id="10-2-ThreadPoolExecutor详解"><a href="#10-2-ThreadPoolExecutor详解" class="headerlink" title="10.2 ThreadPoolExecutor详解"></a>10.2 ThreadPoolExecutor详解</h3><p>主要有是三种Executor：1.CachedThreadPool：一个任务创建一个线程。2.FixedThreadPool：所有任务只能使用固定大小的线程。3.SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
<h4 id="10-2-1-FixedThreadPool详解"><a href="#10-2-1-FixedThreadPool详解" class="headerlink" title="10.2.1 FixedThreadPool详解"></a>10.2.1 FixedThreadPool详解</h4><p>该线程池被称作可重用固定线程数线程池。</p>
<h4 id="10-2-2-SingleThreadExecutor详解"><a href="#10-2-2-SingleThreadExecutor详解" class="headerlink" title="10.2.2 SingleThreadExecutor详解"></a>10.2.2 SingleThreadExecutor详解</h4><p>该线程池是使用单个worker线程的Executor。</p>
<h4 id="10-2-3-CachedThreadPool详解"><a href="#10-2-3-CachedThreadPool详解" class="headerlink" title="10.2.3 CachedThreadPool详解"></a>10.2.3 CachedThreadPool详解</h4><p>该线程池是一个会根据需要创建新线程的线程池。</p>
<h3 id="10-3-ScheduledThreadPoolExecutor详解"><a href="#10-3-ScheduledThreadPoolExecutor详解" class="headerlink" title="10.3 ScheduledThreadPoolExecutor详解"></a>10.3 ScheduledThreadPoolExecutor详解</h3><p>ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutorz。其主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、灵活。Timer对应单个后台线程。</p>
<h4 id="10-3-1-ScheduledThreadPoolExecutor-的运行机制"><a href="#10-3-1-ScheduledThreadPoolExecutor-的运行机制" class="headerlink" title="10.3.1 ScheduledThreadPoolExecutor 的运行机制"></a>10.3.1 ScheduledThreadPoolExecutor 的运行机制</h4><h3 id="10-4-FutureTask详解"><a href="#10-4-FutureTask详解" class="headerlink" title="10.4 FutureTask详解"></a>10.4 FutureTask详解</h3><p>Future接口和实现了Future接口的FutureTask类，表示的是异步计算的结果。</p>
<h4 id="10-4-1-FutureTask简介"><a href="#10-4-1-FutureTask简介" class="headerlink" title="10.4.1 FutureTask简介"></a>10.4.1 FutureTask简介</h4><p>FutureTask除实现Future接口之外，还是Runnable接口。所以FutureTask可以交给Executor执行，也可以调用线程直接执行(FutureTask.run())。</p>
<p>FutureTask可以处于以下3中状态：</p>
<pre><code>1.未启动：

2.已启动：

3.已完成：
</code></pre><h4 id="10-4-2-FutureTask的使用"><a href="#10-4-2-FutureTask的使用" class="headerlink" title="10.4.2 FutureTask的使用"></a>10.4.2 FutureTask的使用</h4><p>可以将FutureTask交给Executor执行，或者通过ExecutorService.submit()方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel()方法。</p>
<h4 id="10-4-3-FutureTask的实现"><a href="#10-4-3-FutureTask的实现" class="headerlink" title="10.4.3 FutureTask的实现"></a>10.4.3 FutureTask的实现</h4><p>FutureTask的实现基于 AbstractQueuedSynchronizer（AQS）。</p>
<blockquote>
<p>提示：java.util.concurrent中很多阻塞类（ReentrantLock）都是基于AQS实现的。AQS 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：基于AQS实现的同步器包括：ReentrantLock | Semaphore | ReentrantReadWriteLock | CountDownLatch | FutureTask。</p>
</blockquote>
</blockquote>
<p>每一个AQS实现的同步器都会包含两种类型的操作：</p>
<pre><code>1.至少有一个acquire操作。该做操阻塞调用线程，直到AQS允许这个线程执行。

    FutureTask的acquire操作是：get()/get(long timeout, TimeUnit unit)方法调用

2.至少有一个release操作。该操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。

    FutureTask的release操作包括run()方法和cancel()方法
</code></pre><h3 id="10-5-Future-模式"><a href="#10-5-Future-模式" class="headerlink" title="10.5 Future 模式"></a>10.5 Future 模式</h3><p>Future模式是多线程开发中常见的一种设计模式，核心思想是异步调用。在调用的方法返回的结果很慢的时候，我们可以让它在后台慢慢执行，我们利用这段时间处理其它任务，在真正需要数据的场合再去尝试获得需要的数据。</p>
<h4 id="10-5-1-Future模式主要方法"><a href="#10-5-1-Future模式主要方法" class="headerlink" title="10.5.1 Future模式主要方法"></a>10.5.1 Future模式主要方法</h4><pre><code>1. boolean cancel(boolean mayInterruptIfRunning);//取消任务

2. boolean isCancelled();//是否已经取消

3. boolean isDone();//是否已经完成

4. V get() throws InterruptedException..;//取得返回对象

5. V get(long timeout, TimeUnit unit);//取得返回对象，可以设置超时时间
</code></pre>]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC11%E7%AB%A0%20Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第十一章-Java并发编程实战"><a href="#第十一章-Java并发编程实战" class="headerlink" title="第十一章 Java并发编程实战"></a>第十一章 Java并发编程实战</h2><h3 id="11-1-生产者和消费者模式"><a href="#11-1-生产者和消费者模式" class="headerlink" title="11.1 生产者和消费者模式"></a>11.1 生产者和消费者模式</h3><blockquote>
<p>提示：生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。</p>
</blockquote>
<p>生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列中取。所以这里的阻塞队列相当于一个缓冲区，平衡生产者和消费者的处理能力。</p>
<h3 id="11-2-ArrayBlockingQueue"><a href="#11-2-ArrayBlockingQueue" class="headerlink" title="11.2 ArrayBlockingQueue"></a>11.2 ArrayBlockingQueue</h3><h3 id="11-3-并发组件ConcurrentHashMap使用注意事项"><a href="#11-3-并发组件ConcurrentHashMap使用注意事项" class="headerlink" title="11.3 并发组件ConcurrentHashMap使用注意事项"></a>11.3 并发组件ConcurrentHashMap使用注意事项</h3><p>在ConcurrentHashMap中的方法map.putIfAbsent()方法添加新设备列表时，如果在key在map中不存在，则将key与对应的值放入map中。注意的是这个操作是原子性操作，放入后会返回null。</p>
<p>如果key在map中存在，则调用putIfAbsent()会返回key对应的value值。如果发现返回的value值不是null则将新的value值添加到返回的列表里面，从而问题得到解决。</p>
<blockquote>
<p>总结：put(K key, V value)方法判断，如果key已经存在，则使用value覆盖原来的值并返回原来的值。如果key不存在则将value放入并返回null。putIfAbsent(K key, V value)方法则是如果key已经存在则直接返回原来对应的值并不使用value覆盖，如果key不存在则放入value并返回null。另外需要注意的是，判断key是否存在和放入是原子操作。</p>
</blockquote>
<h3 id="11-4-SimpleDateFormat-是线程不安全的"><a href="#11-4-SimpleDateFormat-是线程不安全的" class="headerlink" title="11.4 SimpleDateFormat 是线程不安全的"></a>11.4 SimpleDateFormat 是线程不安全的</h3><p>SimpleDateFormat是Java提供的一个格式化和解析日期的工具类，但是它不是线程安全的。所以在多线程程序中共用一个SimpleDateFormat实例对日期进行解析或者格式化会导致程序出错。 </p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>由于多线程使用的是一个calendar对象，所以线程A执行程序之后，线程B再次执行可能是线程A清空的对象，从而导致程序错误。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><pre><code>1. 每次使用时候new一个SimpleDateFormat的实例，这样可以保证每个实例使用自己的Calendar实例。

    这样的过程由于没有其它的引用，需要回收，开销很大

2. 可使用synchronized进行同步

    这样的方式同样也意味着多个线程要竞争锁，在高并发场景下会导致系统响应性能下降。

3. ThreadLocal 这样每个线程只需要使用一个SimpleDateFormat实例
</code></pre><h3 id="11-5-使用Timer时需要注意的事情"><a href="#11-5-使用Timer时需要注意的事情" class="headerlink" title="11.5 使用Timer时需要注意的事情"></a>11.5 使用Timer时需要注意的事情</h3><p>当一个Timer运行多个TimerTask时，只要其中一个TimerTask在执行中向run()方法外抛出了异常，则其它任务也会自动终止。</p>
<h4 id="11-5-2-Timer实现原理分析"><a href="#11-5-2-Timer实现原理分析" class="headerlink" title="11.5.2 Timer实现原理分析"></a>11.5.2 Timer实现原理分析</h4><p>TaskQueue是一个由平衡二叉树堆实现的优先级队列，每个Timer对象内部有一个TaskQueue队列。</p>
<p>用户线程调用Timer的schedule()方法就是将TimerTask任务添加到TaskQueue队列。</p>
<p>在调用schedule()方法时，long delay参数表示任务延迟多少时间执行。</p>
<blockquote>
<p>注意：TimerThread是具体执行任务的线程，是从TaskQueue队列里面获取优先级最高的任务进行执行。只有执行完当前的任务才会从队列里面获取下一个任务，不管队列是否有任务已经到了设置的delay时间。一个Timer只有一个TimerThread线程，所以在Timer的内部实现是一个 多生产者-单消费者模型。</p>
</blockquote>
<p>其实如果需要Timer功能，使用ScheduleThreadPoolExecutor的schedule()是比较好的选择。如果在ScheduledThreadPoolExecutor中的一个任务抛出异常，其它任务不受影响。</p>
<blockquote>
<p>提示：ScheduledThreadPoolExecutor的其它任务不受抛出异常任务的影响，是因为在ScheduledThreadPoolExecutor中的ScheduledFutureTask任务中catch掉了异常。</p>
</blockquote>
<h3 id="11-6-使用ThreadLocal不当会导致内存泄漏"><a href="#11-6-使用ThreadLocal不当会导致内存泄漏" class="headerlink" title="11.6 使用ThreadLocal不当会导致内存泄漏"></a>11.6 使用ThreadLocal不当会导致内存泄漏</h3><p>ThreadLocal只是一个工具类，具体存放变量的是线程的threadLocals变量。</p>
<p>threadLocals变量是一个ThreadLocalMap类型变量，</p>
<h3 id="11-7-线程池使用FutureTask时需要注意的事情"><a href="#11-7-线程池使用FutureTask时需要注意的事情" class="headerlink" title="11.7 线程池使用FutureTask时需要注意的事情"></a>11.7 线程池使用FutureTask时需要注意的事情</h3><p>线程池在使用FutrueTask时如果将拒绝策略设置为 DiscardPolicy 和 DiscardOldestPolicy，并且在被拒绝的任务的Future对象上调用了无参get()方法，那么调用线程会一直被阻塞。</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerMapping</title>
    <url>/undefined/%E7%AC%AC12%E7%AB%A0%20HandlerMapping/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第12章-HandlerMapping"><a href="#第12章-HandlerMapping" class="headerlink" title="第12章 HandlerMapping"></a>第12章 HandlerMapping</h1><p>[TOC]</p>
<p>HandlerMapping的作用是通过request查找Handler和Interceptors。HandlerMapping包括继承AbstractUrlHandlerMapping和继承AbstractHandlerMapping，这两支都继承抽象类AbstractHandlerMapping。</p>
<h2 id="12-1-AbstractHandlerMapping"><a href="#12-1-AbstractHandlerMapping" class="headerlink" title="12.1 AbstractHandlerMapping"></a>12.1 AbstractHandlerMapping</h2><p>AbstractHandlerMapping是HandlerMapping抽象实现。其采用模板模式设计了HandlerMapping实现的整体结构。子类通过模板方法提供初始值或者具体算法即可。这种模式是：首先使用一个抽象实现采用模板模式进行整体设计，然后在子类通过实现模板方法具体实现业务。</p>
<p>HandlerMapping的作用是是通过request查找Handler和Interceptors。获取Handler的过程通过模板方法getHandlerInternal()交给子类。AbstractHandlerMapping中保存了所有的配置Interceptor，在获取Handler后会自己根据从request中获取的lookupPath将相应的Interceptor装配。子类也可以如此。</p>
<h4 id="12-1-1-创建AbstractHandlerMapping"><a href="#12-1-1-创建AbstractHandlerMapping" class="headerlink" title="12.1.1 创建AbstractHandlerMapping"></a>12.1.1 创建AbstractHandlerMapping</h4><p>AbstractHandlerMapping继承WebApplicationObjectSupport，初始化时会自动调用模板方法initApplicationContext()方法。AbstractHandlerMapping创建是在initApplicationContext()方法中。</p>
<pre><code>package org.springframework.web.servlet.handler;
public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport implements HandlerMapping, Ordered {
    // ...
 }

protected void initApplicationContext() throws BeansException {
    //该方法是模板方法，给子类提供一个添加或修改Interceptors的入口
    extendInterceptors(this.interceptors);

    //将SpringMVC容器和父容器中所有的MappedInterceptor类型的Bean添加到mappedInterceptors属性
    detectMappedInterceptors(this.mappedInterceptors);

    //该方法的作用是初始化Interceptor
    initInterceptors();
}

//提供给子类扩展拦截器(没有使用)
protected void extendInterceptors(List&lt;Object&gt; interceptors) {

    }

//扫描应用下的MappedInterceptor,并添加到mappedInterceptors
protected void detectMappedInterceptors(List&lt;MappedInterceptor&gt; mappedInterceptors) {
     mappedInterceptors.addAll(
             BeanFactoryUtils.beansOfTypeIncludingAncestors(
                     getApplicationContext(),MappedInterceptor.class, true, false).values());
 }

//归集MappedInterceptor,并适配HandlerInterceptor和WebRequestInterceptor
protected void initInterceptors() {
     if (!this.interceptors.isEmpty()) {
         for (int i = 0; i &lt; this.interceptors.size(); i++) {
             Object interceptor = this.interceptors.get(i);
             if (interceptor == null) {
                 throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);
             }
             if (interceptor instanceof MappedInterceptor) {
                 mappedInterceptors.add((MappedInterceptor) interceptor);
             }
             else {
                 adaptedInterceptors.add(adaptInterceptor(interceptor));
             }
         }
     }
 }

AbstractHandlerMapping的属性：

    // order赋了最大值,优先级是最小的
    private int order = Integer.MAX_VALUE;

    // 默认的Handler,这边使用的Obejct,子类实现的时候,使用HandlerMethod,HandlerExecutionChain等
    private Object defaultHandler;

    // url计算的辅助类
    private UrlPathHelper urlPathHelper = new UrlPathHelper();

    // 基于ant进行path匹配,解决如/books/{id}场景
    private PathMatcher pathMatcher = new AntPathMatcher();

    // 拦截器配置:两种配置方式 interceptors只用于配置
    // 1 HandlerMapping属性设置;
    // 2 extendInterceptors设置
    private final List&lt;Object&gt; interceptors = new ArrayList&lt;Object&gt;();

    // 从interceptors中解析得到,直接添加给全部handler
    private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;HandlerInterceptor&gt;();

    // 使用前需要跟url进行匹配,匹配通过才会使用。匹配成功后将其添加到getHandler的返回值HandlerExecutionChain中。
    private final List&lt;MappedInterceptor&gt; mappedInterceptors = new ArrayList&lt;MappedInterceptor&gt;();
</code></pre><blockquote>
<p>提示：WebApplicationObjectSupport用于提供上下文ApplicationContext和ServletContext。AbstractHandlerMapping的创建就是上面三个Interceptor的初始化。</p>
</blockquote>
<h4 id="12-1-2-AbstractHandlerMapping的使用"><a href="#12-1-2-AbstractHandlerMapping的使用" class="headerlink" title="12.1.2 AbstractHandlerMapping的使用"></a>12.1.2 AbstractHandlerMapping的使用</h4><p>HandlerMapping通过getHandler()方法获取处理器Handler和拦截器Interceptors。</p>
<pre><code>public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    //留给子类具体实现，子类主要做的事情
    Object handler = getHandlerInternal(request);

    //没有获取到则使用默认的Handler
    if (handler == null) {
        handler = getDefaultHandler();
    }
    if (handler == null) {
        return null;
    }
    // Bean name or resolved handler?
    if (handler instanceof String) {
        String handlerName = (String) handler;
        handler = getApplicationContext().getBean(handlerName);
    }
    return getHandlerExecutionChain(handler, request);
}

//这里预留getHandlerInternal(HttpServletRequest request)方法给子类实现
protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception;
</code></pre><p>然后封装拦截器到HandlerExecutionChain()，该方法用于添加拦截器。</p>
<pre><code>protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {

    //1.首先使用handler创建HandlerExecutionChain类型变量
    HandlerExecutionChain chain = 
    (handler instanceof HandlerExecutionChain) ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler);

    //adaptedInterceptors直接添加
    chain.addInterceptors(getAdaptedInterceptors());

    //mappedInterceptors需要根据url匹配通过后添加
    String lookupPath = urlPathHelper.getLookupPathForRequest(request);
    for (MappedInterceptor mappedInterceptor : mappedInterceptors) {
        if (mappedInterceptor.matches(lookupPath, pathMatcher)) {
            chain.addInterceptor(mappedInterceptor.getInterceptor());
        }
    }

    return chain;
}
</code></pre><h2 id="12-2-AbstractUrlHandlerMapping"><a href="#12-2-AbstractUrlHandlerMapping" class="headerlink" title="12.2 AbstractUrlHandlerMapping"></a>12.2 AbstractUrlHandlerMapping</h2><p>从名字可以看出是通过url进行匹配的。大致原理是将url与对应的handler保存到一个Map中，在getHandlerInternal()方法中使用url从Map中获取Handler，AbstractUrlHandlerMapping中实现了具体用url从Map中获取Handler的过程。</p>
<pre><code>@Override
protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
    // 根据request获取url
    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
    // 根据url查找handler
    Object handler = lookupHandler(lookupPath, request);
    if (handler == null) {
        // 如果没有匹配到handler需要查找默认的,下面需要将PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE缓存到request
        //临时变量，保存找到的原始Handler
        Object rawHandler = null;
        if (&quot;/&quot;.equals(lookupPath)) {
            rawHandler = getRootHandler();
        }
        if (rawHandler == null) {
            rawHandler = getDefaultHandler();
        }
        if (rawHandler != null) {
            //如果是String类型则到容器中查找具体的bean
            if (rawHandler instanceof String) {
                String handlerName = (String) rawHandler;
                rawHandler = getApplicationContext().getBean(handlerName);
            }
            // 预留的校验handler模板方法,没有使用
            validateHandler(rawHandler, request);
            // 添加expose属性到request的拦截器
            handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
        }
    }
    if (handler != null &amp;&amp; logger.isDebugEnabled()) {
        logger.debug(&quot;Mapping [&quot; + lookupPath + &quot;] to &quot; + handler);
    }
    else if (handler == null &amp;&amp; logger.isTraceEnabled()) {
        logger.trace(&quot;No handler mapping found for [&quot; + lookupPath + &quot;]&quot;);
    }
    return handler;
}
</code></pre><blockquote>
<p>提示：这里的lookupHandler()方法用于使用lookupPath从Map中查找Handler。buildPathExposiongHandler()方法用于给查找到的Handler注册两个拦截器PathExposingHandlerIntercptor和UriTemplateVariablesHandlerInterceptor。这两个是内部拦截器，主要作用是将与当前url实际匹配的pattern、匹配条件和url模板参数等设置到request的属性中。这样一来在后面的处理过程中就能够直接从request中获取。</p>
</blockquote>
<pre><code>protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
    // 直接根据url进行查找handler，直接从Map中获取
    Object handler = this.handlerMap.get(urlPath);
    if (handler != null) {
        // 如果是String类型直接从容器中获取
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        validateHandler(handler, request);
        return buildPathExposingHandler(handler, urlPath, urlPath, null);
    }
    // Pattern match? 通过表达式进行匹配具体通过AntPathMatcher实现,具体后面分析
    List&lt;String&gt; matchingPatterns = new ArrayList&lt;String&gt;();
    for (String registeredPattern : this.handlerMap.keySet()) {
        if (getPathMatcher().match(registeredPattern, urlPath)) {
            matchingPatterns.add(registeredPattern);
        }
    }
    String bestPatternMatch = null;
    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);
    if (!matchingPatterns.isEmpty()) {
        Collections.sort(matchingPatterns, patternComparator);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Matching patterns for request [&quot; + urlPath + &quot;] are &quot; + matchingPatterns);
        }
        // order序号最小的优先级最高
        bestPatternMatch = matchingPatterns.get(0);
    }
    if (bestPatternMatch != null) {
        handler = this.handlerMap.get(bestPatternMatch);
        // 如果是String类型则从容器中获取
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        validateHandler(handler, request);
        String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);

        //处理使用sort()方法排序之后，多个Pattern顺序相同，返回值为0的情况
        Map&lt;String, String&gt; uriTemplateVariables = new LinkedHashMap&lt;String, String&gt;();
        for (String matchingPattern : matchingPatterns) {
            if (patternComparator.compare(bestPatternMatch, matchingPattern) == 0) {
                Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);
                Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);
                uriTemplateVariables.putAll(decodedVars);
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;URI Template variables for request [&quot; + urlPath + &quot;] are &quot; + uriTemplateVariables);
        }
        return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);
    }
    // No handler found...
    return null;
}
</code></pre><h4 id="12-2-1-SimpleUrlHandlerMapping"><a href="#12-2-1-SimpleUrlHandlerMapping" class="headerlink" title="12.2.1 SimpleUrlHandlerMapping"></a>12.2.1 SimpleUrlHandlerMapping</h4><p>该类定义了一个Map变量(两个作用：1.方便配置。2.在注册前做一些预处理。如：确保所有的url都以””/“开头)，将所有的url和handler的对应关系放在里面，最后注册到父类的Map中。AbstractDetectingUrlHandlerMapping是将容器中所有bean拿出来，按照一定规则注册到父类的Map中。</p>
<p>SimpleUrlHandlerMapping在创建时重写父类的initApplicationContext()方法，调用registerHandlers()方法完成Handler注册。registerHandlers()方法调用AbstractHandlerMapping的registerHandler()方法将配置的urlMap注册到AbstractUrlHandlerMapping的Map中。</p>
<blockquote>
<p>总结：该类就是直接将配置的内容注册到AbstractUrlHandlerMapping中去。</p>
</blockquote>
<h4 id="12-2-2-AbstractDetectingUrlHandlerMapping"><a href="#12-2-2-AbstractDetectingUrlHandlerMapping" class="headerlink" title="12.2.2 AbstractDetectingUrlHandlerMapping"></a>12.2.2 AbstractDetectingUrlHandlerMapping</h4><p>该类也是通过重写initApplicationContext来注册Handler，在里面调用了detectHandler()方法。在detectHandlers()中根据配置的detectHand-lersInAncestorContexts参数从Springmvc容器或者Springmvc及其父容器中找到所有的bean的beanName，然后使用方法determineUrlsHandler()方法对每个beanName解析出对应的urls。</p>
<pre><code>@Override
public void initApplicationContext() throws ApplicationContextException {
    //进行初始化
    super.initApplicationContext();

    detectHandlers();
}

protected void detectHandlers() throws BeansException {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Looking for URL mappings in application context: &quot; + getApplicationContext());
    }

    //获取容器的所有bean的名字
    String[] beanNames = (this.detectHandlersInAncestorContexts ?
            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :
            getApplicationContext().getBeanNamesForType(Object.class));

    // 对每个beanName解析url，如果能解析到就注册到父类的Map中
    for (String beanName : beanNames) {

        //使用beanName解析url，是模板方法，子类具体实现
        String[] urls = determineUrlsForHandler(beanName);

        //如果能解析到url则注册到父类
        if (!ObjectUtils.isEmpty(urls)) {
            // 父类的registerHandler方法
            registerHandler(urls, beanName);
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Rejected bean name &apos;&quot; + beanName + &quot;&apos;: no URL paths identified&quot;);
            }
        }
    }
}

//预留的模板方法
protected abstract String[] determineUrlsForHandler(String beanName);
</code></pre><blockquote>
<p>提示：AbstractDetectingUrlHandlerMapping中有三个类：BeanNameUrlHandlerMapping | DefaultAnnotationHandlerMapping(@Deprecated 已被弃用) | AbstractControllerUrlHandlerMapping 。</p>
</blockquote>
<p><strong>1.BeanNameUrlHandlerMapping</strong><br><br>该类是检查beanName和alias是否是以”/“开头，如果是则将其作为url，里面只有一个determineUrlsForHandler()方法。</p>
<pre><code>/**
 * Checks name and aliases of the given bean for URLs, starting with &quot;/&quot;.
 */
@Override
protected String[] determineUrlsForHandler(String beanName) {
    List&lt;String&gt; urls = new ArrayList&lt;String&gt;();
    if (beanName.startsWith(&quot;/&quot;)) {
        urls.add(beanName);
    }
    String[] aliases = getApplicationContext().getAliases(beanName);
    for (String alias : aliases) {
        if (alias.startsWith(&quot;/&quot;)) {
            urls.add(alias);
        }
    }
    return StringUtils.toStringArray(urls);
}
</code></pre><p><strong>2.AbstractControllerUrlHandlerMapping</strong><br><br>该类是将实现了Controller接口或注释@Controller的bean作为Handler，同时可以设置excludedClasses和excludedPackages将不包含的bean或者不包含的包下的所有bean排除在外。这里的determineUrlsForHandler()方法主要负责将符合条件的Handler找出来。</p>
<pre><code>//determineUrlsForHandler()方法主要负责将符合条件的Handler找出来
@Override
protected String[] determineUrlsForHandler(String beanName) {
    Class beanClass = getApplicationContext().getType(beanName);
    if (isEligibleForMapping(beanName, beanClass)) {
        return buildUrlsForHandler(beanName, beanClass);
    }
    else {
        return null;
    }
}

//判断controller是否被排除在外(通过包package排除或类class排除)
protected boolean isEligibleForMapping(String beanName, Class beanClass) {
    if (beanClass == null) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Excluding controller bean &apos;&quot; + beanName + &quot;&apos; from class name mapping &quot; +
                    &quot;because its bean type could not be determined&quot;);
        }
        return false;
    }

    //排除excludedClasses里配置的类
    if (this.excludedClasses.contains(beanClass)) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Excluding controller bean &apos;&quot; + beanName + &quot;&apos; from class name mapping &quot; +
                    &quot;because its bean class is explicitly excluded: &quot; + beanClass.getName());
        }
        return false;
    }
    String beanClassName = beanClass.getName();

    //排除excludedPackages里配置的包下的类
    for (String packageName : this.excludedPackages) {
        if (beanClassName.startsWith(packageName)) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Excluding controller bean &apos;&quot; + beanName + &quot;&apos; from class name mapping &quot; +
                        &quot;because its bean class is defined in an excluded package: &quot; + beanClass.getName());
            }
            return false;
        }
    }

    //检查是否实现了Controller接口或注释了@Controller
    return isControllerType(beanClass);
}
</code></pre><p><strong>2.1 AbstractControllerUrlHandlerMapping 的实现类 ControllerBeanNameUrlHandlerMapping</strong><br><br>此类是根据beanName来生产url。</p>
<pre><code>@Override
protected String[] buildUrlsForHandler(String beanName, Class beanClass) {
    List&lt;String&gt; urls = new ArrayList&lt;String&gt;();
    urls.add(generatePathMapping(beanName));
    String[] aliases = getApplicationContext().getAliases(beanName);// 也获取配置的别名
    for (String alias : aliases) {
        urls.add(generatePathMapping(alias));
    }
    return StringUtils.toStringArray(urls);
}
</code></pre><p><strong>2.2 AbstractControllerUrlHandlerMapping 的实现类 ControllerClassNameUrlHandlerMapping</strong><br><br>此类是根据className来生产url。</p>
<pre><code>//对path添加前后缀,还有/
protected String generatePathMapping(String beanName) {
    String name = (beanName.startsWith(&quot;/&quot;) ? beanName : &quot;/&quot; + beanName);
    StringBuilder path = new StringBuilder();
    if (!name.startsWith(this.urlPrefix)) {
        path.append(this.urlPrefix);
    }
    path.append(name);
    if (!name.endsWith(this.urlSuffix)) {
        path.append(this.urlSuffix);
    }
    return path.toString();
}
</code></pre><blockquote>
<p>提示：ControllerClassNameUrlHandlerMapping直接委托给 generatePathMappings 实现。</p>
</blockquote>
<pre><code>@Override
protected String[] buildUrlsForHandler(String beanName, Class beanClass) {
    return generatePathMappings(beanClass);
}


protected String[] generatePathMappings(Class beanClass) {
    StringBuilder pathMapping = buildPathPrefix(beanClass);
    String className = ClassUtils.getShortName(beanClass);
    String path = (className.endsWith(CONTROLLER_SUFFIX) ?
            className.substring(0, className.lastIndexOf(CONTROLLER_SUFFIX)) : className);
    if (path.length() &gt; 0) {
        if (this.caseSensitive) {
            pathMapping.append(path.substring(0, 1).toLowerCase()).append(path.substring(1));
        }
        else {
            pathMapping.append(path.toLowerCase());
        }
    }
    if (isMultiActionControllerType(beanClass)) {
        return new String[] {pathMapping.toString(), pathMapping.toString() + &quot;/*&quot;};
    }
    else {
        return new String[] {pathMapping.toString() + &quot;*&quot;};
    }
}


private StringBuilder buildPathPrefix(Class beanClass) {
    StringBuilder pathMapping = new StringBuilder();
    if (this.pathPrefix != null) {
        pathMapping.append(this.pathPrefix);
        pathMapping.append(&quot;/&quot;);
    }
    else {
        pathMapping.append(&quot;/&quot;);
    }
    if (this.basePackage != null) {
        String packageName = ClassUtils.getPackageName(beanClass);
        if (packageName.startsWith(this.basePackage)) {
            String subPackage = packageName.substring(this.basePackage.length()).replace(&apos;.&apos;, &apos;/&apos;);
            pathMapping.append(this.caseSensitive ? subPackage : subPackage.toLowerCase());
            pathMapping.append(&quot;/&quot;);
        }
    }
    return pathMapping;
}


protected boolean isMultiActionControllerType(Class beanClass) {
    return this.predicate.isMultiActionControllerType(beanClass);
}
</code></pre><h2 id="12-3-AbstractHandlerMethodMapping"><a href="#12-3-AbstractHandlerMethodMapping" class="headerlink" title="12.3 AbstractHandlerMethodMapping"></a>12.3 AbstractHandlerMethodMapping</h2><p>AbstractHandlerMethodMapping系列只有是三个类：AbstractHandlerMethodMapping | RequestMappingInfoHandlerMapping | RequestMappingHandlerMapping。这一系列是将Method作为Handler来使用的。比如经常使用的@RequestMapping所注释的方法就是这种Handler，它专门有一个类型：HandlerMethod，即Method类型的Handler。</p>
<h4 id="12-3-1-创建AbstractHandlerMethodMapping"><a href="#12-3-1-创建AbstractHandlerMethodMapping" class="headerlink" title="12.3.1 创建AbstractHandlerMethodMapping"></a>12.3.1 创建AbstractHandlerMethodMapping</h4><p>该类的作用是定义整个算法流程。这里最重要的理解三个Map的含义：</p>
<pre><code>//该map的作用是保存着匹配条件(RequestCondition)和Handler Method的对应关系。
private final Map&lt;T,HandlerMethod&gt; handlerMethods = new LinkedHashMap&lt;T,HandlerMethod&gt;();

//该map的作用是保存着url与匹配条件的对应关系。
private final MultiValueMap&lt;String,T&gt; urlMap = new LinkedMultiValueMap&lt;String,T&gt;();

//该map的作用是保存着name与handlermathod的对应关系。
private final MultiValueMap&lt;String,HandlerMethod&gt; nameMap = new LinkedMultiValueMap&lt;String,HandlerMethod&gt;();
</code></pre><p>这里的AbstractHandlerMethodMapping实现了initialziingBean接口，所有Spring容器会自动调用其afterProperties方法和afterPropertiesSet又交给initHandlerMethods()方法完成初始化。</p>
<pre><code>protected void initHandlerMethods() {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());
    }
    String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?
            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :
            obtainApplicationContext().getBeanNamesForType(Object.class));

    for (String beanName : beanNames) {
        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
            Class&lt;?&gt; beanType = null;
            try {
                beanType = obtainApplicationContext().getType(beanName);
            }
            catch (Throwable ex) {
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Could not resolve target class for bean with name &apos;&quot; + beanName + &quot;&apos;&quot;, ex);
                }
            }
            if (beanType != null &amp;&amp; isHandler(beanType)) {
                detectHandlerMethods(beanName);
            }
        }
    }
    handlerMethodsInitialized(getHandlerMethods());
}
</code></pre><blockquote>
<p>提示：1.首先拿到容器里面的所有bean。2.然后根据一定的规则筛选出Handler。3.最后保存到Map中。这里的筛选方法是isHandler()方法，是一个模板方法。具体的筛选是在子类里，筛选的逻辑是检查类前是否有@Controller或者@RequestMapping注解。4.在detectHandlerMethods中，首先从传入的处理器中找到符合要求的方法，然后用registerHandlerMethod进行注册（也就是保存在Map中），从这里可以看出Spring其实是将处理请求的方法所在的类看作处理器，而不是处理请求的方法，不过许多地方需要将请求的方法作为处理器来理解。从handler里获取可以处理请求的method的方法使用。</p>
</blockquote>
<h4 id="12-3-1-续-AbstractHandlerMethodMapping-系列之用"><a href="#12-3-1-续-AbstractHandlerMethodMapping-系列之用" class="headerlink" title="12.3.1 续 AbstractHandlerMethodMapping 系列之用"></a>12.3.1 续 AbstractHandlerMethodMapping 系列之用</h4><p>这里的主要功能是通过 getHandlerInternal() 方法获取处理器。这里的 getHandlerInternal() 方法做三件事：1.根据request获取ookupPath(url)。2.使用lookupPath和request找handlerMethod。3.如果可以找到handlerMethod则调用它的createWithResolverBean()方法创建新的 HandlerMethod 并返回。这里的 createWithResolverBean() 方法是判断 handlerMethod 里的handler是否是String类型。如果是则改为将其作为 beanName从容器中所取到的bean，但是HandlerMethod中的属性是final类型，不能修改。</p>
<h4 id="12-3-2-RequestMappingInfoHandlerMapping"><a href="#12-3-2-RequestMappingInfoHandlerMapping" class="headerlink" title="12.3.2 RequestMappingInfoHandlerMapping"></a>12.3.2 RequestMappingInfoHandlerMapping</h4><p>提供匹配条件RequestMappingInfo的解析处理。</p>
<pre><code>/**
 * 获取url集合，即@RequestMapping中设置的value或path
 */
@Override
protected Set&lt;String&gt; getMappingPathPatterns(RequestMappingInfo info) {
    return info.getPatternsCondition().getPatterns();
}
</code></pre><h4 id="12-3-3-RequestMappingHandlerMapping"><a href="#12-3-3-RequestMappingHandlerMapping" class="headerlink" title="12.3.3 RequestMappingHandlerMapping"></a>12.3.3 RequestMappingHandlerMapping</h4><p>根据@RequestMapping注解生成RequestMappingInfo，同时提供isHandler()方法实现。</p>
<pre><code>/**
 * 使用方法和类型注解@RequestMapping创建RequestMappingInfo对象
 */
@Override
@Nullable
protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
    // 创建方法的RequestMappingInfo
    RequestMappingInfo info = createRequestMappingInfo(method);
    if (info != null) {
        // 创建类的RequestMappingInfo
        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);
        if (typeInfo != null) {
            // 将方法RequestMappingInfo和类RequestMappingInfo合并，比如Controller类上有@RequestMapping(&quot;/demo&quot;)，方法的@RequestMapping(&quot;/demo1&quot;)，结果为&quot;/demo/demo1&quot;
            info = typeInfo.combine(info);
        }
    }
    return info;
}

@Nullable
private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {
    // 获取RequestMapping注解
    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);
    RequestCondition&lt;?&gt; condition = (element instanceof Class ?
            getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));
    // 调用createRequestMappingInfo创建匹配条件对象
    return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);
}

/**
 * 构造匹配条件对象
 */
protected RequestMappingInfo createRequestMappingInfo(
        RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) {

    RequestMappingInfo.Builder builder = RequestMappingInfo
            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))
            .methods(requestMapping.method())
            .params(requestMapping.params())
            .headers(requestMapping.headers())
            .consumes(requestMapping.consumes())
            .produces(requestMapping.produces())
            .mappingName(requestMapping.name());
    if (customCondition != null) {
        builder.customCondition(customCondition);
    }
    return builder.options(this.config).build();
}
</code></pre>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerAdapter</title>
    <url>/undefined/%E7%AC%AC13%E7%AB%A0%20HandlerAdapter/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第13章-HandlerAdapter"><a href="#第13章-HandlerAdapter" class="headerlink" title="第13章 HandlerAdapter"></a>第13章 HandlerAdapter</h1><p>[TOC]</p>
<p>HandlerMapping通过request找到Handler，而HandlerAdapter是具体使用Handler来干活的。每个HandlerAdapter封装了一种Handler的具体使用方法。HandlerAdapter结构中有5个Adapter，其中只有RequestMappingHandlerAdapter有两层，而其它的只有一层，是直接实现HandlerAdapter接口。同时其中的有一个类已经弃用，所以只有4类Adapter，5个类。</p>
<blockquote>
<p>提示：在HandlerAdapter的接口中只有三个方法：1.判断是否支持传入Handler。2.使用Handler处理请求。3.获取资源的LastModified值。</p>
</blockquote>
<h2 id="13-1-RequestMappingHandlerAdapter"><a href="#13-1-RequestMappingHandlerAdapter" class="headerlink" title="13.1 RequestMappingHandlerAdapter"></a>13.1 RequestMappingHandlerAdapter</h2><p>RequestMappingHandlerAdapter适配器是与RequestMappingHandlerMapping配合使用的。</p>
<h4 id="13-1-1-AbstractHandlerMethodAdapter"><a href="#13-1-1-AbstractHandlerMethodAdapter" class="headerlink" title="13.1.1 AbstractHandlerMethodAdapter"></a>13.1.1 AbstractHandlerMethodAdapter</h4><p><strong>1.supports()方法</strong><br><br>AbstractHandlerMethodAdapter类实现了supports()方法，可以知道支持的Handler是HandlerMethod，同时附加了一个判断方法supportsInternal，这个方法由RequestMappingHandlerAdapter实现，其就是简单地返回true。</p>
<pre><code>@Override
public final boolean supports(Object handler) {
    // 判断当前handler是否为HandlerMethod类型，并且判断supportsInternal()方法返回值是否为true，
    // 这里supportsInternal()方法是提供给子类实现的一个方法，对于RequestMappingHandlerAdapter
    // 而言，其返回值始终是true，因为其只需要处理的handler是HandlerMethod类型的即可
    return (handler instanceof HandlerMethod 
            &amp;&amp; supportsInternal((HandlerMethod) handler));
}

@Override
protected boolean supportsInternal(HandlerMethod handlerMethod) {
    // 这里RequestMappingHandlerAdapter只是对supportsInternal()返回true，因为其只需要
    // 处理的handler类型是HandlerMethod类型即可
    return true;
}

@Override
protected boolean supportsInternal(HandlerMethod handlerMethod) {
    // 这里RequestMappingHandlerAdapter只是对supportsInternal()返回true，因为其只需要
    // 处理的handler类型是HandlerMethod类型即可
    return true;
}
</code></pre><p><strong>2.handle()方法</strong><br><br>在supports()方法判断了所处理的handler是HandlerMethod类型之后，RequestMappingHandlerAdapter将会调用handle()方法处理当前请求。AbstractHandlerMethodAdapter实现了handle方法，就是简单地调用了模板方法handleInternal，handleInternal方法由RequestMappingHandlerAdapter实现。</p>
<pre><code>public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {
    return handleInternal(request, response, (HandlerMethod) handler);
}

@Override
protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
    ModelAndView mav;
    checkRequest(request);

    // 判断当前是否需要支持在同一个session中只能线性地处理请求
    if (this.synchronizeOnSession) {
        // 获取当前请求的session对象
        HttpSession session = request.getSession(false);
        if (session != null) {
            // 为当前session生成一个唯一的可以用于锁定的key
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized (mutex) {
                // 对HandlerMethod进行参数等的适配处理，并调用目标handler
                mav = invokeHandlerMethod(request, response, handlerMethod);
            }
        } else {
            // 如果当前不存在session，则直接对HandlerMethod进行适配
            mav = invokeHandlerMethod(request, response, handlerMethod);
        }
    } else {
        // 如果当前不需要对session进行同步处理，则直接对HandlerMethod进行适配
        mav = invokeHandlerMethod(request, response, handlerMethod);
    }

    // 判断当前请求头中是否包含Cache-Control请求头，如果不包含，则对当前response进行处理，
    // 为其设置过期时间
    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {
        // 如果当前SessionAttribute中存在配置的attributes，则为其设置过期时间。
        // 这里SessionAttribute主要是通过@SessionAttribute注解生成的
        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);
        } else {
            // 如果当前不存在SessionAttributes，则判断当前是否存在Cache-Control设置，
            // 如果存在，则按照该设置进行response处理，如果不存在，则设置response中的
            // Cache的过期时间为-1，即立即失效
            prepareResponse(response);
        }
    }

    return mav;
}
</code></pre><blockquote>
<p>提示：上面的程序作了两部分处理：1.判断当前是否对session进行同步处理，如果需要则进行加锁处理，不需要则直接调用。2.判断请求头是否已经包含Cache-Control请求头，如果不包含则设置Cache立即失效。对HandlerMethod的具体请求是在invokeHandlerMethod()方法中进行的。</p>
</blockquote>
<pre><code>@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try {
        // 获取容器中全局配置的InitBinder和当前HandlerMethod所对应的Controller中
        // 配置的InitBinder，用于进行参数的绑定
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        // 获取容器中全局配置的ModelAttribute和当前当前HandlerMethod所对应的Controller
        // 中配置的ModelAttribute，这些配置的方法将会在目标方法调用之前进行调用
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

        // 将handlerMethod封装为一个ServletInvocableHandlerMethod对象，
        // 该对象用于对当前request的整体调用流程进行了封装
        ServletInvocableHandlerMethod invocableMethod =
            createInvocableHandlerMethod(handlerMethod);
        if (this.argumentResolvers != null) {
            // 设置当前容器中配置的所有ArgumentResolver
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        if (this.returnValueHandlers != null) {
            // 设置当前容器中配置的所有ReturnValueHandler
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }
        // 将前面创建的WebDataBinderFactory设置到ServletInvocableHandlerMethod中
        invocableMethod.setDataBinderFactory(binderFactory);
        // 设置ParameterNameDiscoverer，该对象将按照一定的规则获取当前参数的名称
        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);

        ModelAndViewContainer mavContainer = new ModelAndViewContainer();
        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
        // 这里initModel()方法主要作用是调用前面获取到的@ModelAttribute标注的方法，
        // 从而达到@ModelAttribute标注的方法能够在目标Handler调用之前调用的目的
        modelFactory.initModel(webRequest, mavContainer, invocableMethod);
        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

        // 获取当前的AsyncWebRequest，这里AsyncWebRequest的主要作用是用于判断目标
        // handler的返回值是否为WebAsyncTask或DefferredResult，如果是这两种中的一种，
        // 则说明当前请求的处理应该是异步的。所谓的异步，指的是当前请求会将Controller中
        // 封装的业务逻辑放到一个线程池中进行调用，待该调用有返回结果之后再返回到response中。
        // 这种处理的优点在于用于请求分发的线程能够解放出来，从而处理更多的请求，只有待目标任务
        // 完成之后才会回来将该异步任务的结果返回。
        AsyncWebRequest asyncWebRequest = WebAsyncUtils
            .createAsyncWebRequest(request, response);
        asyncWebRequest.setTimeout(this.asyncRequestTimeout);

        // 封装异步任务的线程池，request和interceptors到WebAsyncManager中
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.setTaskExecutor(this.taskExecutor);
        asyncManager.setAsyncWebRequest(asyncWebRequest);
        asyncManager.registerCallableInterceptors(this.callableInterceptors);
        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

        // 这里就是用于判断当前请求是否有异步任务结果的，如果存在，则对异步任务结果进行封装
        if (asyncManager.hasConcurrentResult()) {
            Object result = asyncManager.getConcurrentResult();
            mavContainer = (ModelAndViewContainer) 
                asyncManager.getConcurrentResultContext()[0];
            asyncManager.clearConcurrentResult();
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
            }
            // 封装异步任务的处理结果，虽然封装的是一个HandlerMethod，但只是Spring简单的封装
            // 的一个Callable对象，该对象中直接将调用结果返回了。这样封装的目的在于能够统一的
            // 进行右面的ServletInvocableHandlerMethod.invokeAndHandle()方法的调用
            invocableMethod = invocableMethod.wrapConcurrentResult(result);
        }

        // 对请求参数进行处理，调用目标HandlerMethod，并且将返回值封装为一个ModelAndView对象
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
        if (asyncManager.isConcurrentHandlingStarted()) {
            return null;
        }

        // 对封装的ModelAndView进行处理，主要是判断当前请求是否进行了重定向，如果进行了重定向，
        // 还会判断是否需要将FlashAttributes封装到新的请求中
        return getModelAndView(mavContainer, modelFactory, webRequest);
    } finally {
        // 调用request destruction callbacks和对SessionAttributes进行处理
        webRequest.requestCompleted();
    }
}
</code></pre><blockquote>
<p>提示：RequestMappingHandlerAdapter处理请求的主要流程：1.获取当前容器中使用@InitBinder注解注册的属性转换器。2.获取当前容器中使用@ModelAttribute标注但是没有使用@RequestMapping标注的方法，并且在调用目标方法之前调用这些方法。3.判断目标handler返回值是否使用了WebAsync Task或DefferredResult封装，如果封装了按照异步任务的方式执行。4.处理请求参数，调用目标方法和处理返回值。</p>
</blockquote>
<pre><code>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) 
        throws Exception {
    // 判断当前缓存中是否缓存了当前bean所需要装配的InitBinder方法，如果存在，则直接从缓存中取，
    // 如果不存在，则在当前bean中进行扫描获取
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = this.initBinderCache.get(handlerType);
    if (methods == null) {
        // 在当前bean中查找所有标注了@InitBinder注解的方法，这里INIT_BINDER_METHODS就是一个
        // 选择器，表示只获取使用@InitBinder标注的方法
        methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);
        this.initBinderCache.put(handlerType, methods);
    }

    // 这里initBinderAdviceCache是在RequestMappingHandlerAdapter初始化时同步初始化的，
    // 其内包含的方法有如下两个特点：①当前方法所在类使用@ControllerAdvice进行标注了；
    // ②当前方法使用@InitBinder进行了标注。也就是说其内保存的方法可以理解为是全局类型
    // 的参数绑定方法
    List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList&lt;&gt;();
    this.initBinderAdviceCache.forEach((clazz, methodSet) -&gt; {
        // 这里判断的是当前配置的全局类型的InitBinder是否能够应用于当前bean，
        // 判断的方式主要在@ControllerAdvice注解中进行了声明，包括通过包名，类所在的包，
        // 接口或者注解的形式限定的范围
        if (clazz.isApplicableToBeanType(handlerType)) {
            Object bean = clazz.resolveBean();
            for (Method method : methodSet) {
                initBinderMethods.add(createInitBinderMethod(bean, method));
            }
        }
    });

    // 这里是将当前HandlerMethod所在bean中的InitBinder添加到需要执行的initBinderMethods中。
    // 这里从添加的顺序可以看出，全局类型的InitBinder会在当前bean中的InitBinder之前执行
    for (Method method : methods) {
        Object bean = handlerMethod.getBean();
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }

    // 将需要执行的InitBinder封装到InitBinderDataBinderFactory中
    return createDataBinderFactory(initBinderMethods);
}
</code></pre><h4 id="13-1-2-RequestMappingHandlerAdapter"><a href="#13-1-2-RequestMappingHandlerAdapter" class="headerlink" title="13.1.2 RequestMappingHandlerAdapter"></a>13.1.2 RequestMappingHandlerAdapter</h4><p><strong>1.初始化过程</strong><br><br>RequestMappingHandlerAdapter实现了InitializingBean接口，所以它的初始化入口是afterPropertiesSet方法。也就是说 RequestMappingHandlerAdapter 的创建是在 afterPropertiesSet() 方法中实现的。</p>
<blockquote>
<p>提示：handler表示Spring处理具体请求的某个Controller方法，即HandlerAdapter表示将当前请求适配到某个Handler的处理器。RequestMappingHandlerAdapter是HandlerAdapter的一个具体实现，主要用于将某个请求适配给@RequestMapping类型的Handler处理。</p>
</blockquote>
<p><strong>2.HandlerMapping接口的声明</strong><br></p>
<pre><code>public interface HandlerAdapter {
    // 用于判断当前HandlerAdapter是否能够处理当前请求
    boolean supports(Object handler);

    // 如果当前HandlerAdapter能够用于适配当前请求，那么就会处理当前请求中
    // 诸如参数和返回值等信息，以便能够直接委托给具体的Handler处理
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, 
        Object handler) throws Exception;

    // 获取当前请求的最后更改时间，主要用于供给浏览器判断当前请求是否修改过，
    // 从而判断是否可以直接使用之前缓存的结果
    long getLastModified(HttpServletRequest request, Object handler);
}
</code></pre><blockquote>
<p>属性：1.argumentResolvers 用于给处理器方法和被@ModelAttribute注解的方法设置参数。2.initBinderArgumentResolvers 用于给被@InitBinder注解的方法设置参数。3.returnValueHandlers 用于将处理器返回值处理成ModelAndView类型。</p>
</blockquote>
<pre><code>  public void afterPropertiesSet() {

    //初始化注释了 @ControllerAdvice 的类的相关属性
    initControllerAdviceCache();

    if (this.argumentResolvers == null) {
        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();
        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.initBinderArgumentResolvers == null) {
        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();
        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.returnValueHandlers == null) {
        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();
        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
    }
}
</code></pre><h2 id="13-2-RequestMappingHandlerAdapter-自身结构"><a href="#13-2-RequestMappingHandlerAdapter-自身结构" class="headerlink" title="13.2 RequestMappingHandlerAdapter 自身结构"></a>13.2 RequestMappingHandlerAdapter 自身结构</h2><h4 id="13-2-1-创建RequestMappingHandlerAdapter"><a href="#13-2-1-创建RequestMappingHandlerAdapter" class="headerlink" title="13.2.1 创建RequestMappingHandlerAdapter"></a>13.2.1 创建RequestMappingHandlerAdapter</h4><p>创建 RequestMappingHandlerAdapter 是在 afterPropertiesSet()方法中实现，内容主要是初始化 argumentResolvers | initBinderArgumentResolvers | returnValueHandlers | @ControllerAdvice注释的类相关的modelAttributeAdviceCache | initBinderAdviceCache | responseBodyAdvice 六个属性。</p>
<pre><code>1.argumentResolvers 给处理器方法和注释了@ModelAttribute的方法设置参数
2.initBinderArgumentResolvers 给注释了@initBinder的方法设置参数
3.returnValueHandlers 将处理器的返回值处理成ModelAndView的类型
4.modelAttributeAdviceCache | initBinderAdviceCache 用于缓存 @ControllerAdvice注释的类里面的注释了@ModelAttribute 和 @InitBinder 的方法。
5.responseBodyAdvice 保存 ResponseBodyAdvice 接口，可以修改返回的 ResponseBody 的类。
</code></pre><blockquote>
<p>注意：这些属性都是复数形式，可以有多个，使用的时候根据顺序调用即可。所以初始化时的顺序很重要。</p>
</blockquote>
<h4 id="13-2-2-RequestMappingHandlerAdapter之用"><a href="#13-2-2-RequestMappingHandlerAdapter之用" class="headerlink" title="13.2.2 RequestMappingHandlerAdapter之用"></a>13.2.2 RequestMappingHandlerAdapter之用</h4><p>RequestMappingHandlerAdapter 的处理请求入口方法是handleInternal。</p>
<pre><code>protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    //1.判断Handler是否有 @SessionAttribute 注释的参数
    if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
        this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
    } else {
        this.checkAndPrepare(request, response, true);
    } 

    //看代码应该是从session中获取一些信息，然后初始化header等信息
    //这块就是根据需要是否进行同步操作
    if (this.synchronizeOnSession) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized(mutex) {
                return this.invokeHandleMethod(request, response, handlerMethod);
            }
        }
    }
    //正式进入执行环节
    return this.invokeHandleMethod(request, response, handlerMethod);
}
</code></pre><blockquote>
<p>提示：这里关键的方法就是：checkAndPrepare()方法和invokeHandleMethod()方法。</p>
</blockquote>
<h2 id="13-3-ModelAndViewContainer"><a href="#13-3-ModelAndViewContainer" class="headerlink" title="13.3 ModelAndViewContainer"></a>13.3 ModelAndViewContainer</h2><p>ModelAndViewContainer承担着整个请求过程中数据的传递工作。除了保存Model和View之外还有其它的功能。它里面包含的属性有：</p>
<pre><code>1.view 视图，Object类型
2.defaultModel：默认使用的Model
3.redirectModel：redirect类型的Model
4.sessionStatus：用于设置SessionAttribute使用完的标志
5.ignoreDefaultModelOnRedirect：如果为true则在处理器返回redirect视图时一定不使用defaultModel
6.redirectModelScenario：处理器返回redirect视图的标志
7.requestHandled：请求是否已经处理完成的标志
</code></pre><h2 id="13-4-SessionAttributesHandler-和-SessionAttributeStore"><a href="#13-4-SessionAttributesHandler-和-SessionAttributeStore" class="headerlink" title="13.4 SessionAttributesHandler 和 SessionAttributeStore"></a>13.4 SessionAttributesHandler 和 SessionAttributeStore</h2><p>SessionAttributesHandler 作为处理 @SessionAttributes注释的参数，其只做宏观的事情，如：哪个Handler都可以缓存哪些参数，某个参数在当前的SessionAttribute中是否存在等。具体的存储工作交给SessionAttributeStore做，</p>
<h2 id="13-5-ModelFactory"><a href="#13-5-ModelFactory" class="headerlink" title="13.5 ModelFactory"></a>13.5 ModelFactory</h2><p>ModelFactory是用来维护Model的。两个功能：1. 初始化Model。2.处理器执行后将Model中相应参数更新到SessionAttribute。</p>
<h3 id="13-5-1-初始化Model"><a href="#13-5-1-初始化Model" class="headerlink" title="13.5.1 初始化Model"></a>13.5.1 初始化Model</h3><h2 id="13-6-ServletInvocableHandlerMethod"><a href="#13-6-ServletInvocableHandlerMethod" class="headerlink" title="13.6 ServletInvocableHandlerMethod"></a>13.6 ServletInvocableHandlerMethod</h2><p>是一种HandlerMethod，只是增加了方法执行的功能，相应地增加了参数解析、返回值处理等功能。</p>
<h3 id="13-6-1-HandlerMethod"><a href="#13-6-1-HandlerMethod" class="headerlink" title="13.6.1 HandlerMethod"></a>13.6.1 HandlerMethod</h3><h2 id="13-7-HandlerMethodArgumentResolver"><a href="#13-7-HandlerMethodArgumentResolver" class="headerlink" title="13.7 HandlerMethodArgumentResolver"></a>13.7 HandlerMethodArgumentResolver</h2><p>是为处理器解析参数的，主要用在InvocableHandlerMethod中。每个Resolver对应一种类型的参数。</p>
<h2 id="13-8-HandlerMethodReturnValueHandler"><a href="#13-8-HandlerMethodReturnValueHandler" class="headerlink" title="13.8 HandlerMethodReturnValueHandler"></a>13.8 HandlerMethodReturnValueHandler</h2><p>该处理方法用在ServletInvocableHandlerMethod中，功能：1. 将相应参数添加到Model。2. 设置View。3. 如果请求已经处理完则设置ModelAndViewContainer的requestHandled为true。</p>
<p>### </p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC13%E7%AB%A0%20Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第13章-Spring框架的设计理念与设计模式分析"><a href="#第13章-Spring框架的设计理念与设计模式分析" class="headerlink" title="第13章 Spring框架的设计理念与设计模式分析"></a>第13章 Spring框架的设计理念与设计模式分析</h2><p>[TOC]</p>
<h3 id="13-1-Spring的骨骼架构"><a href="#13-1-Spring的骨骼架构" class="headerlink" title="13.1 Spring的骨骼架构"></a>13.1 Spring的骨骼架构</h3><p>Spring的核心组件只有三种：Core | Context | Bean。其构建起整个Spring骨骼架构，没有它们就不可能有AOP | Web等上层的特性功能。</p>
<h4 id="13-1-1-Spring的设计理念"><a href="#13-1-1-Spring的设计理念" class="headerlink" title="13.1.1 Spring的设计理念"></a>13.1.1 Spring的设计理念</h4><p>Spring解决非常关键的问题，它可以让我们将对象之间的依赖关系转而用配置文件来管理，也就是依赖注入机制。而这个注入关系由Ioc容器中管理。</p>
<p>我们知道Bean包装的是Object，而Object必然有数据，而Context要解决的是数据的生存问题，发现每个Bean之间的关系。所以Context是一个Bean关系的集合，这个关系集合又叫Ioc容器。Core就是发现、建立和维护每个Bean之间的关系所需要的一些列工具。</p>
<h3 id="13-2-核心组件"><a href="#13-2-核心组件" class="headerlink" title="13.2 核心组件"></a>13.2 核心组件</h3><h4 id="13-2-1-Bean组件"><a href="#13-2-1-Bean组件" class="headerlink" title="13.2.1 Bean组件"></a>13.2.1 Bean组件</h4><p>Spring Bean的创建是典型的工厂模式，它的顶级接口是BeanFactory。BeanFactory有三个子类：1. ListableFactory 2. HierarchicalBeanFactory 3. AutowireCapacleBeanFactory。但最终的默认实现类都是 DefaultListableBeanFactory。</p>
<p>定义这么多接口的原因是因为每个接口都有其使用的场合，其主要区分在Spring对象内部对象的转换和传递过程，将对象的数据访问做限制。</p>
<pre><code>1. ListableBeanFactory 表示Bean是可列表的

2. HierarchicalBeanFactory 表示这些Bean是有继承关系的

3. Autowire.. 表示Bean的自动装配规则
</code></pre><p>Bean的定义主要有BeanDefinition描述。Bean的完整描述了在Spring配置文件中定义<bean>节点中所有的信息，包括各种子节点。</bean></p>
<blockquote>
<p>提示：Bean的解析过程就是对Spring配置文件的解析。</p>
</blockquote>
<h4 id="13-2-2-Context组件"><a href="#13-2-2-Context组件" class="headerlink" title="13.2.2 Context组件"></a>13.2.2 Context组件</h4><p>Context在Spring的 org.springframework.context 包下面。ApplicationContext是Context的顶级父类，它除了标识一个应用环境的基本信息之外，还继承了5个接口。</p>
<p>ApplicationContext继承了BeanFactory，说明了Spring容器中运行的主体对象是Bean。另外ApplicationContext继承了ResourceFactory接口，可以访问任何外部资源。</p>
<p>ApplicationContext的子类包含两个方面：</p>
<pre><code>1. ConfigurableApplicationContext 表示该Context可修改，在构建Context用户可以动态添加和修改已有的配置信息，其下面有多个子类，最常使用可更新的Context（AbstractRefreshableApplicationContext类）。

2. WebApplicationContext 表示为Web准备的Context，可以直接访问到ServletContext。
</code></pre><p>总体来说Context必须完成以下几件事情：</p>
<pre><code>1. 标识一个应用环境

2. 利用BeanFactory创建Bean对象

3. 保存对象关系表

4. 能够捕获各种事件
</code></pre><h4 id="12-2-3-Core组件"><a href="#12-2-3-Core组件" class="headerlink" title="12.2.3 Core组件"></a>12.2.3 Core组件</h4><p>Core组件是Spring的核心组件，包含了很多关键类，一个重要的组成部分是定义了资源的访问方式。</p>
<h4 id="12-2-4-Ioc容器工作过程"><a href="#12-2-4-Ioc容器工作过程" class="headerlink" title="12.2.4 Ioc容器工作过程"></a>12.2.4 Ioc容器工作过程</h4><pre><code>1. 创建BeanFacoty工厂

    Ioc容器实际上是Context组件结合其它两个组件共同构建了一个Bean关系网。 


4. Ioc容器

    我们如果需要使用Spring必须要先构建Ioc容器，没有它Spring无法工作，ApplicationContext.xml就是Ioc容器默认配置文件，Spring的所有特性功能都是基于Ioc容器工作的。
</code></pre><h3 id="13-3-Spring中AOP"><a href="#13-3-Spring中AOP" class="headerlink" title="13.3 Spring中AOP"></a>13.3 Spring中AOP</h3><h4 id="13-3-1-动态代理"><a href="#13-3-1-动态代理" class="headerlink" title="13.3.1 动态代理"></a>13.3.1 动态代理</h4><p>AOP是基于动态代理实现的。在JDK的java.lang.reflect包下有个Proxy类，是构造代理类的入口。最后一个方法newproxyInstance是创建代理对象的方法。</p>
<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h);

1. ClassLoader 用于加载代理类的Loader类，通常这个Loader类和被代理的类是同一个Loader类。

2. interfaces 被代理的那些接口

3. InvocationHandler 用于执行除了被代理类接口中方法之外的用户定义的操作，是用户需要代理的最终目的。用户调用目标方法都被代理到InvocationHandler类中定义的唯一方法invoke()中。
</code></pre><h4 id="13-3-2-Spring-AOP的实现"><a href="#13-3-2-Spring-AOP的实现" class="headerlink" title="13.3.2 Spring AOP的实现"></a>13.3.2 Spring AOP的实现</h4><p>代理的目的是调用目标方法时可以转而执行InvocationHandler类的invoke()方法，所以如何在InvocationHandler类上做文章便是实现AOP的关键所在。</p>
<p>Spring如何完成代理：</p>
<pre><code>1. 代理类继承了FactoryBean的ProxyFactoryBean，FactoryBeab之所以特别就在于它可以让我们自定义对象的创建方法。

2. Spring在创建代理对象之后，在我们调用目标对象上的方法时，都会被代理到InvocationHandler类的invok()方法中执行。
</code></pre><h3 id="13-4-设计模式之代理模式"><a href="#13-4-设计模式之代理模式" class="headerlink" title="13.4 设计模式之代理模式"></a>13.4 设计模式之代理模式</h3><h4 id="13-4-1-代理模式原理"><a href="#13-4-1-代理模式原理" class="headerlink" title="13.4.1 代理模式原理"></a>13.4.1 代理模式原理</h4><p>代理模式就是给某一个对象创建一个代理对象，由这个代理对象控制对原对象的引用，而创建此代理对象后可以在调用原对象时增加一些额外的操作。</p>
<pre><code>1. Subject 抽象主题，它是代理对象的真实对象要实现的接口

2. ProxySubject 代理类，除了实现抽象主题定义的接口外，还必须持有所代理对象的引用

3. RealSubject 被代理的类，是目标对象
</code></pre><h3 id="13-5-设计模式之策略模式"><a href="#13-5-设计模式之策略模式" class="headerlink" title="13.5 设计模式之策略模式"></a>13.5 设计模式之策略模式</h3><h4 id="13-5-1-策略模式原理"><a href="#13-5-1-策略模式原理" class="headerlink" title="13.5.1 策略模式原理"></a>13.5.1 策略模式原理</h4><p>表示完成某个操作可能有多种方法，这些方法都可能被使用到，每个实现方法都当做一个实现策略，用户可以根据场景选择合适的策略。</p>
<pre><code>1. Context 不同策略的环境，可根据自身条件选择不同的策略实现类完成所要的操作。

2. Strategy 抽象策略，定义每个策略都要实现的策略方法

3. ConcreteStrategy 具体策略实现类，实现抽象策略中定义的策略方法
</code></pre><h4 id="13-5-2-Spring中策略模式的实现"><a href="#13-5-2-Spring中策略模式的实现" class="headerlink" title="13.5.2 Spring中策略模式的实现"></a>13.5.2 Spring中策略模式的实现</h4><p>Spring中有多个地方用到了策略模式。如：Bean定义对象的创建及代理对象的创建等。</p>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC15%E7%AB%A0%20RequestToViewNameTranslator/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第15章-RequestToViewNameTranslator"><a href="#第15章-RequestToViewNameTranslator" class="headerlink" title="第15章 RequestToViewNameTranslator"></a>第15章 RequestToViewNameTranslator</h1><p>RequestToViewNameTranslator能够在处理器返回的view为空时使用其根据request获取viewName。SpringMVC提供的实现类只有：DefaultRequestToViewNameTranslator。</p>
<pre><code>    public class DefaultRequestToViewNameTranslator implements RequestToViewNameTranslator {
    private static final String SLASH = &quot;/&quot;;
    private String prefix = &quot;&quot;;
    private String suffix = &quot;&quot;;

    //该属性表示：如果其值与Slash不同则用于替换原来的分隔符Slash
    private String separator = &quot;/&quot;;

    //该属性表示：如果前面的字符为Slash是否将其去掉
    private boolean stripLeadingSlash = true;

    //该属性表示：如果最后一个字符为Slash是否将其去掉
    private boolean stripTrailingSlash = true;

    //该属性表示：是否需要去掉扩展名
    private boolean stripExtension = true;

    private UrlPathHelper urlPathHelper = new UrlPathHelper();

    //这里分别添加了前缀和后缀
    public String getViewName(HttpServletRequest request) {
        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
        return this.prefix + this.transformPath(lookupPath) + this.suffix;
    }
    //这里处理分隔符“，&quot;,“/&quot;
    @Nullable
    protected String transformPath(String lookupPath) {
        String path = lookupPath;
        if (this.stripLeadingSlash &amp;&amp; lookupPath.startsWith(&quot;/&quot;)) {
            path = lookupPath.substring(1);
        }

        if (this.stripTrailingSlash &amp;&amp; path.endsWith(&quot;/&quot;)) {
            path = path.substring(0, path.length() - 1);
        }

        if (this.stripExtension) {
            path = StringUtils.stripFilenameExtension(path);
        }

        if (!&quot;/&quot;.equals(this.separator)) {
            path = StringUtils.replace(path, &quot;/&quot;, this.separator);
        }

        return path;
    }
}
</code></pre><h4 id="UrlPathHelper属性参数"><a href="#UrlPathHelper属性参数" class="headerlink" title="UrlPathHelper属性参数"></a>UrlPathHelper属性参数</h4><pre><code>1.urlDecode：设置url是否需要编码，一般默认
2.removeSemicolonContent：设置是否删除url中与分号相关的内容
3.alwaysUseFullPath：设置是否总是使用完整路径
</code></pre><blockquote>
<p>提示：因为urlPathHelper是用于处理url的工具，所以参数一般默认即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC14%E7%AB%A0%20ViewResolver/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第14章-ViewResolver"><a href="#第14章-ViewResolver" class="headerlink" title="第14章 ViewResolver"></a>第14章 ViewResolver</h1><p>ViewResolver主要的作用是根据视图名和Locale解析出视图，解析过程主要做两件事：解析出使用的模板和视图的类型。SpringMVC中的ViewResolver主要分为四大类：1.AbstractCachingViewResolver | 2.BeanNameViewResolver | 3.ContentNegotiatingViewResolver | 4.ViewResolverComposite 。其中在后面的三个只有一个实现类。</p>
<pre><code>1.BeanNameViewResolver：通过beanName从SpringMVC容器中查找。
2.ViewResolverComposite：该类封装着多个ViewResolver的容器，解析视图时遍历封装着的ViewResolver具体解析。在ViewResolverComposite遍历成员解析视图的同时还给成员初始化。其中包括对实现了ApplicationContextAware接口的ViewResolver设置ApplicationContext、是给实现了ServletContextAware接口的ViewResolver设置ServletContext以及对实现了InitializingBean接口的ViewResolver调用afterPropertiesSet方法。

    public class ViewResolverComposite implements ViewResolver, Ordered, InitializingBean, ApplicationContextAware, ServletContextAware {
        private final List&lt;ViewResolver&gt; viewResolvers = new ArrayList();
        private int order = 2147483647;

        public ViewResolverComposite() {
        }

        public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {
            this.viewResolvers.clear();
            if (!CollectionUtils.isEmpty(viewResolvers)) {
                this.viewResolvers.addAll(viewResolvers);
            }

        }

        public List&lt;ViewResolver&gt; getViewResolvers() {
            return Collections.unmodifiableList(this.viewResolvers);
        }

        public void setOrder(int order) {
            this.order = order;
        }

        public int getOrder() {
            return this.order;
        }

        public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
            Iterator var2 = this.viewResolvers.iterator();

            while(var2.hasNext()) {
                ViewResolver viewResolver = (ViewResolver)var2.next();
                if (viewResolver instanceof ApplicationContextAware) {
                    ((ApplicationContextAware)viewResolver).setApplicationContext(applicationContext);
                }
            }

        }

        public void setServletContext(ServletContext servletContext) {
            Iterator var2 = this.viewResolvers.iterator();

            while(var2.hasNext()) {
                ViewResolver viewResolver = (ViewResolver)var2.next();
                if (viewResolver instanceof ServletContextAware) {
                    ((ServletContextAware)viewResolver).setServletContext(servletContext);
                }
            }

        }

        public void afterPropertiesSet() throws Exception {
            Iterator var1 = this.viewResolvers.iterator();

            while(var1.hasNext()) {
                ViewResolver viewResolver = (ViewResolver)var1.next();
                if (viewResolver instanceof InitializingBean) {
                    ((InitializingBean)viewResolver).afterPropertiesSet();
                }
            }

        }

        //主要是这个方法用来解析View的
        @Nullable
        public View resolveViewName(String viewName, Locale locale) throws Exception {
            Iterator var3 = this.viewResolvers.iterator();

            View view;
            do {
                if (!var3.hasNext()) {
                    return null;
                }

                ViewResolver viewResolver = (ViewResolver)var3.next();
                view = viewResolver.resolveViewName(viewName, locale);
            } while(view == null);

            return view;
        }
    }
</code></pre><blockquote>
<p>总结：这里它真正的解析过程就是最后一个方法 resolveViewName()。其它方法都是给所包含的ViewResolver做初始化。</p>
</blockquote>
<h2 id="14-1-ContentNegotiatingViewResolver"><a href="#14-1-ContentNegotiatingViewResolver" class="headerlink" title="14.1 ContentNegotiatingViewResolver"></a>14.1 ContentNegotiatingViewResolver</h2><p>该解析器的作用是在别的解析器解析的结果上增加了对MediaType(Content-Type 媒体类型)和后缀支持。对视图的解析不是其本身完成的，而是通过封装的ViewResolver来进行的。</p>
<blockquote>
<p>整个过程是：1.首先遍历所封装的ViewResolver具体视图，这里可能会解析出多个视图。2.然后使用request获取MediaType，可能也是多个结果。3.最后将这两个结果进行匹配查找出最优的视图。</p>
</blockquote>
<blockquote>
<p>属性ViewResolver的两种初始化方式：1.手动设置，不在Spring容器中，则会对它初始化。2.如果没有设置则自动获取Spring容器中除它自己外的所有ViewResolver并设置到ViewResolver中。</p>
</blockquote>
<h4 id="1-initServletContext"><a href="#1-initServletContext" class="headerlink" title="1.initServletContext"></a>1.initServletContext</h4><pre><code> protected void initServletContext(ServletContext servletContext) {
    //获取容器中所有的ViewResolver类型的bean，是整个spring容器，而不仅仅是springMVC获取的
    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
    ViewResolver viewResolver;

    //如果没有手动注册则将容器中找到的ViewResolver设置给ViewResolvers
    if (this.viewResolvers == null) {
        this.viewResolvers = new ArrayList(matchingBeans.size());
        Iterator var3 = matchingBeans.iterator();

        while(var3.hasNext()) {
            viewResolver = (ViewResolver)var3.next();
            if (this != viewResolver) {
                this.viewResolvers.add(viewResolver);
            }
        }
    } else {
         //如果是手动注册，但是容器中不存在，则进行初始化
        for(int i = 0; i &lt; this.viewResolvers.size(); ++i) {
            viewResolver = (ViewResolver)this.viewResolvers.get(i);
            if (!matchingBeans.contains(viewResolver)) {
                String name = viewResolver.getClass().getName() + i;
                this.obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(viewResolver, name);
            }
        }
    }

    if (this.viewResolvers.isEmpty()) {
        this.logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);
    }
    //按照Order属性进行排序
    AnnotationAwareOrderComparator.sort(this.viewResolvers);
    this.cnmFactoryBean.setServletContext(servletContext);
}
</code></pre><h4 id="2-resolveViewName-解析视图的方法"><a href="#2-resolveViewName-解析视图的方法" class="headerlink" title="2.resolveViewName 解析视图的方法"></a>2.resolveViewName 解析视图的方法</h4><pre><code>@Nullable
public View resolveViewName(String viewName, Locale locale) throws Exception {
    //使用RequestContextHolder获取RequestAttribute，进而获取request
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
    //通过request获取MediaType,用作需要满足的条件
    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) {
        //获取所有的候选视图，内部通过遍历封装的viewResolver来解析
        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
        //从多个候选视图中选出最好的一个
        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
        if (bestView != null) {
            return bestView;
        }
    }

    if (this.useNotAcceptableStatusCode) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);
        }

        return NOT_ACCEPTABLE_VIEW;
    } else {
        this.logger.debug(&quot;No acceptable view found; returning null&quot;);
        return null;
    }
}
</code></pre><blockquote>
<p>总结：这里整个过程是：1.首先使用request获取MediaType作为需要满足的条件。2.然后使用viewResolver解析出多个候选视图。3.最后将两者进行匹配找出最优视图。</p>
</blockquote>
<h4 id="3-getCandidateView-获取候选视图"><a href="#3-getCandidateView-获取候选视图" class="headerlink" title="3.getCandidateView() 获取候选视图"></a>3.getCandidateView() 获取候选视图</h4><blockquote>
<p>总结：获取候选视图逻辑：1.遍历viewResolver进行视图解析，同时将所有解析出的结果添加到候选视图。2.然后判断有没有设置默认视图，如果有责将其添加到候选视图。同时这里不仅使用逻辑视图进行解析，而且还使用了通过遍历requestedMediaTypes获取到所对应的后缀，然后添加到逻辑视图后面作为新的视图名进行解析。</p>
</blockquote>
<h4 id="4-getBestView-获取最优视图"><a href="#4-getBestView-获取最优视图" class="headerlink" title="4.getBestView() 获取最优视图"></a>4.getBestView() 获取最优视图</h4><pre><code>private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes, RequestAttributes attrs) {
    Iterator var4 = candidateViews.iterator();
    //判断候选视图中有没有redirect视图，如果有直接返回
    while(var4.hasNext()) {
        View candidateView = (View)var4.next();
        if (candidateView instanceof SmartView) {
            SmartView smartView = (SmartView)candidateView;
            if (smartView.isRedirectView()) {
                if (this.logger.isDebugEnabled()) {
                    this.logger.debug(&quot;Returning redirect view [&quot; + candidateView + &quot;]&quot;);
                }

                return candidateView;
            }
        }
    }

    var4 = requestedMediaTypes.iterator();

    while(var4.hasNext()) {
        MediaType mediaType = (MediaType)var4.next();
        Iterator var10 = candidateViews.iterator();

        while(var10.hasNext()) {
            View candidateView = (View)var10.next();
            if (StringUtils.hasText(candidateView.getContentType())) {
                //根据候选视图获取对应的MediaType
                MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());
                //判断当前MediaType是否支持从候选视图获取对应的MediaType,如text/*可以支持test/html,text/css,text/xml等所有的text类型
                if (mediaType.isCompatibleWith(candidateContentType)) {
                    if (this.logger.isDebugEnabled()) {
                        this.logger.debug(&quot;Returning [&quot; + candidateView + &quot;] based on requested media type &apos;&quot; + mediaType + &quot;&apos;&quot;);
                    }

                    attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, 0);
                    return candidateView;
                }
            }
        }
    }

    return null;
}
</code></pre><blockquote>
<p>总结：1.首先判断候选视图中有没有redirect视图，如果有则直接返回，否则同时遍历从request中获取的requestMediaTypes和解析出的候选逻辑视图candidateViews。2.然后根据候选视图获取对应的MediaType，同时使用当前的requestedMediaType对其进行判断，如果支持则将所有的requestedMediaType添加到request的Attribute中，以便在视图渲染过程中使用，并将当前视图返回。</p>
</blockquote>
<h2 id="14-2-AbstractCachingViewResolver-系列"><a href="#14-2-AbstractCachingViewResolver-系列" class="headerlink" title="14.2 AbstractCachingViewResolver 系列"></a>14.2 AbstractCachingViewResolver 系列</h2><h3 id="14-2-1-AbstractCachingViewResolver解析视图"><a href="#14-2-1-AbstractCachingViewResolver解析视图" class="headerlink" title="14.2.1 AbstractCachingViewResolver解析视图"></a>14.2.1 AbstractCachingViewResolver解析视图</h3><p>该解析器提供统一的缓存功能，当视图被解析过一次就缓存起来，直到缓存被删除前视图的解析都会自动从缓存中获取。它的直接继承有三个类：</p>
<pre><code>1.ResourceBundleViewResolver：通过使用properties属性配置文件解析视图。

2.XmlViewResolver：通过使用xml属性配置文件解析视图。

3.UrlBasedViewResolver：所有直接将逻辑视图作为url查找模板文件的ViewResolver的基类，这个类设置了统一的查找模板的规则，它的子类只需要确定渲染方式就可以确定视图类型，它的每一个子类都对应一种视图类型。
</code></pre><blockquote>
<p>提示：前两种解析器的原理：1.首先根据Locale将相应的配置文件初始化到BeanFactory。2.然后直接将逻辑视图作为beanName到factory里查找。两者的loadView程序一样。</p>
</blockquote>
<pre><code>protected View loadView(String viewName, Locale locale) throws BeansException {
    BeanFactory factory = initFactory();
    try{
        return factory.getBean(viewName, View.class);
    }catch(NoSuchBeanDefinitionException ex){
        return null;
    }
}
</code></pre><h4 id="1-AbstractCachingViewResolver解析视图过程"><a href="#1-AbstractCachingViewResolver解析视图过程" class="headerlink" title="1.AbstractCachingViewResolver解析视图过程"></a>1.AbstractCachingViewResolver解析视图过程</h4><pre><code>public View resolveViewName(String viewName, Locale locale) throws Exception {
    //是否有缓存
    if (!this.isCache()) {
        //实际创建视图
        return this.createView(viewName, locale);
    } else {
        Object cacheKey = this.getCacheKey(viewName, locale);
        //这里是通过concurrentHashMap的容器中获取的缓存
        View view = (View)this.viewAccessCache.get(cacheKey);
        if (view == null) {
            Map var5 = this.viewCreationCache;
            synchronized(this.viewCreationCache) {
                view = (View)this.viewCreationCache.get(cacheKey);
                if (view == null) {
                    //创建视图
                    view = this.createView(viewName, locale);
                    if (view == null &amp;&amp; this.cacheUnresolved) {
                        view = UNRESOLVED_VIEW;
                    }

                    if (view != null) {
                        //这里同时在创建视图后存入缓存中，这里放到两个容器中了
                        this.viewAccessCache.put(cacheKey, view);
                        this.viewCreationCache.put(cacheKey, view);
                        if (this.logger.isTraceEnabled()) {
                            this.logger.trace(&quot;Cached view [&quot; + cacheKey + &quot;]&quot;);
                        }
                    }
                }
            }
        }

        return view != UNRESOLVED_VIEW ? view : null;
    }
}

@Nullable
protected View createView(String viewName, Locale locale) throws Exception {
    return this.loadView(viewName, locale);
}
//这是一个模板方法由子类实现
@Nullable
protected abstract View loadView(String var1, Locale var2) throws Exception;
</code></pre><blockquote>
<p>总结：1.首先判断是否开启缓存功能，如果没有开启则直接调用createView()创建视图，否则检查是否已经存在缓存中。如果存在则直接获取返回，否则使用createView创建一个。2.然后保存到缓存中返回。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在createView()方法内部直接调用了loadView()方法，loadView()方法是模板方法，留给子类实际创建视图，是子类解析视图的入口方法。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：该AbstractCachingViewResolver中有一个cacheLimit参数，是用来设置最大缓存数，设置为0表不启用缓存。设置为正数表示最多可以缓存视图的数量。</p>
</blockquote>
<h3 id="14-2-2-UrlBasedViewResolver"><a href="#14-2-2-UrlBasedViewResolver" class="headerlink" title="14.2.2 UrlBasedViewResolver"></a>14.2.2 UrlBasedViewResolver</h3><p>在该解析器中重写了父类的 getCacheKey | createView | loadView三个方法。</p>
<pre><code>1.getCacheKey()：该方法直接返回viewName 和原来父类的返回viewName+“_”+locale相比，子类覆盖而没有使用locale，说明这个UrlBasedViewResolver并没有使用Locale，只是用viewName。

2.createView()：该方法首先检查是否可以解析传入的逻辑视图，如果不可以则返回null，然后让别的ViewResolver解析，接着分别检查是不是redirect或者forward视图，如果是则返回相应的视图，如果不是则交给父类的createView，父类中又调用loadView。

    protected View createView(String viewName, Locale locale) throws Exception {
        //检查是否支持此逻辑视图，可以配置支持的模板
        if (!this.canHandle(viewName, locale)) {
            return null;
        } else {
            String forwardUrl;
            //检查是不是redirect视图
            if (viewName.startsWith(&quot;redirect:&quot;)) {
                forwardUrl = viewName.substring(&quot;redirect:&quot;.length());
                RedirectView view = new RedirectView(forwardUrl, this.isRedirectContextRelative(), this.isRedirectHttp10Compatible());
                String[] hosts = this.getRedirectHosts();
                if (hosts != null) {
                    view.setHosts(hosts);
                }

                return this.applyLifecycleMethods(viewName, view);
            //检查是不是forward视图
            } else if (viewName.startsWith(&quot;forward:&quot;)) {
                forwardUrl = viewName.substring(&quot;forward:&quot;.length());
                return new InternalResourceView(forwardUrl);
            } else {
                //如果都不是则调用父类的createView，也就会调用loadView()方法
                return super.createView(viewName, locale);
            }
        }
    }

3.检查是否支持传入的逻辑视图和传入的逻辑视图是redirect和forward视图的功能。这里使用canHandle()方法检查，它通过配置的viewName属性检查，这里如果没有配置则可以解析所有逻辑视图，如果已经配置则按照配置的模式检查。

    //canHandle()方法
    protected boolean canHandle(String viewName, Locale locale) {
        String[] viewNames = getViewNames();
        return (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));
    }

    //loadView()方法
    protected View loadView(String viewName, Locale locale) throws Exception {
        //1.创建view
        AbstractUrlBasedView view = buildView(viewName);

        //2.使用applyLifecycleMethods()方法对创建的view初始化
        View result = applyLifecycleMethods(viewName, view);

        //3.检查view对应的模板是否存在，如果存在则将初始化视图返回
        return (View.checkResource(locale) ? result : null);
    }

    private View applyLifecycleMethods(String viewName, AbstractView view) {
        return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName);
    }

4.buildView()方法，它的作用是具体创建View。

    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        //这里viewClass可以在子类通过setViewClass()方法重新设置viewClass类型。
        Class&lt;?&gt; viewClass = this.getViewClass();
        Assert.state(viewClass != null, &quot;No view class&quot;);

        AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(viewClass);

        //这里给viewName加上前缀和后缀，可以通过配置设置
        view.setUrl(this.getPrefix() + viewName + this.getSuffix());

        String contentType = this.getContentType();
        if (contentType != null) {
            //contentType不为空设置给view
            view.setContentType(contentType);
        }

        view.setRequestContextAttribute(this.getRequestContextAttribute());
        view.setAttributesMap(this.getAttributesMap());
        Boolean exposePathVariables = this.getExposePathVariables();
        if (exposePathVariables != null) {
            //这个表示让view使用PathVariables,可以在ViewResolver中设置，PathVariable就是处理器中@PathVariables注释的参数
            view.setExposePathVariables(exposePathVariables);
        }

        Boolean exposeContextBeansAsAttributes = this.getExposeContextBeansAsAttributes();
        if (exposeContextBeansAsAttributes != null) {
            //这个不为空的时候设置给view，表示让view使用容器中注册的bean，此参数可以在ViewResolver中配置
            view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
        }

        String[] exposedContextBeanNames = this.getExposedContextBeanNames();
        if (exposedContextBeanNames != null) {
            //这个不为空的时候设置给view，表示让view使用容器中注册的bean，此参数可以在ViewResolver中配置
            view.setExposedContextBeanNames(exposedContextBeanNames);
        }
        return view;
    }


    public void setViewClass(@Nullable Class&lt;?&gt; viewClass) {
        if (viewClass != null &amp;&amp; !this.requiredViewClass().isAssignableFrom(viewClass)) {
            throw new IllegalArgumentException(&quot;Given view class [&quot; + viewClass.getName() + &quot;] is not of type [&quot; + this.requiredViewClass().getName() + &quot;]&quot;);
        } else {
            this.viewClass = viewClass;
        }
    }

    @Nullable
    protected Class&lt;?&gt; getViewClass() {
        return this.viewClass;
    }

    protected Class&lt;?&gt; requiredViewClass() {
        return AbstractUrlBasedView.class;
    }
</code></pre><blockquote>
<p>总结：这里我们知道UrlBasedViewResolver的子类主要的三件事情：1.通过重写 requiredViewClass()方法修改必须符合的视图类型的值。2.使用setViewClass()方法设置所用的视图类型。3.给创建出来的视图设置一些属性。</p>
</blockquote>
<h3 id="14-2-3-InternalResourceViewResolver和FreeMarkerViewResolver"><a href="#14-2-3-InternalResourceViewResolver和FreeMarkerViewResolver" class="headerlink" title="14.2.3 InternalResourceViewResolver和FreeMarkerViewResolver"></a>14.2.3 InternalResourceViewResolver和FreeMarkerViewResolver</h3><p>InternalResourceViewResolver和FreeMarkerViewResolver两个解析器，前面的解析器是用来解析JSP的，后面的解析器是用来解析freemarker视图的。</p>
<h4 id="1-InternalResourceViewResolver"><a href="#1-InternalResourceViewResolver" class="headerlink" title="1.InternalResourceViewResolver"></a>1.InternalResourceViewResolver</h4><pre><code>public class InternalResourceViewResolver extends UrlBasedViewResolver {
    private static final boolean jstlPresent = ClassUtils.isPresent(&quot;javax.servlet.jsp.jstl.core.Config&quot;, InternalResourceViewResolver.class.getClassLoader());
    @Nullable
    private Boolean alwaysInclude;
    //这里如果类型是jstlPresent，viewClass会使用JstlView.class
    public InternalResourceViewResolver() {
        Class&lt;?&gt; viewClass = this.requiredViewClass();
        if (InternalResourceView.class == viewClass &amp;&amp; jstlPresent) {
            viewClass = JstlView.class;
        }

        this.setViewClass(viewClass);
    }

    public InternalResourceViewResolver(String prefix, String suffix) {
        this();
        this.setPrefix(prefix);
        this.setSuffix(suffix);
    }
    //返回的类型是InternalResourceView  
    protected Class&lt;?&gt; requiredViewClass() {
        return InternalResourceView.class;
    }

    public void setAlwaysInclude(boolean alwaysInclude) {
        this.alwaysInclude = alwaysInclude;
    }
    //新添加了alwaysInclude属性
    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        InternalResourceView view = (InternalResourceView)super.buildView(viewName);
        //这个表示是否在使用forward的情况下也强制使用include，默认是false，可以在注册解析器时配置
        if (this.alwaysInclude != null) {
            view.setAlwaysInclude(this.alwaysInclude);
        }
        //用于阻止循环调用，也就是请求处理完成后又转发回了原来使用的处理器的情况
        view.setPreventDispatchLoop(true);
        return view;
    }
}
</code></pre><h4 id="2-FreeMarkerViewResolver"><a href="#2-FreeMarkerViewResolver" class="headerlink" title="2.FreeMarkerViewResolver"></a>2.FreeMarkerViewResolver</h4><pre><code>public class AbstractTemplateViewResolver extends UrlBasedViewResolver {
    private boolean exposeRequestAttributes = false;
    private boolean allowRequestOverride = false;
    private boolean exposeSessionAttributes = false;
    private boolean allowSessionOverride = false;
    private boolean exposeSpringMacroHelpers = true; 
    //...setter和getter方法

   protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        AbstractTemplateView view = (AbstractTemplateView)super.buildView(viewName);
        //是否将requestAttributes暴露给view，默认为false
        view.setExposeRequestAttributes(this.exposeRequestAttributes);
        //当requestAttributes中存在Model中同名的参数，是否允许将Model中的值覆盖，默认false
        view.setAllowRequestOverride(this.allowRequestOverride);
        //是否将SessionAttribute暴露给view使用，默认是false
        view.setExposeSessionAttributes(this.exposeSessionAttributes);
        //当SessionAttributes中存在Model中同名的参数，是否使用requestAttributes的值将Model中的覆盖，默认false
        view.setAllowSessionOverride(this.allowSessionOverride);
        view.setExposeSpringMacroHelpers(this.exposeSpringMacroHelpers);
        return view;
    }
}

//在这里只需要覆盖requiredViewClass()方法就返回FreeMakerView类型
public class FreeMarkerViewResolver extends AbstractTemplateViewResolver {
    public FreeMarkerViewResolver() {
        this.setViewClass(this.requiredViewClass());
    }

    public FreeMarkerViewResolver(String prefix, String suffix) {
        this();
        this.setPrefix(prefix);
        this.setSuffix(suffix);
    }

    protected Class&lt;?&gt; requiredViewClass() {
        return FreeMarkerView.class;
    }
}
</code></pre><blockquote>
<p>总结：大部分实现类都是继承AbstractCachingViewResolver，它提供了对解析结果进行缓存的统一解决方法，它的子类中ResourceBundlerViewResolver和XmlViewResolver分别通过properties和xml配置文件进行解析。UrlBasedViewResolver将viewName添加前后缀用作url，它的子类只需要提供视图类型就可以了。解析视图的核心工作是查找模板文件和视图类型，而查找的主要参数只有viewName，这里有三种解析思路：</p>
</blockquote>
<pre><code>1.使用viewName查找模板文件：对应URLBasedViewResolver
2.使用viewName查找视图类型：对应BeanNameViewResolver
3.使用viewName同时查找视图类型和模板文件：对应ResourceBundlerViewResolver和XmlViewResolver
</code></pre>]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC17%E7%AB%A0%20MultipartResolver/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第17章-MultipartResolver"><a href="#第17章-MultipartResolver" class="headerlink" title="第17章 MultipartResolver"></a>第17章 MultipartResolver</h1><p>该组件有两个实现类：StandardServletMultipartResolver 和 CommonsMultipartResolver。前者使用Servlet3.0标准上传方式，后者使用Apache的commons-fileupload。</p>
<h2 id="StandardServletMultipartResolver"><a href="#StandardServletMultipartResolver" class="headerlink" title="StandardServletMultipartResolver"></a>StandardServletMultipartResolver</h2><p>该方法使用Servlet 3.0 标准的上传方式。在该方式下只需要调用request的getParts()方法就可以获取所有上传的文件。如果是单个的：request.getPart(fileName)。然后调用它到write(saveFileName)方法就能够将文件保存以saveFileName为文件名的文件。</p>
<p>该方法判断请求是否是上传请求：1.在isMultipart()方法中判断是否是post请求，如果是则再检查contentType是否是以”multipart/开头，如果是则判断该请求是上传请求。</p>
<h2 id="CommonsMultipartResolver"><a href="#CommonsMultipartResolver" class="headerlink" title="CommonsMultipartResolver"></a>CommonsMultipartResolver</h2><p>该方法使用commons-fileupload来完成具体的上传操作。在CommonsMultipartResolver中判断是否是上传请求：isMultipart()，这将交给commons-fileupload的ServletFileUpload类完成。</p>
<pre><code>public boolean isMultipart(HttpServletRequest request){
    return (request != null &amp;&amp; ServletFileUpload.isMultipartContent(request));
}
</code></pre><p>CommonsMultipartResolver中实际处理request的方法是：resolveMultipart()</p>
<pre><code>public MultipartHttpServletRequest resolveMultipart(final HttpServletRequest request) throws MultipartException{
    Assert.notNull(request, &quot;request不能为空&quot;);
    if(this.resolveLazily){
        return new DefaultMultipartHttpServletRequest(request){
            @Override
            protected void initializeMultipart(){
                ...
            }
        }
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MultipartResolver的作用是将上传请求包装成可以直接获取File的request。所以此重点是从request中解析出上传的文件并设置到相应的上传类型request中。</p>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC16%E7%AB%A0%20HandlerExceptionResolver/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第16章-HandlerExceptionResolver"><a href="#第16章-HandlerExceptionResolver" class="headerlink" title="第16章 HandlerExceptionResolver"></a>第16章 HandlerExceptionResolver</h1><p>HandlerExceptionResolver主要实现都继承与抽象类的AbstractHandlerExecutionResolver，它有五个子类，其中AnnotationMethodHandlerExceptionResolver已经被弃用。</p>
<pre><code>1.AbstractHandlerMethodExceptionResolver和其子类ExceptionHandlerExcpetionResolver一起完成 @ExceptionHandler 注释的方法进行异常解析的功能。

2.DefaultHandlerExceptionResolver按照不同类型分别对异常进行解析。

3.ResponseStatusExceptionResolver解析@ResponseStatus注释类型的异常。

4.SimpleMappingExceptionResolver：通过配置的异常类和view的对应关系解析异常。

5.HandlerExecutionResolverComposite作为一个容器使用，里面封装了别的Resolver。
</code></pre><blockquote>
<p>提示：异常解析的过程是：1.给ModelAndView设置相应的内容，设置response的相关属性。</p>
</blockquote>
<h2 id="16-1-AbstractHandlerExceptionResolver"><a href="#16-1-AbstractHandlerExceptionResolver" class="headerlink" title="16.1 AbstractHandlerExceptionResolver"></a>16.1 AbstractHandlerExceptionResolver</h2><p>该类是所有直接解析异常类的父类，在里面定义了通用的解析流程，并使用模板模式，子类只需要覆盖相应的方法即可。</p>
<pre><code>@Nullable
public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    //判断当前ExceptionResolver是否可以解析所传入处理器抛出的异常，这里可以指定只能处理指定的处理器抛出的异常。如果不可以返回null，交给下一个解析
    if (this.shouldApplyTo(request, handler)) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Resolving exception from handler [&quot; + handler + &quot;]: &quot; + ex);
        }
        //设置response
        this.prepareResponse(ex, response);
        //调用这个实际解析异常，这是模板方法交给子类实现
        ModelAndView result = this.doResolveException(request, response, handler, ex);
        if (result != null) {
            this.logException(ex, request);
        }

        return result;
    } else {
        return null;
    }
}

protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler{
    //这里的mappedHandlers用于配置处理器的集合，mappedHandlerClasses用于配置处理器类型的集合，如果设置了这两个属性的一个，那么ExceptionResolver就只能解析所设置的处理器抛出的异常    
    if (handler != null) {
        if (this.mappedHandlers != null &amp;&amp; this.mappedHandlers.contains(handler)) {
            return true;
        }

        if (this.mappedHandlerClasses != null) {
            Class[] var3 = this.mappedHandlerClasses;
            int var4 = var3.length;

            for(int var5 = 0; var5 &lt; var4; ++var5) {
                Class&lt;?&gt; handlerClass = var3[var5];
                if (handlerClass.isInstance(handler)) {
                    return true;
                }
            }
        }
    }

    return this.mappedHandlers == null &amp;&amp; this.mappedHandlerClasses == null;
}
</code></pre><h2 id="16-2-ExceptionHandlerExceptionResolver"><a href="#16-2-ExceptionHandlerExceptionResolver" class="headerlink" title="16.2 ExceptionHandlerExceptionResolver"></a>16.2 ExceptionHandlerExceptionResolver</h2><p>这个类继承AbstractHandlerMethodExceptionResolver，后者又继承于AbstractHandlerMethodExceptionResolver重写了shouldApplyTo方法，并且在处理请求的doResolverException方法中将实际处理请求的过程交给了模板方法doResolveHanlerMethodException。</p>
<blockquote>
<p>提示：AbstractHandlerMethodExceptionResolver作用相当于适配器。一般的处理器是类的形式，但HandlerMethod是将方法作为处理器使用，所以需要适配。1.首先在shouldApplyTo()中判断如果处理器是HandlerMethod类型则将处理器设置为其所在类，然后再交给父类判断。如果为空则直接交给父类判断。如果既不为空也不是HandlerMethod类型则返回false不处理。</p>
</blockquote>
<p>ExceptionHandlerExceptionResolver其实是一个简化版的RequestMappingHandlerAdapter，它的执行也是使用ServletInvocableHandlerMethod。1.首先根据handlerMethod和exception将其创建出来（找出所有注释了@ExceptionHandler的方法，然后根据其配置中的异常和需要解析的异常进行匹配）。2.然后设置argumentResolver和returnValueHandlers。3.接着调用其invokeAndHandle()方法执行处理。4.最后将处理结果封装成ModelAndView返回。</p>
<pre><code>@Nullable
protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) {
    //找到处理异常的方法
    ServletInvocableHandlerMethod exceptionHandlerMethod = this.getExceptionHandlerMethod(handlerMethod, exception);
    if (exceptionHandlerMethod == null) {
        return null;
    } else {
         //设置argumentResolvers和returnValueHandlers
        if (this.argumentResolvers != null) {
            exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }

        if (this.returnValueHandlers != null) {
            exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }

        ServletWebRequest webRequest = new ServletWebRequest(request, response);
        ModelAndViewContainer mavContainer = new ModelAndViewContainer();

        try {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&quot;Invoking @ExceptionHandler method: &quot; + exceptionHandlerMethod);
            }

            Throwable cause = exception.getCause();
            if (cause != null) {
                //执行解析异常
                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, new Object[]{exception, cause, handlerMethod});
            } else {
                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, new Object[]{exception, handlerMethod});
            }
        } catch (Throwable var12) {
            if (var12 != exception &amp;&amp; this.logger.isWarnEnabled()) {
                this.logger.warn(&quot;Failed to invoke @ExceptionHandler method: &quot; + exceptionHandlerMethod, var12);
            }

            return null;
        }

        if (mavContainer.isRequestHandled()) {
            return new ModelAndView();
        } else {
            //封装ModelAndView 
            ModelMap model = mavContainer.getModel();
            HttpStatus status = mavContainer.getStatus();
            ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);
            mav.setViewName(mavContainer.getViewName());
            if (!mavContainer.isViewReference()) {
                mav.setView((View)mavContainer.getView());
            }

            if (model instanceof RedirectAttributes) {
                Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes)model).getFlashAttributes();
                RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
            }

            return mav;
        }
    }
}
</code></pre><blockquote>
<p>注意：这里只是返回了ModelAndView，并没有对response进行设置。如果需要可以自行在异常处理器中设置。</p>
</blockquote>
<h2 id="16-3-DefaultHandlerExceptionResolver"><a href="#16-3-DefaultHandlerExceptionResolver" class="headerlink" title="## 16.3 DefaultHandlerExceptionResolver"></a>## 16.3 DefaultHandlerExceptionResolver</h2><p>该解析器的解析过程是根据异常类型的不同，使用不同的方法进行处理。</p>
<pre><code>@Nullable
protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    try {
        if (ex instanceof HttpRequestMethodNotSupportedException) {
            return this.handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException)ex, request, response, handler);
        }

        if (ex instanceof HttpMediaTypeNotSupportedException) {
            return this.handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException)ex, request, response, handler);
        }

        if (ex instanceof HttpMediaTypeNotAcceptableException) {
            return this.handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException)ex, request, response, handler);
        }

        if (ex instanceof MissingPathVariableException) {
            return this.handleMissingPathVariable((MissingPathVariableException)ex, request, response, handler);
        }

        if (ex instanceof MissingServletRequestParameterException) {
            return this.handleMissingServletRequestParameter((MissingServletRequestParameterException)ex, request, response, handler);
        }

        if (ex instanceof ServletRequestBindingException) {
            return this.handleServletRequestBindingException((ServletRequestBindingException)ex, request, response, handler);
        }

        if (ex instanceof ConversionNotSupportedException) {
            return this.handleConversionNotSupported((ConversionNotSupportedException)ex, request, response, handler);
        }

        if (ex instanceof TypeMismatchException) {
            return this.handleTypeMismatch((TypeMismatchException)ex, request, response, handler);
        }

        if (ex instanceof HttpMessageNotReadableException) {
            return this.handleHttpMessageNotReadable((HttpMessageNotReadableException)ex, request, response, handler);
        }

        if (ex instanceof HttpMessageNotWritableException) {
            return this.handleHttpMessageNotWritable((HttpMessageNotWritableException)ex, request, response, handler);
        }

        if (ex instanceof MethodArgumentNotValidException) {
            return this.handleMethodArgumentNotValidException((MethodArgumentNotValidException)ex, request, response, handler);
        }

        if (ex instanceof MissingServletRequestPartException) {
            return this.handleMissingServletRequestPartException((MissingServletRequestPartException)ex, request, response, handler);
        }

        if (ex instanceof BindException) {
            return this.handleBindException((BindException)ex, request, response, handler);
        }

        if (ex instanceof NoHandlerFoundException) {
            return this.handleNoHandlerFoundException((NoHandlerFoundException)ex, request, response, handler);
        }

        if (ex instanceof AsyncRequestTimeoutException) {
            return this.handleAsyncRequestTimeoutException((AsyncRequestTimeoutException)ex, request, response, handler);
        }
    } catch (Exception var6) {
        if (this.logger.isWarnEnabled()) {
            this.logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in exception&quot;, var6);
        }
    }

    return null;
}
</code></pre><blockquote>
<p>提示：具体的解析方法很简单，主要是设置response的相关属性。</p>
</blockquote>
<h4 id="没有找到处理器执行方法和request的Method类型不支持异常处理"><a href="#没有找到处理器执行方法和request的Method类型不支持异常处理" class="headerlink" title="没有找到处理器执行方法和request的Method类型不支持异常处理"></a>没有找到处理器执行方法和request的Method类型不支持异常处理</h4><h2 id="16-4-ResponseStatusExceptionResolver"><a href="#16-4-ResponseStatusExceptionResolver" class="headerlink" title="16.4 ResponseStatusExceptionResolver"></a>16.4 ResponseStatusExceptionResolver</h2><p>该解析器用来解析注视了@ResponseStatus的异常。</p>
<pre><code>protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    try {
        if (ex instanceof ResponseStatusException) {
            return this.resolveResponseStatusException((ResponseStatusException)ex, request, response, handler);
        }
        //找到@ResponseStatus注释
        ResponseStatus status = (ResponseStatus)AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);
        if (status != null) {
            //然后调用解析方法
            return this.resolveResponseStatus(status, request, response, handler, ex);
        }

        if (ex.getCause() instanceof Exception) {
            ex = (Exception)ex.getCause();
            return this.doResolveException(request, response, handler, ex);
        }
    } catch (Exception var6) {
        this.logger.warn(&quot;ResponseStatus handling resulted in exception&quot;, var6);
    }

    return null;
}

protected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {
    int statusCode = responseStatus.code().value();
    String reason = responseStatus.reason();
    return this.applyStatusAndReason(statusCode, reason, response);
}
</code></pre><h2 id="16-5-SimpleMappingExceptionResolver"><a href="#16-5-SimpleMappingExceptionResolver" class="headerlink" title="16.5 SimpleMappingExceptionResolver"></a>16.5 SimpleMappingExceptionResolver</h2><p>该解析器需要提前配置异常类和view的对应关系后才能使用。</p>
<pre><code>protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    //首先根据异常查找显示错误的逻辑视图
    String viewName = this.determineViewName(ex, request);

    if (viewName != null) {

        //检查是否配置了所找到的viewName对应的statusCode
        Integer statusCode = this.determineStatusCode(request, viewName);

        if (statusCode != null) {

            //设置response
            this.applyStatusCodeIfPossible(request, response, statusCode);
        }
        //将异常和解析出的viewName封装成ModelAndView并返回
        return this.getModelAndView(viewName, ex, request);
    } else {
        return null;
    }
}

@Nullable
protected String determineViewName(Exception ex, HttpServletRequest request) {
    String viewName = null;

    //如果异常在设置的excludeExceptions中包含则返回null
    if (this.excludedExceptions != null) {
        Class[] var4 = this.excludedExceptions;
        int var5 = var4.length;

        for(int var6 = 0; var6 &lt; var5; ++var6) {
            Class&lt;?&gt; excludedEx = var4[var6];
            if (excludedEx.equals(ex.getClass())) {
                return null;
            }
        }
    }

    //调用findMatchingViewName方法实际查找
    if (this.exceptionMappings != null) {
        viewName = this.findMatchingViewName(this.exceptionMappings, ex);
    }

    //如果没有找到viewName且配置了defaultErrorView，则采用默认视图
    if (viewName == null &amp;&amp; this.defaultErrorView != null) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Resolving to default view &apos;&quot; + this.defaultErrorView + &quot;&apos; for exception of type [&quot; + ex.getClass().getName() + &quot;]&quot;);
        }

        viewName = this.defaultErrorView;
    }

    return viewName;
}
</code></pre><blockquote>
<p>提示：这里首先检查异常是不是配置在excludedException中(excludedException用于配置不处理的异常)，如果是则返回null，否则调用findMatchingViewName实际查找viewName，如果没有找到且配置了defaultErrorView，则使用defaultErrorView。findMatchingViewName()方法从传入的参数就可以看出它是根据配置的exceptionMapping参数匹配当前异常的，不过并不是直接完全匹配，而是只要配置异常的字符在当前处理的异常或其父类中存在就可以了。</p>
</blockquote>
<pre><code>protected String findMatchingViewName(Properties exceptionMapping, Exception ex) {
    String viewName = null;
    String dominantMapping = null;
    int deepest = Integer.MAX_VALUE;
    ...
} 
</code></pre><blockquote>
<p>总结：<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a> 会自动将ExceptionHandlerExceptionResolver | DefaultHandlerExceptionResolver | ResponseStatusExceptionResolver配置到SpringMVC中，如果SimpleMappingExceptionResolver使用时需要配置，同时该异常只能处理请求处理过程抛出的异常，异常处理本身抛出的异常和视图解析过程中抛出的异常时不能做到的。</p>
</blockquote>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC18%E7%AB%A0%20LocaleResolver/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第18章-LocaleResolver"><a href="#第18章-LocaleResolver" class="headerlink" title="第18章 LocaleResolver"></a>第18章 LocaleResolver</h1><p>LocaleResolver的主要作用在于根据不同的用户区域展示不同的视图，通过设置系统的环境，根据运行环境使用不同的语言显示。用户的区域称为 Locale ，这一信息可以由前端直接获取。通过这一方式可以实现国际化的目的。如：针对美国用户提供一个视图，针对中国用户提供一个视图。而LocaleResolver的使用是实现对用户不同视图的切换。LocaleResolver的作用是使用request解析出Locale。在LocaleResolver的实现类中，AcceptHeaderLocaleResolver直接使用了Header里的acceptlanguage值，不能在程序里面修改。</p>
<h4 id="1-Spring针对LocaleResoler提供几种实现方式"><a href="#1-Spring针对LocaleResoler提供几种实现方式" class="headerlink" title="1.Spring针对LocaleResoler提供几种实现方式"></a>1.Spring针对LocaleResoler提供几种实现方式</h4><pre><code>1.FixedLocaleResolver 在声明该resolver时，需要指定一个默认的Locale，在进行Locale获取时，始终返回该Locale，并且调用其setLocale()方法也无法改变其Locale。

2.SessionLocaleResolver 其会将Locale信息存储在session中，如果用户想要修改Locale信息，可以通过修改session中对应属性的值即可。

3.CookieLocaleResolver 其读取Locale的方式是在session中通过Cookie来获取其指定的Locale的，如果修改了Cookie的值，页面视图也会同步切换。

4.AcceptHeaderLocaleResolver 其会通过用户请求中名称为Accept-Language的header来获取Locale信息，如果想要修改展示的视图，只需要修改该header信息即可。
</code></pre><blockquote>
<p>提示：在Spring4.x之后，LocaleResolver添加子接口 LocaleContextResolver 其中增加了获取和设置LocaleContext 的能力，并添加了抽象类 AbstractLocaleContextResolver，抽象类添加了对TimeZone(时区)的支持。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：Spring虽然提供几个不同的获取Locale的方式，但是这些方式除 FixedLocaleResolver 以外，其它也都支持在浏览器地址栏添加Locale参数来切换Locale。而对于Locale的切换，Spring通过拦截器来实现，其提供一个LocaleChangeInterceptor，在该拦截器中的preHandler()方法中，Spring会读取浏览器参数中的locale参数，然后调用LocaleResolver.setLocale()方法实现对Locale的切换。</p>
</blockquote>
</blockquote>
<h3 id="2-LocaleResolver接口声明"><a href="#2-LocaleResolver接口声明" class="headerlink" title="2.LocaleResolver接口声明"></a>2.LocaleResolver接口声明</h3><pre><code>public interface LocaleResolver {
    // 根据request对象根据指定的方式获取一个Locale，如果没有获取到，则使用用户指定的默认的Locale
    Locale resolveLocale(HttpServletRequest request);

    // 用于实现Locale的切换。比如SessionLocaleResolver获取Locale的方式是从session中读取，但如果
    // 用户想要切换其展示的样式(由英文切换为中文)，那么这里的setLocale()方法就提供了这样一种可能
    void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, 
        @Nullable Locale locale);
}
</code></pre><h4 id="2-1-重写-resolveLocale-HttpServletRequest-request-方法"><a href="#2-1-重写-resolveLocale-HttpServletRequest-request-方法" class="headerlink" title="2.1 重写 resolveLocale(HttpServletRequest request)方法"></a>2.1 重写 resolveLocale(HttpServletRequest request)方法</h4><p>这里使用默认的解析器 AcceptHeaderLocaleResolver 继承 LocaleResolver 重写resolverLocale(HttpServletRequest request)方法，通过检查客户端发送请求中的Accept-Language头来确定客户端Locale（地区信息）。</p>
<pre><code>/**
 * 从当前的request中解析Locale
 */
@Override
public Locale resolveLocale(HttpServletRequest request) {
    // 获取默认设置，可在配置AcceptHeaderLocaleResolver Bean中设置defaultLocale属性
    Locale defaultLocale = getDefaultLocale();
    // 设置了默认值并且请求中没有Accept-Language头信息时，使用默认设置
    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) {
        return defaultLocale;
    }
    // 从当前请求中获取Locale
    Locale requestLocale = request.getLocale();
    // 从配置中获取支持的Locale集合，可在AcceptHeaderLocaleResolver Bean中设置supportedLocales属性
    List&lt;Locale&gt; supportedLocales = getSupportedLocales();
    // 未设置supportedLocales或者supportedLocales中包括请求Locale，则使用请求Locale
    if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) {
        return requestLocale;
    }
    // 找到设置的Locale集合中是否有请求的Locale
    Locale supportedLocale = findSupportedLocale(request, supportedLocales);
    if (supportedLocale != null) {
        return supportedLocale;
    }
    return (defaultLocale != null ? defaultLocale : requestLocale);
}

/**
 * 不支持程序设置Locale
 */
@Override
public void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale) {
    throw new UnsupportedOperationException(
            &quot;Cannot change HTTP accept header - use a different locale resolution strategy&quot;);
}
</code></pre><h4 id="2-2-在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver-bean"><a href="#2-2-在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver-bean" class="headerlink" title="2.2 在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver bean"></a>2.2 在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver bean</h4><pre><code>&lt;!-- 国际化资源文件 --&gt;
&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;
    &lt;!-- 如果资源文件放在classpath下，basename的value必须有classpath:前缀，否则报错：No message found under code... --&gt;
    &lt;property name=&quot;basename&quot; value=&quot;classpath:i18n/messages&quot; /&gt;
    &lt;!-- 如果在国际化资源文件中找不到对应代码的信息，就用这个代码作为名称返回  --&gt;
    &lt;property name=&quot;useCodeAsDefaultMessage&quot; value=&quot;true&quot; /&gt;
    &lt;!--&lt;property name=&quot;defaultEncoding&quot; value=&quot;ISO-8859-1&quot;/&gt;--&gt;
&lt;/bean&gt;
&lt;!-- LocaleResolver解析器 --&gt;
&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver&quot;&gt;
    &lt;property name=&quot;defaultLocale&quot; value=&quot;zh_CN&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="2-3-属性文件"><a href="#2-3-属性文件" class="headerlink" title="2.3 属性文件"></a>2.3 属性文件</h4><p><strong>2.3.1 messages_en.properties</strong><br></p>
<pre><code>message.locale = en
</code></pre><p><strong>2.3.2 messages_zh_CN.properties</strong><br></p>
<pre><code>message.locale=zh_CN
</code></pre><h4 id="2-4-Controller"><a href="#2-4-Controller" class="headerlink" title="2.4 Controller"></a>2.4 Controller</h4><pre><code>@GetMapping(value = &quot;/acceptHeaderLocaleResolver&quot; , produces = &quot;text/html;charset=UTF-8&quot;)
@ResponseBody
public String test(HttpServletRequest request) {
    String clientLocale = &quot;&quot;;
    Enumeration&lt;Locale&gt; enus =  request.getLocales();
    while (enus.hasMoreElements()){
        Locale locale = enus.nextElement();
        clientLocale += locale + &quot;,&quot;;
    }
    RequestContext requestContext = new RequestContext(request);
    String value = requestContext.getMessage(&quot;message.locale&quot;);
    return &quot;客户端支持的Locale有：&quot;+clientLocale+&quot; &lt;/br&gt;当前使用的Locale是：&quot; + requestContext.getLocale() + &quot; &lt;/br&gt;使用的资源Locale文件是：&quot; + value ;
}
</code></pre><hr>
<h4 id="3-CookieLocaleResolver解析器"><a href="#3-CookieLocaleResolver解析器" class="headerlink" title="3.CookieLocaleResolver解析器"></a>3.CookieLocaleResolver解析器</h4><p>CookieLocaleResolver解析器通过不同的Locale展示不同的视图。CookieLocaleResolver类的入口是：resolveLocaleContext(final HttpServletRequest request); SpringMVC接收到客户端请求之后会调用该方法。</p>
<pre><code>@Override
public LocaleContext resolveLocaleContext(final HttpServletRequest request) {
    // 解析Cookie信息
    parseLocaleCookieIfNecessary(request);
    // 返回Locale和TimeZone
    return new TimeZoneAwareLocaleContext() {
        @Override
        @Nullable
        public Locale getLocale() {
            return (Locale) request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME);
        }
        @Override
        @Nullable
        public TimeZone getTimeZone() {
            return (TimeZone) request.getAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME);
        }
    };
}

private void parseLocaleCookieIfNecessary(HttpServletRequest request) {
    // 第一次请求为null
    if (request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME) == null) {
        Locale locale = null; // 地区
        TimeZone timeZone = null; // 时区

        // 获取cookie的名称，取自Spring MVC配置，默认为：CookieLocaleResolver.DEFAULT_COOKIE_NAME
        String cookieName = getCookieName();
        if (cookieName != null) {
            // 根据名称获取当前请求中的Cookie（第一次访问为null）
            Cookie cookie = WebUtils.getCookie(request, cookieName);
            if (cookie != null) {
                // 以下主要是从客户端Cookie中解析出Locale
                String value = cookie.getValue();
                String localePart = value;
                String timeZonePart = null;
                int spaceIndex = localePart.indexOf(&apos; &apos;);
                if (spaceIndex != -1) {
                    localePart = value.substring(0, spaceIndex);
                    timeZonePart = value.substring(spaceIndex + 1);
                }
                try {
                    locale = (!&quot;-&quot;.equals(localePart) ? parseLocaleValue(localePart) : null);
                    if (timeZonePart != null) {
                        timeZone = StringUtils.parseTimeZoneString(timeZonePart);
                    }
                }
                catch (IllegalArgumentException ex) {
                    if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {
                        // Error dispatch: ignore locale/timezone parse exceptions
                        if (logger.isDebugEnabled()) {
                            logger.debug(&quot;Ignoring invalid locale cookie &apos;&quot; + cookieName +
                                    &quot;&apos; with value [&quot; + value + &quot;] due to error dispatch: &quot; + ex.getMessage());
                        }
                    }
                    else {
                        throw new IllegalStateException(&quot;Invalid locale cookie &apos;&quot; + cookieName +
                                &quot;&apos; with value [&quot; + value + &quot;]: &quot; + ex.getMessage());
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Parsed cookie value [&quot; + cookie.getValue() + &quot;] into locale &apos;&quot; + locale +
                            &quot;&apos;&quot; + (timeZone != null ? &quot; and time zone &apos;&quot; + timeZone.getID() + &quot;&apos;&quot; : &quot;&quot;));
                }
            }
        }
        // 把Locale设置到请求的Attribute区，客户端请求没有携带Cookie，取Spring MVC中配置的defaultLocale
        request.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,
                (locale != null ? locale : determineDefaultLocale(request)));
        request.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,
                (timeZone != null ? timeZone : determineDefaultTimeZone(request)));
    }
}

// 设置Locale
@Override
public void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale) {
    setLocaleContext(request, response, (locale != null ? new SimpleLocaleContext(locale) : null));
}

// 主要是把Locale信息写回客户端
@Override
public void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response,
        @Nullable LocaleContext localeContext) {

    Assert.notNull(response, &quot;HttpServletResponse is required for CookieLocaleResolver&quot;);

    Locale locale = null;
    TimeZone timeZone = null;
    if (localeContext != null) {
        locale = localeContext.getLocale();
        if (localeContext instanceof TimeZoneAwareLocaleContext) {
            timeZone = ((TimeZoneAwareLocaleContext) localeContext).getTimeZone();
        }
        addCookie(response,
                (locale != null ? toLocaleValue(locale) : &quot;-&quot;) + (timeZone != null ? &apos; &apos; + timeZone.getID() : &quot;&quot;));
    }
    else {
        removeCookie(response);
    }
    request.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,
            (locale != null ? locale : determineDefaultLocale(request)));
    request.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,
            (timeZone != null ? timeZone : determineDefaultTimeZone(request)));
}
</code></pre><p><strong>3.1 配置xml文件</strong><br></p>
<pre><code>&lt;context:component-scan base-package=&quot;mvc&quot;/&gt;
&lt;mvc:annotation-driven/&gt;

&lt;mvc:interceptors&gt;
    &lt;!--添加拦截器，用于对Locale的切换--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;/&gt;
    &lt;bean class=&quot;mvc.interceptor.MyHandlerInterceptor&quot;/&gt;
&lt;/mvc:interceptors&gt;

&lt;!--指定ViewResolver是ResourceBundleViewResolver是因为其支持通过不同的Locale进行不同的视图切换--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;/&gt;

&lt;!--指定LocaleResolver为CookieLocaleResolver--&gt;
&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;
    &lt;!--指定defaultlocal是zh_CN--&gt;
    &lt;property name=&quot;defaultLocale&quot; value=&quot;zh_CN&quot;/&gt;
&lt;/bean&gt;
</code></pre><p><strong>3.2 声明接口</strong><br></p>
<pre><code>@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
  @Autowired
  private UserService userService;

  @RequestMapping(value = &quot;/detail&quot;, method = RequestMethod.GET)
  public ModelAndView detail(@RequestParam(&quot;id&quot;) long id, @ModelAttribute(&quot;message&quot;) String message, Locale locale) {
    System.out.println(message);
    ModelAndView view = new ModelAndView(&quot;user&quot;);
    User user = userService.detail(id);
    view.addObject(&quot;user&quot;, user);
    view.addObject(&quot;locale&quot;, locale);
    return view;
  }
}
</code></pre><blockquote>
<p>提示：这里返回的视图是：user 并将Locale信息返回给前端。这里获取Locale数据的方式就只需要简单的声明一个类型为Locale的参数。</p>
</blockquote>
<p><strong>3.3 视图的展示</strong><br><br>由于需要根据不同的Locale展示不同的视图，我们在上面的接口中没有发现这样的路由。在实际中，这个路由是根据ResourceBundleViewResolver类实现的，在使用该ViewResolver时，其会到class路径下查找名称为views的Resource Bundle，同时通过用户指定的Locale，唯一定位到某个 Resource Bundle。 然后在该Resource Bundle 中查找指定的视图信息。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里我们的LocaleResolver的bean名称必须是 localeResolver，并且需要指定的 ViewResolver 辅以支持，否则切换的视图可能无法工作。</p>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC19%E7%AB%A0%20ThemeResolver/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第19章-ThemeResolver"><a href="#第19章-ThemeResolver" class="headerlink" title="第19章 ThemeResolver"></a>第19章 ThemeResolver</h1><p>·这里的SpringMVC框架提供的主题设置应用的整体样式和风格，提高用户体验。SpringMVC主题是一些静态资源的集合。ThemeResolver根据request解析Theme，ThemeResolver的实现和LocalResolver相似。AbstractThemeResolver设置默认的主题：defaultThemeName属性，提供get/set方法。在SpringMVC中包括两部分内容：Theme和ThemeResolver。</p>
<h2 id="1-Theme"><a href="#1-Theme" class="headerlink" title="1.Theme"></a>1.Theme</h2><p>在应用Theme主题时需要实现org.springframework.ui.context.ThemeSource接口，WEB应用上下文WebApplication接口继承自ThemeSource，但实现功能委派给具体的类实现，默认：org.springframework.ui.context.support.ResouceBundleThemeSource类。此类默认从classpath加载主题文件。</p>
<blockquote>
<p>注意：无论是自定义ThemeSource接口的实现 或 通过配置属性文件路径的ResourceBundleThemeSource实现，都需要在Spring上下文中定义此bean，并且bean的id必须为themeSource，Spring会自动发现并使用。</p>
</blockquote>
<h2 id="2-ThemeResolver"><a href="#2-ThemeResolver" class="headerlink" title="2.ThemeResolver"></a>2.ThemeResolver</h2><p>在Spring上下文中定义Theme之后，DispatcherServlet会在Spring容器中查找id是themeResolver的bean使用。</p>
<blockquote>
<p>提示：ThemeResolver的使用和LocalResolver的工作原理一样，它在request中查找theme主题并且可以修改request的theme主题，Spring提供如下的主体解析器：</p>
</blockquote>
<pre><code>1.FixedThemeResolver：默认主题解析器，使用固定的主题，通过defaultThemeName属性设置，即此属性指定主题属性文件的文件名。此解析器不能动态设置主题。

2.SessionThemeResolver：通过用户会话来保持主题，每个会话（session）仅需要设置一次，所有请求共享主题，但是不能两个会话共享。

3.CookieThemeResolver：使用客户端cookie存储的主题。
</code></pre><blockquote>
<p>提示：Spring提供ThemeChangeInterceptor拦截器，通过request参数控制改变用户请求的主题。</p>
</blockquote>
<h4 id="1-FixedThemeResolver"><a href="#1-FixedThemeResolver" class="headerlink" title="1.FixedThemeResolver"></a>1.FixedThemeResolver</h4><p>该解析器是默认的主题解析器(在DispatcherServlet.properties文件中配置默认策略)，实现ThemeResolver接口，主题的名字通过defaultThemeName属性指定，该值默认是theme。</p>
<pre><code>public class FixedThemeResolver extends AbstractThemeResolver {
    // 解析主题文件名
    @Override
    public String resolveThemeName(HttpServletRequest request) {
        // 返回主题文件名，默认值为theme（在父类中定义）
        return getDefaultThemeName();
    }

    // 设置主题文件名，此解析器不能设置。
    @Override
    public void setThemeName(
            HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName) {
        throw new UnsupportedOperationException(&quot;Cannot change theme - use a different theme resolution strategy&quot;);
    }
}
</code></pre><p><strong>1.1 FixedThemeResolver 配置文件</strong><br></p>
<pre><code>&lt;!-- 默认Servlet处理静态资源 --&gt;
&lt;mvc:default-servlet-handler /&gt;
&lt;!-- jsp视图映射与视图解析 --&gt;
&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 加载主题资源文件 --&gt;
&lt;bean id=&quot;themeSource&quot; class=&quot;org.springframework.ui.context.support.ResourceBundleThemeSource&quot;&gt;
    &lt;!-- 指定文件前缀，即文件所在目录，如果放在classpath下，value为空（默认从classpath下加载） --&gt;
    &lt;property name=&quot;basenamePrefix&quot; value=&quot;theme.&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 使用FixedThemeResolver --&gt;
&lt;bean id=&quot;themeResolver&quot; class=&quot;org.springframework.web.servlet.theme.FixedThemeResolver&quot;&gt;
    &lt;!-- 定义theme文件的名称 --&gt;
    &lt;property name=&quot;defaultThemeName&quot; value=&quot;myTheme&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>说明：1.ResourceBundleThemeSource的属性basenamePrefix即为主题属性文件所在目录名称，其后必须有”.”或”/“。 2.FixedThemeResolver是Spring默认的解析器，再此配置是为了自定义defaultThemeName属性值，即属性文件名称。</p>
</blockquote>
<blockquote>
<p>提示：在配置文件之后还应该有jsp文件和controller文件等。这里省略。</p>
</blockquote>
<h4 id="2-SessionThemeResolver"><a href="#2-SessionThemeResolver" class="headerlink" title="2.SessionThemeResolver"></a>2.SessionThemeResolver</h4><blockquote>
<p>说明：1.SessionThemeResolver与FixedThemeResolver解析器的继承关系一样，都继承自AbstractThemeResolver抽象类，其中抽象类中定义了defaultThemeName属性，用于设置属性文件的名称，默认为theme。2.SessionThemeResolver类实现ThemeResolver接口，使用用户会话（session）中的主题。</p>
</blockquote>
<pre><code>public class SessionThemeResolver extends AbstractThemeResolver {
    // 用于设置session Attribute中的key使用
    public static final String THEME_SESSION_ATTRIBUTE_NAME = SessionThemeResolver.class.getName() + &quot;.THEME&quot;;

    // 解析请求中使用的主题
    @Override
    public String resolveThemeName(HttpServletRequest request) {
        // 从请求会话中获取到主题
        String themeName = (String) WebUtils.getSessionAttribute(request, THEME_SESSION_ATTRIBUTE_NAME);
        // 如果会话中不存在，使用默认的主题
        return (themeName != null ? themeName : getDefaultThemeName());
    }
    // 设置请求的主题
    @Override
    public void setThemeName(
            HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName) {
        // 从客户端请求获取主题并设置到session的Attribute区中
        WebUtils.setSessionAttribute(request, THEME_SESSION_ATTRIBUTE_NAME,
                (StringUtils.hasText(themeName) ? themeName : null));
    }
}
</code></pre><p><strong>2.1 SessionThemeResolver 配置文件</strong><br></p>
<pre><code>&lt;mvc:interceptors&gt;
    &lt;!-- 该拦截器通过名为”theme”的参数来拦截HTTP请求，设置Theme主题 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.theme.ThemeChangeInterceptor&quot;&gt;
        &lt;!-- 用户请求参数的名称为：theme --&gt;
        &lt;property name=&quot;paramName&quot; value=&quot;theme&quot;/&gt;
    &lt;/bean&gt;
&lt;/mvc:interceptors&gt;

&lt;!-- 指定ThemeResolver --&gt;
&lt;bean id=&quot;themeResolver&quot; class=&quot;org.springframework.web.servlet.theme.SessionThemeResolver&quot;&gt;
    &lt;!-- 配置默认的主题文件 --&gt;
    &lt;property name=&quot;defaultThemeName&quot; value=&quot;myTheme&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 其余配置省略，参加上章 --&gt;
...
</code></pre><h4 id="3-CookieThemeResolver"><a href="#3-CookieThemeResolver" class="headerlink" title="3.CookieThemeResolver"></a>3.CookieThemeResolver</h4><p>CookieThemeResolver将主题保存到cookie中，为了处理cookie方便继承了CookieGenerator，所以不能继承AbstractThemeResolver，其实现了对默认主题的支持。</p>
<pre><code>// 设置Theme，在请求到达Controller之前，进行设置
@Override
public void setThemeName(
        HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName) {

    Assert.notNull(response, &quot;HttpServletResponse is required for CookieThemeResolver&quot;);
    // 请求参数中传来的themeName值
    if (StringUtils.hasText(themeName)) {
        // 把请求参数指定的主题设置request Attribute并写cookie
        request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);
        addCookie(response, themeName);
    }
    else {
        // 将默认的主题设置request Attribute并写cookie
        request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, getDefaultThemeName());
        removeCookie(response);
    }
}

// 解析请求的Theme
@Override
public String resolveThemeName(HttpServletRequest request) {
    // 从request中获取主题theme
    String themeName = (String) request.getAttribute(THEME_REQUEST_ATTRIBUTE_NAME);
    if (themeName != null) {
        return themeName;
    }

    // 从客户端cookie中获取指定名字的theme，在设置时指定了cookie名字
    String cookieName = getCookieName();
    if (cookieName != null) {
        Cookie cookie = WebUtils.getCookie(request, cookieName);
        if (cookie != null) {
            String value = cookie.getValue();
            if (StringUtils.hasText(value)) {
                themeName = value;
            }
        }
    }

    // 请求和cookie中都无时，使用默认theme
    if (themeName == null) {
        themeName = getDefaultThemeName();
    }
    request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);
    return themeName;
}
</code></pre>]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC20%E7%AB%A0%20FlashMapManager/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第20章-FlashMapManager"><a href="#第20章-FlashMapManager" class="headerlink" title="第20章 FlashMapManager"></a>第20章 FlashMapManager</h1><p>FlashMapManager用来管理FlashMap，FlashMap用于在redirect时传递参数。FlashMapManager实现结构简单，只有一个抽象类和一个实现类。抽象类采用模板模式定义整体流程。具体实现类SessionFlashManager通过模板方法提供具体操作FlashMap的功能。</p>
<blockquote>
<p>说明：1.实际的Session中保存的FlashMap类型是List<flashmap>类型，也就是说一个Session可以保存多个FlashMap，一个FlashMap保存着一套Redirect转发所传递的参数。2. FlashMap继承自HashMap，除了用于HashMap的功能和设置有效期，还可以保存Redirect后的目标路径和通过url传递的参数，这两项内容主要用来从Session保存的多个FlashMap中查找当前的FalshMap。</flashmap></p>
</blockquote>
<h2 id="1-AbstractFlashMapManager"><a href="#1-AbstractFlashMapManager" class="headerlink" title="1.AbstractFlashMapManager"></a>1.AbstractFlashMapManager</h2><h4 id="1-1-saveOutputFlashMap"><a href="#1-1-saveOutputFlashMap" class="headerlink" title="1.1 saveOutputFlashMap"></a>1.1 saveOutputFlashMap</h4><pre><code>public final void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response) {
    if (!CollectionUtils.isEmpty(flashMap)) {
        //首先对flashMap中转发的地址和参数进行编码，这里的request主要是用来获取当前的编码
        String path = this.decodeAndNormalizePath(flashMap.getTargetRequestPath(), request);            
        flashMap.setTargetRequestPath(path);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Saving FlashMap=&quot; + flashMap);
        }
        //设置过期时间，默认值是180秒
        flashMap.startExpirationPeriod(this.getFlashMapTimeout());
        用于获取互斥变量，是模板方法，如果子类返回不为null则同步执行，否则不需要同步
        Object mutex = this.getFlashMapsMutex(request);
        if (mutex != null) {
            synchronized(mutex) {
                //取回保存的flashMap，如果没有则新建一个
                List&lt;FlashMap&gt; allFlashMaps = this.retrieveFlashMaps(request);
                List&lt;FlashMap&gt; allFlashMaps = allFlashMaps != null ? allFlashMaps : new CopyOnWriteArrayList();
                ((List)allFlashMaps).add(flashMap);
                //将添加完的list&lt;FalshMap&gt;更新到存储介质中去，是模板方法，由子类实现
                this.updateFlashMaps((List)allFlashMaps, request, response);
            }
        } else {
            List&lt;FlashMap&gt; allFlashMaps = this.retrieveFlashMaps(request);
            List&lt;FlashMap&gt; allFlashMaps = allFlashMaps != null ? allFlashMaps : new LinkedList();
            ((List)allFlashMaps).add(flashMap);
            this.updateFlashMaps((List)allFlashMaps, request, response);
        }

    }
}
</code></pre><blockquote>
<p>总结：1.首先对flashMap中的目标地址和url参数进行编码，编码格式使用当前request获取。2.然后设置有效期，通过flashMapTimeout参数配置。3.最后将flashMap添加到整体的List<flashmap>中并更新。</flashmap></p>
</blockquote>
<h4 id="1-2-SessionFlashMapManager"><a href="#1-2-SessionFlashMapManager" class="headerlink" title="1.2 SessionFlashMapManager"></a>1.2 SessionFlashMapManager</h4><pre><code>public class SessionFlashMapManager extends AbstractFlashMapManager {
    private static final String FLASH_MAPS_SESSION_ATTRIBUTE = SessionFlashMapManager.class.getName() + &quot;.FLASH_MAPS&quot;;

    public SessionFlashMapManager() {
    }

    @Nullable
    protected List&lt;FlashMap&gt; retrieveFlashMaps(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        return session != null ? (List)session.getAttribute(FLASH_MAPS_SESSION_ATTRIBUTE) : null;
    }

    protected void updateFlashMaps(List&lt;FlashMap&gt; flashMaps, HttpServletRequest request, HttpServletResponse response) {
        WebUtils.setSessionAttribute(request, FLASH_MAPS_SESSION_ATTRIBUTE, !flashMaps.isEmpty() ? flashMaps : null);
    }

    protected Object getFlashMapsMutex(HttpServletRequest request) {
        return WebUtils.getSessionMutex(request.getSession());
    }
}
</code></pre><h4 id="1-3-retrieveAndUpdate"><a href="#1-3-retrieveAndUpdate" class="headerlink" title="1.3 retrieveAndUpdate"></a>1.3 retrieveAndUpdate</h4><pre><code>public final FlashMap retrieveAndUpdate(HttpServletRequest request, HttpServletResponse response) {
     //从存储介质session中获取list&lt;FlashMap&gt;，模板方法，子类实现
    List&lt;FlashMap&gt; allFlashMaps = this.retrieveFlashMaps(request);
    if (CollectionUtils.isEmpty(allFlashMaps)) {
        return null;
    } else {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Retrieved FlashMap(s): &quot; + allFlashMaps);
        }
        //检查过期的flashMap，并将那他们设置到mapsToRemove
        List&lt;FlashMap&gt; mapsToRemove = this.getExpiredFlashMaps(allFlashMaps);
        //获取与当前request匹配的FlashMap，并设置到match中
        FlashMap match = this.getMatchingFlashMap(allFlashMaps, request);
        //如果有匹配的则将其添加到mapsToRemove，待下面删除
        if (match != null) {
            mapsToRemove.add(match);
        }
        //删除mapsToRemove中保存的变量
        if (!mapsToRemove.isEmpty()) {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&quot;Removing FlashMap(s): &quot; + mapsToRemove);
            }

            Object mutex = this.getFlashMapsMutex(request);
            if (mutex != null) {
                synchronized(mutex) {
                    allFlashMaps = this.retrieveFlashMaps(request);
                    if (allFlashMaps != null) {
                        allFlashMaps.removeAll(mapsToRemove);
                        this.updateFlashMaps(allFlashMaps, request, response);
                    }
                }
            } else {
                allFlashMaps.removeAll(mapsToRemove);
                this.updateFlashMaps(allFlashMaps, request, response);
            }
        }
        return match;
    }
}
</code></pre><blockquote>
<p>总结：上面的过程是：1.首先使用retrieveFlashMaps模板方法获取List<flashmap>。2.然后检查其中已经过期的FlashMap并保存，检查方法通过保存时设置的过期时间进行判断。3.然后调用getMatchingFlashMap()方法从获取的List<flashmap>中找出和当前request相匹配的FlashMap。4.最后将过期的和当前请求匹配的FlashMap从List<flashmap>中删除并更新到Session中，将与当前request匹配的返回。</flashmap></flashmap></flashmap></p>
</blockquote>
<h4 id="1-4-getMatchingFlashMap"><a href="#1-4-getMatchingFlashMap" class="headerlink" title="1.4 getMatchingFlashMap()"></a>1.4 getMatchingFlashMap()</h4><p>该方法是查找与当前request匹配的FlashMap。</p>
<pre><code>private FlashMap getMatchingFlashMap (List&lt;FlashMap&gt; allMaps, HttpServletRequest request) {
    List&lt;FlashMap&gt; result = new LinkedList&lt;FlashMap&gt;();
    for(FlashMap flashMap : allMaps){
        //1.调用isFlashMapForRequest()方法实际检查是否匹配，如果匹配则保存到临时变量result
        if(isFlashMapForRequest(flashMap, request)){
            result.add(flashMap);
        }
    }

    if(!result.isEmpty()){
        Collections.sort(result);
        if(logger.isDebugEnable){
            logger.debug(&quot;&quot;);
        }
        return result.get(0);
    }
    return null;
}
</code></pre><h4 id="1-5-isFlashMapForRequest"><a href="#1-5-isFlashMapForRequest" class="headerlink" title="1.5 isFlashMapForRequest()"></a>1.5 isFlashMapForRequest()</h4><pre><code>protected boolean isFlashMapForRequest(FlashMap flashMap, HttpServletRequest request) {
    //检查目标路径，如果flashMap中保存的和request的不匹配，返回false
    String expectedPath = flash.getTargetRequestpath();
    if(expectedPath != null){
        String requestUri = getUrlPathHelper().getOriginatingRequestUri(request);
        if(!requestUri.equals(expectedPath) &amp;&amp; !requestUri.equals(expectedPath + &quot;/&quot;)){
            return false;
        }
    }

    //检查参数，如果在FlashMap中保存的参数在request中没有则返回false
    MultiValueMap&lt;String, String&gt; targetParams = flashMap.getTargetRequestParams();
    for(String expectedName : targetParams.keySet()){
        if(!ObjectUtils.containsElement(request.getParameterValues(expectedName), expectedValue)){
            return false;
        }
    }

    return true;
}
</code></pre><blockquote>
<p>总结：这里的检查方法是通过FlashMap中保存的目标地址和url参数与request进行比较的。</p>
</blockquote>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC22%E7%AB%A0%20%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第22章-异步请求"><a href="#第22章-异步请求" class="headerlink" title="第22章 异步请求"></a>第22章 异步请求</h1><p>在Servlet 3.0中新增对异步请求的支持。异步请求表示在处理比较耗时的业务时先将request返回，然后另起线程处理耗时的业务，处理完之后再返回给用户。异步请求的核心原理主要分为：轮询和长连接。</p>
<pre><code>1.轮询：定时自动发起请求检查有没有需要返回的数据
2.长连接：客户端发起请求，服务端处理并返回后不结束连接，这样就能够在后面再次返回给客户端数据。
</code></pre><blockquote>
<p>提示：Servlet对异步请求的支持是采用长连接的方式，异步请求在原始的请求返回的时候没有关闭连接，关闭的只是处理请求的那个线程，只有在异步请求全部处理完之后才会关闭连接。</p>
</blockquote>
<blockquote>
<p>扩展：浏览器将请求交给代理对象 XMLHttpRequest(浏览器内置此对象)，由代理对象向服务器发起请求，接收和解析服务器响应的数据，并将数据更新到浏览器指定的控件上。从而实现页面数据的局部更新。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/undefined/%E7%AC%AC2%E7%AB%A0%20Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第二章-Java并发机制的底层实现原理"><a href="#第二章-Java并发机制的底层实现原理" class="headerlink" title="第二章 Java并发机制的底层实现原理"></a>第二章 Java并发机制的底层实现原理</h2><h3 id="2-1-volatile的应用"><a href="#2-1-volatile的应用" class="headerlink" title="2.1 volatile的应用"></a>2.1 volatile的应用</h3><p>在多线程并发编程中 synchronize 和 volatile 扮演重要角色。 volatile 是轻量级的 synchronize ，在多处理器中保证共享变量的可见性。</p>
<p>如果使用 volatile 变量修饰符使用恰当，比 synchronize 的使用和执行成本更低。因为它不会引起线程上下文的切换和调度。</p>
<h4 id="2-2-1-volatile定义与实现原理"><a href="#2-2-1-volatile定义与实现原理" class="headerlink" title="2.2.1 volatile定义与实现原理"></a>2.2.1 volatile定义与实现原理</h4><p>定义：Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致地更新，线程应该确保通过排它锁单独获取这个变量。</p>
<pre><code>CPU操作术语：

    1.内存屏障：是一组处理器指令，用于实现对内存操作的顺序限制。

    ...
</code></pre><h3 id="2-2-synchronize的实现原理和应用"><a href="#2-2-synchronize的实现原理和应用" class="headerlink" title="2.2 synchronize的实现原理和应用"></a>2.2 synchronize的实现原理和应用</h3><p>synchronize实现同步的基础：Java中每一个对象都可以作为锁。</p>
<pre><code>1.对于普通同步方法，锁是当前实例对象。

2.对于静态同步方法，锁是当前静态类的Class对象。

3.对于同步方法块，锁是synchronize括号里配置的对象。
</code></pre><blockquote>
<p>提示：在JVM中，代码块同步是使用monitorenter和monitorexit指令实现的。</p>
</blockquote>
<h4 id="2-2-1-Java对象头"><a href="#2-2-1-Java对象头" class="headerlink" title="2.2.1 Java对象头"></a>2.2.1 Java对象头</h4><p>synchronize 用的锁是存在Java对象头里。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果是非数组类型，则用2字宽存储对象头。</p>
<h4 id="2-2-2-锁的升级和对比"><a href="#2-2-2-锁的升级和对比" class="headerlink" title="2.2.2 锁的升级和对比"></a>2.2.2 锁的升级和对比</h4><p>Java 1.6中，锁有四种状态，级别从低到高是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</p>
<blockquote>
<p>注意：锁可以升级，不可以降级。如：偏向级锁升级成轻量级锁之后不能降为偏向锁。</p>
</blockquote>
<p><strong>1.偏向锁</strong><br></p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试下对象头的mark word里是否存有指向当前线程的偏向锁。</p>
<p><strong>2.轻量级锁</strong><br></p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中。然后尝试使用CAS将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其它现车个竞争锁。</p>
<p><strong>3.锁之间的对比</strong><br></p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的开销，和执行非同步方法相比仅存在纳秒级差距</td>
<td>如果线程之间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，适用自旋会消耗CPU</td>
<td>追求响应时间同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
<h3 id="2-3-原子操作实现原理"><a href="#2-3-原子操作实现原理" class="headerlink" title="2.3 原子操作实现原理"></a>2.3 原子操作实现原理</h3><h4 id="2-3-3-Java实现原子操作"><a href="#2-3-3-Java实现原子操作" class="headerlink" title="2.3.3 Java实现原子操作"></a>2.3.3 Java实现原子操作</h4><p>在Java中通过锁和循环CAS的方式实现原子操作。</p>
<p><strong>1.使用CAS实现原子操作</strong><br></p>
<p>JVM中的CAS操作正是利用了处理器提供 CMPXCHG 指令实现的，自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<blockquote>
<p>提示：在Java 1.5以后，JDK的并发包提供一些类支持原子操作，如：AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新int值）、AtomicInteger（用原子方式更新Long值）。</p>
</blockquote>
<p><strong>2.CAS实现原子操作的三大问题</strong><br></p>
<pre><code>1.ABA问题：因为CAS需要操作值时，检查值有没有发生变化，如果没有则更新，但如果值原来是A，后变成B，后又变成A，那么使用CAS进行检查时发现它的值没有发生变化，实际上变化了。

    解决：ABA问题使用版本号解决，每次更新的时候将版本号加1。在Java 1.5之后，JDK的Atomic包提供一个类 AtomicStampedReferance 解决ABA问题。

2.循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM提供pause指令，那么效率会提升。

3.只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS来保证原子操作，但是对于多个共享变量时，这时候CAS无法保证操作的原子性，这时候可以用锁。或者将多个共享变量合并成一个共享变量来操作。
</code></pre><p><strong>3.使用锁机制来实现原子操作</strong><br></p>
<p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域。</p>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 深入分析Java IO的工作机制</title>
    <url>/undefined/%E7%AC%AC2%E7%AB%A0%20%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第二章-深入分析Java-IO的工作机制"><a href="#第二章-深入分析Java-IO的工作机制" class="headerlink" title="第二章 深入分析Java IO的工作机制"></a>第二章 深入分析Java IO的工作机制</h2><h3 id="2-1-Java-的I-O库的基本架构"><a href="#2-1-Java-的I-O库的基本架构" class="headerlink" title="2.1 Java 的I/O库的基本架构"></a>2.1 Java 的I/O库的基本架构</h3><p>IO问题是整个人机交互的核心问题，因为IO是机器获取和交换信息的重要渠道。Java的io类都在类java.io下，这些io类可以分为四组：</p>
<pre><code>传输数据的数据格式：

    1. 基于字节操作的IO接口：InputStream | OutputStream

    2. 基于字符操作的IO接口：Writer | Reader

传输数据的方式：

    3. 基于磁盘操作的IO接口：File

    4. 基于网络操作的IO接口：Socket
</code></pre><h4 id="2-1-1-基于字节的IO操作接口"><a href="#2-1-1-基于字节的IO操作接口" class="headerlink" title="2.1.1 基于字节的IO操作接口"></a>2.1.1 基于字节的IO操作接口</h4><pre><code>1. 操作数据的方式是可以组合使用的

    OutputStream out = new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream(new FileOutputStream(&quot;fileName&quot;))));

2. 流最终写到什么地方必须要指定，要么写到磁盘，要么写到网络中
</code></pre><h4 id="2-1-2-基于字符的IO操作接口"><a href="#2-1-2-基于字符的IO操作接口" class="headerlink" title="2.1.2 基于字符的IO操作接口"></a>2.1.2 基于字符的IO操作接口</h4><pre><code>1. write(char[] buf, int off, int len);

2. int read(char[] buf, int off, int len);
</code></pre><h4 id="2-1-3-字节与字符的转换接口"><a href="#2-1-3-字节与字符的转换接口" class="headerlink" title="2.1.3 字节与字符的转换接口"></a>2.1.3 字节与字符的转换接口</h4><p>数据持久化与网络传输都是以字节进行的，所以必须要有字符和字节之间的转换。</p>
<pre><code>1. InputStreamReader 字节到字符的转换桥梁，InputStream到Reader的过程需要指定编码字符集，否则采用默认编码，可能出现乱码。
</code></pre><h3 id="2-2-磁盘IO工作机制"><a href="#2-2-磁盘IO工作机制" class="headerlink" title="2.2 磁盘IO工作机制"></a>2.2 磁盘IO工作机制</h3><h4 id="2-2-1-几种访问文件的方式"><a href="#2-2-1-几种访问文件的方式" class="headerlink" title="2.2.1 几种访问文件的方式"></a>2.2.1 几种访问文件的方式</h4><p><strong>1.标准访问文件方式</strong><br></p>
<p><strong>2.直接IO方式</strong><br></p>
<p><strong>3.同步访问文件方式</strong><br></p>
<p>数据的写入和读取都是同步的，它与标准访问方式不一样的是，只有当数据被成功写到磁盘时才返回给应用程序成功标志。</p>
<p><strong>4.异步访问文件方式</strong><br></p>
<h4 id="2-2-2-Java访问磁盘文件"><a href="#2-2-2-Java访问磁盘文件" class="headerlink" title="2.2.2 Java访问磁盘文件"></a>2.2.2 Java访问磁盘文件</h4><h4 id="2-2-3-Java序列化"><a href="#2-2-3-Java序列化" class="headerlink" title="2.2.3 Java序列化"></a>2.2.3 Java序列化</h4><h3 id="2-3-网络IO工作机制"><a href="#2-3-网络IO工作机制" class="headerlink" title="2.3 网络IO工作机制"></a>2.3 网络IO工作机制</h3><h4 id="2-3-1-TCP状态转换"><a href="#2-3-1-TCP状态转换" class="headerlink" title="2.3.1 TCP状态转换"></a>2.3.1 TCP状态转换</h4><h4 id="2-3-5-数据传输"><a href="#2-3-5-数据传输" class="headerlink" title="2.3.5 数据传输"></a>2.3.5 数据传输</h4><p>当连接建立成功之后，服务端和客户端都会拥有一个socket实例，每个socket实例都有一个inputStream和outputStream，通过这两个对象来交换数据。</p>
<h3 id="2-4-NIO的工作方式"><a href="#2-4-NIO的工作方式" class="headerlink" title="2.4 NIO的工作方式"></a>2.4 NIO的工作方式</h3><h4 id="2-4-1-BIO的挑战"><a href="#2-4-1-BIO的挑战" class="headerlink" title="2.4.1 BIO的挑战"></a>2.4.1 BIO的挑战</h4><p>BIO（阻塞IO），不管是磁盘IO还是网络IO，数据在写入OutputStream或者从InputStream读取时都会可能阻塞，一旦阻塞，线程将会失去CPU使用权，这在当前的大规模访问量和有性能要求的情况下是不能被接受的。</p>
<h4 id="2-4-2-NIO的工作机制"><a href="#2-4-2-NIO的工作机制" class="headerlink" title="2.4.2 NIO的工作机制"></a>2.4.2 NIO的工作机制</h4><p>NIO的两个核心概念，Channel | Selector。</p>
<pre><code>1.Channel：channel要比socket更加具体，其可以体现为一种具体的交通工具。如：汽车或高铁。

2.Selector：其可以看做是一个车站的车站运行调度系统，将负责监控车辆的当前运行状态（在路上或者出站等）。可以轮询每个Channel的状态。

3. Buffer类：它比Stream更加具体，如果Channel是汽车的话，那么Buffer就是汽车上的具体座位，它始终是一个具体的概念。在Buffer中我们可以控制Buffer的容量、是否扩容以及如何扩容。
</code></pre><h4 id="2-4-3-Buffer的工作方式"><a href="#2-4-3-Buffer的工作方式" class="headerlink" title="2.4.3 Buffer的工作方式"></a>2.4.3 Buffer的工作方式</h4><p>在Selector检测到通信信道IO有数据传输时，通过select()取得SocketChannel，将数据读取或写入Buffer缓冲区。</p>
<p>Buffer可以简单的理解为一组基本数据类型的元素列表。</p>
<pre><code>1. capacity 缓冲区数组总长度

2. position 下一个要操作数据元素的位置

3. limit 缓冲区数组中不可操作的下一个元素位置

4. mark 记录当前position的前一个位置或默认是0
</code></pre><p>ByteBuffer.allocate(n)，创建长度n的数组缓冲区。</p>
<p>要将字节数据写入Channel通信信道，调用Buffer.flip()方法。</p>
<h4 id="2-4-4-NIO数据访问方式"><a href="#2-4-4-NIO数据访问方式" class="headerlink" title="2.4.4 NIO数据访问方式"></a>2.4.4 NIO数据访问方式</h4><p>NIO提供比传统文件方式访问的更好的方式。</p>
<pre><code>1. FileChannel.transferTo

2. FileChannel.transferFrom

上面两种方式与传统访问文件方式相比可以减少数据从内核到用户空间的复制。

3. FileChannel.map

上面的方式将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，这种方式省去数据从内核空间向用户空间复制的损耗。
</code></pre><blockquote>
<p>提示：NIO引入Channel | Buffer | Selector就是想将这些信息具体化，让我们有机会控制它们。</p>
</blockquote>
<h3 id="2-5-IO调优"><a href="#2-5-IO调优" class="headerlink" title="2.5 IO调优"></a>2.5 IO调优</h3><h4 id="2-5-1-磁盘IO优化"><a href="#2-5-1-磁盘IO优化" class="headerlink" title="2.5.1 磁盘IO优化"></a>2.5.1 磁盘IO优化</h4><pre><code>1. 性能检测
</code></pre><h3 id="2-6-设计模式之适配器模式"><a href="#2-6-设计模式之适配器模式" class="headerlink" title="2.6 设计模式之适配器模式"></a>2.6 设计模式之适配器模式</h3><p>适配器模式是将一个类的接口变换成客户端所能接受的另一种接口，从而使得两个接口不匹配而无法在一起工作的两个类能够在一起工作。如在项目中需要引用一些开源框架来一起工作的情况下需要引入适配器模式。</p>
<p>适配器模式的结构：</p>
<pre><code>1. Target 目标接口，所需要转换的所期待的接口

2. Adaptee 源角色，需要适配的接口

3. Adapter 适配器，将源接口适配成目标接口，继承源接口，实现目标接口
</code></pre><h4 id="2-6-2-Java-IO中适配器模式"><a href="#2-6-2-Java-IO中适配器模式" class="headerlink" title="2.6.2 Java IO中适配器模式"></a>2.6.2 Java IO中适配器模式</h4><p>适配器的作用是将一个接口适配到另一个接口，在Java IO类库中有很多这样的需求。如将字符串数据转变成字节数据保存到文件中，将字节数据转变成流数据等。</p>
<h3 id="2-7-设计模式之装饰器模式"><a href="#2-7-设计模式之装饰器模式" class="headerlink" title="2.7 设计模式之装饰器模式"></a>2.7 设计模式之装饰器模式</h3><p>装饰器模式的构建：</p>
<pre><code>1. Component 抽象组件角色，定义一组抽象的接口，规定被装饰器组件都有哪些功能。

2. ConcreteComponent 实现抽象组件的所有功能

3. Decorator 装饰器角色，持有一个Component对象实例的引用，定义一个与抽象组件一直的接口。

4. ConcreteDecorator 具体的装饰器实现者，负责实现装饰器角色定义的功能
</code></pre><h4 id="2-7-2-Java-IO-装饰器模式"><a href="#2-7-2-Java-IO-装饰器模式" class="headerlink" title="2.7.2 Java IO 装饰器模式"></a>2.7.2 Java IO 装饰器模式</h4><h3 id="2-8-适配器模式与装配器模式的区别"><a href="#2-8-适配器模式与装配器模式的区别" class="headerlink" title="2.8 适配器模式与装配器模式的区别"></a>2.8 适配器模式与装配器模式的区别</h3><p>适配器模式的意义在于将一个接口转变成另一个子接口。而装配器模式不是要改变被装饰对象的接口，而恰恰要保持原有的接口，但是增强原有对象的功能。或者改变原有对象的处理方式而提升性能。</p>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC4%E7%AB%A0%20Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第四章-Java并发编程基础"><a href="#第四章-Java并发编程基础" class="headerlink" title="第四章 Java并发编程基础"></a>第四章 Java并发编程基础</h2><p>[TOC]</p>
<h3 id="4-1-线程"><a href="#4-1-线程" class="headerlink" title="4.1 线程"></a>4.1 线程</h3><blockquote>
<p>提示：在一个Java程序中，Java程序运行不仅是main()方法运行，而是main线程和多个其它线程的同时运行。</p>
</blockquote>
<h4 id="4-1-3-线程优先级"><a href="#4-1-3-线程优先级" class="headerlink" title="4.1.3 线程优先级"></a>4.1.3 线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待下一次分配。</p>
<blockquote>
<p>提示：线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不理会Java线程对于优先级的设定。</p>
</blockquote>
<h4 id="4-1-4-线程的状态"><a href="#4-1-4-线程的状态" class="headerlink" title="4.1.4 线程的状态"></a>4.1.4 线程的状态</h4><pre><code>1.NEW 初始状态，线程被创建，但是还没有调用start()方法。

2.RUNNABLE 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统称作：运行中

3.BLOCKED 阻塞状态，表示线程阻塞干预

4.WAITING 等待状态，表示线程进入进入等待状态，需要等待其它线程做出一些动作（通知或中断）

5.TIME_WAITING 超时等待，不同于WAITING，是可以在指定时间自行返回的

6.TERMINATED 终止状态，表示该线程已经执行完毕
</code></pre><blockquote>
<p>提示：线程被创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态。当线程调用同步方法时，在没有获取到锁的状态下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：阻塞状态是线程阻塞在进入 synchronized 关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在 java.concurrent 包中的 Lock 接口的线程状态是等待状态，因为 java.concurrent 包中接口 Lock 对于阻塞的实现均使用了 LockSupport 类中的相关方法。</p>
</blockquote>
</blockquote>
<h4 id="4-1-5-Daemon-线程"><a href="#4-1-5-Daemon-线程" class="headerlink" title="4.1.5 Daemon 线程"></a>4.1.5 Daemon 线程</h4><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调用以及支持性工作。表示在一个Java虚拟机中 不存在非Daemon线程 的时候，Java虚拟机将会退出。</p>
<blockquote>
<p>提示：Daemon线程被用作支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
</blockquote>
</blockquote>
<h3 id="4-2-启动或终止线程"><a href="#4-2-启动或终止线程" class="headerlink" title="4.2 启动或终止线程"></a>4.2 启动或终止线程</h3><h4 id="4-2-1-构造线程"><a href="#4-2-1-构造线程" class="headerlink" title="4.2.1 构造线程"></a>4.2.1 构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如：线程所属线程组、线程优先级、是否是Daemon线程等信息。</p>
<h4 id="4-2-2-启动线程"><a href="#4-2-2-启动线程" class="headerlink" title="4.2.2 启动线程"></a>4.2.2 启动线程</h4><p>线程对象在初始化完成之后，调用start()方法可以启动这个线程。start()方法表示：当前线程同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<blockquote>
<p>提示：启动一个线程之前设置线程名称，在利用jstack分析程序或者进行问题排查可以方便一些。</p>
</blockquote>
<h4 id="4-2-3-中断"><a href="#4-2-3-中断" class="headerlink" title="4.2.3 中断"></a>4.2.3 中断</h4><h4 id="4-2-4-过期的-suspend-resume-stop"><a href="#4-2-4-过期的-suspend-resume-stop" class="headerlink" title="4.2.4 过期的 suspend() | resume() | stop()"></a>4.2.4 过期的 suspend() | resume() | stop()</h4><p>对线程做 暂停 恢复 停止 操作对应的API就是 suspend() | resume() | stop()。但是这些方法都是过期了的，是因为以suspend()方法为例，在调用后线程不会释放已经占有的资源（如锁），而是占用资源进入睡眠状态，容易引起死锁问题。</p>
<blockquote>
<p>提示：因为 suspend() | resume() | stop() 带来的副作用，而暂停和恢复操作可以用后面提到的等待/通知机制来替代。</p>
</blockquote>
<h4 id="4-2-5-安全终止线程"><a href="#4-2-5-安全终止线程" class="headerlink" title="4.2.5 安全终止线程"></a>4.2.5 安全终止线程</h4><p>通过标识位或者中断操作的方式能够使得线程在终止时有机会去清理资源，不是武断将线程停止，因此这种操作更加安全和优化。</p>
<h3 id="4-3-线程间通信"><a href="#4-3-线程间通信" class="headerlink" title="4.3 线程间通信"></a>4.3 线程间通信</h3><h4 id="4-3-1-volatile和synchronize关键字"><a href="#4-3-1-volatile和synchronize关键字" class="headerlink" title="4.3.1 volatile和synchronize关键字"></a>4.3.1 volatile和synchronize关键字</h4><p>关键字 volatile 可以用来修饰字段，就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<blockquote>
<p>提示：过多的使用volatile关键字会降低程序执行的效率。</p>
</blockquote>
<p>关键字synchronize可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或同步块中。保证线程对变量访问的可见性和排它性。</p>
<h4 id="4-3-2-等待-通知机制"><a href="#4-3-2-等待-通知机制" class="headerlink" title="4.3.2 等待/通知机制"></a>4.3.2 等待/通知机制</h4><p>等待/通知的相关方法是任意Java对象都具备的。因为这些方法被定义在所有对象的超类 java.lang.Object 上。</p>
<pre><code>1.notify() 通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁。

2.notifyAll() 通知所有等待在该对象上的线程。

3.wait() 调用该方法的线程进入 WAITING 状态

4.wait(long) 超时等待一段时间
</code></pre><p>通知/等待机制表示一个线程 A 调用该对象O的wait()方法进入等待状态，而另一个线程 B 调用了对象O的notify()或者notifyAll()方法，线程 A 收到通知后从对象O的wait()方法返回，进而执行后续操作。</p>
<h4 id="4-3-3-等待-通知的经典范式"><a href="#4-3-3-等待-通知的经典范式" class="headerlink" title="4.3.3 等待/通知的经典范式"></a>4.3.3 等待/通知的经典范式</h4><p>等待/通知的经典范式分为两部分：等待方（消费者）和通知方（生产者）。</p>
<ul>
<li><p>等待方遵循原则：</p>
<p>  1.获取对象的锁。</p>
<p>  2.如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p>
<p>  3.条件满足时执行对应的逻辑。</p>
</li>
<li><p>通知方遵循原则：</p>
<p>  1.获取对象的锁。</p>
<p>  2.改变条件。</p>
<p>  3.通知所有等待在对象上的线程。</p>
</li>
</ul>
<h4 id="4-3-4-管道输入-输出流"><a href="#4-3-4-管道输入-输出流" class="headerlink" title="4.3.4 管道输入/输出流"></a>4.3.4 管道输入/输出流</h4><p>管道输入/输出流和普通文件的输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输媒介是内存。</p>
<p>管道输入/输出流主要包括以下四种具体实现：</p>
<pre><code>1.PipedOutputStream

2.PipedInputStream

3.PipedWriter

4.PipedReader
</code></pre><blockquote>
<p>提示：对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
</blockquote>
<h4 id="4-3-5-Thread-join"><a href="#4-3-5-Thread-join" class="headerlink" title="4.3.5 Thread.join()"></a>4.3.5 Thread.join()</h4><p>join() 表示当前线程A等待thread线程终止之后才从thread.join()返回。</p>
<h4 id="4-3-6-ThreadLocal-的使用"><a href="#4-3-6-ThreadLocal-的使用" class="headerlink" title="4.3.6 ThreadLocal 的使用"></a>4.3.6 ThreadLocal 的使用</h4><p>ThreadLocal 线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。这个结构被附带在线程上，即一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
<h3 id="4-4-线程应用实例"><a href="#4-4-线程应用实例" class="headerlink" title="4.4 线程应用实例"></a>4.4 线程应用实例</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC4%E7%AB%A0%20Spring%20MVC/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第4章-Spring-MVC"><a href="#第4章-Spring-MVC" class="headerlink" title="第4章 Spring MVC"></a>第4章 Spring MVC</h2><p>[TOC]</p>
<h3 id="4-1-Spring-MVC-概述"><a href="#4-1-Spring-MVC-概述" class="headerlink" title="4.1 Spring MVC 概述"></a>4.1 Spring MVC 概述</h3><p><img src="https://upload-images.jianshu.io/upload_images/5376408-5d50c3491fd9aae2.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="MVC模式"></p>
<p>在我们使用Spring MVC的时候，需要我们在web.xml文件中配置DispatcherServlet，该DispatcherServerlet可以看做是一个前端控制器的具体实现，还需要在Bean定义中配置Web请求和Controller的对应关系，以及各种视图的展现方式。在具体使用Controller的时候，会看到ModelAndView数据的生成，还会看到将ModelAndView数据交给相应的View来进行呈现。</p>
<h3 id="4-2-Web环境中的Spring-MVC"><a href="#4-2-Web环境中的Spring-MVC" class="headerlink" title="4.2 Web环境中的Spring MVC"></a>4.2 Web环境中的Spring MVC</h3><p>Spring MVC 是建立在IoC容器基础上的，要了解SpringMVC，首先要了解 Spring IoC 是如何在Web环境中发挥作用的。</p>
<p>Spring IoC是个独立的模块，并不是直接在Web环境中发挥作用。如果我们需要在Web环境中使用IOC容器，需要为IOC设计一个启动过程，将ioc容器导入。在web容器启动过程中，将IoC导入，并在web容器中建立起来并初始化，这样才能建立起 Spring MVC 运行机制，从而响应web容器传递的HTTP请求。</p>
<p>我们通常在web.xml文件中可以得到通常的配置。</p>
<ol>
<li><p>首选是定义一个Servlet对象，它是Spring MVC的DispatcherServlet。该DispatcherServlet是MVC中最重要的一个类，起着分发请求的作用。</p>
</li>
<li><p>然后为这个DispatcherServlet定义了对应的URL映射，这些URL映射为这个Servlet指定了需要处理的HTTP请求。context-param参数的配置用来指定Spring IOC容器读取Bean定义的XML文件的路径，在这里，这个配置文件被定义为/WEB-INF/applicationContext.xml。</p>
</li>
<li><p>最后ContextLoaderListener被定义为一个监听器，该监听器是与Web服务器的生命周期相关联的，由ContextLoaderListener监听器负责完成IOC容器在Web环境中的启动工作。</p>
</li>
</ol>
<p>DispatcherServlet和ContextLoaderListener提供了在Web容器中对Spring的接口，这些接口与web容器耦合是通过 ServletContext 来实现的。</p>
<h3 id="4-3-上下文在Web容器中的启动"><a href="#4-3-上下文在Web容器中的启动" class="headerlink" title="4.3 上下文在Web容器中的启动"></a>4.3 上下文在Web容器中的启动</h3><h4 id="4-3-1-IOC容器启动的基本过程"><a href="#4-3-1-IOC容器启动的基本过程" class="headerlink" title="4.3.1 IOC容器启动的基本过程"></a>4.3.1 IOC容器启动的基本过程</h4><p>IoC容器启动过程就是建立上下文的过程，该上下文与ServletContext相伴而生，由ContextLoaderListener启动的上下文为根上下文。在根上下文的基础上，还有一个与Web MVC相关的上下文用来保存控制器（DispatcherServlet）需要的MVC对象，作为跟上下文的子上下文。</p>
<p>在web.xml中，已经配置了由Spring提供的实现了ServletContextListener接口的ContextLoaderListener，该监听器类为在Web容器中建立IoC容器提供服务。</p>
<p>在Web容器中，建立WebApplicationContext的过程，是在contextInitialized的接口实现中完成的。</p>
<p>具体的载入IOC容器的过程是由ContextLoaderListenser交由ContextLoader来完成的，而ContextLoader本身就是ContextLoaderListener的基类。</p>
<p>在ContextLoader中，完成两个IoC容器建立的基本过程，一个是在Web容器中建立起双亲IoC容器，另一个是生成相应的WebApplicationContext并将其初始化。</p>
<h4 id="4-3-2-Web容器中的上下文设计"><a href="#4-3-2-Web容器中的上下文设计" class="headerlink" title="4.3.2 Web容器中的上下文设计"></a>4.3.2 Web容器中的上下文设计</h4><p>在启动过程中，Spring使用默认的XmlWebApplicationContext 实现作为IoC容器。</p>
<h4 id="4-3-3-ContextLoader的设计与实现"><a href="#4-3-3-ContextLoader的设计与实现" class="headerlink" title="4.3.3 ContextLoader的设计与实现"></a>4.3.3 ContextLoader的设计与实现</h4><p>对于Spring承载的Web应用而言，可以指定在Web应用程序启动时载人IoC容器(或者称为WebAppl icationContext)。这个功能是由ContextLoaderListener这样的类来完成的，它是在Web容器中配置的监听器。这个ContextLoaderListener通过使用ContextLoader来完成实际的WebApplicationContext，也就是IoC容器的初始化工作。这个ContextLoader就像Spring应用程序在Web容器中的启动器。这个启动过程是在Web容器中发生的，所以需要根据Web容器部署的要求来定义ContextLoader。</p>
<p>在初始化这个上下文以后，该上下文会被存储到SevletContext中，这样就建立了一个全局的关于整个应用的上下文。同时，在启动Spring MVC时.我们还会看到这个上下文被以后的DispatcherServlet在进行自己持有的上下文的初始化时，设置为DispatcherServlet自带的上下文的双亲上下文。</p>
<h3 id="4-4-Spring-MVC-的设计与实现"><a href="#4-4-Spring-MVC-的设计与实现" class="headerlink" title="4.4 Spring MVC 的设计与实现"></a>4.4 Spring MVC 的设计与实现</h3><h4 id="4-4-1-Spring-MVC的应用场景"><a href="#4-4-1-Spring-MVC的应用场景" class="headerlink" title="4.4.1 Spring MVC的应用场景"></a>4.4.1 Spring MVC的应用场景</h4><p>在web.xml中，除了需要配置ContextLoaderListener之外，还需要配置DispatcherServlet。建立Spring的上下文体系并初始化。</p>
<p>在完成对ContextLoaderListener的初始化以后，Web容器开始初始化DispatcherServlet，这个初始化的启动与在web.xml中对载入次序的定义有关。</p>
<p>DispatcherServiet会建立自己的上下文来持有 Spring MVC 的 Bean 对象，在建立这个自己持有的Ioc容器时，会从ServletContext中得到根上下文作为DispatcherServlet持有上下文的双亲上下文。有了这个根上下文，再对自己持有的上下文进行初始化，最后把自己持有的这个上下文保存到ServletContext（Web容器的上下文）中，供以后检索和使用。</p>
<h4 id="4-4-2-Spring-MVC设计概览"><a href="#4-4-2-Spring-MVC设计概览" class="headerlink" title="4.4.2 Spring MVC设计概览"></a>4.4.2 Spring MVC设计概览</h4><p><img src="https://upload-images.jianshu.io/upload_images/5376408-ea1f3f0ee11892ce.png?imageMogr2/auto-orient/strip|imageView2/2/w/585/format/webp" alt="DispatcherServlet的处理过程"></p>
<p>DispatcherServiet的工作大致可以分为两个部分：</p>
<ol>
<li>由initServletBean()启动，通过initWebAppIicationContext()方法最终调用DispatcherServlet的initStrategies方法。在这个方法里，DispatcherServlet对MVC模块的其他部分进行了初始化，比如handlerMapping, ViewResolver等。</li>
<li>对HTTP请求进行响应，作为一个Serviet，Web容器会调用Servlet的doGet()和doPost()方法，在经过FrameworkServlet的processRequest()简单处理后，会调用DispatcherServlet的doService()方法，在这个方法调用中封装了doDispatch()，这个doDispatch()是Dispatcher实现MVC模式的主要部分。</li>
</ol>
<h4 id="4-4-3-DispatcherServlet的启动和初始化"><a href="#4-4-3-DispatcherServlet的启动和初始化" class="headerlink" title="4.4.3 DispatcherServlet的启动和初始化"></a>4.4.3 DispatcherServlet的启动和初始化</h4><h4 id="4-4-4-MVC处理HTTP分发请求"><a href="#4-4-4-MVC处理HTTP分发请求" class="headerlink" title="4.4.4 MVC处理HTTP分发请求"></a>4.4.4 MVC处理HTTP分发请求</h4><p>1.HandlerMapping的配置和设计原理</p>
<p>在初始化完成时，在上下文环境中已定义的所有HandlerMapping都已经被加载了，这些加载的handlerMappings被放在一个List中并排序，存储着HTTP请求对应的映射数据。这个List中的每一个元素都对应着一个具体handlerMapping的配置，一般每一个handlerMapping可以持有一系列从URL请求到Controller的映射，而Spring MVC 提供了一系列的HandlerMapping实现。</p>
<p>2.使用HandlerMapping完成请求的映射处理</p>
<p>通过SimpleUrlHandlerMapping的实现来分析HandlerMapping的接口方法getHandler，该方法会根据初始化时得到的映射关系来生成DispatcherServlet需要的HandlerExecutionChain，也就是说，这个getHandler方法是实际使用HandlerMapping完成请求的映射处理的地方。</p>
<p>获得handler的具体过程在getHandlerInternal方法中实现，这个方法接受HTTP请求作为参数，它的实现在AbstractHandlerMapping的子类AbstractUrlHandlerMapping中，这个实现过程包括从HTTP请求中得到URL，并根据URL到urlMapping中获得handler。</p>
<p>经过这一系列对HTTP请求进行解析和匹配handler的过程，得到了与请求对应的handler处理器。在返回的handler中，已经完成了在HandlerExecutionChain中的封装工作，为handler对HTTP请求的响应做好了准备。</p>
<p>接下来就是解决请求如何实现分发的问题，从而得到对应的handler。</p>
<p>3.Spring MVC对HTTP请求的分发处理</p>
<h3 id="4-5-Spring-MVC-视图的呈现"><a href="#4-5-Spring-MVC-视图的呈现" class="headerlink" title="4.5 Spring MVC 视图的呈现"></a>4.5 Spring MVC 视图的呈现</h3><h4 id="4-5-1-DispatcherServlet视图呈现的设计"><a href="#4-5-1-DispatcherServlet视图呈现的设计" class="headerlink" title="4.5.1 DispatcherServlet视图呈现的设计"></a>4.5.1 DispatcherServlet视图呈现的设计</h4>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC5%E7%AB%A0%20Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第五章-Java中的锁"><a href="#第五章-Java中的锁" class="headerlink" title="第五章 Java中的锁"></a>第五章 Java中的锁</h2><p>[TOC]</p>
<h3 id="5-1-Lock接口"><a href="#5-1-Lock接口" class="headerlink" title="5.1 Lock接口"></a>5.1 Lock接口</h3><p>Java SE 1.5 之后，在并发包中新增 Lock 接口用来实现锁功能。它提供了与synchronize关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<blockquote>
<p>提示：使用synchronize关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取后释放。这种方式简化了同步的管理，但是扩展性没有显式的锁获取和释放好。</p>
</blockquote>
<blockquote>
<p>注意：不要将获取锁的过程写在try块中，如果在获取锁（自定义锁的实现）时发生异常，异常抛出的同时，也会导致锁的释放。</p>
</blockquote>
<p>Lock接口提供的 synchronize 关键字不具备的特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>尝试非阻塞地获取锁</td>
<td>当前线程尝试获取锁，如果这一时刻锁没有被其它线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁</td>
<td>与synchronize不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回</td>
</tr>
</tbody>
</table>
<p>Lock是一个接口，它定义了锁获取和释放的基本操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void lock()</td>
<td>获取锁</td>
</tr>
<tr>
<td>void lockInterruptibly() throws InterruptedException</td>
<td>可中断获取锁</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试非阻塞的获取锁</td>
</tr>
<tr>
<td>boolean tryLock(long time, TimeUtil unit) throws InterruptedException</td>
<td>超时的获取锁，当前线程在以下三种情况会返回：1.当前线程在超时时间内获得了锁。2.当前线程在超时时间内被终端。3.超时时间结束，返回false。</td>
</tr>
<tr>
<td>void unlock</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition</td>
<td>获取等待通知组件</td>
</tr>
</tbody>
</table>
<h3 id="5-2-队列同步器"><a href="#5-2-队列同步器" class="headerlink" title="5.2 队列同步器"></a>5.2 队列同步器</h3><p>队列同步器AbstractQueuedSynchronize（AQS），是用来构建锁或者其它同步组件的基础框架，其使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器的设计基于模板方法模式，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<p>重写同步器指定的方法时，需要使用同步器提供的三个方法访问或修改：</p>
<pre><code>1.getState() 获取当前同步状态

2.setState() 设置当前同步状态

3.compareAndSetState(int expect, int update) 使用CAS设置当前状态，该方法能够保证状态设置的原子性
</code></pre><h4 id="5-2-2-队列同步器的实现分析"><a href="#5-2-2-队列同步器的实现分析" class="headerlink" title="5.2.2 队列同步器的实现分析"></a>5.2.2 队列同步器的实现分析</h4><p>1.同步队列</p>
<h3 id="5-3-重入锁"><a href="#5-3-重入锁" class="headerlink" title="5.3 重入锁"></a>5.3 重入锁</h3><p>重入锁 ReentrantLock，支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁。该锁还支持获取锁时的公平和非公平性选择。</p>
<blockquote>
<p>提示：ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
</blockquote>
<p>公平性问题：公平性的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是有顺序的。ReentrantLock 提供了一个构造函数，能够控制锁是否是公平。</p>
<blockquote>
<p>提示：公平的锁机制往往没有非公平的效率高，但是并不是任何场景都是以TPS作为唯一的标准，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>
</blockquote>
<h4 id="5-3-1-实现重进入"><a href="#5-3-1-实现重进入" class="headerlink" title="5.3.1 实现重进入"></a>5.3.1 实现重进入</h4><p>重进入表示任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞，该特性的实现需要解决的问题：</p>
<pre><code>1.线程再次获取锁：锁需要去识别获取锁的线程是否是当前占据锁的线程。如果是则再次成功获取。

2.锁的最终释放：线程重复n次获取该锁，随后在第n次释放该锁后，其它线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，锁被释放时，计数自减。当计数为0时表示锁已经成功释放。
</code></pre><blockquote>
<p>提示：</p>
</blockquote>
<h4 id="5-3-2-公平与非公平获取锁的区别"><a href="#5-3-2-公平与非公平获取锁的区别" class="headerlink" title="5.3.2 公平与非公平获取锁的区别"></a>5.3.2 公平与非公平获取锁的区别</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。</p>
<blockquote>
<p>总结：公平性锁保证了锁的获取按照FIFO原则，而代价是<code>进行大量的线程切换</code>。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
</blockquote>
<h4 id="5-3-3-重入锁的方法"><a href="#5-3-3-重入锁的方法" class="headerlink" title="5.3.3 重入锁的方法"></a>5.3.3 重入锁的方法</h4><pre><code>1. lock() 获得锁，如果锁已经被占用则等待

2. lockInterruptibly() 获得锁，但优先响应中断

3. tryLock() 尝试获得锁，如果成功则返回true，否则返回false，该方法不等待，立即返回

4. tryLock(long time, TimeUnit unit) 在给定时间内尝试获得锁

5. unlock() 释放锁
</code></pre><h3 id="5-4-读写锁"><a href="#5-4-读写锁" class="headerlink" title="5.4 读写锁"></a>5.4 读写锁</h3><p>之前的锁（Mutex | ReentrantLock）基本都是<code>排它锁</code>，这些锁在<code>同一时刻只允许一个线程进行访问</code>，而<code>读写锁</code>在同一时刻可以允许多个<code>读线程</code>进行访问，但是在<code>写线程</code>访问时，所有读线程和其它线程均被阻塞。</p>
<blockquote>
<p>提示：读写锁维护了一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发相比一般的排它锁有了很高提升。</p>
</blockquote>
<p>Java并发包中提供的读写锁实现是：ReentrantReadWriteLock，其提供特性为：</p>
<pre><code>特性 | 说明
--- | ---
公平性选择 | 支持非公平和公平的锁获取方式，吞吐量还是非公平由于公平
重进入 | 该锁支持重进入
锁降级 | 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁
</code></pre><h4 id="5-4-1-读写锁实例"><a href="#5-4-1-读写锁实例" class="headerlink" title="5.4.1 读写锁实例"></a>5.4.1 读写锁实例</h4><h3 id="5-6-Condition接口"><a href="#5-6-Condition接口" class="headerlink" title="5.6 Condition接口"></a>5.6 Condition接口</h3><p>任意一个Java对象都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait() | wait(long timeout) | notify() | notifyAll()方法，这些方法与synchronize同步关键字配合，可以实现等待/通知模式。</p>
<p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是两者再使用方式以及功能特性上是有差别的。</p>
<p>Condition的方法和描述：</p>
<pre><code>方法名称 | 描述
--- | ---
await() | 当前线程进入等待状态直到被通知或中断
signal() | 唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁
</code></pre><p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要<code>提前获取到Condition对象关联的锁</code>。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说就是<code>Condition是依赖Lock对象</code>的。</p>
<blockquote>
<p>提示：Condition在调用方法前需要获取锁。</p>
</blockquote>
<pre><code>//1. 在调用方法之前获取锁
Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();

public void conditionWait() throws InterruptedException {
    lock.lock();
    try {
        condition.await();
    }finally {
        lock.unlock();
    }
}

public void conditionSignal(){
    lock.lock();
    try {
        condition.signal();
    }finally {
        lock.unlock();
    }
}
</code></pre><p>一般都会将Condition对象作为成员变量，在调用成员变量之后，当前线程会释放锁并在此等待，而其它线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<blockquote>
<p>提示：获取一个Condition必须通过Lock的newCondition()方法。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现空位。</p>
</blockquote>
</blockquote>
<h4 id="5-6-1-Condition接口提供基本方法"><a href="#5-6-1-Condition接口提供基本方法" class="headerlink" title="5.6.1 Condition接口提供基本方法"></a>5.6.1 Condition接口提供基本方法</h4><pre><code>1. void await(); 

2. void awaitUninterruptibly();

3. awaitNanos(long nanosTimeout);

4. boolean await(long time, TimeUnit unit);

5. boolean awaitUnit(Date deadline);

6. void signal();

7. void signalAll();
</code></pre><h4 id="5-6-2-Condition实现分析"><a href="#5-6-2-Condition实现分析" class="headerlink" title="5.6.2 Condition实现分析"></a>5.6.2 Condition实现分析</h4><p>每个Condition对象都包含着一个队列（等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<p><strong>1.等待队列</strong><br></p>
<p>等待队列是一个FIFO的队列，在队列中的每个节点都包含一个线程引用，该线程就是在Condition对象上等待的线程。如果一个线程调用了 Condition.await() 方法，那么该线程将会被释放锁、构造成节点加入等待队列并进入等待状态。</p>
<p><strong>2.等待</strong><br></p>
<p>调用Condition的await()方法（或者以await()方法开头的方法）会使当前线程进入等待队列并释放锁，同时线程状态变成等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p><strong>3.通知</strong><br></p>
<p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒结点之前，会将节点移到同步队列中。</p>
<h3 id="5-6-锁"><a href="#5-6-锁" class="headerlink" title="5.6 锁"></a>5.6 锁</h3><h4 id="5-6-1-无锁"><a href="#5-6-1-无锁" class="headerlink" title="5.6.1 无锁"></a>5.6.1 无锁</h4><p>在并发控制层面，锁是一种悲观策略。无锁是一种乐观策略，所有线程都能够在不停顿的状态下持续执行，在遇到冲突的时候使用一种比较交换的策略（CAS）鉴别线程冲突。</p>
<h5 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h5><p>CAS算法过程，包含三个参数 CAS(V,E,N)，V表示要更新的变量，E表示预期值，N表示新值。仅仅当V==E时，才会将V设置为N，如果E!=E，说明其它线程已经做了更新，当前线程什么都不用做。最后CAS返回当前V的真实值。</p>
<p>CAS总是持乐观态度，在多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅仅是告知失败，并且允许再次尝试或放弃操作。</p>
<h5 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h5><p>AtomicInteger直接使用CAS操作的线程安全的类型，可以将其看做一个整数。与Integer不一样的是它是可变的，并且线程安全。对其各种修改或其它操作都是CAS指令进行的。</p>
<h5 id="3-Java中的指针-Unsafe类"><a href="#3-Java中的指针-Unsafe类" class="headerlink" title="3. Java中的指针 Unsafe类"></a>3. Java中的指针 Unsafe类</h5><p>Unsafe类是 sun.misc.Unsafe类型。该类封装了一些不安全的操作（指针是不安全的），所以该类封装了一些类似指针的操作。</p>
<p>Unsafe类提供的一些方法</p>
<pre><code>1. public native int getInt(Object o, long offset);//获取给定对象偏移量上的int值

2. public native void putInt(Object o, long offset, int x);//设置给定对象偏移量上的int值

3. public native long objectFieldOffset(Field f);

...
</code></pre><h5 id="4-无锁对象的引用-AtomicReference"><a href="#4-无锁对象的引用-AtomicReference" class="headerlink" title="4. 无锁对象的引用 AtomicReference"></a>4. 无锁对象的引用 AtomicReference</h5><p>该类型是对普通的对象的引用。保证我们在修改对象引用时线程安全性，</p>
<h5 id="5-带有时间戳的对象引用-AtomicStampedReference"><a href="#5-带有时间戳的对象引用-AtomicStampedReference" class="headerlink" title="5. 带有时间戳的对象引用 AtomicStampedReference"></a>5. 带有时间戳的对象引用 AtomicStampedReference</h5><p>在其内部不仅维护了对象值，还维护了一个时间戳，当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须更新时间戳。</p>
<h5 id="6-数组无锁-AtomicIntegerArray"><a href="#6-数组无锁-AtomicIntegerArray" class="headerlink" title="6. 数组无锁 AtomicIntegerArray"></a>6. 数组无锁 AtomicIntegerArray</h5><p>原子数组包括：AtomicIntegerArray | AtomicLongArray | AtomicReferenceArray。</p>
<p>AtomicIntegerArray本质上是对int[]类型的封装，使用Unsafe类通过CAS的方式控制int[]在多线程下的安全性。</p>
<h5 id="7-普通变量享受原子操作-AtomicIntegerFieldUpdater"><a href="#7-普通变量享受原子操作-AtomicIntegerFieldUpdater" class="headerlink" title="7. 普通变量享受原子操作 AtomicIntegerFieldUpdater"></a>7. 普通变量享受原子操作 AtomicIntegerFieldUpdater</h5><p>AtomicIntegerFieldUpdater 在不改动或极少改动原有程序的基础上让普通的变量享受CAS操作带来的线程安全性。</p>
<p>根据数据类型不同，Updater有三种：AtomicIntegerFieldUpdater | AtomicLongFieldUpdater | AtomicReferenceFieldUpdater。</p>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>Updater只能修改它可见范围内的变量，因为Updater使用反射得到这个变量。如果变量不可见，就会出错。如：score声明为private。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="2">
<li>为了确保变量被正确的读写，其必须是volatile类型的。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="3">
<li>由于CAS操作会通过对象实例中的偏移量直接进行复制，所以它不支持static字段。</li>
</ol>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC5%E7%AB%A0%20%E6%B7%B1%E5%85%A5class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第5章-深入class文件结构"><a href="#第5章-深入class文件结构" class="headerlink" title="第5章 深入class文件结构"></a>第5章 深入class文件结构</h2><p>[toc]</p>
<h3 id="5-1-JVM指令集简介"><a href="#5-1-JVM指令集简介" class="headerlink" title="5.1 JVM指令集简介"></a>5.1 JVM指令集简介</h3><h4 id="5-1-1-类相关的指令"><a href="#5-1-1-类相关的指令" class="headerlink" title="5.1.1 类相关的指令"></a>5.1.1 类相关的指令</h4><pre><code>.source 表示该代码的源文件

.class 表示这是一个类且公有的类名

.super 表示该类的父类
</code></pre><h4 id="5-1-2-方法的定义"><a href="#5-1-2-方法的定义" class="headerlink" title="5.1.2 方法的定义"></a>5.1.2 方法的定义</h4><pre><code>.method public &lt;init&gt;() V 表示该方法是公有的，没有参数，返回值类型是V（void），&lt;init&gt;表示构造函数。
</code></pre><h3 id="5-2-class文件头的表示形式"><a href="#5-2-class文件头的表示形式" class="headerlink" title="5.2 class文件头的表示形式"></a>5.2 class文件头的表示形式</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC6%E7%AB%A0%20Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第六章-Java并发容器和框架"><a href="#第六章-Java并发容器和框架" class="headerlink" title="第六章 Java并发容器和框架"></a>第六章 Java并发容器和框架</h2><p>[TOC]</p>
<h3 id="6-1-ConcurrentHashMap的实现原理和使用"><a href="#6-1-ConcurrentHashMap的实现原理和使用" class="headerlink" title="6.1 ConcurrentHashMap的实现原理和使用"></a>6.1 ConcurrentHashMap的实现原理和使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h4 id="6-1-1-为何使用ConcurrentHashMap"><a href="#6-1-1-为何使用ConcurrentHashMap" class="headerlink" title="6.1.1 为何使用ConcurrentHashMap"></a>6.1.1 为何使用ConcurrentHashMap</h4><p>在并发编程中使用HashMap可能会导致死循环，而使用线程安全的HashTable效率非常低下，基于上面两个原因，所以有了ConcurrentHashMap。</p>
<p><strong>1.线程不安全的HashMap</strong><br></p>
<p>多线程环境下，使用HashMap进行put操作会导致死循环，导致CPU利用率接近1。</p>
<p><strong>2.效率低下的HashTable</strong><br></p>
<p>HashTable容器使用synchronize来保证线程安全，但是在竞争激励的情况下HashTable效率低下。当一个线程访问HashTable的同步方法，其它线程访问将会进入阻塞或者是轮询状态。</p>
<p><strong>3.ConcurrentHashMap的锁分段技术可有效提升并发访问率</strong><br></p>
<blockquote>
<p>提示：HashTable在并发环境下表现效率低下的原因是因为所有访问HashTable的线程都必须要竞争同一把锁，<code>如果容器中存在多把锁，每一把锁用于锁定容器中的一部分数据</code>，那么多线程访问容器里不同数据段的数据时，线程间就不存在锁竞争（锁分段技术）。</p>
</blockquote>
<blockquote>
<blockquote>
<p>锁分段技术：将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其它段的数据也能被其它线程访问。</p>
</blockquote>
</blockquote>
<h4 id="6-1-2-ConcurrentHashMap的结构"><a href="#6-1-2-ConcurrentHashMap的结构" class="headerlink" title="6.1.2 ConcurrentHashMap的结构"></a>6.1.2 ConcurrentHashMap的结构</h4><p>ConcurrentHashMap是由 Segment数组结构 和 HashEntry数组结构 组成。Segment数组结构 是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色。HashEntry 则用于存储键值数据。</p>
<p>一个ConcurrentHashMap里包含一个 Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。</p>
<h4 id="6-1-3-ConcurrentHashMap初始化"><a href="#6-1-3-ConcurrentHashMap初始化" class="headerlink" title="6.1.3 ConcurrentHashMap初始化"></a>6.1.3 ConcurrentHashMap初始化</h4><p>ConcurrentHashMap初始化方法是通过 initialCapacity loadFactor concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentshift、段掩码segmentMask和每个segment里的HashEntry数组实现。</p>
<h4 id="6-1-4-定位Segment"><a href="#6-1-4-定位Segment" class="headerlink" title="6.1.4 定位Segment"></a>6.1.4 定位Segment</h4><p>因为ConcurrentHashMap是通过分段锁Segment来保护不同段的数据，那么在<code>插入和获取元素</code>的时候，必须先通过散列算法定位到Segment。</p>
<h4 id="6-1-5-ConcurrentHashMap的操作"><a href="#6-1-5-ConcurrentHashMap的操作" class="headerlink" title="6.1.5 ConcurrentHashMap的操作"></a>6.1.5 ConcurrentHashMap的操作</h4><p><strong>1.get操作</strong><br></p>
<p>Segment的get操作非常高效和简单。先通过一次<code>再散列</code>，然后使用<code>这个散列值</code>通过散列运算定位到Segment，再通过散列算法定位到元素。</p>
<p><strong>2.put操作</strong><br></p>
<p>由于put方法需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。</p>
<p><strong>3.size操作</strong><br></p>
<p>如果需要统计整个ConcurrentHashMap中元素的大小，需要统计所有Segment里元素的大小后求和。</p>
<h3 id="6-2-ConcurrentLinkedQueue"><a href="#6-2-ConcurrentLinkedQueue" class="headerlink" title="6.2 ConcurrentLinkedQueue"></a>6.2 ConcurrentLinkedQueue</h3><p>在并发编程环境下，需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：1.使用阻塞算法。2.使用非阻塞算法。</p>
<pre><code>1.使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或者两把锁。

2.非阻塞实现方式则可以使用循环CAS的方式来实现。
</code></pre><p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素的时候，它会添加到队列的尾部。当获取一个元素时，会返回队列的头部。采用CAS算法实现。</p>
<h4 id="6-2-1-ConcurrentLinkedQueue的结构"><a href="#6-2-1-ConcurrentLinkedQueue的结构" class="headerlink" title="6.2.1 ConcurrentLinkedQueue的结构"></a>6.2.1 ConcurrentLinkedQueue的结构</h4><p>ConcurrentLinkedQueue 由head节点和tail节点组成，每个节点Node由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过next关联起来，从而组成一张链表结构的队列。</p>
<h4 id="6-2-2-入队列"><a href="#6-2-2-入队列" class="headerlink" title="6.2.2 入队列"></a>6.2.2 入队列</h4><p>入队列就是将入队节点添加到队列的尾部。</p>
<h4 id="6-2-3-出队列"><a href="#6-2-3-出队列" class="headerlink" title="6.2.3 出队列"></a>6.2.3 出队列</h4><p>出队列就是从队列中返回一个结点元素，并清空该节点对元素的引用。</p>
<h3 id="6-3-Java阻塞队列"><a href="#6-3-Java阻塞队列" class="headerlink" title="6.3 Java阻塞队列"></a>6.3 Java阻塞队列</h3><h4 id="6-3-1-什么是阻塞队列"><a href="#6-3-1-什么是阻塞队列" class="headerlink" title="6.3.1 什么是阻塞队列"></a>6.3.1 什么是阻塞队列</h4><p>阻塞队列，指一个支持两个附加操作的队列。这两个附件操作支持阻塞的插入和移除操作。</p>
<pre><code>1.支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。

2.支持阻塞的移除方法：对队列为空时，获取元素的线程会等待队列变为非空。
</code></pre><blockquote>
<p>提示：阻塞队列常用于生产者和消费者的场景。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p>
</blockquote>
</blockquote>
<h4 id="6-3-2-Java里的阻塞队列"><a href="#6-3-2-Java里的阻塞队列" class="headerlink" title="6.3.2 Java里的阻塞队列"></a>6.3.2 Java里的阻塞队列</h4><p>JDK 7 提供7个阻塞队列：</p>
<pre><code>1.ArrayBlockingQueue 数组组成的有界阻塞队列，按照先进先出的原则对元素进行排序。默认情况不保证线程公平的访问队列。

    //在初始化时指定阻塞队列的容量和公平性
    ArrayBlockingQueue(int capacity, boolean fair);
</code></pre><blockquote>
<p>提示：公平访问队列是指，阻塞的线程可以按照阻塞的先后顺序访问队列，先阻塞的线程先访问队列。非公平性是指，阻塞的线程可以争夺访问队列的资格。</p>
</blockquote>
<pre><code>2.LinkedBlockingQueue 链表实现的有界阻塞队列

3.PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况采取自然升序排列。

4.DelayQueue 支持延时获取元素的无界阻塞队列

5.SynchronousQueue 不存储元素的阻塞队列，每一个put操作都必须等待一个take操作，否则不能继续添加元素。

    //可以指定公平性策略
    public SynchronousQueue(boolean fair);

6.LinkedTransferQueue

7.LinkedBlockingDeque
</code></pre><h4 id="6-3-3-阻塞队列的实现原理"><a href="#6-3-3-阻塞队列的实现原理" class="headerlink" title="6.3.3 阻塞队列的实现原理"></a>6.3.3 阻塞队列的实现原理</h4><h5 id="通知模式"><a href="#通知模式" class="headerlink" title="通知模式"></a>通知模式</h5><p>当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费队列中的一元素之后会通知生产者当前队列可用。</p>
<h3 id="6-4-Fork-Join框架"><a href="#6-4-Fork-Join框架" class="headerlink" title="6.4 Fork | Join框架"></a>6.4 Fork | Join框架</h3><h4 id="6-4-1-Fork-Join框架简介"><a href="#6-4-1-Fork-Join框架简介" class="headerlink" title="6.4.1 Fork/Join框架简介"></a>6.4.1 Fork/Join框架简介</h4><p>并行执行任务框架，将一个大任务分割成若干个小任务，最终汇总每个任务结果后得到大任务结果的框架。</p>
<p>Fork是将大任务切分成若干小任务并行的执行，Join是合并这些子任务的执行结果，最后得到大任务的结果。</p>
<h4 id="6-4-2-工作窃取算法"><a href="#6-4-2-工作窃取算法" class="headerlink" title="6.4.2 工作窃取算法"></a>6.4.2 工作窃取算法</h4><p>该算法表示某个线程从其它队列里窃取任务来执行。此时会发生窃取任务线程和被窃取任务线程之间的竞争，为了解决这个问题，使用双端队列，被窃取的任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<pre><code>1.优点：充分利用线程进行并行运算，减少线程间的竞争。

2.缺点：某些情况下还是存在竞争。如：双端队列中只有一个任务时。
</code></pre><h4 id="6-4-3-Fork-Join框架的设计"><a href="#6-4-3-Fork-Join框架的设计" class="headerlink" title="6.4.3 Fork/Join框架的设计"></a>6.4.3 Fork/Join框架的设计</h4><pre><code>1.分割任务

2.执行任务并合并结果
</code></pre><p>那么这里Fork/Join使用两个类来完成上面两件事情：</p>
<pre><code>1.ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。

提示：ForkJoinTask与一般任务的主要区别在于它需要实现compute()方法。在此方法中首先需要判断任务足够小，才执行当前子任务并返回结果。

    在这里不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供以下两个子类：

        1.RecursiveAction：用于没有返回结果的任务。

        2.RecursiveTask：用于有返回结果的任务。

2.ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。
</code></pre><h4 id="6-4-4-使用Fork-Join框架"><a href="#6-4-4-使用Fork-Join框架" class="headerlink" title="6.4.4 使用Fork/Join框架"></a>6.4.4 使用Fork/Join框架</h4><pre><code>package Java.ChapterSeven.ForkJoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.Future;
import java.util.concurrent.RecursiveTask;

public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; {

    private final int threshold = 5;
    private int firstOne;
    private int lastOne;

    public ForkJoinExample(int firstOne, int lastOne) {
        this.firstOne = firstOne;
        this.lastOne = lastOne;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        //任务小可以直接计算
        if (lastOne - firstOne &lt;= threshold){
            for (int i = firstOne; i &lt;= lastOne; i++){
                result += i;
            }
        }else {
            //拆分成小任务
            int middle = firstOne + (lastOne - firstOne) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(firstOne, lastOne);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, lastOne);
            leftTask.fork();
            rightTask.fork();

            result = leftTask.join() + rightTask.join();
        }

        return result;
    }

    public static void main(String[] args) {
        ForkJoinExample example = new ForkJoinExample(1, 1000);
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Future&lt;Integer&gt; result = forkJoinPool.submit(example);
        try {
            System.out.println(result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h4 id="6-4-5-Fork-Join框架的异常处理和实现原理"><a href="#6-4-5-Fork-Join框架的异常处理和实现原理" class="headerlink" title="6.4.5 Fork/Join框架的异常处理和实现原理"></a>6.4.5 Fork/Join框架的异常处理和实现原理</h4><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供isCompletedAbnormally()方法检查任务是否已经抛出异常或者被取消了，并且可以通过ForkJoinTask的getException()方法获取异常。</p>
<p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<h4 id="6-4-6-Fork-Join框架的实现原理"><a href="#6-4-6-Fork-Join框架的实现原理" class="headerlink" title="6.4.6 Fork/Join框架的实现原理"></a>6.4.6 Fork/Join框架的实现原理</h4><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责存放程序提交给ForkJoinPool的任务。ForkJoinWorkerThread负责执行这些任务。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC6%E7%AB%A0%20%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第6章-深入分析ClassLoader工作机制"><a href="#第6章-深入分析ClassLoader工作机制" class="headerlink" title="第6章 深入分析ClassLoader工作机制"></a>第6章 深入分析ClassLoader工作机制</h2><p>[toc]</p>
<p>ClassLoader是类加载器，负责将Class加载到JVM中。ClassLoader在能够将Class加载到JVM中之外，还有一个重要作用就是审查每个类应该由谁加载，它是一种父优先的等级加载机制。</p>
<h3 id="6-1-ClassLoader类结构分析"><a href="#6-1-ClassLoader类结构分析" class="headerlink" title="6.1 ClassLoader类结构分析"></a>6.1 ClassLoader类结构分析</h3><p>ClassLoader中经常用到的方法</p>
<pre><code>1. defineClass(byte[], int, int) 将byte字节流解析成JVM能够识别的Class对象

2. findClass(String)

3. loadClass(String)

4. resolveClass(Class&lt;?&gt;)
</code></pre><p>defineClass()与findClass()方法一起使用的时候，我们通过直接覆盖ClassLoader父类的findClass()方法来实现类的加载规则，从而取得要加载类的字节码。然后调用defineClass()方法生成类的class对象。</p>
<p>如果不需要重新定义加载规则则可以用 this.getClass().getClassLoader().loadClass(“class”);调用ClassLoader的loadClass()方法获取该类的对象。</p>
<p>ClassLoader还提供另外一些辅助类，如获取class文件的方法：getResource() | getResourceAsStream()方法等。</p>
<h3 id="6-2-ClassLoader等级加载机制"><a href="#6-2-ClassLoader等级加载机制" class="headerlink" title="6.2 ClassLoader等级加载机制"></a>6.2 ClassLoader等级加载机制</h3><pre><code>1. Bootstrap ClassLoader 主要加载JVM自身工作需要的类，这个ClassLoader是完全由JVM自己控制。它仅仅是一个类的加载工具，既没有更高一级的父加载器，也没有子加载器。

2. ExtClassLoader 它是JVM中自身的一部分，该类可以理解为加载第三方的类文件。

3. AppClassLoader 它的父类是ExtClassLoader，所有在System.getProperty(&quot;java.class.path&quot;)目录下的类都可以被这个类加载器加载。该目录就是我们经常用到的classpath。
</code></pre><h3 id="6-3-加载class文件"><a href="#6-3-加载class文件" class="headerlink" title="6.3 加载class文件"></a>6.3 加载class文件</h3><pre><code>1. 找到.class文件并将这个文件包含的字节码加载到内存

2.1 字节码验证

2.2 Class类数据结构分析及相应的内存分配

2.3 符号表的链接

3. 类中静态属性和初始化赋值以及静态块的执行
</code></pre><h4 id="6-3-1-加载字节码到内存"><a href="#6-3-1-加载字节码到内存" class="headerlink" title="6.3.1 加载字节码到内存"></a>6.3.1 加载字节码到内存</h4><p>找到指定类并且将它的字节码加载到内存需要子类中实现（实现findClass()方法）。</p>
<h4 id="6-3-2-验证与解析"><a href="#6-3-2-验证与解析" class="headerlink" title="6.3.2 验证与解析"></a>6.3.2 验证与解析</h4><pre><code>1. 字节码验证，这一过程保证格式正确、行为正确。

2. 类准备，准备代表每个类中定义的字段、方法和实现接口所必须的数据结构。

3. 解析，该阶段类装入器装入类所引用的其它所有类。如：超类、接口、字段、方法签名。
</code></pre><h4 id="6-3-3-初始化Class对象"><a href="#6-3-3-初始化Class对象" class="headerlink" title="6.3.3 初始化Class对象"></a>6.3.3 初始化Class对象</h4><h3 id="6-4-类加载错误分析"><a href="#6-4-类加载错误分析" class="headerlink" title="6.4 类加载错误分析"></a>6.4 类加载错误分析</h3><h4 id="6-4-1-ClassNotFoundException"><a href="#6-4-1-ClassNotFoundException" class="headerlink" title="6.4.1 ClassNotFoundException"></a>6.4.1 ClassNotFoundException</h4><p>该异常发生于在显示加载类的时候。在加载指定字节码到内存时没有找到该文件对应的字节码，也就是该文件不存在。可以通过命令来获取当前的classpath路径。</p>
<pre><code>this.getClass().getClassLoader().getResource(&quot;&quot;).toString();
</code></pre><h4 id="6-4-2-NoClassDefFoundError"><a href="#6-4-2-NoClassDefFoundError" class="headerlink" title="6.4.2 NoClassDefFoundError"></a>6.4.2 NoClassDefFoundError</h4><p>该异常是可能使用new关键字、属性引用某个类、继承了某个接口或类，以及方法的某个参数中引用某个类，会触发JVM隐式加载这些类时发现类不存在异常。</p>
<p>解决的方案是确保每个类引用的类都在当前的classpath下面。</p>
<h4 id="6-4-3-UnsatisfiedLinkError"><a href="#6-4-3-UnsatisfiedLinkError" class="headerlink" title="6.4.3 UnsatisfiedLinkError"></a>6.4.3 UnsatisfiedLinkError</h4><h3 id="6-6-自定义-ClassLoader"><a href="#6-6-自定义-ClassLoader" class="headerlink" title="6.6 自定义 ClassLoader"></a>6.6 自定义 ClassLoader</h3><p>ClassLoader完成的事情：</p>
<pre><code>1. 在自定义路径下查找自定义的class类文件，我们需要的class文件并不在classpath下面，所以需要实现ClassLoader。

2. 对要加载的自定义类做特殊处理

3. 可以定义类的时效机制，在检测到类修改，可以重新加载，从而实现热部署
</code></pre><h4 id="6-6-1-加载自定义路径下的class文件"><a href="#6-6-1-加载自定义路径下的class文件" class="headerlink" title="6.6.1 加载自定义路径下的class文件"></a>6.6.1 加载自定义路径下的class文件</h4>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC7%E7%AB%A0%20Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第七章-Java中的13个原子操作类"><a href="#第七章-Java中的13个原子操作类" class="headerlink" title="第七章 Java中的13个原子操作类"></a>第七章 Java中的13个原子操作类</h2><p>Java从JDK 1.5开始提供了 java.util.concurrent.atomic 包（Atomic包），这个包里面的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<h3 id="7-1-原子更新基本类型类"><a href="#7-1-原子更新基本类型类" class="headerlink" title="7.1 原子更新基本类型类"></a>7.1 原子更新基本类型类</h3><p>使用原子的方式更新基本类型，Atomic包提供以下三个类：</p>
<pre><code>1.AtomicBoolean：原子更新布尔类型

2.AtomicInteger：原子更新整型

    方法：

        1.int addAndGet(int delta)：以原子方式将输入的数组与实例中的值相加，并返回结果。

        2.boolean compareAndSet(int expect, int update)：如果输入的数值等于预期值，则以原子方式将该数值设置为输入的值。

        3.int getAndIncrement()：以原子方式将当前值加1，注意这里返回的是自增前的新值。

        4.void lazySet(int newValue)：最终会设置成newValue，使用lazySet设置值后，可能导致其它线程在之后一小段时间内还是读到旧值。

        5.int getAndSet(int newValue)：以原子方式设置newValue的值，并返回旧值。

3.AtomicLong：原子更新长整型
</code></pre><h3 id="7-2-原子更新数组"><a href="#7-2-原子更新数组" class="headerlink" title="7.2 原子更新数组"></a>7.2 原子更新数组</h3><p>通过原子的方式更新数组里的某个元素，Atomic包提供以下4个类：</p>
<pre><code>1.AtomicIntegerArray：原子更新整型数组里的元素\

    //以原子方式将输入值与数组中索引i的元素相加
    int addAndGet(int i, int delta);

    //如果当前值等于预期值，则以原子方式将数组i的元素设置成update
    boolean compareAndGet(int i, int expect, int update);

2.AtomicLongArray：原子更新长整型数组里的元素

3.AtomicReferenceArray：原子更新引用类型数组里的元素

...
</code></pre><h3 id="7-3-原子更新引用类型"><a href="#7-3-原子更新引用类型" class="headerlink" title="7.3 原子更新引用类型"></a>7.3 原子更新引用类型</h3><p>因为原子更新基本类型AtomicInteger只能更新一个变量，如果需要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了一下3个类：</p>
<pre><code>1.AtomicReference：原子更新引用类型

    public static AtomicReference&lt;user&gt; userRef = new AtomicReference&lt;user&gt;();

    userRef.set(..);
    userRef.compareAndSet(..);

2.AtomicReferenceFieldUpdater：原子更新引用类型里的字段

3.AtomicMarkableReferance：原子更新带有标记位的引用类型
</code></pre><h3 id="7-4-原子更新字段类"><a href="#7-4-原子更新字段类" class="headerlink" title="7.4 原子更新字段类"></a>7.4 原子更新字段类</h3><p>如果需要<code>原子更新某个类里面的某个字段时</code>，需要使用原子更新字段类，Atomic包提供以下三个类进行原子字段更新。</p>
<pre><code>1.AtomicIntegerFieldUpdate：原子更新整型的字段的更新器。

    //创建原子更新器，并设置需要更新的对象类和对象的属性
    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;old&quot;);

    //原子更新
    a.getAndIncrement(user);

2.AtomicLongFieldUpdater：原子更新长整型字段的更新器。

3.AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与数据的版本号更新。可以解决使用CAS原子更新时可能出现的ABA问题。

提示：上面三者的更新类似，所以只提及Integer的代码更新。
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC8%E7%AB%A0%20Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第八章-Java中的并发工具类"><a href="#第八章-Java中的并发工具类" class="headerlink" title="第八章 Java中的并发工具类"></a>第八章 Java中的并发工具类</h2><p>[TOC]</p>
<p><code>CountDownLatch、CyclicBarrier和Semaphore</code>工具类提供一种并发流程控制手段，<code>Exchanger</code>工具类提供了在线程间交换数据的一种手段。</p>
<h3 id="8-1-等待多线程完成的CountDownLatch"><a href="#8-1-等待多线程完成的CountDownLatch" class="headerlink" title="8.1 等待多线程完成的CountDownLatch"></a>8.1 等待多线程完成的CountDownLatch</h3><p>CountDownLatch 允许一个或多个线程等待其它线程完成操作。</p>
<blockquote>
<p>需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完成之后，程序需要提示解析完成。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：join用于让当前线程等待join线程执行结束。其实现原理是不停的检查join线程是否存活，如果join线程存活则让当前线程永远等待。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里实现的。</p>
</blockquote>
<p>CountDownLatch 的构造函数接收一个int类型的参数作为计数器，如果想等待N个点完成，就传入N。</p>
<p>当调用CountDownLatch的countDown方法时，N就会减1，<code>CountDownLatch的await()方法</code>会阻塞当前线程，直到N变为0。</p>
<pre><code>await() 阻塞当前线程
</code></pre><p>如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await()方法，这个方法等待特定时间之后就会不再阻塞当前线程。join也有类似方法。</p>
<pre><code>await(long time, TimeUnit unit);//在特定时间之后就不会阻塞当前线程
</code></pre><h3 id="8-2-同步屏障-CyclicBarrier"><a href="#8-2-同步屏障-CyclicBarrier" class="headerlink" title="8.2 同步屏障 CyclicBarrier"></a>8.2 同步屏障 CyclicBarrier</h3><p>CyclicBarrier 表可循环使用的屏障。其做的事情是，让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<h4 id="8-2-1-CyclicBarrier简介"><a href="#8-2-1-CyclicBarrier简介" class="headerlink" title="8.2.1 CyclicBarrier简介"></a>8.2.1 CyclicBarrier简介</h4><p>CyclicBarrier 的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个<code>线程调用await()方法告诉 CyclicBarrier 我已经到达屏障，然后当前线程被阻塞</code>。</p>
<pre><code>CyclicBarrier(int parties);//参数表示屏障拦截的线程数量
</code></pre><h4 id="8-2-2-CyclicBarrier-应用场景"><a href="#8-2-2-CyclicBarrier-应用场景" class="headerlink" title="8.2.2 CyclicBarrier 应用场景"></a>8.2.2 CyclicBarrier 应用场景</h4><p>CyclicBarrier 可用于多线程计算数据，最后合并计算结果的场景。</p>
<h4 id="8-2-3-CyclicBarrier-和-CountDownLatch-的区别"><a href="#8-2-3-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="8.2.3 CyclicBarrier 和 CountDownLatch 的区别"></a>8.2.3 CyclicBarrier 和 CountDownLatch 的区别</h4><p>CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用reset()方法重置。</p>
<h3 id="8-3-控制并发线程数的Semaphore"><a href="#8-3-控制并发线程数的Semaphore" class="headerlink" title="8.3 控制并发线程数的Semaphore"></a>8.3 控制并发线程数的Semaphore</h3><p>Semaphore （信号量）是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。</p>
<p>信号量可以指定多个线程同时访问某一个资源。提供构造函数：</p>
<pre><code>1. public Semaphore(int permits);

2. public Semaphore(int permits, boolean fair);//fair指是否是公平锁
</code></pre><p>在构造信号量对象时应该指定信号量的准入数，即能够同时申请多少个许可。当每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。</p>
<pre><code>1. public void acquire();

2. public void acquireUninterruptibly();//不响应中断

3. public boolean tryAcquire();//获取一个许可

4. public boolean tryAcquire(long timeout, TimeUnit unit);

5. public void release();
</code></pre><h4 id="8-3-1-应用场景"><a href="#8-3-1-应用场景" class="headerlink" title="8.3.1 应用场景"></a>8.3.1 应用场景</h4><p>Semaphore 可以用作流量控制，特别是公用资源有限的应用场景。</p>
<h4 id="8-3-2-其它方法"><a href="#8-3-2-其它方法" class="headerlink" title="8.3.2 其它方法"></a>8.3.2 其它方法</h4><pre><code>1. int availablePermits() 返回此信号量当前可用的许可证数量

2. int getQueueLength() 返回正在等待获取许可证的线程数

3. boolean hasQueueThreads() 是否有线程正在等待获取许可证

4. void reducePermits(int reduction) 减少reduction个许可证

5. Collection getQueuedThread() 返回所有等待获取许可证的线程集合
</code></pre><h3 id="8-4-线程间交换数据的Exchanger"><a href="#8-4-线程间交换数据的Exchanger" class="headerlink" title="8.4 线程间交换数据的Exchanger"></a>8.4 线程间交换数据的Exchanger</h3><p>Exchanger 是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两线程可以交换彼此的数据。</p>
<p>如果一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange()方法，当两个线程都到达同步点时，这两个线程可以交换数据，将本线程生产出来的数据传递给对方。</p>
<h3 id="8-5-线程阻塞工具类-LockSupport"><a href="#8-5-线程阻塞工具类-LockSupport" class="headerlink" title="8.5 线程阻塞工具类 LockSupport"></a>8.5 线程阻塞工具类 LockSupport</h3><p>线程阻塞工具类 LockSupport 是一个实用的工具类，可以在线程任意位置让线程阻塞。与Thread.suspend()方法比较，弥补了resume()方法发生导致线程无法继续执行的情况。</p>
<p>线程阻塞工具类 LockSupport 的静态方法 park() 方法阻塞当前线程，类似的还有 parkNanos() | parkUntil()等方法，其实现了一个限时等待。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E7%AC%AC9%E7%AB%A0%20Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第九章-Java中的线程池"><a href="#第九章-Java中的线程池" class="headerlink" title="第九章 Java中的线程池"></a>第九章 Java中的线程池</h2><p>[TOC]</p>
<p>Java中线程池的运行场景最多的是并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。合理使用线程池的3个好处：</p>
<pre><code>1.降低资源消耗

2.提高响应速度

3.提高线程的可管理性
</code></pre><h3 id="9-1-线程池的实现原理"><a href="#9-1-线程池的实现原理" class="headerlink" title="9.1 线程池的实现原理"></a>9.1 线程池的实现原理</h3><p>当提交一个新任务到线程池时，线程池的处理流程：</p>
<pre><code>1.线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程。

2.线程池判断工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。

3.线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
</code></pre><p><strong>1.ThreadPoolExecutor 执行execute()方法</strong><br></p>
<pre><code>1.如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意：执行这一步骤需要获取全局锁）。

2.如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。

3.如果无法将任务加入 BlockingQueue（队列已满），则创建新的线程来处理任务（注意：执行这一步需要获取全局锁）。

4.如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExceptionExecution()方法。
</code></pre><blockquote>
<p>提示：ThreadPoolExecutor采取上述步骤的总体设计思路，为了在执行execute()方法时尽可能避免获取全局锁。</p>
</blockquote>
<h3 id="9-2-线程池的使用"><a href="#9-2-线程池的使用" class="headerlink" title="9.2 线程池的使用"></a>9.2 线程池的使用</h3><h4 id="9-2-1-线程池的创建"><a href="#9-2-1-线程池的创建" class="headerlink" title="9.2.1 线程池的创建"></a>9.2.1 线程池的创建</h4><p>我们可通过ThreadPoolExecutor来创建一个线程池：</p>
<pre><code>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue, handler);

1.corePoolSize 线程池基本大小
2.runnableTaskQueue 任务队列，用于保存等待执行的任务的阻塞队列

    阻塞队列：ArrayBlockingQueue | LinkedBlockingQueue | SynchronousQueue | PriorityBlockingQueue

3.ThreadFactory 用于设置创建线程工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字

4.RejectedExecutionHandler(饱和策略) 当队列和线程池都满了，说明线程池处于饱和状态，需要采用一种策略处理提交的新任务。

    1. AbortPolicy 直接抛出异常

    2. CallerRunsPolicy 只用调用者所在线程运行任务

    3. DiscardOldestPolicy 丢弃队列里最近的一个任务，并执行当前任务

    4. DiscardPolicy 不处理、不丢弃

5.maximumPoolSize 线程池最大数量，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。
</code></pre><h4 id="9-2-2-向线程池提交任务"><a href="#9-2-2-向线程池提交任务" class="headerlink" title="9.2.2 向线程池提交任务"></a>9.2.2 向线程池提交任务</h4><p>我们可以使用两个方法向线程池提交任务：1.execute()方法，提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。2.submit()方法，用于提交需要返回值的任务，线程池会返回一个future类型对象…。</p>
<h4 id="9-2-3-关闭线程池"><a href="#9-2-3-关闭线程池" class="headerlink" title="9.2.3 关闭线程池"></a>9.2.3 关闭线程池</h4><p>我们可以通过调用线程池的shutdown或者shutdownNow方法关闭线程池。</p>
<h4 id="9-2-4-合理配置线程池"><a href="#9-2-4-合理配置线程池" class="headerlink" title="9.2.4 合理配置线程池"></a>9.2.4 合理配置线程池</h4><h4 id="9-2-5-线程池的监控"><a href="#9-2-5-线程池的监控" class="headerlink" title="9.2.5 线程池的监控"></a>9.2.5 线程池的监控</h4><p>监控线程池时可以使用以下属性。</p>
<pre><code>1. taskCount 线程池需要执行的任务数量

2. completedTaskCount 线程池在运行过程中已完成的任务数量，小于或等于taskCount

...
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/undefined/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第一章-Java多线程技能"><a href="#第一章-Java多线程技能" class="headerlink" title="第一章 Java多线程技能"></a>第一章 Java多线程技能</h2><h3 id="1-1-继承Thread类"><a href="#1-1-继承Thread类" class="headerlink" title="1.1 继承Thread类"></a>1.1 继承Thread类</h3><blockquote>
<p>提示：使用多线程技术时，代码运行结果与代码执行顺序或调用顺序无关。线程调用的随机性。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>注意：执行start()方法的顺序不代表线程启动的顺序。</p>
</blockquote>
<h3 id="1-2-实现Runnable接口"><a href="#1-2-实现Runnable接口" class="headerlink" title="1.2 实现Runnable接口"></a>1.2 实现Runnable接口</h3><blockquote>
<p>提示：Thread构造函数支持传进一个Runnable接口对象。其不光可以传入Runnable接口的对象，还可以传入一个Thread类的对象，这样做完全可以将一个Thread对象中的run()方法交由其它线程进行调用。</p>
</blockquote>
<h3 id="1-3-实例变量与线程安全"><a href="#1-3-实例变量与线程安全" class="headerlink" title="1.3 实例变量与线程安全"></a>1.3 实例变量与线程安全</h3><p>自定义线程类中的实例变量针对其它线程可以可以有共享与不共享之分，这在多个线程之间进行交互时很重要。</p>
<h4 id="1-3-1-数据不共享"><a href="#1-3-1-数据不共享" class="headerlink" title="1.3.1 数据不共享"></a>1.3.1 数据不共享</h4><p>每个线程都各自执行自己的count变量，自己减少自己的count变量值。线程之间变量不共享。不存在多线程访问同一个实例变量的情况。</p>
<h4 id="1-3-2-数据共享"><a href="#1-3-2-数据共享" class="headerlink" title="1.3.2 数据共享"></a>1.3.2 数据共享</h4><p>数据共享情况就是多线程可以访问同一个变量。</p>
<h3 id="1-4-currentThread-方法"><a href="#1-4-currentThread-方法" class="headerlink" title="1.4 currentThread()方法"></a>1.4 currentThread()方法</h3><p>自定义的线程内部不是同时被同一个线程调用。</p>
<h3 id="1-5-isAlive-方法"><a href="#1-5-isAlive-方法" class="headerlink" title="1.5 isAlive()方法"></a>1.5 isAlive()方法</h3><p>isAlive()方法判断当前线程是否处于活动状态。</p>
<h3 id="1-5-sleep-方法"><a href="#1-5-sleep-方法" class="headerlink" title="1.5 sleep()方法"></a>1.5 sleep()方法</h3><h3 id="1-6-停止线程"><a href="#1-6-停止线程" class="headerlink" title="1.6 停止线程"></a>1.6 停止线程</h3><p>大多数停止一个线程的操作使用 Thread.interrupt()方法，尽管方法的名称是终止的意思，但是这个方法不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。</p>
<h4 id="1-6-1-Java中三种终止正在运行线程方法"><a href="#1-6-1-Java中三种终止正在运行线程方法" class="headerlink" title="1.6.1 Java中三种终止正在运行线程方法"></a>1.6.1 Java中三种终止正在运行线程方法</h4><pre><code>1.使用退出标志，使得线程正常退出，也就是当run()方法完成后线程终止

2.使用stop()方法强行终止线程

3.使用 interrupt() 方法中断线程
</code></pre><blockquote>
<p>提示：调用interrupt()方法只是在当前线程中打了一个停止的标记，并不是真正的停止线程。所以有时候并不能停止线程。</p>
</blockquote>
<h4 id="1-6-2-判断线程是否是停止状态"><a href="#1-6-2-判断线程是否是停止状态" class="headerlink" title="1.6.2 判断线程是否是停止状态"></a>1.6.2 判断线程是否是停止状态</h4><p>在Thread.java类中提供两种方法判断线程的状态：</p>
<pre><code>1.this.interrupt()方法：测试当前线程是否已经中断，这里的当前线程是指运行该方法的线程。

2.this.isInterrupted()方法：测试线程是否已经中断
</code></pre><h3 id="1-7-暂停线程"><a href="#1-7-暂停线程" class="headerlink" title="1.7 暂停线程"></a>1.7 暂停线程</h3><p>在Java多线程中，可以使用suspend()方法暂停线程，使用resume()方法恢复线程执行。</p>
<blockquote>
<p>注意：suspend()方法与resume()方法的缺点，它们很容易独占公共的同步对象，使得其它线程无法访问公共同步对象。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：这两个方法也容易出现因为线程的暂停而导致数据不同步的情况。</p>
</blockquote>
</blockquote>
<h3 id="1-8-yield-方法"><a href="#1-8-yield-方法" class="headerlink" title="1.8 yield()方法"></a>1.8 yield()方法</h3><p>该方法的作用是放弃当前的CPU资源，将它让给其它的任务去占用CPU执行时间。但是放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</p>
<h3 id="1-9-守护线程"><a href="#1-9-守护线程" class="headerlink" title="1.9 守护线程"></a>1.9 守护线程</h3><p>典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。</p>
<p>Daemon的作用是为其它线程的运行提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)，它是一个称职的守护者。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/undefined/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h2><h3 id="1-1-上下文切换"><a href="#1-1-上下文切换" class="headerlink" title="1.1 上下文切换"></a>1.1 上下文切换</h3><pre><code>时间片：CPU通过每个线程分配CPU时间片来实现单核处理器多线程执行代码。时间片是分配给每一个线程的时间，因为很短，通常是几十毫秒。所以会有多个线程同时执行的错觉。
</code></pre><blockquote>
<p>注意：当并发执行累加操作不超过百万次时，速度会比串行执行累加操作慢。这是因为线程有创建和上下文切换的开销。<br><a id="more"></a><br>提示：减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p>
</blockquote>
<pre><code>1.无锁并发编程：多线程竞争锁时会引起上下文切换，所以多线程开发时尽量避免使用锁。如：将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。

2.CAS：Java的Atomic包使用CAS算法来更新数据，不需要加锁。

3.使用尽量少的线程：避免创建不需要的线程。如：任务少，而创建大量的线程。

4.协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
</code></pre><h4 id="1-1-4-减少上下文切换实战"><a href="#1-1-4-减少上下文切换实战" class="headerlink" title="1.1.4 减少上下文切换实战"></a>1.1.4 减少上下文切换实战</h4><h3 id="1-2-死锁"><a href="#1-2-死锁" class="headerlink" title="1.2 死锁"></a>1.2 死锁</h3><blockquote>
<p>提示：一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么只能通过dump线程查看到底哪个线程出现问题。</p>
</blockquote>
<h4 id="1-2-1-避免死锁的常用方法"><a href="#1-2-1-避免死锁的常用方法" class="headerlink" title="1.2.1 避免死锁的常用方法"></a>1.2.1 避免死锁的常用方法</h4><pre><code>1.避免一个线程同时获取多个锁。

2.避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。

3.尝试使用定时锁，使用 `lock.tryLock(timeout)` 来替代使用内部锁机制。

4.对于数据库锁，加锁和解锁必须在一个数据库连接里面，否则会出现解锁失败情况。
</code></pre><h3 id="1-3-资源限制挑战"><a href="#1-3-资源限制挑战" class="headerlink" title="1.3 资源限制挑战"></a>1.3 资源限制挑战</h3><p>资源限制表示在并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。硬件资源限制有：带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源有：数据库的连接数和socket连接数等。</p>
<p>因为资源限制的问题，在并发程序执行的过程中，程序执行不仅不会变快，还可能会更慢，因为增加了上下文的切换和资源调度的时间。</p>
<p>对于硬件资源限制解决方法：集群并行执行程序。<br>对于软件资源限制解决方法：资源池复用。</p>
<h3 id="1-4-同步"><a href="#1-4-同步" class="headerlink" title="1.4 同步"></a>1.4 同步</h3><p>“同步”这个术语包括：关键字synchronized，volatile类型的变量，显式锁（Explicit Lock）以及原子变量。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程基础</title>
    <url>/undefined/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第一章-线程与多线程基础"><a href="#第一章-线程与多线程基础" class="headerlink" title="第一章 线程与多线程基础"></a>第一章 线程与多线程基础</h2><h3 id="1-1-线程的创建"><a href="#1-1-线程的创建" class="headerlink" title="1.1 线程的创建"></a>1.1 线程的创建</h3><p>线程是一个对象，它有唯一标识符ID、名称、状态、优先级等属性。线程只能修改其优先级和名称等属性 ，无法修改 ID 、状态。ID 是 JVM 分配的，名字默认也为Thread-XX，XX是一组数字。线程初始状态为 NEW。<br><a id="more"></a></p>
<blockquote>
<p>提示：调用satrt()方法后并不是立即执行多线程程序，而是使该线程变为可运行状态，至于什么时候执行该线程是OS决定的。</p>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/undefined/%E7%AC%AC%E4%B8%89%E7%AB%A0%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h2><h3 id="3-1-Java内存模型基础"><a href="#3-1-Java内存模型基础" class="headerlink" title="3.1 Java内存模型基础"></a>3.1 Java内存模型基础</h3><p>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。<br><a id="more"></a></p>
<h4 id="3-1-3-重排序"><a href="#3-1-3-重排序" class="headerlink" title="3.1.3 重排序"></a>3.1.3 重排序</h4><pre><code>1. 编译器优化的重排序：编译器在不改变单线程语义的情况下，可以重新安排语句的执行顺序。

2. 指令集并行的重排序：现代处理器采用指令并行技术来将多条指令重叠执行。如果不错在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3. 内存系统的重排序：处理器使用缓存读/写缓冲区，从而使得加载和存储操作看上去可能在乱序执行。
</code></pre><h4 id="3-1-5-happens-before"><a href="#3-1-5-happens-before" class="headerlink" title="3.1.5 happens-before"></a>3.1.5 happens-before</h4><blockquote>
<p>注意：两个操作之间具有happens-before关系并不意味着前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一个操作之前。</p>
</blockquote>
<h3 id="3-4-volitale的内存语义"><a href="#3-4-volitale的内存语义" class="headerlink" title="3.4 volitale的内存语义"></a>3.4 volitale的内存语义</h3><h4 id="3-4-1-volatile的特性"><a href="#3-4-1-volatile的特性" class="headerlink" title="3.4.1 volatile的特性"></a>3.4.1 volatile的特性</h4><p>我们理解volitle特性是将volatile变量的单个读/写看成是使用同一个锁对象对这些单个读/写操作做同步。</p>
<blockquote>
<p>提示：一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间执行效果一样。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：锁的happen-before规则保证释放锁和获取锁的两个线程之间的内存可见性，意味着对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</p>
</blockquote>
</blockquote>
<blockquote>
<p>总结：volatile变量具有以下特性：1.可见性，对于一个volatile变量的读，总是能看到对这个volatile变量最后的写入。2.原子性，对任意单个volatile变量的读/写具有原子性。</p>
</blockquote>
<h4 id="3-4-2-volatile写-读建立的happen-before关系"><a href="#3-4-2-volatile写-读建立的happen-before关系" class="headerlink" title="3.4.2 volatile写-读建立的happen-before关系"></a>3.4.2 volatile写-读建立的happen-before关系</h4><p>从内存语义的角度来看，volatile的读-写与锁的释放-获取有相同的内存效果。</p>
]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间通信</title>
    <url>/undefined/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第三章-线程间通信"><a href="#第三章-线程间通信" class="headerlink" title="第三章 线程间通信"></a>第三章 线程间通信</h2><h3 id="3-1-等待-通知机制"><a href="#3-1-等待-通知机制" class="headerlink" title="3.1 等待/通知机制"></a>3.1 等待/通知机制</h3><h4 id="3-1-3-等待-通知机制的实现"><a href="#3-1-3-等待-通知机制的实现" class="headerlink" title="3.1.3 等待/通知机制的实现"></a>3.1.3 等待/通知机制的实现</h4><p>wait()方法是使当前执行程序的线程进入等待状态，wait()方法是Object类方法，该方法用来将当前线程置入“预执行队列”中。<br><a id="more"></a><br>如果在使用该方法前没有 同步加锁 将会弹出异常 Exception in thread “main” java.lang.IllegalMonitorStateException 。</p>
<blockquote>
<p>提示：只能在同步方法或同步块中调用wait()方法，在执行wait()方法后，当前线程释放锁。</p>
</blockquote>
<p>notify()方法也要在同步块或同步方法中调用，在调用前需要获得该对象的对象级别锁。</p>
<blockquote>
<p>提示：该方法是用来提示那些可能等待该对象的对象锁的其它线程，如果有多个线程等待，则由线程规划器随机挑选出其中一个呈wait()状态的线程，对其发出通知notify()，并使它等待获取该对象的对象锁。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：在执行notify()方法之后，不会立即获取该对象锁，要等到执行notify()的线程将程序执行完之后，退出synchronize块之后释放锁。</p>
</blockquote>
</blockquote>
<p>总结：wait()使线程停止运行，notify()使停止的线程继续执行。</p>
<p>关键字synchronize可以将任何一个Object对象作为同步对象看待，而Java为每个Object对象都实现了wait()方法和notify()方法，它们必须用在被 synchronize 同步的Object临界区内。</p>
<p>通过wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁。notify()方法可以唤醒一个因调用了wait()操作处于阻塞状态的线程，使其进入就绪状态。</p>
<h4 id="3-1-4-wait-方法锁释放-notify-方法锁不释放"><a href="#3-1-4-wait-方法锁释放-notify-方法锁不释放" class="headerlink" title="3.1.4 wait()方法锁释放 | notify()方法锁不释放"></a>3.1.4 wait()方法锁释放 | notify()方法锁不释放</h4><p>当方法wait()被执行后，锁被自动释放，但执行完notify()方法后，锁不自动释放。</p>
<blockquote>
<p>提示：必须执行完notify()方法所在的同步synchronize代码块之后才释放锁。</p>
</blockquote>
<h4 id="3-1-5-interrupt-方法遇到wait-方法"><a href="#3-1-5-interrupt-方法遇到wait-方法" class="headerlink" title="3.1.5 interrupt()方法遇到wait()方法"></a>3.1.5 interrupt()方法遇到wait()方法</h4><p>当线程处于wait()状态时，调用线程对象的 interrupt()方法会出现 InterruptedException 异常。</p>
<h3 id="3-2-方法join使用"><a href="#3-2-方法join使用" class="headerlink" title="3.2 方法join使用"></a>3.2 方法join使用</h3><p>方法join()的作用是：使所属的线程对象x正常执行run()方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的程序。</p>
<p>方法join()具有使线程排队运行的作用，有些类似同步的运行效果。join()方法与synchronize的区别是：join在内部使用wait()方法进行等待，而synchronize关键字使用的是“对象监视器”原理作为同步。</p>
<h3 id="3-3-类ThreadLocal使用"><a href="#3-3-类ThreadLocal使用" class="headerlink" title="3.3 类ThreadLocal使用"></a>3.3 类ThreadLocal使用</h3><p>类ThreadLocal主要解决每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<blockquote>
<p>提示：类ThreadLocal解决的是变量在不同线程间的隔离性，即就是不同线程拥有自己的值，不同线程的值可以放入 ThreadLocal 类中进行保存。</p>
</blockquote>
<h4 id="3-3-2-验证线程变量的隔离性"><a href="#3-3-2-验证线程变量的隔离性" class="headerlink" title="3.3.2 验证线程变量的隔离性"></a>3.3.2 验证线程变量的隔离性</h4><h3 id="3-4-类InheritableThreadLocal的使用"><a href="#3-4-类InheritableThreadLocal的使用" class="headerlink" title="3.4 类InheritableThreadLocal的使用"></a>3.4 类InheritableThreadLocal的使用</h3><p>使用类 InheritableThreadLocal 可以在子线程中取得父线程继承下来的值。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程 - 对象及变量的并发访问</title>
    <url>/undefined/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第二章-对象及变量的并发访问"><a href="#第二章-对象及变量的并发访问" class="headerlink" title="第二章 对象及变量的并发访问"></a>第二章 对象及变量的并发访问</h2><h3 id="2-1-synchronize-同步方法"><a href="#2-1-synchronize-同步方法" class="headerlink" title="2.1 synchronize 同步方法"></a>2.1 synchronize 同步方法</h3><h4 id="2-1-1-方法内的变量是线程安全"><a href="#2-1-1-方法内的变量是线程安全" class="headerlink" title="2.1.1 方法内的变量是线程安全"></a>2.1.1 方法内的变量是线程安全</h4><blockquote>
<p>提示：方法中变量不存在非线程安全问题，永远都是线程安全的。这是方法内部变量的私有属性造成的。</p>
</blockquote>
<h4 id="2-1-2-实例变量非线程安全"><a href="#2-1-2-实例变量非线程安全" class="headerlink" title="2.1.2 实例变量非线程安全"></a>2.1.2 实例变量非线程安全</h4><h4 id="2-1-6-synchronize锁重入"><a href="#2-1-6-synchronize锁重入" class="headerlink" title="2.1.6 synchronize锁重入"></a>2.1.6 synchronize锁重入</h4><p>关键字 synchronize 拥有锁重入的功能，也就是在使用 synchronize 时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。<br><a id="more"></a><br>那么表示一个 synchronize 方法/块内部调用本类的其它 synchronize 方法/块时，是永远可以得到锁的。</p>
<blockquote>
<p>提示：可重入锁是指：自己可以再次获取自己的内部锁。可重入锁也支持父子类继承的环境。</p>
</blockquote>
<h4 id="2-1-7-将任意对象作为对象监视器"><a href="#2-1-7-将任意对象作为对象监视器" class="headerlink" title="2.1.7 将任意对象作为对象监视器"></a>2.1.7 将任意对象作为对象监视器</h4><p>多个线程调用同一个对象中的不同名称的 synchronize 同步方法或 synchronize(this) 同步代码块时，调用的效果就是按照顺序执行的，也就是同步的，阻塞的。</p>
<p>Java还支持任意对象作为对象监视器来实现同步功能，这个任意对象大多数是实例变量及方法参数，使用格式是：synchronize(非this对象)。</p>
<p>锁非this对象具有的优点：如果在一个类中很多个synchronize方法，这时虽然能实现同步，但是会受到阻塞，所以影响运行效率。但是如果使用同步代码块锁非this对象，则 synchronize(非this对象) 代码块中程序与同步方法是异步的，不与其他锁 this同步方法争抢 this锁，可提高效率。</p>
<blockquote>
<p>提示：使用 synchronize(非this对象)同步块格式进行同步操作时，对象监视器必须是同一个对象，如果不是同一个对象监视器，运行的结果就是异步调用了，会交叉运行。</p>
</blockquote>
<h4 id="2-1-8-3个结论"><a href="#2-1-8-3个结论" class="headerlink" title="2.1.8 3个结论"></a>2.1.8 3个结论</h4><pre><code>1.当多个线程同时执行 synchronize(x){} 同步代码块时呈现同步效果。

    同步的原因是因为使用了同一个 对象监视器，如果使用不同的对象监视器会异步输出。

2.当其它线程执行x对象中 synchronize 同步方法时呈现同步效果。

3.当其它线程执行x对象方法里面的 synchronize(this) 代码块时也呈现同步效果。
</code></pre><blockquote>
<p>注意：如果其它线程调用不加 synchronize 关键字的方法时，还是异步调用。</p>
</blockquote>
<h4 id="2-1-9-静态同步-synchronize-方法与-synchronize-class-代码块"><a href="#2-1-9-静态同步-synchronize-方法与-synchronize-class-代码块" class="headerlink" title="2.1.9 静态同步 synchronize 方法与 synchronize(class) 代码块"></a>2.1.9 静态同步 synchronize 方法与 synchronize(class) 代码块</h4><p>在静态方法上加关键字 synchronize 实现的效果和非static方法效果一样。但在本质上是不同的，synchronize 关键字加到static静态方法上是给Class类上锁，而synchronize 关键字加到非static方法上是给对象上锁。</p>
<h4 id="2-1-10-同步方法容易造成-synchronize-方法无限等待"><a href="#2-1-10-同步方法容易造成-synchronize-方法无限等待" class="headerlink" title="2.1.10 同步方法容易造成 synchronize 方法无限等待"></a>2.1.10 同步方法容易造成 synchronize 方法无限等待</h4><p>对于这样的方法，提供多个锁解决问题，如果一个synchronize方法内部陷入死循环状态，只有该方法进入死锁状态，而其它被 synchronize关键字修饰的方法不会进入死锁状态，获取它们方法的锁正常执行。</p>
<h4 id="2-1-11-多线程的死锁"><a href="#2-1-11-多线程的死锁" class="headerlink" title="2.1.11 多线程的死锁"></a>2.1.11 多线程的死锁</h4><p>Java线程死锁是一个经典的问题，因为不同的线程都在等在根本不可能被释放的锁，从而导致所有的任务都无法继续完成。</p>
<h4 id="2-1-16-锁对象的改变"><a href="#2-1-16-锁对象的改变" class="headerlink" title="2.1.16 锁对象的改变"></a>2.1.16 锁对象的改变</h4><p>在将任何数据类型作为同步锁时，需要注意的是，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间是同步的。如果分别获得锁对象，则这些线程是异步的。</p>
<h3 id="2-2-volatile关键字"><a href="#2-2-volatile关键字" class="headerlink" title="2.2 volatile关键字"></a>2.2 volatile关键字</h3><h4 id="2-2-1-volatile关键字和synchronize关键字的比较"><a href="#2-2-1-volatile关键字和synchronize关键字的比较" class="headerlink" title="2.2.1 volatile关键字和synchronize关键字的比较"></a>2.2.1 volatile关键字和synchronize关键字的比较</h4><pre><code>1.关键字 volatile 是线程同步的轻量级实现，所以volatile性能肯定比 synchronize 关键字好，并且volatile只能修饰变量，而synchronize关键字可以修饰方法，以及代码块。

2.多线程访问volatile不会发生阻塞，而synchronize会发生阻塞。

3.volatile能够保证数据的可见性，但是不能保证原子性。synchronize可以保证原子性，也可以间接保证可见性。

4.关键字 volatile 解决的是变量在多线程之间的可见性，而synchronize关键字解决的是多个线程之间访问资源的同步性。
</code></pre><blockquote>
<p>提示：线程安全包括原子性和可见性两个方面，Java同步机制围绕着两方面保证线程安全的。</p>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存管理</title>
    <url>/undefined/%E7%AC%AC%E5%85%AB%E7%AB%A0%20JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第八章-JVM内存管理"><a href="#第八章-JVM内存管理" class="headerlink" title="第八章 JVM内存管理"></a>第八章 JVM内存管理</h2><p>[TOC]</p>
<h3 id="8-3-Java中内存使用组件"><a href="#8-3-Java中内存使用组件" class="headerlink" title="8.3 Java中内存使用组件"></a>8.3 Java中内存使用组件</h3><h4 id="8-3-1-Java堆"><a href="#8-3-1-Java堆" class="headerlink" title="8.3.1 Java堆"></a>8.3.1 Java堆</h4><p>Java堆是用来存储Java对象的内存区域，堆的大小在JVM启动时就一次向操作系统申请完成，通过-Xmx | -Xms两个选项控制大小。一旦分配完成那么堆的大小就固定，不能在内存不够时再向操作系统重新申请。不能在内存空闲时将多余的空间交还给操作系统。</p>
<pre><code>-Xmx 表示堆的最大大小
</code></pre><hr>
<pre><code>-Xms 表示初始大小
</code></pre><blockquote>
<p>提示：Java堆内存空间的管理由JVM控制，对象创建由Java应用程序控制，但是对象所占的空间释放由管理堆内存的垃圾收集器完成。</p>
</blockquote>
<h4 id="8-3-2-线程"><a href="#8-3-2-线程" class="headerlink" title="8.3.2 线程"></a>8.3.2 线程</h4><p>JVM运行实际程序的实体是线程，线程需要内存空间存储一些必要的数据。每个线程创建时，JVM都会3为它创建一个堆栈。堆栈的大小由不同的JVM实现而不同。</p>
<h4 id="8-3-3-类和类加载器"><a href="#8-3-3-类和类加载器" class="headerlink" title="8.3.3 类和类加载器"></a>8.3.3 类和类加载器</h4><h4 id="8-3-4-NIO"><a href="#8-3-4-NIO" class="headerlink" title="8.3.4 NIO"></a>8.3.4 NIO</h4><p>NIO类库，新加一种基于通道和缓冲区来执行I/O的新方式。就如同Java堆上的内存支持I/O缓冲区一样，NIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存。</p>
<p>ByteBuffer.allocateDirect()分配的内存使用的是本机内存而不是Java堆上的内存。</p>
<h4 id="8-3-5-JNI"><a href="#8-3-5-JNI" class="headerlink" title="8.3.5 JNI"></a>8.3.5 JNI</h4><p>JNI技术使得本机代码可以调用Java方法，也就是通常所说的native memory。在实际上Java运行时也依赖于JNI代码来实现类库功能，如：文件操作、网络IO操作或其它系统调用。</p>
<h3 id="8-4-JVM内存结构"><a href="#8-4-JVM内存结构" class="headerlink" title="8.4 JVM内存结构"></a>8.4 JVM内存结构</h3><p>在Java虚拟机规范中将Java运行时数据划分为6种。</p>
<pre><code>1. PC寄存器数据

    PC寄存器严格来说是一个数据结构，它用于保存当前正常执行的程序的内存地址。

2. Java栈

    Java栈总是与线程关联起来的，每当创建一个线程时，JVM就会给这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧都包含一些内部变量（在方法内定义的变量），操作栈和方法返回值等信息。

3. 堆

    堆是存储Java对象的地方，它是JVM管理Java对象的核心存储区域。

    注意：堆是被Java线程所共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。

4. 方法区

    Java方法区是用作存储类结构信息的地方，如：常量池、域、方法数据、方法体、构造函数。

    方法区又是堆中的一部分，是永久区。

5. 本地方法栈

    本地方法栈是为JVM运行Native方法准备的空间，与Java栈的作用类似。

6. 运行时常量池
</code></pre><h3 id="8-5-JVM内存分配策略"><a href="#8-5-JVM内存分配策略" class="headerlink" title="8.5 JVM内存分配策略"></a>8.5 JVM内存分配策略</h3><h4 id="8-5-1-通常内存分配策略"><a href="#8-5-1-通常内存分配策略" class="headerlink" title="8.5.1 通常内存分配策略"></a>8.5.1 通常内存分配策略</h4><pre><code>1. 静态内存分配

    表示程序在编译时能够确定每个数据在运行时刻的存储空间需求，所以在编译时能够为它们分配固定的内存空间。

2. 栈内存分配

    该内存分配又称动态内存分配，是类似于堆栈的运行栈实现。程序对数据区的需求在编译时未知，在运行时知道，在规定运行时进入程序模块时，必须知道程序模块所需的数据区大小才能为其分配内存。

3. 堆内存分配

    程序真正运行到相应代码时才会知道空间大小，这时候就需要堆内存分配策略。
</code></pre><h4 id="8-5-2-Java内存分配"><a href="#8-5-2-Java内存分配" class="headerlink" title="8.5.2 Java内存分配"></a>8.5.2 Java内存分配</h4><p>JVM内存分配主要基于两种，堆和栈。</p>
<p>Java栈的分配是与线程绑定在一起，在创建一个线程时，JVM会给该线程创建一个新的Java栈。在线程激活一个Java方法时，JVM就在线程的Java堆栈中新压入一个帧。帧存放当前方法在执行期间的参数、局部变量等。</p>
<p>栈中主要存放一些基本变量数据和对象句柄（引用）。</p>
<h3 id="8-6-Java内存回收机制"><a href="#8-6-Java内存回收机制" class="headerlink" title="8.6 Java内存回收机制"></a>8.6 Java内存回收机制</h3><h4 id="8-6-1-静态内存分配与回收"><a href="#8-6-1-静态内存分配与回收" class="headerlink" title="8.6.1 静态内存分配与回收"></a>8.6.1 静态内存分配与回收</h4><p>由前面知道的静态内存分配，我们知道在静态内存空间是在Java栈上分配的，当这个方法运行结束时，对应的栈帧也就撤销，所以分配的静态内存空间也就回收了。</p>
<h4 id="8-6-2-动态内存分配与回收"><a href="#8-6-2-动态内存分配与回收" class="headerlink" title="8.6.2 动态内存分配与回收"></a>8.6.2 动态内存分配与回收</h4><p>动态内存回收与垃圾回收机制有关。</p>
<h3 id="8-7-内存问题分析"><a href="#8-7-内存问题分析" class="headerlink" title="8.7 内存问题分析"></a>8.7 内存问题分析</h3><h4 id="8-7-1-GC日志分析"><a href="#8-7-1-GC日志分析" class="headerlink" title="8.7.1 GC日志分析"></a>8.7.1 GC日志分析</h4><p>GC日志输出如下参数：</p>
<pre><code>1. -verbose:gc 辅助输出详细的GC信息

2. -XX:+PrintGCDetails 输出GC的详细信息

3. -XX:+PrintGCApplicationStoppedTime 输出GC造成应用程序暂停的时间

4. -XX:+PrintGCDateStamps GC发生的时间信息

5. -XX:+PrintHeapAtGC 在GC前后输出堆中各个区域的大小

6. -Xloggc:[file] 将GC信息输出到单独的文件中
</code></pre>]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>任务执行</title>
    <url>/undefined/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第六章-任务执行"><a href="#第六章-任务执行" class="headerlink" title="第六章 任务执行"></a>第六章 任务执行</h2><h3 id="6-2-Executor框架"><a href="#6-2-Executor框架" class="headerlink" title="6.2 Executor框架"></a>6.2 Executor框架</h3><p>通过使用Executor将请求处理任务的提交与任务的实际执行解耦开来，并且只需采用另一种不同的Executor实现，就能够改变服务器的行为。</p>
<h4 id="6-2-3-线程池"><a href="#6-2-3-线程池" class="headerlink" title="6.2.3 线程池"></a>6.2.3 线程池</h4><p>线程池，指管理一组同构工作线程的资源池。线程池与工作队列密切相关，工作队列是保存了所有等待执行的任务。工作者线程的任务很简单，从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</p>
]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式与多线程</title>
    <url>/undefined/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第六章-单例模式与多线程"><a href="#第六章-单例模式与多线程" class="headerlink" title="第六章 单例模式与多线程"></a>第六章 单例模式与多线程</h2><p>[TOC]</p>
<h3 id="6-1-立即加载-“饿汉模式”"><a href="#6-1-立即加载-“饿汉模式”" class="headerlink" title="6.1 立即加载/“饿汉模式”"></a>6.1 立即加载/“饿汉模式”</h3><p>立即加载，在使用类的时候已经将对象创建完毕，常见的实现是直接new实例化。</p>
<h3 id="6-2-延迟加载-“懒汉模式”"><a href="#6-2-延迟加载-“懒汉模式”" class="headerlink" title="6.2 延迟加载/“懒汉模式”"></a>6.2 延迟加载/“懒汉模式”</h3><p>延迟加载就是在调用get()方法时实例才被创建，常见的方法是在get()方法中进行new实例化。</p>
<h4 id="6-2-2-延迟加载-“懒汉模式的缺点”"><a href="#6-2-2-延迟加载-“懒汉模式的缺点”" class="headerlink" title="6.2.2 延迟加载/“懒汉模式的缺点”"></a>6.2.2 延迟加载/“懒汉模式的缺点”</h4><p>在多线程环境下创建的是多个对象，不是单例模式。</p>
<pre><code>解决方案

    1. 生命synchronized关键字

        缺点：此种方法运行效率低，下一个线程想要取得对象需要等待上一个线程释放锁才行。

    2. 同步代码块

        缺点：和synchronized方法一样，效率低

    3. 针对某些重要的程序进行单独的同步


    4. DCL双检查锁机制

        首先加入锁机制，然后再次判断对象是否存在
</code></pre><h3 id="6-3-静态内置类实现单例模式"><a href="#6-3-静态内置类实现单例模式" class="headerlink" title="6.3 静态内置类实现单例模式"></a>6.3 静态内置类实现单例模式</h3><p>DCL可以解决多线程单例模式的非线程安全问题。但静态内置类也可以达到同样效果。</p>
<pre><code>private static class handler {
    private static MyObject hd = new MyObject();
}

//构造方法

public static MyObject getInstance(){
    return handler.hd;
}
</code></pre><h3 id="6-4-序列化与反序列化的单例模式"><a href="#6-4-序列化与反序列化的单例模式" class="headerlink" title="6.4 序列化与反序列化的单例模式"></a>6.4 序列化与反序列化的单例模式</h3><p>静态内置类可以达到线程安全问题，但如果遇到序列化对象时，使用默认的方式运行得到的结果还是多例的。</p>
<pre><code>解决方法

    在反序列化中使用 readResolve() 方法
</code></pre><h3 id="6-5-static块实现单例模式"><a href="#6-5-static块实现单例模式" class="headerlink" title="6.5 static块实现单例模式"></a>6.5 static块实现单例模式</h3><p>因为静态块在使用类的时候就已经执行了，所以可以利用这一特性实现单例模式。</p>
<pre><code>private static MyObject instance = null;

static {
    instance = new MyObject();
}

public static MyObject getInstance(){
    return instance;
}
</code></pre><h3 id="6-6-枚举类enum实现单例模式"><a href="#6-6-枚举类enum实现单例模式" class="headerlink" title="6.6 枚举类enum实现单例模式"></a>6.6 枚举类enum实现单例模式</h3><p>在使用枚举类时构造方法会被自动调用，可以利用这一特性实现单例模式。</p>
]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E8%87%AA%E5%AE%9A%E4%B9%89%20FreeMarkerView/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<blockquote>
<p>注意：这里自定义FreeMarkerView的目的是为了放一些公共的变量到FreeMarkerView模板里面。</p>
</blockquote>
<h4 id="1-配置文件-spring-application-xml"><a href="#1-配置文件-spring-application-xml" class="headerlink" title="1.配置文件 spring-application.xml"></a>1.配置文件 spring-application.xml</h4><pre><code>&lt;!-- ********************************************************************** 
 ** FreeMaker解析器                                                      ** 
 ********************************************************************** --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
    &lt;!--&lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerView&quot; /&gt;--&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;net.mingyang.cms.util.FtlView&quot; /&gt;   
    &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt;
    &lt;property name=&quot;exposeRequestAttributes&quot; value=&quot;true&quot; /&gt;  
    &lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt;  
    &lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt;
    &lt;!-- &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; --&gt;  
    &lt;property name=&quot;order&quot; value=&quot;0&quot; /&gt;
&lt;/bean&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; 
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/views/&quot; /&gt; 
    &lt;property name=&quot;freemarkerSettings&quot;&gt; 
        &lt;props&gt; 
            &lt;prop key=&quot;template_update_delay&quot;&gt;0&lt;/prop&gt; 
            &lt;prop key=&quot;default_encoding&quot;&gt;UTF-8&lt;/prop&gt; 
            &lt;prop key=&quot;number_format&quot;&gt;0.##########&lt;/prop&gt; 
            &lt;prop key=&quot;datetime_format&quot;&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt;
            &lt;prop key=&quot;date_format&quot;&gt;yyyy-MM-dd&lt;/prop&gt; 
            &lt;prop key=&quot;classic_compatible&quot;&gt;true&lt;/prop&gt; 
            &lt;prop key=&quot;template_exception_handler&quot;&gt;ignore&lt;/prop&gt; 
        &lt;/props&gt; 
    &lt;/property&gt; 
&lt;/bean&gt;
</code></pre><h4 id="2-自定义实现类"><a href="#2-自定义实现类" class="headerlink" title="2.自定义实现类"></a>2.自定义实现类</h4><pre><code>package cn.edu.xidian.see.ext;

import org.springframework.web.servlet.view.freemarker.FreeMarkerView;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

public class FreeMarkerViewExt extends FreeMarkerView {

    private static final String CONTEXT_PATH = &quot;basePath&quot;;

    @Override
    protected void exposeHelpers(Map&lt;String, Object&gt; model, HttpServletRequest request)
            throws Exception {
        //返回项目根目录
        model.put(CONTEXT_PATH, request.getContextPath());
        super.exposeHelpers(model, request);
    }
}

//或者是这样...

package net.mingyang.cms.util;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.web.servlet.view.freemarker.FreeMarkerView;

public class FtlView extends FreeMarkerView {
    @Override
    protected void exposeHelpers(Map&lt;String, Object&gt; model,
            HttpServletRequest request) throws Exception {
        model.put(&quot;contextPath&quot;, request.getContextPath());
        super.exposeHelpers(model, request);
    }

}
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E8%87%AA%E5%AE%9A%E4%B9%89%20HandlerExceptionResolver%20-%20%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%20%20HandlerMethodArgumentResolver%20-%20%E5%85%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="1-Spring-使用-HandlerExceptionResolver-实现全局异常捕获"><a href="#1-Spring-使用-HandlerExceptionResolver-实现全局异常捕获" class="headerlink" title="1.Spring 使用 HandlerExceptionResolver 实现全局异常捕获"></a>1.Spring 使用 HandlerExceptionResolver 实现全局异常捕获</h3><p>首先实现的功能，我们在项目实现的过程中，项目会发生异常，但是我们并没有捕获这些异常，所以会经常出现bug等。在我们没有配置捕获全局异常时，容器会自动打印错误信息。但是如果我们在web.xml中配置，就会拦截错误，然后跳转到响应的处理错误页面。</p>
<pre><code>//表示在web.xml中配置错误拦截，然后跳转到指定的错误处理界面
&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;/500.jsp&lt;/location&gt;
&lt;/error-page&gt;
</code></pre><p>但是现在我们在项目中通过实现Spring的HandlerExceptionResolver接口是实现所有的异常的捕获。</p>
<ul>
<li><p>方式一(通过实现HandlerExceptionResolver接口)使用步骤：</p>
<p>  1.新建GlobalExceptionResolver</p>
<pre><code>@Component
//使用spring 利用 HandlerExceptionResolver实现全局异常捕获
public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {
    private static Logger LOG = Logger.getLogger(GlobalHandleExceptionResolver.class);
    private static  final int USER_EXCEPTION_CODE = 1;
    private static  final int OTHER_EXCEPTION_CODE =2;

    //编写自己需要的类
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,
                                          Object handle, Exception ex){
        ModelAndView mv = new ModelAndView(&quot;error&quot;);
        if(ex instanceof  UserException){
            mv.addObject(&quot;message&quot;, ex.getMessage());
            mv.addObject(&quot;code&quot;,USER_EXCEPTION_CODE);
            LOG.error(&quot;用户异常:&quot; +ex.getMessage(),ex);
        }else{
            mv.addObject(&quot;message&quot;,&quot;未知异常&quot;);
            mv.addObject(&quot;code&quot;,OTHER_EXCEPTION_CODE);
            LOG.error(&quot;未知异常:&quot;+ ex.getMessage(),ex);
        }
        return mv;
    }
}
</code></pre><p>  2.在spring配置文件中配置新建的类</p>
<pre><code>&lt;!--全局异常捕捉 --&gt;
&lt;bean class=&quot;com.ssm.exception.GlobalExceptionResolver&quot; /&gt;
</code></pre><p>  3.根据需求编写自己需要处理的方法</p>
</li>
</ul>
<blockquote>
<p>注意：在开发的过程中如果返回null，这样的话这个类如同不起作用。如果我们想返回错误页面，那么直接在ModleAndView里面写好即可。</p>
</blockquote>
<pre><code>ModelAndView modelAndView = new ModelAndView();
modelAndView.setViewName(&quot;error&quot;);
return modelAndView;
</code></pre><ul>
<li><p>方式二(通过使用注解)使用步骤：</p>
<p>  1.创建GlobalExceptionResolver</p>
<pre><code>//通过使用ControllerAdvice和ExceptionHandler这两个注解实现全局的异常捕获
@ControllerAdvice
public class GlobalExceptionResolver {
    //这里的ServiceException是自定义的异常
    @ExceptionHandler(value = ServiceException.class)
    public @ResponseBody String serviceCommonExceptionHandler(ServiceException e) {
        //对捕获的异常进行处理并打印日志等，之后返回json数据，方式与Controller相同
        return &quot;{&apos;code&apos;:-1}&quot;;
    }

    @ExceptionHandler(value = Exception.class)
    public ModelAndView exceptionHandler() {
        //当然也可以直接返回ModelAndView等类型，然后跳转相应的错误页面，这都根据实际的需要进行使用
        return new ModelAndView();
    }
}

//自定义异常：
public class ServiceException extends RuntimeException{
    //...
}
</code></pre><blockquote>
<p>注意：spring会根据@ExceptionHandler的value值进行匹配，如果我们项目中的一些异常没有被捕获，那么这里就会处理一些没有捕获的异常。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="2-Spring-MVC-之-HandlerMethodArgumentResolver"><a href="#2-Spring-MVC-之-HandlerMethodArgumentResolver" class="headerlink" title="2.Spring MVC 之 HandlerMethodArgumentResolver"></a>2.Spring MVC 之 HandlerMethodArgumentResolver</h3><p>简言之，HandlerMethodArgumentResolver = HandlerMethod + Argument(参数) + Resolver(解析器),其实就是HandlerMethod方法的解析器, 将 HttpServletRequest(header + body 中的内容)解析为HandlerMethod方法的参数。</p>
<blockquote>
<p>SpringMVC中的HandlerAdapter会对Controller层方法的参数执行HandlerMethodArgumentResolver(对参数的解析器)中的方法。</p>
</blockquote>
<blockquote>
<blockquote>
<p>HandlerMethodArgumentResolver接口主要有两个方法：supportsParameter和resolveArgument</p>
</blockquote>
</blockquote>
<h4 id="2-1-supportsParameter-方法"><a href="#2-1-supportsParameter-方法" class="headerlink" title="2.1 supportsParameter()方法"></a>2.1 supportsParameter()方法</h4><pre><code>boolean supportsParameter(MethodParameter parameter);
</code></pre><p>此方法返回的类型是boolean类型，作用是判断Controller层中参数是否满足条件，满足则执行resolveArgument()方法，不满足则跳过。</p>
<pre><code>一般地，在supportParameter中执行getParameterAnnotations来判断是否包含这样的注解类型。getParameterAnnotations()方法表示在参数列表中经常会有添加注解的情况，所以在这种情况下使用getParameterAnnotations()方法来获得这些注解。

//在下面这个方法中有四个参数，在参数上又有注解，所以可以通过这种方法来获得
public void testa(@TestAnnocation(pat = &quot;5&quot;) String s,@TestAnnocation2 @TestAnnocation(pat = &quot;6&quot;) String s1,String s3,@TestAnnocation(pat = &quot;9&quot;) String s4) {
    System.out.println(&quot;------------&quot; + s);
}
</code></pre><h4 id="2-2-resolveArgument-方法"><a href="#2-2-resolveArgument-方法" class="headerlink" title="2.2 resolveArgument()方法"></a>2.2 resolveArgument()方法</h4><p>此方法只会在supportsParameter()方法返回true的情况下才会调用，用于处理业务，将返回值赋值给Controller层中的参数。</p>
<pre><code>Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;
</code></pre><hr>
<pre><code>//判断 HandlerMethodArgumentResolver 是否支持 MethodParameter(PS: 一般都是通过 参数上面的注解|参数的类型)
public interface HandlerMethodArgumentResolver {

    //判断是否支持要转换的参数类型
    boolean supportsParameter(MethodParameter var1);

    //当支持后进行相应的转换
    //此方法中包括四个参数
    //MethodParameter parameter, M
    //odelAndViewContainer mavContainer,
    //NativeWebRequest webRequest, 
    //WebDataBinderFactory binderFactory

    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;
}
</code></pre><blockquote>
<blockquote>
<p>总结：我们清楚，HandlerMethodArgumentResolver是一个参数解析器，我们可以通过写一个类实现HandlerMethodArgumentResolver接口来实现对Controller层中方法参数的修改。</p>
</blockquote>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E8%87%AA%E5%AE%9A%E4%B9%89%20HandlerMethodArgumentResolver%20%E8%A7%A3%E5%86%B3%E5%85%A5%E5%8F%82%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>自定义HandlerMethodArgumentResolver可以理解为用一个对象封装需要查询的参数到后台查询相关值。</p>
<h2 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h2><pre><code>@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface PropertyNaming {

}
</code></pre><hr>
<h2 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2.实现方法"></a>2.实现方法</h2><pre><code>package cn.edu.xidian.see.ext;
//这里省略导入的包文件
...
//在编写之前应该实现此解决入参问题的接口
public class DataTableArgumentResolver implements HandlerMethodArgumentResolver {

    //1.首先需要实现的方法是：supportsParameter()方法
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        // 仅作用于添加了注解DataTableArgument的参数
        return parameter.hasParameterAnnotation(DataTableArgument.class);
    }

    //2.然后重写resolveArgument方法
    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

        DataTableRequest dtRequest = new DataTableRequest();

        if (webRequest.getParameter(&quot;draw&quot;) != null) {
            dtRequest.setDraw(Integer.valueOf(webRequest.getParameter(&quot;draw&quot;)));
        }
        if (webRequest.getParameter(&quot;start&quot;) != null) {
            dtRequest.setStart(Integer.valueOf(webRequest.getParameter(&quot;start&quot;)));
        }
        if (webRequest.getParameter(&quot;length&quot;) != null) {
            dtRequest.setLength(Integer.valueOf(webRequest.getParameter(&quot;length&quot;)));
        }

        Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();

        if (parameterMap.containsKey(&quot;search[value]&quot;)) {
            Search search = new Search();
            search.setValue(parameterMap.get(&quot;search[value]&quot;)[0]);
            search.setRegex(Boolean.valueOf(parameterMap.get(&quot;search[regex]&quot;)[0]));
            dtRequest.setSearch(search);
        }

        List&lt;Order&gt; orders = new ArrayList&lt;&gt;();
        int i = 0;
        String ockey = &quot;order[&quot; + i + &quot;][column]&quot;, odkey;
        while (parameterMap.containsKey(ockey)) {

            odkey = &quot;order[&quot; + i + &quot;][dir]&quot;;

            Order order = new Order();
            order.setColumn(Integer.valueOf(parameterMap.get(ockey)[0]));
            order.setDir(parameterMap.get(odkey)[0]);
            orders.add(order);

            ockey = &quot;order[&quot; + (++i) + &quot;][column]&quot;;
        }
        dtRequest.setOrder(orders);

        List&lt;Column&gt; columns = new ArrayList&lt;&gt;();
        i = 0;
        String cdkey, cnkey, cskey, cokey, csvkey, csrkey;
        cdkey = &quot;columns[&quot; + i + &quot;][data]&quot;;
        while (parameterMap.containsKey(cdkey)) {

            cnkey = &quot;columns[&quot; + i + &quot;][name]&quot;;
            cskey = &quot;columns[&quot; + i + &quot;][searchable]&quot;;
            cokey = &quot;columns[&quot; + i + &quot;][orderable]&quot;;
            csvkey = &quot;columns[&quot; + i + &quot;][search][value]&quot;;
            csrkey = &quot;columns[&quot; + i + &quot;][search][regex]&quot;;

            Column column = new Column();
            column.setData(parameterMap.get(cdkey)[0]);
            column.setName(parameterMap.get(cnkey)[0]);
            column.setSearchable(Boolean.valueOf(parameterMap.get(cskey)[0]));
            column.setOrderable(Boolean.valueOf(parameterMap.get(cokey)[0]));
            Search search = new Search();
            search.setValue(parameterMap.get(csvkey)[0]);
            search.setRegex(Boolean.valueOf(parameterMap.get(csrkey)[0]));
            column.setSearch(search);
            columns.add(column);

            cdkey = &quot;columns[&quot; + (++i) + &quot;][data]&quot;;
        }
        dtRequest.setColumns(columns);

        return dtRequest;
    }

}
</code></pre><hr>
<h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h2><pre><code>@RequestMapping(value = &quot;/teacher/process&quot;, produces = {&quot;application/json;charset=UTF-8&quot;})
@ResponseBody
public String teacher_process(HttpSession session,
                                @DataTableArgument DataTableRequest dtRequest,
                                @RequestParam(value = &quot;showColumns[]&quot;, required = false) String[] showColumns) throws Exception{
                                //controller程序实现  
                              }
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>自定义注解是程序中特殊的标记，用于替代配置文件。传统方式通过配置文件告诉类如何运行，有了注解技术之后，开发人员可以通过注解告诉类如何执行。在Java技术里应用注解的典型应用：通过反射技术去得到类里面的注解，从而决定如何去运行类。</p>
<blockquote>
<p>提示：自定义使用场景，类属性自动赋值；验证对象属性完整性；代替配置文件功能，像Spring基于注解的配置；可以生成文档，像Java程序注释中的@see @param等。</p>
</blockquote>
<h2 id="Target-元注解"><a href="#Target-元注解" class="headerlink" title="@Target 元注解"></a>@Target 元注解</h2><p>@Target 元注解决定一个注解可以标识到哪些成分上。如：表示在类上或者属性上或者方法上 @Target 默认值为任何元素成分</p>
<h2 id="自定义注解："><a href="#自定义注解：" class="headerlink" title="自定义注解："></a>自定义注解：</h2><p>使用 @interface 自定义注解，自动继承 java.lang.annotation.Annotation 接口。</p>
<blockquote>
<p>注意：在定义自定义注解时不能继承其他的注解或接口</p>
</blockquote>
<p>@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型(返回值类型只有基本类型、class、String、enum)</p>
<h4 id="1-定义注解的格式"><a href="#1-定义注解的格式" class="headerlink" title="1.定义注解的格式"></a>1.定义注解的格式</h4><pre><code>public @interface 注解名{定义体}
</code></pre><h4 id="2-注解参数的可支持数据类型"><a href="#2-注解参数的可支持数据类型" class="headerlink" title="2.注解参数的可支持数据类型"></a>2.注解参数的可支持数据类型</h4><pre><code>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)
2.String类型
3.Class类型
4.enum类型
5.Annotation类型
6.以上所有类型的数组
</code></pre><h4 id="3-注解元素的默认值"><a href="#3-注解元素的默认值" class="headerlink" title="3.注解元素的默认值"></a>3.注解元素的默认值</h4><p>注解元素需要有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，同时不是基本类型的注解元素不能为null。所以在使用空字符串或 0 作为默认值是一种常用的方法。</p>
<h4 id="4-注解-Retention-用来修饰注解，是注解的注解，称为元注解"><a href="#4-注解-Retention-用来修饰注解，是注解的注解，称为元注解" class="headerlink" title="4.注解@Retention 用来修饰注解，是注解的注解，称为元注解"></a>4.注解@Retention 用来修饰注解，是注解的注解，称为元注解</h4><pre><code>@Retention 注解有一个属性 value 是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，这个枚举决定了Retention注解应该如何去保持，也可理解为Rentention 搭配 RententionPolicy使用。

@Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候

@Retention(RetentionPolicy.SOURCE )修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中

@Retention(RetentionPolicy.RUNTIME )修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时

所以他们可以用反射方式来读取，RetentionPolicy.RUNTIME 可以让你从JVM中读取Annotation注解的信息，以便在分析程序的时候使用。
</code></pre><h4 id="5-注解-Documented"><a href="#5-注解-Documented" class="headerlink" title="5.注解@Documented"></a>5.注解@Documented</h4><p>@Documented 注解表明这个注解应该被 JavaDoc 工具记录。默认情况下，javadoc是不包括注解的，如果声明注解时指定了@Documented 则其会被javadoc之类的工具处理，所以注解类型信息会被包括在生成的文档中。</p>
<h4 id="6-Target-注解"><a href="#6-Target-注解" class="headerlink" title="6.@Target 注解"></a>6.@Target 注解</h4><p>@Target注解时为了说明Annotation所修饰的范围，Annotation可被用于 package、types(类、接口、枚举、Annotation类型)、类型成员、方法参数和本地变量</p>
<pre><code>1.CONSTRUCTOR:用于描述构造器 

2.FIELD:用于描述域 

3.LOCAL_VARIABLE:用于描述局部变量

4.METHOD:用于描述方法

5.PACKAGE:用于描述包 

6.PARAMETER:用于描述参数

7.TYPE:用于描述类、接口(包括注解类型) 或enum声明
</code></pre><h4 id="7-案例"><a href="#7-案例" class="headerlink" title="7.案例"></a>7.案例</h4><pre><code>package annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 是否需要从解析Excel赋值
 * @author administrator
 * @see [相关类/方法]
 */
@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = {ElementType.FIELD})
public @interface IsNeeded {
    boolean isNeeded() default true;
}
</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 传输层</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="计算机网络-传输层"><a href="#计算机网络-传输层" class="headerlink" title="计算机网络 - 传输层"></a>计算机网络 - 传输层</h2><p>网络层只将 分组 发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信通道。</p>
<h3 id="UDP-TCP的特点"><a href="#UDP-TCP的特点" class="headerlink" title="UDP | TCP的特点"></a>UDP | TCP的特点</h3><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<blockquote>
<p>特点：1.面向非连接。2.不维护连接状态，支持同时向多个客户端传输相同的消息。3.数据包报头只有8个字节，额外开销小。4.吞吐量只受限于数据生成速率、传输速率以及机器性能。5.尽最大可能交付，不保证可靠交付，不需要维持复杂的链接状态表。6.面向报文，不对应用程序提交的报文信息进行拆分或者合并。</p>
</blockquote>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
<blockquote>
<p>特点：1.基于字节流的传输层通信协议。2.将应用层的数据流分割成报文段并发送给目标节点的TCP层。3.数据包都有序号，对方收到则发送ACK确认，未收到则重传。4.使用奇偶校验来校验数据是否有错。5.数据包报头有20个字节。</p>
</blockquote>
<blockquote>
<p>TCP FLAGS</p>
<blockquote>
<p>URG：紧急指针标志<br><br>ACK：确认序号标志<br><br>PSH：push标志<br><br>RST：重置连接标志<br><br>SYN：同步序号，用于建立连接过程<br><br>FIN：finish标志，用于释放连接</p>
</blockquote>
</blockquote>
<h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><p>首部字段只有8个字节，然后包括源端口、目的端口、长度、校验和。12字节的伪首部是为了计算校验和临时添加的。</p>
<h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><pre><code>1.序号：对字节流进行编号。

2.确认号：期望收到的下一个报文段的序号。

3.数据偏移：表示数据部分距离报文段起始处的偏移量，实际上指首部的长度。

4.确认ACK：当ACK=1时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

5.同步SYN：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

6.终止FIN：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

7.窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
</code></pre><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><pre><code>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

    1.第一次握手，建立连接时，客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。

    2.第二次握手，服务器收到SYN包，必须确认客户端的SYN（ACK = j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。

    3.第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
</code></pre><blockquote>
<p>提示：三次握手的目的是为了初始化Sequence Number的初始值。</p>
</blockquote>
<h4 id="首次握手的隐患"><a href="#首次握手的隐患" class="headerlink" title="首次握手的隐患"></a>首次握手的隐患</h4><p><code>这里有一个问题就是在第一次客户端发送连接请求之后掉线，服务器接收到连接请求（SYN）之后，回复SYN-ACK时候没有收到ACK确认，会不断的重试直到超时。</code></p>
<p>在这个超时等待过程中可能会存在 SYN Flood 恶意攻击</p>
<h4 id="连接建立之后，客户端出现故障"><a href="#连接建立之后，客户端出现故障" class="headerlink" title="连接建立之后，客户端出现故障"></a>连接建立之后，客户端出现故障</h4><p>TCP有一个保活机制，在客户端出现故障之后，向对方发送保活探测报文，如果未收到则响应则继续发送。尝试次数达到保活探测数仍未收到响应则中断连接。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><pre><code>TCP采用四次挥手是为了终止连接，流程：

    1.第一次挥手，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态。

    2.第二次挥手，服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSE_WAIT状态。

    3.第三次挥手，服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。

    4.第四次挥手，客户端收到FIN后，客户端进入TIME_WAIT状态（客户端在经过2*MSL时间后进入CLOSED状态），接着发送一个ACK到服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成四次挥手。
</code></pre><blockquote>
<p>提示：TCP连接在经过 2*MSL 时间之后才会进入CLOSED状态的原因是：1.确保对方有足够的时间收到ACK包。2.避免有足够时间避免新旧连接混淆。</p>
</blockquote>
<blockquote>
<p>提示：为什么需要四次握手才能断开连接的原因是：因为全双工，发送方和接收方都需要FIN报文和ACK报文，所以看起来就是四次的挥手。</p>
</blockquote>
<blockquote>
<p>提示：服务器出现大量CLOSE_WAIT状态的原因是：客户端一直在请求，但是返回给客户端的信息是异常的，服务端没有收到请求</p>
</blockquote>
<h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><p>TCP在使用超时重传实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，那么久重传这个报文段。</p>
<h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><pre><code>RTT：发送一个数据包到收到对应的ACK所花费的时间

RTO：重传时间间隔
</code></pre><p>TCP使用滑动窗口做流量控制与乱序重排。作用是：1.保证TCP的可靠性。2.保证TCP的流控特性。</p>
<p>滑动窗口的窗口数据计算过程：</p>
<pre><code>window = maxRcvBuffer - (LastByteRcvd - LastByteRead)
</code></pre><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，而不影响发送方的发送速率。如果窗口字段设置为 0，则发送方不能发送数据。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 应用层</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="计算机网络-应用层"><a href="#计算机网络-应用层" class="headerlink" title="计算机网络 - 应用层"></a>计算机网络 - 应用层</h2><p>### </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 概述</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="计算机网络-概述"><a href="#计算机网络-概述" class="headerlink" title="计算机网络 - 概述"></a>计算机网络 - 概述</h2><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p>
<h4 id="OSI-七层网络参考模型"><a href="#OSI-七层网络参考模型" class="headerlink" title="OSI 七层网络参考模型"></a>OSI 七层网络参考模型</h4><h4 id="TCP-IP-四层网络模型"><a href="#TCP-IP-四层网络模型" class="headerlink" title="TCP/IP 四层网络模型"></a>TCP/IP 四层网络模型</h4><h4 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h4><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>
<h4 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h4><pre><code>1.客户-服务区（C/S）：客户是服务的请求方，服务器是服务的提供方。

2.对等（p2p）：不区分客户端和服务器。
</code></pre><h4 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h4><p><strong>1.电路交换</strong><br></p>
<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<p><strong>2.分组交换</strong><br></p>
<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><pre><code>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延
</code></pre><p><strong>1.排队时延</strong><br></p>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<p><strong>2.处理时延</strong><br></p>
<p>主机或路由器收到分组时进行处理所需要的时间。如：分析首部、从分组中提取数据、进行差错校验或查找适当的路由等。</p>
<p><strong>3.传输时延</strong><br></p>
<p>主机或路由传输数据帧所需要的时间。</p>
<pre><code>delay = l(m) / v(m/s) l-表示信道长度 v-表示电磁波在信道上的传播速度
</code></pre><h4 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h4><pre><code>1.OSI模型 （从上到下）

    应用层 | 表示层 | 会话层 | 运输层 | 网络层 | 数据链路层 | 物理层

        表示层：数据压缩、加密以及数据描述，这使得应用程序不需要关系在各台主机中数据内部格式不同问题。

        会话层：建立以及管理会话。

2.五层协议模型 （从上到下）

    应用层 | 运输层 | 网络层 | 数据链路层 | 物理层

        应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

        传输层：为进程提供通用数据传输服务。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

        网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

        数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

        物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

3.TCP/IP （从上到下）

    应用层 | 运输层 | 网际层 | 网络接口层 （相当于五层协议中的数据链路层和物理层合并为接口层）

        注意：TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

4.数据在各层之间的传递过程

    在向下的过程中，需要添加下层协议所需要的首部和尾部，而在向上的过程中不断拆开首部和尾部。

    注意：路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或应用程序提供服务，因此也就不需要传输层和应用层。
</code></pre>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="计算机网络（针对面试）"><a href="#计算机网络（针对面试）" class="headerlink" title="计算机网络（针对面试）"></a>计算机网络（针对面试）</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><h4 id="​IP-数据报格式"><a href="#​IP-数据报格式" class="headerlink" title="​IP 数据报格式"></a>​IP 数据报格式</h4><p>​    <img src="images/31.png" alt=""></p>
<h4 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h4><ul>
<li><strong>标识</strong>：统一数据报的分片使用统一标识，同一个数据报使用同一个标识。</li>
<li><strong>DF 不分片标识</strong>： DF = 1 禁止分片。 <strong>DF = 0 允许分片</strong></li>
<li><strong>MF 更多分片标识</strong>： MF = 1后面还有分片。 <strong>MF = 0，代表最后一片，或者是没分片。</strong> </li>
<li><strong>片偏移：</strong>指的是分片后在原分组中的位置。单位是 8 字节</li>
</ul>
<h5 id="如何确定分片顺序"><a href="#如何确定分片顺序" class="headerlink" title="如何确定分片顺序"></a>如何确定分片顺序</h5><p>​    <strong>标识 + 片偏移</strong></p>
<h4 id="报文的两大分类"><a href="#报文的两大分类" class="headerlink" title="报文的两大分类"></a>报文的两大分类</h4><h5 id="2-种查询报文"><a href="#2-种查询报文" class="headerlink" title="2 种查询报文"></a>2 种查询报文</h5><h5 id="5-种差错报文"><a href="#5-种差错报文" class="headerlink" title="5 种差错报文"></a>5 种差错报文</h5><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h4><ol>
<li>无连接的，减少开销和发送数据之前的时延</li>
<li>UDP 使用最大努力交付，不保证可靠交付</li>
<li>UDP 是面向报文的，适合一次性传输少量数据</li>
<li><p>UDP 无拥塞控制，适合很多实时应用</p>
<ol start="5">
<li>UDP 首部开销比较小，8个字节</li>
</ol>
</li>
</ol>
<h4 id="首部各个字段解析"><a href="#首部各个字段解析" class="headerlink" title="首部各个字段解析"></a>首部各个字段解析<img src="images/6.png" alt="UDP首部格式"></h4><ul>
<li><p>16位源端口号</p>
<ul>
<li>2B 可有可无 看是否要回发</li>
</ul>
</li>
<li><p>16位目的端口号</p>
</li>
<li><p>16位UDP长度</p>
<ul>
<li>UDP 用户数据报的整个长度</li>
</ul>
</li>
<li><p>16位检验和</p>
<ul>
<li>检测整个UDP数据报是否有错</li>
</ul>
</li>
</ul>
<h4 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h4><p>  <img src="images/7.png" alt=""></p>
<ul>
<li>伪首部只在计算校验和的时候才出现，不会进行传输<ul>
<li>17 UDP 协议的值</li>
<li>UDP 长度 ： UDP 首部 8B + 数据部分长度（不包括伪首部）</li>
</ul>
</li>
</ul>
<p>发送端： ==加上伪首部之后，二进制反码求和 在取反==</p>
<p>接收端： ==加上伪首部之后，二进制反码求和 在取反 结果为全 1 则代表无差错==</p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="==TCP 协议=="></a>==TCP 协议==</h3><h4 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h4><ul>
<li>面向连接</li>
<li>每一条连接都是点对点的</li>
<li>提供可靠交付，无差错，不丢失，不重复，按序到达==可靠有序，不丢不重==</li>
<li>TCP 提供全双工通信（发送缓存 + 接收缓存）</li>
<li>TCP 是面向字节流的</li>
</ul>
<h4 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h4><p>  <img src="images/8.png" alt=""></p>
<p><strong>序号：</strong> 代表本报文段所发送数据的第一个字节的序号</p>
<p><strong>确认号</strong>： 期望收到对方下一个报文段得第一个数据字节的序号</p>
<p><strong>数据偏移</strong>： TCP 报文距离数据的距离（可能加了数据填充等）</p>
<p><strong>6个控制位</strong>：</p>
<ul>
<li>URG 紧急指针：不用在发送缓存中排队，配合<strong>紧急指针</strong>使用</li>
<li>ACK 确认位： ACK = 1，小写的 ack 才有效</li>
<li>PSH  推送位： 接受放应该尽快交付上层应用，不用等缓存填满</li>
<li>RST 复位： 表示TCP 连接出现了问题，要释放连接，再重新建立连接</li>
<li>SYN 同步位：表示是一个连接报文</li>
<li>FIN 终止位： 表明发送方已经发送完毕，要求释放连接</li>
</ul>
<p><strong>窗口位</strong>：表示接收方的接收缓存大小</p>
<p><strong>检验和</strong>：加上伪包头之后的二进制反码求和在取反</p>
<p><strong>紧急位：</strong> 指出本报文段得紧急数据的字节数</p>
<h4 id="可靠手段"><a href="#可靠手段" class="headerlink" title="可靠手段"></a>可靠手段</h4><h5 id="TCP连接控制"><a href="#TCP连接控制" class="headerlink" title="TCP连接控制"></a>TCP连接控制</h5><h6 id="​三次握手："><a href="#​三次握手：" class="headerlink" title="​三次握手："></a>​三次握手：</h6><p>  <img src="images/9.png" alt=""></p>
<p>  <img src="images/11.png" alt=""></p>
<h6 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h6><p>  <img src="images/10.png" alt=""></p>
<p>  <img src="images/12.png" alt=""></p>
<h5 id="TCP流量-拥塞控制"><a href="#TCP流量-拥塞控制" class="headerlink" title="==TCP流量/拥塞控制=="></a>==TCP流量/拥塞控制==</h5><p>​    <strong>超时重传</strong>：在规定时间内没有收到确认就重发（RTTs 加权平均往返时间）</p>
<p>​    <strong>快速重传</strong>： 连续收到三个冗余ACK之后便认为，该数据报已经丢失，则重新发送</p>
<p>​    <strong>滑动窗口</strong>： 让发送方慢点，使得接收方来得及接收，让接收方根据自己的接收缓存的大小，动态的调整发送窗口的大小。（窗口值 取 rrwd  和 crwd 的最小值）</p>
<p>​    <strong>当滑动窗口的值为 0 是，启动一个计时器。进行窗口探测，防止报文丢失，导致窗口一直为0</strong></p>
<p>​    <strong>慢启动</strong>： 从一开始，每次扩增二倍</p>
<p>​    <strong>拥塞避免</strong>：线性增长</p>
<p>​    <strong>快速恢复</strong>：不在回退到0， 而是消减一半</p>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="==TCP 和 UDP 的区别=="></a>==TCP 和 UDP 的区别==</h3><ul>
<li><p>1、 TCP面向连接 ； UDP是无连接的</p>
</li>
<li><p>2、 TCP提供可靠的服务，<strong>不丢不重按序不错。</strong>UDP尽最大努力交付</p>
</li>
<li><p>3 、TCP面向字节流，UDP是面向报文的且 <strong>UDP没有拥塞控制</strong></p>
</li>
<li><p>4、 每一条TCP连接只能是<strong>点到点</strong>的 ； UDP支持一对一，一对多，多对一和多对多的交互通信</p>
</li>
<li><p>5 、TCP首部开销<strong>20字节</strong>   ;   UDP的首部开销小，只有<strong>8个字节</strong></p>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="==HTTP 协议=="></a>==HTTP 协议==</h3><h4 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h4><h5 id="​1-请求行："><a href="#​1-请求行：" class="headerlink" title="​1.请求行："></a>​1.请求行：</h5><p>​            请求方式（get post put delete） URL   HTTP协议版本    </p>
<h5 id="2-请求头："><a href="#2-请求头：" class="headerlink" title="2.请求头："></a>2.请求头：</h5><p>​        <img src="images/14.png" alt=""></p>
<h5 id="3-空行："><a href="#3-空行：" class="headerlink" title="3.空行："></a>3.空行：</h5><h5 id="4-请求体："><a href="#4-请求体：" class="headerlink" title="4.请求体："></a>4.请求体：</h5><p>​    你输入的 账号 密码等</p>
<h4 id="响应报文："><a href="#响应报文：" class="headerlink" title="响应报文："></a>响应报文：</h4><h5 id="1-响应行："><a href="#1-响应行：" class="headerlink" title="1.响应行："></a>1.响应行：</h5><p>Http 版本  状态码</p>
<h5 id="2-响应头："><a href="#2-响应头：" class="headerlink" title="2.响应头："></a>2.响应头：</h5><p><img src="images/15.png" alt=""></p>
<h5 id="3-空行：-1"><a href="#3-空行：-1" class="headerlink" title="3.空行："></a>3.空行：</h5><h5 id="4-响应体："><a href="#4-响应体：" class="headerlink" title="4.响应体："></a>4.响应体：</h5><p>​    html代码 等</p>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><h5 id="2XX——表明请求被正常处理了"><a href="#2XX——表明请求被正常处理了" class="headerlink" title="2XX——表明请求被正常处理了"></a>2XX——表明请求被正常处理了</h5><p><strong>200 OK</strong>：请求已正常处理。</p>
<p><strong>204 No Content</strong>：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<h5 id="3XX——表明浏览器需要执行某些特殊的处理以正确处理请求"><a href="#3XX——表明浏览器需要执行某些特殊的处理以正确处理请求" class="headerlink" title="3XX——表明浏览器需要执行某些特殊的处理以正确处理请求"></a>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</h5><p><strong>==301 Moved Permanently==</strong>：资源的uri已更新，你也更新下你的书签引用吧。<strong>永久性重定向</strong>，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</p>
<p><strong>==302 Found==</strong>：资源的URI<strong>已临时定位</strong>到其他位置了，姑且算你已经知道了这个情况了。<strong>临时性重定向</strong>。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</p>
<p><strong>303 See Other</strong>：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。<strong>303状态码和302状态码有着相同的功能</strong>，但303状态码明确表示客户端应当<strong>采用GET方法获取资源</strong>，这点与302状态码有区别。</p>
<h5 id="4XX——表明客户端是发生错误的原因所在。"><a href="#4XX——表明客户端是发生错误的原因所在。" class="headerlink" title="4XX——表明客户端是发生错误的原因所在。"></a>4XX——表明客户端是发生错误的原因所在。</h5><p><strong>400 Bad Request</strong>：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</p>
<p><strong>403 Forbidden</strong>：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</p>
<p><strong>404 Not Found</strong>：服务器上没有请求的资源。路径错误等。</p>
<h5 id="5XX——服务器本身发生错误"><a href="#5XX——服务器本身发生错误" class="headerlink" title="5XX——服务器本身发生错误"></a>5XX——服务器本身发生错误</h5><p><strong>500 Internal Server Error：</strong>貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</p>
<p><strong>503 Service Unavailable：</strong>抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>
<h3 id="HTTP-过程"><a href="#HTTP-过程" class="headerlink" title="==HTTP 过程=="></a>==<strong>HTTP 过程</strong>==</h3><ol>
<li>浏览器 分析 URL</li>
<li>DNS 请求解析 IP 地址</li>
<li>DNS 解析出 IP 地址</li>
<li>建立 TCP 连接</li>
<li>取文件</li>
<li>服务器响应</li>
<li>释放 TCP 连接</li>
<li>浏览器显示</li>
</ol>
<h3 id="Ping-命令的过程"><a href="#Ping-命令的过程" class="headerlink" title="==Ping 命令的过程=="></a>==Ping 命令的过程==</h3><h4 id="同一个网段下"><a href="#同一个网段下" class="headerlink" title="同一个网段下"></a>同一个网段下</h4><ul>
<li>如果主机A，要去ping主机B，那么主机A，他会先查自己的MAC地址表，如果没有B的MAC地址，就会向外发送一个ARP广播包</li>
<li>交换机会收到这个报文后，所以他会检索自己有没有保存主机B的MAC地址，如果有，就返回给主机A，如果没有，就会向所有端口发送ARP广播，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会。直到主机B收到了报文后，就立即响应，我的MAC地址是多少，同时学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A。</li>
<li>这时候主机A学到了主机B的MAC地址，就把这个MAC地址封装到ICMP协议的二层报文中向主机B发送</li>
<li>主机B收到了这个报文后，发现是主机A 的ICPM回显请求，就按同样的格式，返回一个值给主机A，这样就完成了同一网段内的ping过程。</li>
</ul>
<h4 id="不同网段内（多了一个或者几个路由器的过程）"><a href="#不同网段内（多了一个或者几个路由器的过程）" class="headerlink" title="不同网段内（多了一个或者几个路由器的过程）"></a>不同网段内（多了一个或者几个路由器的过程）</h4><ul>
<li>如果主机A要ping主机C，那么主机A发现主机C的IP和自己不是同一网段，他就去找网关转发，但是他也不知道网关的MAC地址情况下呢？他就会向之前那个步骤一样先发送一个ARP广播，学到网关的MAC地址，再发封装ICMP报文给网关路由器.。</li>
<li>当路由器收到主机A发过来的ICMP报文，根据目的的IP，查路由表，得到一个出口指针，去掉原来的MAC头部，加上自己的MAC地址向主机C转发。(如果网关也没有主机C的MAC地址，还是要向前面一个步骤一样，ARP广播一下即可相互学到。路由器2端口能学到主机D的MAC地址，主机D也能学到路由器2端口的MAC地址。)报文格式如下：</li>
<li>最后，在主机C已学到路由器2端口MAC地址，路由器2端口转发给路由器1端口，路由1端口学到主机A的MAC地址的情况下，他们就不需要再做ARP解析，就将ICMP的回显请求回复过来。</li>
</ul>
<h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="==HTTPS 协议=="></a>==HTTPS 协议==</h3><h4 id="什么是-HTTPS"><a href="#什么是-HTTPS" class="headerlink" title="什么是 HTTPS"></a>什么是 HTTPS</h4><p>​    HTTP + SSL 安全套接字</p>
<h4 id="HTTPS-的详细握手过程"><a href="#HTTPS-的详细握手过程" class="headerlink" title="==HTTPS 的详细握手过程=="></a>==HTTPS 的详细握手过程==</h4><ul>
<li><strong>浏览器向服务端发送请求，请求中包含浏览器支持的加密协议，以及一个随机数。</strong></li>
<li><strong>服务器收到请求后，选择一种非对称加密的算法，把数字证书，签名公钥，身份信息，以及一个随机数发送给浏览器。</strong></li>
<li><strong>浏览器收到后，验证证书的真实性，并用服务器的公钥加密握手信息发给服务器。</strong></li>
<li><strong>服务器解密后，用之前的随机数计算出一个 对称加密的秘钥，以此作为加密信息发送</strong></li>
<li><strong>后续所有的信息发送都是以对称加密的方式进行的。</strong></li>
<li>总结一句话：==就是用对称加密加密了非对称加密的秘钥。在进行传输==</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 网络层</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="计算机网络-网络层"><a href="#计算机网络-网络层" class="headerlink" title="计算机网络 - 网络层"></a>计算机网络 - 网络层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。与IP配套的三个协议：</p>
<pre><code>1.地址解析协议 ARP
2.网际控制报文协议 ICMP
3.网际组管理协议 IGMP
</code></pre><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><a id="more"></a>
<p>ip数据报在首部是固定的20字节，然后首部还包含可变部分，用于填充等。</p>
<pre><code>1.版本：4 | 6 两个值

2.首部长度：占4位，最大值是15

3.区分服务：用来获取更好的服务，一般情况下不使用

4.总长度：包括首部长度和数据部分长度

5.生存时间（TTL）：它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当TTL为0时放弃数据报。

6.协议：指出携带的数据应该上交给哪个协议进行处理，如：ICMP/TCP/UDP等。

7.首部校验和：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。

8.标识：在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。

9.片偏移：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。
</code></pre><h3 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h3><h4 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h4><p>由两部分组成，网络号与主机号，其中不同分类具有不同的网络长度，并且是固定的。</p>
<pre><code>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}
</code></pre><h4 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2.子网划分"></a>2.子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<pre><code>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}
</code></pre><p>如果需要使用子网，则需要配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<blockquote>
<p>注意：外部网络看不到子网的存在。</p>
</blockquote>
<h4 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3.无分类"></a>3.无分类</h4><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<pre><code>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}
</code></pre><p>CIDR 的记法采用在ip地址后面加上网络前缀长度的方法，如：128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h3><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP数据报的源地址和目的地址始终不变，而MAC地址随着链路的改变而改变。</p>
<blockquote>
<p>提示：ARP协议实现由IP地址得到MAC地址</p>
</blockquote>
<p>每一个主机都有一个ARP高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><p>ICMP目的是为了更有效转发IP数据报和提高交付成功的机会，其封装在IP数据报（封装在数据部分）中，但是不属于高层协议。</p>
<h4 id="1-ping"><a href="#1-ping" class="headerlink" title="1.ping"></a>1.ping</h4><p>ping命令是ICMP的一个重要应用，用来测试两台主机的连通性。Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h4 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2.Traceroute"></a>2.Traceroute</h4><p>Traceroute的作用是ICMP的另外一个应用，用来跟踪一个分组从源点到终点的路径，Traceroute发送的IP数据报封装的是无法交付的UDP用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<h3 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h3><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>那么这里就有三个专用地址块：</p>
<pre><code>10.0.0.0 ~ 10.255.255.255
172.16.0.0 ~ 172.31.255.255
192.168.0.0 ~ 192.168.255.255
</code></pre><p>VPN使用公用的互联网作为本机构个专用网之间的通信载体。</p>
<h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h3><p>专用网内部的主机使用本地IP地址又想和互联网主机通信时，可以使用NAT将本地iP转换为全球ip。</p>
<h3 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h3><p>路由器从功能上划分为：路由选择和分组转发。分组转发结构由三部分构成：1.交换结构。2.一组输入端口。3.一组输出端口。</p>
<h4 id="1-路由器转发分组流程"><a href="#1-路由器转发分组流程" class="headerlink" title="1.路由器转发分组流程"></a>1.路由器转发分组流程</h4><h4 id="2-路由选择协议"><a href="#2-路由选择协议" class="headerlink" title="2.路由选择协议"></a>2.路由选择协议</h4><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。我们可以将路由选择协议分为两部分：</p>
<pre><code>1.自治系统内部的路由选择：RIP | OSPF

2.自治系统间的路由选择：BGP
</code></pre><p><strong>1.内部网关协议 RIP</strong><br></p>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<blockquote>
<p>提示：RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
</blockquote>
<p><strong>2.内部网关协议 OSPF</strong><br></p>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p><strong>3.外部网关协议 BGP</strong><br></p>
<p>BGP（边界网关协议）：BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - HTTP协议</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%20-%20HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="计算机网络-HTTP协议"><a href="#计算机网络-HTTP协议" class="headerlink" title="计算机网络 - HTTP协议"></a>计算机网络 - HTTP协议</h2><p>HTTP协议是属于应用层的协议，是超文本传输协议。</p>
<blockquote>
<p>特点：1.支持客户端与服务器模式。2.简单快速。3.无连接。4.无状态。</p>
</blockquote>
<blockquote>
<p>问题：在浏览器地址栏输入URL之后，按下回车之后经历的流程：1.DNS解析（DNS缓存，浏览器缓存…）。2.在DNS找到ip地址之后会根据ip地址进行TCP连接。3.之后浏览器会发送HTTP请求。4.紧接着服务器请求并返回HTTP报文。5.浏览器解析渲染页面。6.浏览器释放TCP连接。</p>
</blockquote>
<blockquote>
<p>GET请求和POST请求的区别：1.HTTP报文层面，GET请求将信息放在URL中，POST请求将请求信息放在报文体中。2.在数据库层面，GET符合幂等性（对数据库一次操作和多次操作获得的结果是一致的）和安全性，POST不符合。3.GET请求可以被缓存、被存储，而POST请求不行。</p>
</blockquote>
<blockquote>
<p>Cookie和Session的区别：</p>
</blockquote>
<h3 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1.Cookie"></a>1.Cookie</h3><pre><code>1.Cookie是由服务器发送给客户端的特殊信息，以文本的形式存放在客户端。

2.客户端再次请求的时候，会把Cookie回发。

3.服务器接收到后，会解析Cookie生成与客户端相对应的内容。
</code></pre><h4 id="Cookie的设置和发送过程"><a href="#Cookie的设置和发送过程" class="headerlink" title="Cookie的设置和发送过程"></a>Cookie的设置和发送过程</h4><pre><code>1.客户端向服务器发送一个HTTP请求

2.服务器发送一个HTTP Response 和 Set-Cookie到客户端

3.客户端发送一个HTTP request 和 Cookie到服务器

4.服务器发送一个Http响应到客户端
</code></pre><h3 id="2-Session"><a href="#2-Session" class="headerlink" title="2.Session"></a>2.Session</h3><pre><code>1.Session是服务器端的机制，在服务器上保存的信息

2.解析客户端请求并操作SessionId，按需保存状态信息
</code></pre><h4 id="Session的实现方式"><a href="#Session的实现方式" class="headerlink" title="Session的实现方式"></a>Session的实现方式</h4><pre><code>1.使用Cookie实现

    在客户端发起http请求之后，服务器返回response和一个sessionId

2.使用URL回写实现
</code></pre><blockquote>
<p>两者之间的区别：1.Cookie数据存放在客户的浏览器上，Session数据存放在服务器上。2.Session相对于Cookie更安全。3.如果考虑减轻服务器负担，应当使用Cookie。</p>
</blockquote>
<blockquote>
<p>HTTP和HTTPS的区别：</p>
</blockquote>
<pre><code>1.SSL：安全套接层，为网络通信提供安全及数据完整性的一种安全协议。是操作系统对外的API，SSL3.0之后更名TLS。采用身份验证和数据加密保证网络通信的安全和数据的完整性。
</code></pre><h4 id="HTTPS数据传输流程"><a href="#HTTPS数据传输流程" class="headerlink" title="HTTPS数据传输流程"></a>HTTPS数据传输流程</h4><pre><code>1.浏览器将支持的加密算法信息发送给服务器

2.服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器

3.浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器

4.服务器使用私密解密信息，验证哈希，加密响应消息回发浏览器

5.浏览器解密响应信息，对消息进行验真，之后进行加密交互数据
</code></pre><blockquote>
<p>两者之间的区别：1.HTTPS需要到CA申请证书，HTTP不需要。2.HTTPS密文传输，HTTP明文传输。3.连接方式不同，HTTPS默认使用443端口，HTTP使用80端口。4.HTTPS=HTTP+加密+认证+完整性保护，相对于HTTP来说安全。</p>
</blockquote>
<h4 id="HTPS"><a href="#HTPS" class="headerlink" title="HTPS"></a>HTPS</h4><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><pre><code>在网络中可以利用 协议+ip地址+端口号 唯一标识一个网络进程。
</code></pre><p>Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口。</p>
<h4 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a>Socket通信流程</h4><pre><code>1.服务器

    1.创建socket socket()

    2.绑定socket和端口号 bind()

    3.监听该端口号 listen()

    4.接收来自客户端的连接请求 accept()

    5.从socket中读取字符 recv()

    6.关闭socket close()


2.客户端

    1.创建socket socket()

    2.连接指定的计算机的端口 connect()

    3.向socket中写入信息 send()

    4.关闭socket close()
</code></pre>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 链路层</title>
    <url>/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%20-%20%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="计算机网络-链路层"><a href="#计算机网络-链路层" class="headerlink" title="计算机网络 - 链路层"></a>计算机网络 - 链路层</h2><h4 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h4><p><strong>1.封装成帧</strong><br></p>
<p>表示将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。即在ip数据报之前和之后添加首部和尾部。</p>
<p><strong>2.透明传输</strong><br></p>
<blockquote>
<p>提示：透明表示一个实际存在的事物好像不存在一般。</p>
</blockquote>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判断。所以我们需要在数据部分出现与首部尾部相同内容的前面插入转义字符。</p>
<p>如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。在这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<p><strong>3.差错检测</strong><br></p>
<p>循环冗余检验（CRC）来检查比特差错。</p>
<h4 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h4><p><strong>1.广播信道</strong><br></p>
<p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有节点都在同一广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（碰撞）。主要有两种控制方法进行协调：1.信道复用技术。2.CSMA/CD协议。</p>
<p><strong>2.点对点信道</strong><br></p>
<p>一对一通信，因为不会发生碰撞，所以比较简单，使用ppp协议进行控制。</p>
<h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><p><strong>1.频分复用</strong><br></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 中介</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是用来降低多个对象和类之间的通信复杂性。该模式提供一个中介类，该类负责处理不同类之间的通信。</p>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p><strong>1.创建中介类</strong><br></p>
<pre><code>import java.util.Date;
public class ChatRoom {
   public static void showMessage(User user, String message){
      System.out.println(new Date().toString()
         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);
   }
}
</code></pre><p><strong>2.创建user类</strong><br></p>
<pre><code>public class User {
   private String name;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

   public User(String name){
      this.name  = name;
   }

   public void sendMessage(String message){
      ChatRoom.showMessage(this,message);
   }
}
</code></pre><p><strong>3.使用User对象来显示它们之间的通信</strong><br></p>
<pre><code>public class MediatorPatternDemo {
   public static void main(String[] args) {
      User robert = new User(&quot;Robert&quot;);
      User john = new User(&quot;John&quot;);

      robert.sendMessage(&quot;Hi! John!&quot;);
      john.sendMessage(&quot;Hello! Robert!&quot;);
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>中介者模式提供了一种简化复杂交互的解决方案，其引入一个中介者，将原本对象之间的两两交互转换成为每一个对象与中介者之间的交互，中介者可以对对象之间的通信进行控制和协调，极大降低原有系统的耦合度，使得系统更加灵活，易于扩展。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 享元</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>提示：享元，表示共享元器件，即复用已经生成的对象。而复用最简单的方式是用一个HashMap来存放每次新生成的对象。每次需要一个对象时，就去HashMap里面找。如果没有再生成新的对象不迟。</p>
</blockquote>
<p>该模式主要用于减少创建对象的数量，从而能够减少内存的占用和提高性能。其提供减少对象数量从而改善应用所需的对象结构的方式。该模式尝试重用现有的类对象，如果没有找到匹配的对象，则创建新对象。也就是在大量对象存在的时候将共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<blockquote>
<p>提示：如果系统中存在大量的对象，且这些对象消耗大量的内存，这些对象的状态大部分可以外部化。</p>
</blockquote>
<p>概括：减少对象创建的数量，减少内存的占用，提高性能</p>
<p>场景</p>
<pre><code>1. 系统底层开发，以便解决系统的性能问题。如：java.lang.String、数据库连接池，如果有则返回，没有则创建一个字符串并保存在缓存池里面

2. 系统中有大量相似的对象，需要缓冲池的场景
</code></pre><p>优点</p>
<pre><code>1. 减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率

2. 减少内存之外的其它资源占用
</code></pre><p>缺点</p>
<pre><code>1. 关注内/外部状态、关注线程安全问题

2. 系统、程序逻辑比较复杂
</code></pre><p>扩展</p>
<pre><code>1. 内部状态 不会随着环境改变而改变的状态，在享元对象的内部

    是享元对象的属性

    private String title = &quot;manager&quot;;//final属性，不可改变

2. 外部状态 随着环境的改变而改变的状态，不可共享的状态
</code></pre><p>相关的设计模式</p>
<pre><code>1. 享元模式与代理模式

2. 享元模式与单例模式

是一种复用对象的思想
</code></pre><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><strong>1.创建一个接口</strong><br></p>
<pre><code>public interface Shape {
    void draw();
}
</code></pre><p><strong>2.创建实现接口的实体类</strong><br></p>
<pre><code>public class Circle implements Shape {
   private String color;
   private int x;
   private int y;
   private int radius;

   public Circle(String color){
      this.color = color;     
   }

   public void setX(int x) {
      this.x = x;
   }

   public void setY(int y) {
      this.y = y;
   }

   public void setRadius(int radius) {
      this.radius = radius;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Circle: Draw() [Color : &quot; + color 
         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);
   }
}
</code></pre><p><strong>3.创建一个工厂 生成基于给定信息的实体类的对象</strong><br></p>
<pre><code>import java.util.HashMap;
public class ShapeFactory {

   //这里先创建一个存储新生成对象的HashMap
   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();

   public static Shape getCircle(String color) {
      Circle circle = (Circle)circleMap.get(color);

      if(circle == null) {
         circle = new Circle(color);
         circleMap.put(color, circle);
         System.out.println(&quot;Creating circle of color : &quot; + color);
      }
      return circle;
   }
}
</code></pre><p><strong>4.使用该工厂 通过传递颜色信息来获取实体类的对象</strong><br></p>
<pre><code>public class FlyweightPatternDemo {
   private static final String colors[] = 
      { &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; };
   public static void main(String[] args) {

      for(int i=0; i &lt; 20; ++i) {
         Circle circle = 
            (Circle)ShapeFactory.getCircle(getRandomColor());
         circle.setX(getRandomX());
         circle.setY(getRandomY());
         circle.setRadius(100);
         circle.draw();
      }
   }
   private static String getRandomColor() {
      return colors[(int)(Math.random()*colors.length)];
   }
   private static int getRandomX() {
      return (int)(Math.random()*100 );
   }
   private static int getRandomY() {
      return (int)(Math.random()*100);
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>享元模式就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下，可以使用享元模式。所以此模式是先利用已创建的对象，通过某种规则判断当前所需对象是否可以利用已存在对象作相应修改后得到想要的效果。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code>1. Integer

    - valueOf() 在这了解IntegerCache 如果在-128-127之间，会直接从缓存中取值，否则会新建对象

2. Long

    - LongCache

3. GenericObjectPool

    - Tomcat连接池，在连接池中保存Deque对象。
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 代理</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式中一个类代表另一个类的功能，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<blockquote>
<p>注意：该模式和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。该模式和装饰器模式的区别：装饰器模式为了增强功能，而代理模式为了加以控制。</p>
</blockquote>
<blockquote>
<p>提示：是最常用的模式之一，用一个代理来隐藏具体实现细节，通常还用于在真实的实现前后添加一部分逻辑。</p>
</blockquote>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p><strong>1.创建接口</strong><br></p>
<pre><code>public interface Image {
    void display();
}
</code></pre><p><strong>2.创建实现接口的实体类</strong><br></p>
<pre><code>public class RealImage implements Image {

   private String fileName;

   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }

   @Override
   public void display() {
      System.out.println(&quot;Displaying &quot; + fileName);
   }

   private void loadFromDisk(String fileName){
      System.out.println(&quot;Loading &quot; + fileName);
   }
}

//这里的代理要表现得就像是真实类
public class ProxyImage implements Image{

   //在内部需要一个真实实现类
   private RealImage realImage;

   private String fileName;

   public ProxyImage(String fileName){
      this.fileName = fileName;
   }

   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}
</code></pre><p><strong>3.当被请求时 使用 ProxyImage 来获取 RealImage 类的对象</strong><br></p>
<pre><code>public class ProxyPatternDemo {
   public static void main(String[] args) {
      Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);

      // 图像将从磁盘加载
      image.display(); 
      System.out.println(&quot;&quot;);
      // 图像不需要从磁盘加载
      image.display();  
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>代理在实际意义上就是 方法包装 和 方法增强。在AOP中就是动态代理的过程。</p>
<p><strong>1.JDK动态代理</strong><br></p>
<pre><code>1.java.lang.reflect.Proxy 生成动态代理类和对象
2.java.lang.reflect.InvocationHandler(处理器接口) 可通过invoke()方法实现
</code></pre><blockquote>
<p>注意：此动态代理对真实角色的代理访问，每次都是通过Proxy生成的代理类对象都要指定对应的处理器对象。</p>
</blockquote>
<pre><code>1.接口

    public interface Subject {
        public int sellBooks();
        public String speak();
    }

2.真实对象

    public class RealSubject implements Subject {
        @Override 
        public int sellBooks(){
            System.out.println(&quot;sellbooks&quot;);
            return 1;
        }

        @Override
        public String speak() {
            System.out.println(&quot;说话&quot;);
            return &quot;张三&quot;;
        }
    }

3.处理对象

    public class MyInvocationHandler implements InvocationHandler {

        //这里需要处理真实角色 所以传入真实角色
        Subject realSubject;

        public MyInvocationHandler(Subject subject){
            this.realSubject = subject;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println(&quot;调用代理类&quot;);
            if(method.getName().equals(&quot;sellBooks&quot;)){
                int invoke = (int)method.invoke(realSubject, args);
                System.out.println(&quot;调用的是卖书的方法&quot;);
                return invoke ;
            }else {
                String string = (String) method.invoke(realSubject,args) ;
                System.out.println(&quot;调用的是说话的方法&quot;);
                return  string ;
            }
        }
    }

4.调用 main.java

    public class Client {
        public static void main(String[] args){
            //真实对象
            Subject subject = new RealSubject();

            MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject);

            //代理对象
            Subject proxyClass = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader, new Class[]{Subject.class}, myInvocationHandler);

            proxyClass.sellBooks();
            proxyClass.speak();
        }
    }
</code></pre><p><strong>2.Cglib动态代理</strong><br></p>
<pre><code>1.被代理类

    public class Engineer {
        //该方法可以被代理
        public void eat(){
            System.out.println(&quot;正在吃饭...&quot;);
        }

        //final方法不会被生成的子类覆盖
        public final void work(){
            System.out.println(&quot;正在工作...&quot;);
        }

        //private方法不会被生成的子类覆盖
        private void play(){
            System.out.println(&quot;正在玩耍...&quot;);
        }
    }

2.cglib代理类

    ...
    public class CglibProxy implements MethodInterceptor {
        private Object target;

        public CglibProxy(Object target){
            this.target = target;
        }

        @Override
        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
            System.out.println(&quot;###   before invocation&quot;);
            Object result = method.invoke(target, objects);
            System.out.println(&quot;###   end invocation&quot;);
            return result;
        }

        public static Object getProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        // 设置需要代理的对象
        enhancer.setSuperclass(target.getClass());
        // 设置代理人
        enhancer.setCallback(new CglibProxy(target));
        return enhancer.create();

        }
    }

3.测试

    public class CglibMainTest {
        public static void main(String[] args) {
            // 生成 Cglib 代理类
            Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer());
            // 调用相关方法
            engineerProxy.eat();
        }
    }
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 单例</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该类型模式属于创建型模式，提供了一种创建对象的最佳方式。该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。此类提供一种访问其唯一的对象的方式，可直接访问，不需要实例化该类对象。</p>
<blockquote>
<p>注意：1.单例类只能有一个实例 2.单例类必须自己创建自己的唯一实例 3.单例类必须给所有其它对象提供这一实例</p>
</blockquote>
<p>单例模式的优点：</p>
<pre><code>1. 对于频繁使用的对象，可以省略new操作花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销。

2. 由于new操作的次数减少，因为对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。
</code></pre><h4 id="单例模式的具体实现"><a href="#单例模式的具体实现" class="headerlink" title="单例模式的具体实现"></a>单例模式的具体实现</h4><p><strong>1.创建Singleton类</strong><br></p>
<pre><code>public class SingleObject {

   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();

   //让构造函数为 private，这样该类就不会被实例化 new Singleton()
   private SingleObject(){}

   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }

   public void showMessage(){
      System.out.println(&quot;Hello World!&quot;);
   }
}
</code></pre><p><strong>2.从新创建的Singleton类获取唯一对象</strong><br></p>
<pre><code>public class SingletonPatternDemo {
    public static void main(String[] args){
          //不合法的构造函数
          //编译时错误：构造函数 SingleObject() 是不可见的
          //SingleObject object = new SingleObject();

          //获取唯一可用的对象
          SingleObject object = SingleObject.getInstance();

          //显示消息
          object.showMessage();
    }
}
</code></pre><h4 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h4><p><strong>1.懒汉式(线程不安全)</strong><br><br>这种方式是基本的实现方式，但是此实现不支持多线程，因为没有加锁synchronized。</p>
<pre><code>public class Singleton {  
    private static Singleton instance; 
    //堵死 new Singleton() 路
    private Singleton (){}  

    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
</code></pre><p><strong>2.懒汉式(线程安全)</strong><br><br>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是效率很低。必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p>
<pre><code>public class Singleton {  
    private static Singleton instance;  

    //堵死 new Singleton() 路
    private Singleton (){}  

    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
</code></pre><p><strong>3.饿汉式</strong><br><br>该模式先将单例进行实例化，获取的时候通过静态方法直接获取即可。缺点是类加载后就完成了类的实例化，浪费部分空间。这种方式常用，但是容易产生垃圾对象，这种方式没有加锁，执行效率很高。但是在类加载时就初始化，浪费内存。</p>
<pre><code>public class Singleton {  
    //这一句是饿汉模式的核心
    private static Singleton instance = new Singleton();  

    private Singleton (){}  

    public static Singleton getInstance() {  
    return instance;  
    }  
}
</code></pre><p><strong>4.双检锁/双重校验锁（DCL double-checked locking）</strong><br><br>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p>
<pre><code>public class Singleton { 
    //采用volatile修饰单例，然后通过一次检查判断单例是否初始化
    private volatile static Singleton singleton;  

    private Singleton (){}  
    public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;  
    }  
}
</code></pre><p><strong>5.登记式/静态内部类</strong><br><br>这种方式能达到双检锁方式一样的功效。这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程</p>
<pre><code>public class Singleton {  

    //静态内部类只有在被使用的时候才会初始化
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();  
    }  

    private Singleton (){}  

    public static final Singleton getInstance() { 

        return SingletonHolder.INSTANCE;  
    }  
}
</code></pre><p><strong>6.枚举</strong><br><br>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。枚举类在类加载的时候会初始化里面所有的实例，而且JVM保证它们不会被实例化，所以天生是单例的。</p>
<pre><code>public enum Singleton {  
    //枚举类确保每一个列对象在全局是唯一的。
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>懒汉式和饿汉式的根本区别在于是否在类内方法外创建自己的对象，同时声明对象私有化，构造方法私有化，从而外部不能通过new对象的方式来访问。而饿汉式的话是声明并且创建对象，懒汉式只是声明对象，在调用该类的getInstance()方法时才会进行new对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 原型</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是用于创建重复的对象，同时又能够保证性能。这种类型的设计模式是一种创建对象的模式。这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。</p>
<blockquote>
<p>注意：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable 重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
</blockquote>
<blockquote>
<p>提示：该模式一般通过一个实例进行克隆从而获得更多同一原型的实例，使用实例的clone()方法即可完成。</p>
</blockquote>
<h4 id="原型模式（深克隆和浅克隆）"><a href="#原型模式（深克隆和浅克隆）" class="headerlink" title="原型模式（深克隆和浅克隆）"></a>原型模式（深克隆和浅克隆）</h4><p>浅克隆：所谓浅克隆只在类那一层进行克隆。</p>
<p>深克隆：在clone()方法那块儿进行clone()设置。</p>
<h4 id="原型模式在JDK源码中应用"><a href="#原型模式在JDK源码中应用" class="headerlink" title="原型模式在JDK源码中应用"></a>原型模式在JDK源码中应用</h4><ul>
<li>clone() 方法</li>
<li>Cloneable 接口</li>
<li></li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><strong>1.创建一个实现Cloneable接口的抽象类(原型角色)</strong><br></p>
<pre><code>//1.（抽象类或者接口）实现 java.lang.Cloneable 接口
public abstract class Shape implements Cloneable {

   private String id;
   protected String type;

   abstract void draw();

   public String getType(){
      return type;
   }

   public String getId() {
      return id;
   }

   public void setId(String id) {
      this.id = id;
   }

   //具体原型角色
   public Object clone() {//2.定义复制现有实例来生成新实例的方法
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}
</code></pre><p><strong>2.创建扩展上面抽象类的实体类</strong><br></p>
<pre><code>public class Rectangle extends Shape {

   public Rectangle(){
     type = &quot;Rectangle&quot;;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   }
}

public class Square extends Shape {

   public Square(){
     type = &quot;Square&quot;;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   }
}

public class Circle extends Shape {

   public Circle(){
     type = &quot;Circle&quot;;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   }
}
</code></pre><p><strong>3.创建一个类 从数据库获取实体类 并把它们存储在一个 Hashtable 中 </strong><br></p>
<pre><code>import java.util.Hashtable;

public class ShapeCache {
    //维护一个注册表
    private static Hashtable&lt;String, Shape&gt; shapeMap 
      = new Hashtable&lt;String, Shape&gt;();

    public static Shape getShape(String shapeId) {//提供一个获取新实例的方法
      Shape cachedShape = shapeMap.get(shapeId);//提供一个找出正确实例原型的方法
      return (Shape) cachedShape.clone();//委托复制实例的方法生成新实例。
   }

   // 对每种形状都运行数据库查询，并创建该形状
   // shapeMap.put(shapeKey, shape);
   // 例如，我们要添加三种形状
   public static void loadCache() {
      Circle circle = new Circle();
      circle.setId(&quot;1&quot;);
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId(&quot;2&quot;);
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId(&quot;3&quot;);
      shapeMap.put(rectangle.getId(),rectangle);
   }
}
</code></pre><p><strong>4.PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆</strong><br></p>
<pre><code>public class PrototypePatternDemo {
   public static void main(String[] args) {
      ShapeCache.loadCache();

      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);
      System.out.println(&quot;Shape : &quot; + clonedShape.getType());        

      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);
      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());        

      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);
      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());        
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在原型模式中有三个角色：原型角色，定义用于复制现有实例来生成新实例的方法。 具体原型角色，实现用于复制现有实例来生成新实例的方法。 使用者角色，维护一个注册表，并提供一个找出正确实例原型的方法。最后提供一个获取新实例的方法，用来委托复制实例的方法生成新实例。</p>
<blockquote>
<p>总结：对于原型模式，我们可以理解为对象的复制。在原型模式中因为复制的对象之间有差别，所以存在有深复制和浅复制。浅拷贝，其实就是引用，两者之间指向同一块内存区域。深拷贝，其实就是开辟另一块内存空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 备忘录</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式表示保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<p>概括：后悔药</p>
<p>场景</p>
<pre><code>1. 保存和恢复数据相关业务场景

2. 后悔的时候，即想恢复到之前的状态
</code></pre><p>优点</p>
<pre><code>1. 为用户提供一种可恢复机制

2. 存档信息的封装
</code></pre><p>缺点</p>
<pre><code>1. 资源占用
</code></pre><p>相关设计模式</p>
<pre><code>1. 备忘录模式与状态模式

2. 
</code></pre><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><strong>1.创建Memento类</strong><br></p>
<pre><code>public class Memento {
   private String state;

   public Memento(String state){
      this.state = state;
   }

   public String getState(){
      return state;
   }  
}
</code></pre><p><strong>2.创建Originato类</strong><br></p>
<pre><code>public class Originator {
   private String state;

   public void setState(String state){
      this.state = state;
   }

   public String getState(){
      return state;
   }

   public Memento saveStateToMemento(){
      return new Memento(state);
   }

   public void getStateFromMemento(Memento Memento){
      state = Memento.getState();
   }
}
</code></pre><p><strong>3.创建CareTask类</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class CareTaker {
   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();

   public void add(Memento state){
      mementoList.add(state);
   }

   public Memento get(int index){
      return mementoList.get(index);
   }
}
</code></pre><p><strong>4.使用 CareTaker 和 Originator 对象</strong><br></p>
<pre><code>public class MementoPatternDemo {
   public static void main(String[] args) {
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState(&quot;State #1&quot;);
      originator.setState(&quot;State #2&quot;);

      //这里只存储了2,1没有存（被覆盖了）
      careTaker.add(originator.saveStateToMemento());

      originator.setState(&quot;State #3&quot;);
      careTaker.add(originator.saveStateToMemento());

      originator.setState(&quot;State #4&quot;);

      System.out.println(&quot;Current State: &quot; + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));
      System.out.println(&quot;First saved State: &quot; + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println(&quot;Second saved State: &quot; + originator.getState());
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>该模式是将之前已有的操作存储起来，到需要用到的时候直接去之前存好的内存中取出来用即可。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 命令</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并且传给调用对象。调用对象寻找可以处理该命令的合适对象，并将该命令传给相应的对象，该对象执行命令。</p>
<blockquote>
<p>注意：系统需要支持命令的撤销和恢复操作，可以使用命令模式。</p>
</blockquote>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>1.创建命令接口</strong><br></p>
<pre><code>public interface Order {
   void execute();
}
</code></pre><p><strong>2.创建请求类</strong><br></p>
<pre><code>public class Stock {
   private String name = &quot;ABC&quot;;
   private int quantity = 10;

   public void buy(){
      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, 
         Quantity: &quot; + quantity +&quot; ] bought&quot;);
   }
   public void sell(){
      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, 
         Quantity: &quot; + quantity +&quot; ] sold&quot;);
   }
}
</code></pre><p><strong>3.创建实现 Order 接口的实体类</strong><br></p>
<pre><code>public class BuyStock implements Order {
   private Stock abcStock;

   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.buy();
   }
}

public class SellStock implements Order {
   private Stock abcStock;

   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.sell();
   }
}
</code></pre><p><strong>4.创建命令调用类</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

   public class Broker {
   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); 

   public void takeOrder(Order order){
      orderList.add(order);      
   }

   public void placeOrders(){
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}
</code></pre><p><strong>5.使用 Broker 类来接受并执行命令</strong><br></p>
<pre><code>public class CommandPatternDemo {
   public static void main(String[] args) {
      Stock abcStock = new Stock();

      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);

      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);

      broker.placeOrders();
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>命令模式将请求发送者和请求接收者解耦，请求发送者通过命令对象间引用接收者。将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 外观</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
<blockquote>
<p>注意：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
</blockquote>
<p>子系统越来越复杂，增加外观模式提供简单调用接口。构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。</p>
<p>优点</p>
<pre><code>1. 简化调用过程，无需了解深入子系统，防止带来风险

2. 减少系统依赖、松散耦合

3. 更好的划分访问层次

4. 符合迪米特法则，最少知道原则
</code></pre><p>缺点</p>
<pre><code>1. 增加子系统、扩展子系统行为容易带来风险

2. 不符合开闭原则
</code></pre><p>相关设计模式</p>
<pre><code>1. 中介者模式

2. 单例模式

3. 抽象工厂模式
</code></pre><h4 id="外观模式具体实现"><a href="#外观模式具体实现" class="headerlink" title="外观模式具体实现"></a>外观模式具体实现</h4><p><strong>1.创建接口</strong><br></p>
<pre><code>public interface Shape {
   void draw();
}
</code></pre><p><strong>2.创建实现接口的实体类</strong><br></p>
<pre><code>public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Rectangle::draw()&quot;);
   }
}

public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Square::draw()&quot;);
   }
}

public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Circle::draw()&quot;);
   }
}
</code></pre><p><strong>3.创建一个外观类</strong><br></p>
<pre><code>public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;

   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }

   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
</code></pre><p><strong>4.使用该外观类画出各种类型的形状</strong><br></p>
<pre><code>public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();

      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里的外观模式可以形象的表示为将所有的功能都集成在一个类里面，然后该类提供一个接口给用户，用户通过此接口使用该类里面定义的功能。</p>
<h4 id="外观模式在源码中的应用"><a href="#外观模式在源码中的应用" class="headerlink" title="外观模式在源码中的应用"></a>外观模式在源码中的应用</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 工厂</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>工厂模式是Java中最常用的设计模式之一。它提供一种创建对象的最佳方式。在这一模式中在创建对象的时候不会对客户端暴露创建逻辑，同时使用一个共同的接口来指向新创建的对象。</p>
<blockquote>
<p>注意：该模式是一种创建类模式，在任何需要生成复杂对象的地方，都能够使用工厂方法模式。同时还需注意，复杂对象适合使用工厂模式，而简单对象，特别是只需要同时new就可以完成创建的对象，无需使用工厂模式。<code>如果需要使用工厂模式，就需要引入一个类，会增加系统的复杂度</code>。</p>
</blockquote>
<pre><code>1.该模式是一种创建对象的模式。
2.该模式将创建对象的责任转移到工厂类。
</code></pre><blockquote>
<blockquote>
<p>提示：简单工厂一般是用一个工厂创建多个类的实例。工厂模式一般是指一个工厂服务一个接口，为这个接口的实现类进行实例化。</p>
</blockquote>
</blockquote>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p><strong>1.创建接口 Shape.java</strong><br></p>
<pre><code>public interface Shape {
    void draw();
}
</code></pre><p><strong>2.创建实现接口的实现类</strong><br></p>
<pre><code>public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   }
}

public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   }
}

public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   }
}
</code></pre><p><strong>3.创建一个工厂 生成基于给定信息的实体类对象</strong><br></p>
<pre><code>public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }
}
</code></pre><p><strong>4.使用该工厂 通过传递类型信息来获取实体类的对象</strong><br></p>
<pre><code>public class FactoryPatternDemo {
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);

      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面提供的只是一个简单的普通工厂模式，除此之外还有多个工厂模式和静态工厂模式。</p>
<blockquote>
<p>多个工厂模式：该模式是对普通工厂模式的改进，其提供多个工厂方法，分别创建对象。</p>
</blockquote>
<blockquote>
<p>静态工厂模式：将上面多个工厂模式里面的方法设置为静态的，不需要创建实例，直接调用便可。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 建造</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是使用多个简单的对象一步一步构建成一个复杂的对象。一个Builder类会一步一步构造最终的对象。该Builder类是独立于其它对象的。</p>
<blockquote>
<p>提示：经常碰到的XxxBuilder类就是建造者的产物。套路：1.首先new一个Builer。2.然后可以链式的调用一堆方法。3.最后调用build()方法。</p>
</blockquote>
<blockquote>
<p>提示：建造者模式有个概念叫做链式调用。</p>
</blockquote>
<h4 id="建造者模式的具体实现"><a href="#建造者模式的具体实现" class="headerlink" title="建造者模式的具体实现"></a>建造者模式的具体实现</h4><p><strong>1.创建表示食物条目和食物包装的接口</strong><br></p>
<pre><code>public interface Item {
   public String name();
   public Packing packing();
   public float price();    
}

public interface Packing {
   public String pack();
}
</code></pre><p><strong>2.创建实现Packing接口的实体类</strong><br></p>
<pre><code>public class Wrapper implements Packing {
   @Override
   public String pack() {
      return &quot;Wrapper&quot;;
   }
}

public class Bottle implements Packing {
   @Override
   public String pack() {
      return &quot;Bottle&quot;;
   }
}
</code></pre><p><strong>3.创建实现 Item 接口的抽象类 该类提供了默认的功能</strong><br></p>
<pre><code>public abstract class Burger implements Item {
   @Override
   public Packing packing() {
      return new Wrapper();
   }

   @Override
   public abstract float price();
}

public abstract class ColdDrink implements Item {
    @Override
    public Packing packing() {
       return new Bottle();
    }

    @Override
    public abstract float price();
}
</code></pre><p><strong>4.创建扩展 Burger 和 ColdDrink 的实体类</strong><br></p>
<pre><code>public class VegBurger extends Burger {

   @Override
   public float price() {
      return 25.0f;
   }

   @Override
   public String name() {
      return &quot;Veg Burger&quot;;
   }
}

public class ChickenBurger extends Burger {

   @Override
   public float price() {
      return 50.5f;
   }

   @Override
   public String name() {
      return &quot;Chicken Burger&quot;;
   }
}

public class Coke extends ColdDrink {
   @Override
   public float price() {
      return 30.0f;
   }

   @Override
   public String name() {
      return &quot;Coke&quot;;
   }
}

public class Pepsi extends ColdDrink {
   @Override
   public float price() {
      return 35.0f;
   }

   @Override
   public String name() {
      return &quot;Pepsi&quot;;
   }
}
</code></pre><p><strong>5.创建一个Meal类 带有上面定义的Item对象</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class Meal {
   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    

   public void addItem(Item item){
      items.add(item);
   }

   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }

   public void showItems(){
      for (Item item : items) {
         System.out.print(&quot;Item : &quot;+item.name());
         System.out.print(&quot;, Packing : &quot;+item.packing().pack());
         System.out.println(&quot;, Price : &quot;+item.price());
      }        
   }    
}
</code></pre><p><strong>6.创建一个 MealBuilder 类 实际的 builder 类负责创建 Meal 对象</strong><br></p>
<pre><code>public class MealBuilder {
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   

   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
</code></pre><p><strong>7.BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）</strong><br></p>
<pre><code>public class BuilderPatternDemo {
   public static void main(String[] args) {
      MealBuilder mealBuilder = new MealBuilder();

      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println(&quot;Veg Meal&quot;);
      vegMeal.showItems();
      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());

      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println(&quot;\n\nNon-Veg Meal&quot;);
      nonVegMeal.showItems();
      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>建造者模式主要包含四个角色：产品角色(具体产品对象) | 抽象建造者 | 具体建造者 | 指挥者。</p>
<pre><code>1.首先定义产品的变量(主体)，是一个具体的产品对象。
2.抽象建造者定义产品的创建方法和返回方法。
3.具体建造者：实现抽象接口，构建和装配各个部件。
4.构建一个使用Builder接口的对象。主要用于创建一个复杂的对象。
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 抽象工厂</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是围绕一个超级工厂创建其它工厂，该超级工厂又称为其他工厂的工厂。它提供了一种创建对象的最佳方式。在该模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<blockquote>
<p>提示：抽象工厂模式是指一个工厂服务于一个产品族，一个产品族可能会包含多个接口，接口又会包含多个实现类，通过一个工厂就可以将这些绑定在一起。涉及到产品族的问题一般需要抽象模式来支持。</p>
</blockquote>
<pre><code>//这里以造电脑为例
//1.首先直接定义电脑工厂，每个电脑工厂负责生产所有设备
//2.在电脑工厂中定义做Cpu的和做主板的
//3.然后其它的所有工厂都来继承实现该超级工厂
</code></pre><blockquote>
<p>注意：在需要新加方法的时候，需要修改所有的工厂，给所有的工厂都加上新的方法。</p>
</blockquote>
<h4 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h4><p><strong>1.创建接口 形状</strong><br></p>
<pre><code>public interface Shape {
    void draw();
}
</code></pre><p><strong>2.创建实现接口 形状的实体类</strong><br></p>
<pre><code>public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   }
}

public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   }
}

public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   }
}
</code></pre><p><strong>3.创建接口 颜色</strong><br></p>
<pre><code>public interface Color {
   void fill();
}
</code></pre><p><strong>4.创建实现接口 颜色的实体类</strong><br></p>
<pre><code>public class Red implements Color {
   @Override
   public void fill() {
      System.out.println(&quot;Inside Red::fill() method.&quot;);
   }
}

public class Green implements Color {
    @Override
    public void fill() {
       System.out.println(&quot;Inside Green::fill() method.&quot;);
   }
}

public class Blue implements Color {
   @Override
   public void fill() {
      System.out.println(&quot;Inside Blue::fill() method.&quot;);
   }
}
</code></pre><p><strong>5.为 Color 和 Shape 对象创建抽象类来获取工厂</strong><br></p>
<pre><code>public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape) ;
}
</code></pre><p><strong>6.创建扩展了 AbstractFactory 的工厂类 基于给定的信息生成实体类的对象</strong><br></p>
<pre><code>public class ShapeFactory extends AbstractFactory {
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }

   @Override
   public Color getColor(String color) {
      return null;
   }
}


public class ColorFactory extends AbstractFactory {
   @Override
   public Shape getShape(String shapeType){
      return null;
   }

   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase(&quot;RED&quot;)){
         return new Red();
      } else if(color.equalsIgnoreCase(&quot;GREEN&quot;)){
         return new Green();
      } else if(color.equalsIgnoreCase(&quot;BLUE&quot;)){
         return new Blue();
      }
      return null;
   }
}
</code></pre><p><strong>7.创建一个工厂创造器/生成器类 通过传递形状或颜色信息来获取工厂</strong><br></p>
<pre><code>public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;)){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase(&quot;COLOR&quot;)){
         return new ColorFactory();
      }
      return null;
   }
}
</code></pre><p><strong>8.使用 FactoryProducer 来获取 AbstractFactory 通过传递类型信息来获取实体类的对象</strong><br></p>
<pre><code>public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {

      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);

      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);

      //调用 Square 的 draw 方法
      shape3.draw();

      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);

      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor(&quot;RED&quot;);

      //调用 Red 的 fill 方法
      color1.fill();

      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor(&quot;Green&quot;);

      //调用 Green 的 fill 方法
      color2.fill();

      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);

      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在工厂模式中，类的创建依赖工厂类，如果想要扩展程序，需要对工厂类进行修改，违反闭包原则。而抽象工厂模式中，创建多个工厂类，如果需要增加新的功能，直接增加新的工厂类便可，不需要修改之前的程序。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 过滤器</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并再将请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p>
<pre><code>1.过滤器：过滤器在请求处理程序执行请求之前或之后执行某些任务。
2.过滤器链：过滤器链带有多个过滤器，并在target上按照定义的顺序执行这些过滤器。
3.target：target对象是请求处理程序。
4.过滤管理器：过滤管理器管理过滤器和过滤器链。
5.客户端：客户端是target对象发送请求的对象。
</code></pre><h4 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h4><p><strong>1.创建过滤器接口</strong><br></p>
<pre><code>public interface Filter {
   public void execute(String request);
}
</code></pre><p><strong>2.创建实体过滤器</strong><br></p>
<pre><code>public class AuthenticationFilter implements Filter {
   public void execute(String request){
      System.out.println(&quot;Authenticating request: &quot; + request);
   }
}

public class DebugFilter implements Filter {
   public void execute(String request){
      System.out.println(&quot;request log: &quot; + request);
   }
}
</code></pre><p><strong>3.创建target</strong><br></p>
<pre><code>public class Target {
   public void execute(String request){
      System.out.println(&quot;Executing request: &quot; + request);
   }
}
</code></pre><p><strong>4.创建过滤器链</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class FilterChain {
   private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();
   private Target target;

   public void addFilter(Filter filter){
      filters.add(filter);
   }

   public void execute(String request){
      for (Filter filter : filters) {
         filter.execute(request);
      }
      target.execute(request);
   }

   public void setTarget(Target target){
      this.target = target;
   }
}
</code></pre><p><strong>5.创建过滤管理器</strong><br></p>
<pre><code>public class FilterManager {
   FilterChain filterChain;

   public FilterManager(Target target){
      filterChain = new FilterChain();
      filterChain.setTarget(target);
   }
   public void setFilter(Filter filter){
      filterChain.addFilter(filter);
   }

   public void filterRequest(String request){
      filterChain.execute(request);
   }
}
</code></pre><p><strong>6.创建客户端</strong><br></p>
<pre><code>public class Client {
   FilterManager filterManager;

   public void setFilterManager(FilterManager filterManager){
      this.filterManager = filterManager;
   }

   public void sendRequest(String request){
      filterManager.filterRequest(request);
   }
}
</code></pre><p><strong>7.使用 Client 来演示拦截过滤器设计模式</strong><br></p>
<pre><code>public class InterceptingFilterDemo {
   public static void main(String[] args) {
      FilterManager filterManager = new FilterManager(new Target());
      filterManager.setFilter(new AuthenticationFilter());
      filterManager.setFilter(new DebugFilter());

      Client client = new Client();
      client.setFilterManager(filterManager);
      client.sendRequest(&quot;HOME&quot;);
   }
}
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 服务器定位</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式用在我们想使用JNDI查询定位各种服务的时候。考虑到为某个服务查找JNDI的代价很高，服务定位器模式充分利用缓存技术。所以在首次请求某个服务的时候，服务定位器在JNDI中查找服务，并缓存该服务对象。所以当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以很大程度上提高应用程序的性能。</p>
<pre><code>1.服务：实际处理请求的服务。
2.context/初始的context：JNDI context带有对要查找的服务的引用。
3.服务定位器：服务定位器是通过JNDI查找和缓存服务来获取服务的单点接触。
4.缓存：缓存服务的引用。
5.客户端：通过ServiceLocator调用服务的对象。
</code></pre><h4 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h4><p><strong>1.创建服务接口Service</strong><br></p>
<pre><code>public interface Service {
   public String getName();
   public void execute();
}
</code></pre><p><strong>2.创建实体服务</strong><br></p>
<pre><code>public class Service1 implements Service {
   public void execute(){
      System.out.println(&quot;Executing Service1&quot;);
   }

   @Override
   public String getName() {
      return &quot;Service1&quot;;
   }
}

public class Service2 implements Service {
   public void execute(){
      System.out.println(&quot;Executing Service2&quot;);
   }

   @Override
   public String getName() {
      return &quot;Service2&quot;;
   }
}
</code></pre><p><strong>3.为 JNDI 查询创建 InitialContext</strong><br></p>
<pre><code>public class InitialContext {
   public Object lookup(String jndiName){
      if(jndiName.equalsIgnoreCase(&quot;SERVICE1&quot;)){
         System.out.println(&quot;Looking up and creating a new Service1 object&quot;);
         return new Service1();
      }else if (jndiName.equalsIgnoreCase(&quot;SERVICE2&quot;)){
         System.out.println(&quot;Looking up and creating a new Service2 object&quot;);
         return new Service2();
      }
      return null;      
   }
}
</code></pre><p><strong>4.创建缓存 Cache</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class Cache {

   private List&lt;Service&gt; services;

   public Cache(){
      services = new ArrayList&lt;Service&gt;();
   }

   public Service getService(String serviceName){
      for (Service service : services) {
         if(service.getName().equalsIgnoreCase(serviceName)){
            System.out.println(&quot;Returning cached  &quot;+serviceName+&quot; object&quot;);
            return service;
         }
      }
      return null;
   }

   public void addService(Service newService){
      boolean exists = false;
      for (Service service : services) {
         if(service.getName().equalsIgnoreCase(newService.getName())){
            exists = true;
         }
      }
      if(!exists){
         services.add(newService);
      }
   }
}
</code></pre><p><strong>5.创建服务定位器</strong><br></p>
<pre><code>public class ServiceLocator {
   private static Cache cache;

   static {
      cache = new Cache();    
   }

   public static Service getService(String jndiName){

      Service service = cache.getService(jndiName);

      if(service != null){
         return service;
      }

      InitialContext context = new InitialContext();
      Service service1 = (Service)context.lookup(jndiName);
      cache.addService(service1);
      return service1;
   }
}
</code></pre><p><strong>6.使用 ServiceLocator 来演示服务定位器设计模式</strong><br></p>
<pre><code>public class ServiceLocatorPatternDemo {
   public static void main(String[] args) {
      Service service = ServiceLocator.getService(&quot;Service1&quot;);
      service.execute();
      service = ServiceLocator.getService(&quot;Service2&quot;);
      service.execute();
      service = ServiceLocator.getService(&quot;Service1&quot;);
      service.execute();
      service = ServiceLocator.getService(&quot;Service2&quot;);
      service.execute();      
   }
}
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 桥接</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是用于将抽象化与实现化解耦，使得二者独立变化。它通过提供抽象化与实现化之间的桥接功能，来实现两者之间的解耦。</p>
<blockquote>
<p>注意：该设计模式实现抽象和实现的分离。而两个独立变化的维度使用桥接模式是最好的选择。</p>
</blockquote>
<p>场景</p>
<pre><code>1. 抽象和具体实现之间增加更多的灵活性

2. 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展

3. 不希望使用继承，或因为过多继承导致系统类的个数增多
</code></pre><p>优点 </p>
<pre><code>1. 分离抽象部分及其具体实现部分

2. 提高系统可扩展性

3. 符合开闭原则

4. 符合合成复用原则
</code></pre><p>缺点</p>
<pre><code>1. 增加了系统的理解与设计难度

2. 需要正确识别系统中两个独立变化的维度
</code></pre><p>相关设计模式</p>
<pre><code>1. 桥接模式与组合模式

2. 桥接模式与适配器模式
</code></pre><h4 id="桥接模式的具体实现"><a href="#桥接模式的具体实现" class="headerlink" title="桥接模式的具体实现"></a>桥接模式的具体实现</h4><p><strong>1.创建桥接实现的接口</strong><br></p>
<pre><code>public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
</code></pre><p><strong>2.创建实现 DrawAPI 接口的实体桥接实现类</strong><br></p>
<pre><code>public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;
         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
   }
}

public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;
         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
   }
}
</code></pre><p><strong>3.使用 DrawAPI 接口创建抽象类 Shape</strong><br></p>
<pre><code>public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}
</code></pre><p><strong>4.创建实现 Shape 接口的实体类</strong><br></p>
<pre><code>public class Circle extends Shape {
   private int x, y, radius;

   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }

   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
</code></pre><p><strong>5.使用 Shape 和 DrawAPI 类画出不同颜色的圆</strong><br></p>
<pre><code>public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());

      redCircle.draw();
      greenCircle.draw();
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>桥接模式案例中可以得到，提供两个父类：颜色和形状。颜色父类和形状父类都包含相应的子类，然后根据需要对颜色和形状进行组合。</p>
<p>桥接模式是将抽象部分和它的实现部分抽离开来，使得它们可以独立变化。</p>
<pre><code>1.抽象化：将复杂的物体的一个或者几个特性抽离出去而只注意其它特性的行动和过程。在面向对象中就是将对象的共同性质抽取出去形成类的过程。

2.实现化：针对类给出的具体实现。

3.脱耦：将抽象化和实现化之间的耦合解脱开，或者是将它们之间的强关联改成弱关联，将两个角色之间的关系从继承改成关联关系。
</code></pre><p><strong>桥接模式的应用场景</strong><br></p>
<pre><code>1.如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。

2.对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

3.一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 模板</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在该模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按照需要重写方法实现，但是调用将以抽象类中定义的方式进行。</p>
<h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p><strong>1.创建一个抽象类 它的模板方法被设置为final</strong><br></p>
<pre><code>public abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();

   //模板
   public final void play(){

      //初始化游戏
      initialize();

      //开始游戏
      startPlay();

      //结束游戏
      endPlay();
   }
}
</code></pre><p><strong>2.创建扩展上述类的实体类</strong><br></p>
<pre><code>public class Cricket extends Game {

   @Override
   void endPlay() {
      System.out.println(&quot;Cricket Game Finished!&quot;);
   }

   @Override
   void initialize() {
      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);
   }

   @Override
   void startPlay() {
      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);
   }
}

public class Football extends Game {

   @Override
   void endPlay() {
      System.out.println(&quot;Football Game Finished!&quot;);
   }

   @Override
   void initialize() {
      System.out.println(&quot;Football Game Initialized! Start playing.&quot;);
   }

   @Override
   void startPlay() {
      System.out.println(&quot;Football Game Started. Enjoy the game!&quot;);
   }
}
</code></pre><p><strong>3.使用 Game 的模板方法 play() 来演示游戏的定义方式</strong><br></p>
<pre><code>public class TemplatePatternDemo {
   public static void main(String[] args) {

      Game game = new Cricket();
      game.play();
      System.out.println();
      game = new Football();
      game.play();      
   }
}
</code></pre><h4 id="模板模式-番外"><a href="#模板模式-番外" class="headerlink" title="模板模式 番外"></a>模板模式 番外</h4><p><strong>1.创建抽象类</strong><br></p>
<pre><code>package Pattern_Design_Behavior.template_pattern;

public abstract class Hamburger {
    //默认是有生菜的
    private boolean lettuceHook = true;
    public void setLettuceHook(boolean lettuceHook){
        this.lettuceHook = lettuceHook;
    }

    public final void getHumburger(){
        topBread();
        if (lettuceHook){
            lettuce();
        }
        meat();
        bottomBread();
    }

    protected void topBread(){
        System.out.println(&quot;上面的面包&quot;);
    }

    protected void lettuce(){
        System.out.println(&quot;中间的生菜&quot;);
    }

    protected abstract void meat();

    private void bottomBread(){
        System.out.println(&quot;底部的面包&quot;);
    }
}
</code></pre><p><strong>2.创建抽象类的实现类</strong><br></p>
<pre><code>package Pattern_Design_Behavior.template_pattern.impl;

import Pattern_Design_Behavior.template_pattern.Hamburger;

public class CodFishBurger extends Hamburger {
    @Override
    protected void meat() {
        System.out.println(&quot;深海鲟鱼&quot;);
    }
}
</code></pre><p><strong>3.测试</strong><br></p>
<pre><code>package Pattern_Design_Behavior.template_pattern.impl;

import Pattern_Design_Behavior.template_pattern.Hamburger;

public class TemplatePattern {
    public static void main(String[] args) {
        System.out.println(&quot;第一个汉堡包&quot;);
        Hamburger codFishBurger = new CodFishBurger();
        codFishBurger.getHumburger();

        System.out.println();

        System.out.println(&quot;第二个汉堡包&quot;);
        Hamburger codFishBurgerTow = new CodFishBurger();
        codFishBurgerTow.setLettuceHook(false);
        codFishBurgerTow.getHumburger();
    }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模板方法是一种非常基础的设计模式，在面向对象中有着大量的应用(如Java的HttpServlet)。它用简洁的机制（抽象函数的多态性）实现为很多应用框架提供灵活的扩展点，是程序复用方面的基本实现结构。</p>
<p>除了提供灵活的应用子步骤变化之外，”不要调用我，让我来调用你”的反向控制结构是模板方法的典型应用。（钩子）</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 状态</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E8%A6%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在该模式中，类的行为基于它的状态改变的。在该模式中创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p>场景</p>
<pre><code>1. 一个对象存在多个状态（不同状态下行为不同），且状态可以相互转换。
</code></pre><p>优点</p>
<pre><code>1. 将不同的状态隔离

2. 将各种状态的转换逻辑分布到state的子类中，减少相互间的依赖
</code></pre><p>缺点</p>
<pre><code>1. 状态多的业务场景导致类数目增加系统变复杂
</code></pre><p>相关设计模式</p>
<pre><code>1. 状态模式与享元模式
</code></pre><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p><strong>1.创建状态一个接口</strong><br></p>
<pre><code>public abstract class CourseVideoState {

    protected CourseVideoContext courseVideoContext;

    public void setCourseVideoContext(CourseVideoContext courseVideoContext) {
        this.courseVideoContext = courseVideoContext;
    }

    public abstract void play();
    public abstract void pause();
    public abstract void speed();
    public abstract void stop();
}
</code></pre><p><strong>3.创建 Context 类 上下文类</strong><br></p>
<pre><code>public class CourseVideoContext {

    private CourseVideoState courseVideoState;

    public final static PlayState PLAY_STATE = new PlayState();
    public final static StopState STOP_STATE = new StopState();
    public final static PauseState PAUSE_STATE = new PauseState();
    public final static SpeedState SPEED_STATE = new SpeedState();

    public CourseVideoState getCourseVideoState() {
        return courseVideoState;
    }

    public void setCourseVideoState(CourseVideoState courseVideoState) {
        this.courseVideoState = courseVideoState;
        this.courseVideoState.setCourseVideoContext(this);
    }

    public void play(){
        this.courseVideoState.play();
    }

    public void speed(){
        this.courseVideoState.speed();
    }

    public void stop(){
        this.courseVideoState.stop();
    }

    public void pause(){
        this.courseVideoState.pause();
    }
}
</code></pre><p><strong>2.创建实现接口的实体类</strong><br></p>
<pre><code>public class PauseState extends CourseVideoState {
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void pause() {
        System.out.println(&quot;暂停播放视频状态&quot;);
    }

    @Override
    public void speed() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}


public class PlayState extends CourseVideoState {
    @Override
    public void play() {
        System.out.println(&quot;正常播放视频状态&quot;);
    }

    @Override
    public void pause() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);
    }

    @Override
    public void speed() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}

package Pattern_Design_Behavior.state;

public class SpeedState extends CourseVideoState {
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void pause() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);
    }

    @Override
    public void speed() {
        System.out.println(&quot;快进状态下播放视频&quot;);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}

package Pattern_Design_Behavior.state;

public class StopState extends CourseVideoState {

    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void pause() {
        System.out.println(&quot;停止状态下不能暂停 ERROR!!&quot;);
    }

    @Override
    public void speed() {
        System.out.println(&quot;停止状态下不能快进 ERROR!!&quot;);
    }

    @Override
    public void stop() {
        System.out.println(&quot;视频停止状态&quot;);
    }
}
</code></pre><p><strong>4.使用 Context 来查看当状态 State 改变时的行为变化</strong><br></p>
<pre><code>package Pattern_Design_Behavior.state;

public class Test {

    public static void main(String[] args) {
        CourseVideoContext courseVideoContext = new CourseVideoContext();

        courseVideoContext.setCourseVideoState(new PlayState());
        System.out.println(&quot;当前状态是：&quot; + courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.pause();
        System.out.println(&quot;当前状态是：&quot; + courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.speed();
        System.out.println(&quot;当前状态是：&quot; + courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.stop();
        System.out.println(&quot;当前状态是：&quot; + courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.speed();
    }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们不关心当前context处于什么状态，context不用维护state属性。</p>
<p>状态模式适用于某一个对象的行为取决于该对象的状态，并且该对象的状态会在运行时转换。又或者有很多的if else判断，而这些判断只是因为状态不同而不断的切换行为。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 空对象</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在空对象模式中，一个空对象取代null对象实例的检查。null对象不是检查空值，而是反应一个不做任何动作的关系。在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
<h4 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h4><p><strong>1.创建一个抽象类</strong><br></p>
<pre><code>public abstract class AbstractCustomer {
   protected String name;
   public abstract boolean isNil();
   public abstract String getName();
}
</code></pre><p><strong>2.创建扩展上述类的实体类</strong><br></p>
<pre><code>public class RealCustomer extends AbstractCustomer {

   public RealCustomer(String name) {
      this.name = name;    
   }

   @Override
   public String getName() {
      return name;
   }

   @Override
   public boolean isNil() {
      return false;
   }
}

public class NullCustomer extends AbstractCustomer {

   @Override
   public String getName() {
      return &quot;Not Available in Customer Database&quot;;
   }

   @Override
   public boolean isNil() {
      return true;
   }
}
</code></pre><p><strong>3.创建 CustomerFactory 类</strong><br></p>
<pre><code>public class CustomerFactory {

   public static final String[] names = {&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;};

   public static AbstractCustomer getCustomer(String name){
      for (int i = 0; i &lt; names.length; i++) {
         if (names[i].equalsIgnoreCase(name)){
            return new RealCustomer(name);
         }
      }
      return new NullCustomer();
   }
}
</code></pre><p><strong>4.使用 CustomerFactory 基于客户传递的名字来获取 RealCustomer 或 NullCustomer 对象</strong><br></p>
<pre><code>public class NullPatternDemo {
   public static void main(String[] args) {

      AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;);
      AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;);
      AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;);
      AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;);

      System.out.println(&quot;Customers&quot;);
      System.out.println(customer1.getName());
      System.out.println(customer2.getName());
      System.out.println(customer3.getName());
      System.out.println(customer4.getName());
   }
}
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 策略</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在该模式中，一个类的行为或其算法可以在运行时更改。我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<blockquote>
<p>提示：这里策略模式和桥梁模式相似</p>
</blockquote>
<p>场景</p>
<pre><code>1. 系统有很多类，而它们的区别仅仅在于它们的行为不同

2. 一个系统需要动态的在几种算法中选择一种
</code></pre><p>优点</p>
<pre><code>1. 开闭原则

2. 避免使用多重条件转移语句

3. 提高算法的保密性和安全性
</code></pre><p>缺点</p>
<pre><code>1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类

2. 产生很多策略类
</code></pre><p>相关设计模式</p>
<pre><code>1. 策略模式与工厂模式

2. 策略模式和状态模式
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>1.创建接口</strong><br></p>
<pre><code>public interface Strategy {
   public int doOperation(int num1, int num2);
}
</code></pre><p><strong>2.创建实现接口的实现类</strong><br></p>
<pre><code>public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}

public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}

public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
</code></pre><p><strong>3.创建context类</strong><br></p>
<pre><code>public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;
   }

   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
</code></pre><p><strong>4.使用 Context 来查看当它改变策略 Strategy 时的行为变化</strong><br></p>
<pre><code>public class StrategyPatternDemo {
   public static void main(String[] args) {

      //当使用策略是加操作时
      Context context = new Context(new OperationAdd());    
      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));

      context = new Context(new OperationSubstract());      
      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());    
      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>状态模式和策略模式类似，并且都能够动态改变对象的行为。状态模式是通过状态的转移来改变context所组合的state对象，策略模式是通过context本身来改变组合的strategy对象。所谓的状态转移是指context在运行过程中由于一些条件发生改变而使得state对象发生改变，此过程是在运行过程中。状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 简介</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h4><pre><code>1.对接口编程而不是对实现编程
2.优先使用对象组合而不是继承
</code></pre><hr>
<pre><code>1.开闭原则（Open Close Principle）

    表示对扩展开放，对修改关闭。在程序进行扩展的时候，不能去修改原有的程序。所以在实现过程中需要接口和抽象类。

2.里氏代换原则（Liskov Substitution Principle）

    该原则是面向对象设计的基本原则之一。指任何基类可以出现的地方，子类一定可以出现。

3.依赖倒转原则（Dependence Inversion Principle）

    这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。高层模块不应该依赖低层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。

    优点：减少类之间的耦合性，提高系统的稳定性，提高代码的可读性和维护性，降低修改程序所造成的风险。
    注意：核心思想就是面向接口编程。

4.接口隔离原则（Interface Segregation Principle）

    这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5.迪米特法则，又称最少知道原则（Demeter Principle）

    最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。尽量降低类与类之间的耦合。

    优点：降低类之间的耦合

6.合成复用原则（Composite Reuse Principle）

    合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

7.单一职责原则

    不要存在多于一个导致类变更的原因。一个类|接口|方法只负责一项职责。

    优点：降低类的负责度、提高类的可读性，提高系统的可维护性、降低变更引起的风险。
</code></pre><h4 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h4><p><strong>1.创新型模式</strong><br><br>该类型设计模式提供一种在创建对象的同时隐藏创建逻辑的方式，不使用new运算符直接实例化对象。这一模式表示对象是怎么来的。</p>
<pre><code>1.工厂模式（Factory Pattern）
2.抽象工厂模式（Abstract Factory Pattern）
3.单例模式（Singleton Pattern）
4.建造者模式（Builder Pattern）
5.原型模式（Prototype Pattern）
</code></pre><p><strong>2.结构型模式</strong><br><br>该类型设计模式关注类和对象的组合。继承的概念被用来组个接口和定义组合对象获得新功能的方式。这一模式表示对象和谁有关。</p>
<pre><code>1.适配器模式（Adapter Pattern）
2.桥接模式（Bridge Pattern）
3.过滤器模式（Filter、Criteria Pattern）
4.组合模式（Composite Pattern）
5.装饰器模式（Decorator Pattern）
6.外观模式（Facade Pattern）
7.享元模式（Flyweight Pattern）
8.代理模式（Proxy Pattern）
</code></pre><p><strong>3.行为型模式</strong><br><br>该类型设计模式关注对象之间的通信。这一模式表示对象和对象在干嘛。</p>
<pre><code>1.责任链模式（Chain of Responsibility Pattern）
2.命令模式（Command Pattern）
3.解释器模式（Interpreter Pattern）
4.迭代器模式（Iterator Pattern）
5.中介者模式（Mediator Pattern）
6.备忘录模式（Memento Pattern）
7.观察者模式（Observer Pattern）
8.状态模式（State Pattern）
9.空对象模式（Null Object Pattern）
10.策略模式（Strategy Pattern）
11.模板模式（Template Pattern）
12.访问者模式（Visitor Pattern）
</code></pre><p><strong>4.J2EE型设计模式</strong><br><br>该类型设计模式特别关注表示层。这一模式表示对象合起来要干嘛。</p>
<pre><code>1.MVC 模式（MVC Pattern）
2.业务代表模式（Business Delegate Pattern）
3.组合实体模式（Composite Entity Pattern）
4.数据访问对象模式（Data Access Object Pattern）
5.前端控制器模式（Front Controller Pattern）
6.拦截过滤器模式（Intercepting Filter Pattern）
7.服务定位器模式（Service Locator Pattern）
8.传输对象模式（Transfer Object Pattern）
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 简单工厂</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>简单工厂不属于GOF23种设计模式中的设计模式。</p>
<p>适用场景：工厂类负责创建的对象比较少。客户端只知道传入工厂类的参数，对于如何创建对象不关心。</p>
<p>优点：只需要传入一个正确的参数，就能够获取你所需要的对象，而无需知道其创建的细节。</p>
<p>缺点：工厂类的职责过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。</p>
<h4 id="简单工厂-JDK源码解析"><a href="#简单工厂-JDK源码解析" class="headerlink" title="简单工厂 - JDK源码解析"></a>简单工厂 - JDK源码解析</h4><ul>
<li>Calendar 类里面的实现</li>
<li>JDBC 连接类里面的实现</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 组合</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式是用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。将一组相似的对象当作一个单一的对象。此模式创建了一个包含自己对象组的类。将对象组合成树形结构表示“部分-整体”的层次结构。</p>
<p>组合模式使得客户端对单个对象和组合对象保持一致的方式处理。</p>
<p>场景</p>
<pre><code>1. 希望客户端可以忽略组合对象与单个对象的差异时

2. 处理一个树形结构时
</code></pre><p>优点</p>
<pre><code>1. 清楚定义分层次的复杂对象，表示对象的全部或部分层次

2. 让客户端忽略层次的差异，方便对整个层次结构进行控制

3. 简化客户端程序
</code></pre><p>缺点</p>
<pre><code>1. 限制类型时会比较复杂

2. 设计变得更加抽象
</code></pre><p>相关设计模式</p>
<pre><code>1. 组合模式与访问者模式
</code></pre><h4 id="组合模式的具体实现"><a href="#组合模式的具体实现" class="headerlink" title="组合模式的具体实现"></a>组合模式的具体实现</h4><p><strong>1.创建 Employee 类 该类带有 Employee 对象的列表</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List&lt;Employee&gt; subordinates;

   //构造函数
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList&lt;Employee&gt;();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List&lt;Employee&gt; getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return (&quot;Employee :[ Name : &quot;+ name 
      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;
      + salary+&quot; ]&quot;);
   }   
}
</code></pre><p><strong>2.使用 Employee 类来创建和打印员工的层次结构</strong><br></p>
<pre><code>public class CompositePatternDemo {
   public static void main(String[] args) {
      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);

      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);

      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);

      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);
      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);

      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);
      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);

      CEO.add(headSales);
      CEO.add(headMarketing);

      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);

      headMarketing.add(clerk1);
      headMarketing.add(clerk2);

      //打印该组织的所有员工
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }        
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>组合模式，表一个对象中包含其它对象，这些被包含的对象可能是终点对象，也可能不是终点对象。作为具有容器特征的对象，不经包含对象本身的属性，还包括其它对象。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code>1. java.awt.container

2. java.util.HashMap
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 装饰器</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式允许向一个现有的对象添加新的功能，同时不改变其结构。此模式创建了一个装饰类，用来包装原有的类，并在保持方法签名完整性的前提下，提供额外的功能。装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>场景</p>
<pre><code>1. 扩展一个类的功能或给一个类添加附加职责

2. 动态的给一个对象添加功能，这些功能可以动态的撤销
</code></pre><p>优点</p>
<pre><code>1. 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能

2. 通过使用不同类型以及这些装饰类的排列组合可以实现不同的效果

3. 符合开闭原则
</code></pre><p>缺点</p>
<pre><code>1. 会出现更多的代码，更多的类，增加程序的复杂性

2. 动态装饰或多层装饰时会更加复杂
</code></pre><p>相关设计模式</p>
<pre><code>1. 装饰者模式与代理模式

2. 适配器模式
</code></pre><h4 id="装饰器模式具体实现"><a href="#装饰器模式具体实现" class="headerlink" title="装饰器模式具体实现"></a>装饰器模式具体实现</h4><p><strong>1.创建接口</strong><br></p>
<pre><code>public interface Shape {
   void draw();
}
</code></pre><p><strong>2.创建实现接口的实现类</strong><br></p>
<pre><code>public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Shape: Rectangle&quot;);
   }
}

public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Shape: Circle&quot;);
   }
}
</code></pre><p><strong>3.创建实现Shape接口的抽象装饰类</strong><br></p>
<pre><code>public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;

   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }

   public void draw(){
      decoratedShape.draw();
   }  
}
</code></pre><p><strong>4.创建扩展了ShapeDecorator类的实体装饰类</strong><br></p>
<pre><code>public class RedShapeDecorator extends ShapeDecorator {
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }

   @Override
   public void draw() {
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }

   private void setRedBorder(Shape decoratedShape){
      System.out.println(&quot;Border Color: Red&quot;);
   }
}
</code></pre><p><strong>5.使用 RedShapeDecorator 来装饰 Shape 对象</strong><br></p>
<pre><code>public class DecoratorPatternDemo {
   public static void main(String[] args) {

      Shape circle = new Circle();

      Shape redCircle = new RedShapeDecorator(new Circle());

      Shape redRectangle = new RedShapeDecorator(new Rectangle());
      System.out.println(&quot;Circle with normal border&quot;);
      circle.draw();

      System.out.println(&quot;\nCircle of red border&quot;);
      redCircle.draw();

      System.out.println(&quot;\nRectangle of red border&quot;);
      redRectangle.draw();
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>装饰者模式表示在已有的类的基础上动态的添加额外的功能。装饰者模式和Spring中的AOP功能类似，在原有的程序的基础上通过横切代码补充原先没有的功能。</p>
<h4 id="Java-IO-的装饰者模式"><a href="#Java-IO-的装饰者模式" class="headerlink" title="Java IO 的装饰者模式"></a>Java IO 的装饰者模式</h4><pre><code>                                        InputStream
                                            /|\

ByteArrayInputStream FileInpuStream PipedInputStream FilterInputStream extends InputStream
</code></pre><blockquote>
<p>提示：这里的InputStream代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等。FilterInputStream承接了装饰模式的关键节点，其实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>
</blockquote>
<h4 id="装饰者模式-源码分析"><a href="#装饰者模式-源码分析" class="headerlink" title="装饰者模式 - 源码分析"></a>装饰者模式 - 源码分析</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 观察者</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>当对象存在一对多的时候则使用观察者模式。如：当一个对象被修改时，则会自动通知它依赖对象。定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<blockquote>
<p>提示：观察者模式无外乎两个操作，观察者订阅自己关心的主体和主体有数据变化后通知观察者们。</p>
</blockquote>
<pre><code>1.需要自定义主体，每个主体需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者。

类似于发布订阅
</code></pre><p>优点</p>
<pre><code>1. 观察者与被观察者之间建立一个抽象的耦合

2. 观察者模式支持广播通信
</code></pre><p>缺点</p>
<pre><code>1. 过多的细节依赖，提高时间消耗和程序复杂度

2. 需要使用得当否则容易陷入循环调用
</code></pre><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>1.创建Subject类</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class Subject {

   private List&lt;Observer&gt; observers 
      = new ArrayList&lt;Observer&gt;();
   private int state;

   public int getState() {
      return state;
   }

   //这里表示数据变更，通知各个观察者
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }

   public void attach(Observer observer){
      observers.add(observer);      
   }

   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}
</code></pre><p><strong>2.创建Observer类</strong><br></p>
<pre><code>public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
</code></pre><p><strong>3.创建实体观察者类</strong><br></p>
<pre><code>public class BinaryObserver extends Observer{

   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
      System.out.println( &quot;Binary String: &quot; 
      + Integer.toBinaryString( subject.getState() ) ); 
   }
}

public class OctalObserver extends Observer{

   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
     System.out.println( &quot;Octal String: &quot; 
     + Integer.toOctalString( subject.getState() ) ); 
   }
}

public class HexaObserver extends Observer{

   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
      System.out.println( &quot;Hex String: &quot; 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   }
}
</code></pre><p><strong>4.使用 Subject 和实体观察者对象</strong><br></p>
<pre><code>public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();

      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);

      System.out.println(&quot;First state change: 15&quot;);   
      subject.setState(15);
      System.out.println(&quot;Second state change: 10&quot;);  
      subject.setState(10);
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>观察者模式表示观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 解释器</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式提供了评估语言的语法或表达式的方式。此模式实现了一个表达式接口，该接口解释一个特定的上下文。在编程中需要分析一件事情，并决定其含义所以需要解释器模式来完成。</p>
<p>此模式基于表达式和评估器部分。第一个代表要分析的事情，该分析是由评价者做出，它们知道构成表达的人物的意义。</p>
<p>为了解释一种语言而为语言创建的解释器。</p>
<p>场景</p>
<pre><code>1. 某个特定类型问题发生频率足够高的时候
</code></pre><p>优点</p>
<pre><code>1. 语法由很多类表示，容易改变和扩展此语言
</code></pre><p>缺点</p>
<pre><code>1. 当语法规则数目太多时，增加了系统的复杂度
</code></pre><p>相关设计模式</p>
<pre><code>1. 解释器模式和适配器模式
</code></pre><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p><strong>1.创建表达式接口(抽象表达式类)</strong><br></p>
<pre><code>public interface Expression {
    //解释方法
    public boolean interpret(String context);
}
</code></pre><p><strong>2.创建实现上述接口的实体类(终结表达式类)</strong><br></p>
<pre><code>public class TerminalExpression implements Expression {
   private String data;

   public TerminalExpression(String data){
      this.data = data; 
   }
    //对终结表达式的处理
   @Override
   public boolean interpret(String context) {
      if(context.contains(data)){
         return true;
      }
      return false;
   }
}

public class OrExpression implements Expression {
   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {      
      return expr1.interpret(context) || expr2.interpret(context);
   }
}

public class AndExpression implements Expression {
   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {      
      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);
   }
}
</code></pre><p><strong>3.InterpreterPatternDemo 使用 Expression 类来创建规则 并解析它们</strong><br></p>
<pre><code>public class InterpreterPatternDemo {

   //规则：Robert 和 John 是男性
   public static Expression getMaleExpression(){
      Expression robert = new TerminalExpression(&quot;Robert&quot;);
      Expression john = new TerminalExpression(&quot;John&quot;);
      return new OrExpression(robert, john);    
   }

   //规则：Julie 是一个已婚的女性
   public static Expression getMarriedWomanExpression(){
      Expression julie = new TerminalExpression(&quot;Julie&quot;);
      Expression married = new TerminalExpression(&quot;Married&quot;);
      return new AndExpression(julie, married);    
   }

   public static void main(String[] args) {
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();

      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));
      System.out.println(&quot;Julie is a married women? &quot; 
      + isMarriedWoman.interpret(&quot;Married Julie&quot;));
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解释器模式包含以下主要角色：</p>
<pre><code>1.抽象表达式：定义解释器的接口，约定解释器的解释操作，主要包含方法：intercept()。

2.终结符表达式：抽象表达式的子类，实现文法中与终结符相关的操作。

3.非终结符表达式：抽象表达式的子类，用来实现文法中与非终结符相关的操作。

4.环境：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据。

5.客户端：验证正确与否
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 访问者</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在该模式中，使用访问者类，其改变了元素类的执行算法。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p>场景</p>
<pre><code>1. 一个数据结构（List/Set/Map）包含很多类型对象

2. 数据结构与数据操作分离
</code></pre><p>优点</p>
<pre><code>1. 增加新的操作很容易，即增加一个新的访问者
</code></pre><p>缺点</p>
<pre><code>1. 增加新的数据结构困难

2. 具体元素变更比较麻烦
</code></pre><p>相关设计模式</p>
<pre><code>访问者模式和迭代器模式
</code></pre><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p><strong>1.定义表示元素的接口</strong><br></p>
<pre><code>public interface ComputerPart {
   public void accept(ComputerPartVisitor computerPartVisitor);
}
</code></pre><p><strong>2.创建扩展上述类的实体类</strong><br></p>
<pre><code>public class Keyboard  implements ComputerPart {
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Monitor  implements ComputerPart {
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Mouse  implements ComputerPart {
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Computer implements ComputerPart {
   ComputerPart[] parts;

   public Computer(){
      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      
   } 

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      for (int i = 0; i &lt; parts.length; i++) {
         parts[i].accept(computerPartVisitor);
      }
      computerPartVisitor.visit(this);
   }
}
</code></pre><p><strong>3.定义一个表示访问者的接口</strong><br></p>
<pre><code>public interface ComputerPartVisitor {
   public void visit(Computer computer);
   public void visit(Mouse mouse);
   public void visit(Keyboard keyboard);
   public void visit(Monitor monitor);
}
</code></pre><p><strong>4.创建实现上述类的实体访问者</strong><br></p>
<pre><code>public class ComputerPartDisplayVisitor implements ComputerPartVisitor {

   @Override
   public void visit(Computer computer) {
      System.out.println(&quot;Displaying Computer.&quot;);
   }

   @Override
   public void visit(Mouse mouse) {
      System.out.println(&quot;Displaying Mouse.&quot;);
   }

   @Override
   public void visit(Keyboard keyboard) {
      System.out.println(&quot;Displaying Keyboard.&quot;);
   }

   @Override
   public void visit(Monitor monitor) {
      System.out.println(&quot;Displaying Monitor.&quot;);
   }
}
</code></pre><p><strong>5.使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分</strong><br></p>
<pre><code>public class VisitorPatternDemo {
   public static void main(String[] args) {

      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>访问者模式表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。我们需要清楚的知道访问者模式适用于数据结构相对稳定的系统。</p>
<pre><code>访问者模式角色：

    1.抽象访问者
    2.具体访问者
    3.抽象元素
    4.具体元素
    5.对象结构
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 责任链</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式为请求创建了一个接受者对象的链。此模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式之中，通常每个接收者都包含对另一个接受者的引用，如果一个对象不能处理该请求，那么它会将相同的请求传给下一个接收者，依次类推。</p>
<blockquote>
<p>提示：责任链通常建立一个单向链表，然后调用方只需要调用头部结点即可，后面会自动流转下去。比如：流程审批。</p>
</blockquote>
<p>场景</p>
<pre><code>1. 一个请求的处理需要多个对象当中的一个或几个协作处理
</code></pre><p>优点</p>
<pre><code>1. 请求的发送者和接收者（请求的处理）解耦

2. 责任链可以动态的组合
</code></pre><p>缺点</p>
<pre><code>1. 责任链太长或者处理时间过长会影响性能

2. 责任链有可能过多
</code></pre><p>相关设计模式</p>
<pre><code>责任链模式与状态模式
</code></pre><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>1.创建抽象的记录器类</strong><br></p>
<pre><code>public abstract class AbstractLogger {
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;

   protected int level;

   //责任链中的下一个元素
   protected AbstractLogger nextLogger;

   public void setNextLogger(AbstractLogger nextLogger){
      this.nextLogger = nextLogger;
   }

   public void logMessage(int level, String message){
      if(this.level &lt;= level){
         write(message);
      }
      if(nextLogger !=null){
         nextLogger.logMessage(level, message);
      }
   }

   abstract protected void write(String message);

}
</code></pre><p><strong>2.创建扩展了该记录器类的实体类</strong><br></p>
<pre><code>public class ConsoleLogger extends AbstractLogger {
   public ConsoleLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {    
      System.out.println(&quot;Standard Console::Logger: &quot; + message);
   }
}

public class ErrorLogger extends AbstractLogger {
   public ErrorLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {    
      System.out.println(&quot;Error Console::Logger: &quot; + message);
   }
}

public class FileLogger extends AbstractLogger {
   public FileLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {    
      System.out.println(&quot;File::Logger: &quot; + message);
   }
}
</code></pre><p><strong>3.创建不同类型的记录器 赋予它们不同的错误级别，并在每个记录器中设置下一个记录器 每个记录器中的下一个记录器代表的是链的一部分</strong><br></p>
<pre><code>public class ChainPatternDemo {
   private static AbstractLogger getChainOfLoggers(){

      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);

      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);

      return errorLogger;  
   }

   public static void main(String[] args) {
      AbstractLogger loggerChain = getChainOfLoggers();

      loggerChain.logMessage(AbstractLogger.INFO, &quot;This is an information.&quot;);

      loggerChain.logMessage(AbstractLogger.DEBUG, 
         &quot;This is a debug level information.&quot;);

      loggerChain.logMessage(AbstractLogger.ERROR, 
         &quot;This is an error information.&quot;);
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>责任链模式表示如果一个对象不能处理请求，那么它会将相同的请求传递给下一个接收者，依次类推。</p>
<p>在责任链模式里，很多对象通过对其下家的引用而连接起来形成一条链。请求在这条链上传递，直到链上的某一个对象决定处理此请求。客户端不清楚链上的哪一个对象会最终处理这个请求，这使得系统可以在不影响客户端的情况下动态的重新组织和分配责任。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 过滤器</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式将它们连接起来。它结合多个标准来获取单一标准。</p>
<h4 id="过滤器模式的具体实现"><a href="#过滤器模式的具体实现" class="headerlink" title="过滤器模式的具体实现"></a>过滤器模式的具体实现</h4><p><strong>1.创建一个类 在该类上应用标准</strong><br></p>
<pre><code>public class Person {

   private String name;
   private String gender;
   private String maritalStatus;

   public Person(String name,String gender,String maritalStatus){
      this.name = name;
      this.gender = gender;
      this.maritalStatus = maritalStatus;    
   }

   public String getName() {
      return name;
   }
   public String getGender() {
      return gender;
   }
   public String getMaritalStatus() {
      return maritalStatus;
   }  
}
</code></pre><p><strong>2.为标准（Criteria）创建一个接口</strong><br></p>
<pre><code>import java.util.List;

public interface Criteria {
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);
}
</code></pre><p><strong>3.创建实现 Criteria 接口的实体类</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class CriteriaMale implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;)){
            malePersons.add(person);
         }
      }
      return malePersons;
   }
}

import java.util.ArrayList;
import java.util.List;

public class CriteriaFemale implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;)){
            femalePersons.add(person);
         }
      }
      return femalePersons;
   }
}

import java.util.ArrayList;
import java.util.List;

public class CriteriaSingle implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;)){
            singlePersons.add(person);
         }
      }
      return singlePersons;
   }
}

import java.util.List;

public class AndCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public AndCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);     
      return otherCriteria.meetCriteria(firstCriteriaPersons);
   }
}

import java.util.List;

public class OrCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public OrCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);
      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);

      for (Person person : otherCriteriaItems) {
         if(!firstCriteriaItems.contains(person)){
           firstCriteriaItems.add(person);
         }
      }  
      return firstCriteriaItems;
   }
}
</code></pre><p><strong>4.使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表</strong><br></p>
<pre><code>import java.util.ArrayList; 
import java.util.List;

public class CriteriaPatternDemo {
   public static void main(String[] args) {
      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));
      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));
      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));

      Criteria male = new CriteriaMale();
      Criteria female = new CriteriaFemale();
      Criteria single = new CriteriaSingle();
      Criteria singleMale = new AndCriteria(single, male);
      Criteria singleOrFemale = new OrCriteria(single, female);

      System.out.println(&quot;Males: &quot;);
      printPersons(male.meetCriteria(persons));

      System.out.println(&quot;\nFemales: &quot;);
      printPersons(female.meetCriteria(persons));

      System.out.println(&quot;\nSingle Males: &quot;);
      printPersons(singleMale.meetCriteria(persons));

      System.out.println(&quot;\nSingle Or Females: &quot;);
      printPersons(singleOrFemale.meetCriteria(persons));
   }

   public static void printPersons(List&lt;Person&gt; persons){
      for (Person person : persons) {
         System.out.println(&quot;Person : [ Name : &quot; + person.getName() 
            +&quot;, Gender : &quot; + person.getGender() 
            +&quot;, Marital Status : &quot; + person.getMaritalStatus()
            +&quot; ]&quot;);
      }
   }      
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里通过创建一个Person对象，Criteria接口和实现了该接口的实体类，来过滤Person对象的列表。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 迭代器</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>场景</p>
<pre><code>1. 访问一个集合对象的内容而无需暴露它内部表示。

2. 遍历不同的集合结构提供统一的接口。
</code></pre><p>优点</p>
<pre><code>1. 分离集合对象的遍历行为
</code></pre><p>缺点</p>
<pre><code>1. 类的个数成对增加
</code></pre><p>相关设计模式</p>
<pre><code>1. 迭代器模式与访问者模式
</code></pre><blockquote>
<p>注意：迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部程序透明的访问集合内的数据。</p>
</blockquote>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><strong>1.创建接口</strong><br></p>
<pre><code>public interface Iterator {
   public boolean hasNext();
   public Object next();
}

public interface Container {
   public Iterator getIterator();
}
</code></pre><p><strong>2.创建实现 Container 接口的实体类 该类有实现了 Iterator 接口的内部类 NameIterator</strong><br></p>
<pre><code>public class NameRepository implements Container {
   public String names[] = {&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {

      int index;

      @Override
      public boolean hasNext() {
         if(index &lt; names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }     
   }
}
</code></pre><p><strong>3.使用 NameRepository 来获取迭代器 并打印名字</strong><br></p>
<pre><code>public class IteratorPatternDemo {
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println(&quot;Name : &quot; + name);
      }  
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>提示：聚合对象拥有两个职责：1.存储数据。2.遍历数据。</p>
</blockquote>
<p>可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为。</p>
<p>迭代器模式提供一种方法来访问聚合对象，不用暴露这个对象的内部表示。</p>
<p>将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 适配器</title>
    <url>/undefined/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%20-%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>适配器模式是作为两个不兼容接口之间的桥梁，它结合了两个独立接口的功能。这里的适配器模式和代理模式相像。</p>
<pre><code>1.适配器模式表示有一个接口需要实现，但现成对象不满足，需要加一层适配器来进行适配。

    默认适配器模式
    类适配器模式
    对象适配器模式
</code></pre><blockquote>
<p>提示：类适配器和对象适配器的异同：一个采用继承，一个采用组合。类适配器属于静态实现，对象适配器属于动态实现，对象适配需要多实例化一个对象。对象适配器用得比较多。</p>
</blockquote>
<p>通过继承的方法，适配器自动获得了所需要的大部分方法。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p><strong>1.为媒体播放器和更高级的媒体播放器创建接口</strong><br></p>
<pre><code>public interface MediaPlayer {
   public void play(String audioType, String fileName);
}

public interface AdvancedMediaPlayer { 
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}
</code></pre><p><strong>2.创建实现 AdvancedMediaPlayer 接口的实体类</strong><br></p>
<pre><code>public class VlcPlayer implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);      
   }

   @Override
   public void playMp4(String fileName) {
      //什么也不做
   }
}

public class Mp4Player implements AdvancedMediaPlayer{

   @Override
   public void playVlc(String fileName) {
      //什么也不做
   }

   @Override
   public void playMp4(String fileName) {
      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);      
   }
}
</code></pre><p><strong>3.创建实现 MediaPlayer 接口的适配器类</strong><br></p>
<pre><code>public class MediaAdapter implements MediaPlayer {

   //将具体对象注入到适配器中，帮助适配器实现部分方法
   AdvancedMediaPlayer advancedMusicPlayer;

   public MediaAdapter(String audioType){
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) ){
         advancedMusicPlayer = new VlcPlayer();       
      } else if (audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         advancedMusicPlayer = new Mp4Player();
      }  
   }

   @Override
   public void play(String audioType, String fileName) {
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;)){
         advancedMusicPlayer.playVlc(fileName);
      }else if(audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}
</code></pre><p><strong>4.创建实现 MediaPlayer 接口的实体类</strong><br></p>
<pre><code>public class AudioPlayer implements MediaPlayer {
   MediaAdapter mediaAdapter; 

   @Override
   public void play(String audioType, String fileName) {    

      //播放 mp3 音乐文件的内置支持
      if(audioType.equalsIgnoreCase(&quot;mp3&quot;)){
         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);         
      } 
      //mediaAdapter 提供了播放其他文件格式的支持
      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) 
         || audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      }
      else{
         System.out.println(&quot;Invalid media. &quot;+
            audioType + &quot; format not supported&quot;);
      }
   }   
}
</code></pre><p><strong>5.使用 AudioPlayer 来播放不同类型的音频格式</strong><br></p>
<pre><code>public class AdapterPatternDemo {
   public static void main(String[] args) {
      AudioPlayer audioPlayer = new AudioPlayer();

      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);
      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);
      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);
      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果一个类需要实现此类没有的功能，而其它类有的功能，这时候就可以实现一个该类的适配器类，使用其它类的对象来实现其功能。</p>
<blockquote>
<p>提示：适配器模式和代理模式的区别(比较对象适配器模式和代理模式)：<br>1.代理模式是增强原方法，而适配器是提供”将狗包装成鸭，然后当做鸭来用””。狗和鸭之间原本没有继承关系。</p>
</blockquote>
<p>适配器模式引入一个被称为适配器的包装类，它所包装的对象称为适配者。将一个接口转换成希望的另一个接口，是接口不兼容的哪些类一起工作。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB锁问题</title>
    <url>/undefined/%E9%94%81%E9%97%AE%E9%A2%98%20-%20InnoDB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="锁问题-InnoDB锁问题"><a href="#锁问题-InnoDB锁问题" class="headerlink" title="锁问题 - InnoDB锁问题"></a>锁问题 - InnoDB锁问题</h2><p>[TOC]</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<blockquote>
<p>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用。</p>
</blockquote>
<p>行级锁：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度高。</p>
<blockquote>
<p>行级锁更适用于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。</p>
</blockquote>
<p>页面锁：开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。</p>
<h4 id="查询表级锁争用的情况"><a href="#查询表级锁争用的情况" class="headerlink" title="查询表级锁争用的情况"></a>查询表级锁争用的情况</h4><pre><code>show status like &apos;table%&apos;

- 查看table_locks_waited和table_locks_immediate状态变量分析系统上的表锁定争夺。
</code></pre><h4 id="表级锁的锁模式"><a href="#表级锁的锁模式" class="headerlink" title="表级锁的锁模式"></a>表级锁的锁模式</h4><p>表级锁的两种模式，表共享模式和表独占写锁。</p>
<h4 id="加入表锁"><a href="#加入表锁" class="headerlink" title="加入表锁"></a>加入表锁</h4><p>lock table 显式给某一表加上表锁。</p>
<h4 id="获取InnoDB行锁争用情况"><a href="#获取InnoDB行锁争用情况" class="headerlink" title="获取InnoDB行锁争用情况"></a>获取InnoDB行锁争用情况</h4><pre><code>show status like &apos;innodb_row_lock%&apos; 

    - innodb_row_lock_waits 和 innodb_row_lock_time_avg值比较高，可以通过查询information_schema数据库中相关的表来查看锁的情况
</code></pre><h4 id="InnoDB行锁模式以及加锁方法"><a href="#InnoDB行锁模式以及加锁方法" class="headerlink" title="InnoDB行锁模式以及加锁方法"></a>InnoDB行锁模式以及加锁方法</h4><pre><code>1. 共享锁（S），允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁。

2. 排它锁（X），允许获得排它锁的事务更新数据，阻止其它事务取得相同数据集的共享锁和排它锁。
</code></pre><blockquote>
<p>提示：为了允许行锁和表锁共存，实现多粒度锁机制，innodb还有两种内部使用的意向锁（表锁）。</p>
</blockquote>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁。</p>
<blockquote>
<p>注意：该行锁实现特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p>
</blockquote>
<pre><code>1. 在不通过索引条件查询时，InnoDB会锁定表中的所有记录。

2. 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然访问不同行的记录，但是如果是使用相同的索引键，会出现锁冲突的。

3. 不论使用何种所以，InnoDB都会使用行锁来对数据加锁。

4. 
</code></pre><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>事务是一组操作的执行单元，相对于数据库操作来说，事务管理的是一组SQL指令(增删改)，事务的一致性要求这个事务内的操作必须全部执行成功，如果在此过程出现差错，如一条sql语句没有执行成功，那么这一组操作都将全部回滚。</p>
<h4 id="1-事务的性质-ACID"><a href="#1-事务的性质-ACID" class="headerlink" title="1.事务的性质(ACID)"></a>1.事务的性质(ACID)</h4><pre><code>这里可以用四个词来解释事务：
    A（atomic 原子性）：发生就是全部都发生，不发生全都不发生
    C（consistent 一致性）：数据应该不被破坏
    I（isolate 隔离性）：用户间操作不相混淆
    D（durable 持久性）：永久保存，如保存到数据库中等
</code></pre><h4 id="2-事务管理接口"><a href="#2-事务管理接口" class="headerlink" title="2.事务管理接口"></a>2.事务管理接口</h4><p>所谓的事务管理就是按照给定的事务规则来执行提交和回滚事务操作。</p>
<h4 id="0-0-spring事务管理的两种方式"><a href="#0-0-spring事务管理的两种方式" class="headerlink" title="0.0 spring事务管理的两种方式"></a>0.0 spring事务管理的两种方式</h4><pre><code>1)编程式事务管理(不用)
2)声明式事务管理
    1.基于xml配置文件实现
    2.基于注解方式实现
</code></pre><h4 id="0-1-声明式事务管理-xml配置"><a href="#0-1-声明式事务管理-xml配置" class="headerlink" title="0.1 声明式事务管理(xml配置)"></a>0.1 声明式事务管理(xml配置)</h4><pre><code>1.配置文件的方式使用aop思想配置

  1.配置事务管理器
  &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;
  2.配置事务的增强
  &lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;&quot; propagation=&quot;&quot;/&gt;//指定运行事务的匹配规则 propagation：
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  3.配置切面
  &lt;aop:config&gt;
    //1.切入点
    &lt;aop:pointcut expression=&quot;&quot; id=&quot;&quot;/&gt;
    //2.切面
    &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;//表示的意思是将哪个增强(advice-ref)用到哪一个切面(pointcut-ref)上面
  &lt;/aop:config&gt;

2.
</code></pre><h4 id="0-2-声明式事务管理-注解"><a href="#0-2-声明式事务管理-注解" class="headerlink" title="0.2 声明式事务管理(注解)"></a>0.2 声明式事务管理(注解)</h4><pre><code>1.配置事务管理器
  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframwork.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
  &lt;/bean&gt;

2.配置事务注解
  &lt;tx:annnotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

3.在要使用事务的方法所在类上面添加注释

  @Transactional
  public class OrdersService{
    private OrdersDao ordersDao;
    public void setOrdersDao(OrdersDao ordersDao){

        }
        //调用dao的方法，业务逻辑层写转账业务等
        //要使用到的业务逻辑
    public void accountMoney(){

        }    
    }
</code></pre><h4 id="1-PlatformTransactionManager-接口1"><a href="#1-PlatformTransactionManager-接口1" class="headerlink" title="1.PlatformTransactionManager 接口1"></a>1.PlatformTransactionManager 接口1</h4><pre><code>1.事务管理器：PlatformTransactionManager
    1)Spring针对不同的DAO层框架都提供了不同的实现类
    2)无论是使用基于xml配置文件方式实现事务管理还是使用基于注解方式实现事务管理，首先都需要配置事务管理器
</code></pre><blockquote>
<p>案例：搭建转账环境</p>
</blockquote>
<pre><code>1.创建数据库表，添加数据(创建基本的用户信息(用户名、密码))
2.创建service类和dao类，完成注入关系

&lt;bean id=&quot;orderService&quot; class=&quot;cn.itcast.service.OrderService&quot;&gt;
    &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;ordersDao&quot; class=&quot;cn.itcast.dao.OrdersDao&quot;&gt;
    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<blockquote>
<p>注意：service层又叫做业务逻辑层，dao层单纯对数据库做操作，在dao层不添加业务</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：在bean.xml文件配置时候是service中注入dao，dao中注入模板，模板中注入dataSource</p>
</blockquote>
<h4 id="2-TransactionDefinition-接口2"><a href="#2-TransactionDefinition-接口2" class="headerlink" title="2.TransactionDefinition 接口2"></a>2.TransactionDefinition 接口2</h4><p>事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</p>
<h4 id="3-TransactionStatus-接口3"><a href="#3-TransactionStatus-接口3" class="headerlink" title="3.TransactionStatus 接口3"></a>3.TransactionStatus 接口3</h4><p>事务运行状态</p>
<h4 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4.事务隔离级别"></a>4.事务隔离级别</h4><p>事务的隔离级别定义一个事务可能受其他并发事务影响的程度。在我们项目中，多个事务并发运行会操作相同的数据来完成各自的任务，所以在这一过程中会导致一些问题的出现。</p>
<p><strong>1.脏读</strong><br><br>脏读表示一个事务正在访问数据并对数据进行修改，而这修改还没有提交到数据库中，另外的事务也访问该数据，然后使用这个数据，因为这个数据还没有提交，所以另外一个事务读到的数据是脏数据，所做的操作是不正确的。</p>
<p><strong>2.丢失修改</strong><br><br>表示在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改这个数据后，第二个事务也修改这个数据，这样第一个事务内修改的数据结果丢失，从而称之为丢失修改。</p>
<p><strong>3.不可重复读</strong><br><br>表示在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问该数据。那么在两个事务操作之后，第一个事务读取的数据可能不一样。</p>
<p><strong>4.幻读</strong><br><br>幻读与不可重复读类似，表示一个事务读取数据，然后另外一个并发事务又插入数据，从而在第一个事务读取时会发现一些原本不存在的数据，这就像幻觉，从而是幻读。</p>
<blockquote>
<p>注意：为了解决数据库读一致性的问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式：1.在读取数据前对其加锁，阻止其它事务对其进行修改。2.通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别的一致性读取。</p>
</blockquote>
<h4 id="5-获取InnoDB行锁争用情况"><a href="#5-获取InnoDB行锁争用情况" class="headerlink" title="5.获取InnoDB行锁争用情况"></a>5.获取InnoDB行锁争用情况</h4><p>在这里通过innodb_row_lock状态命令来分析系统上的行锁争用情况。</p>
<pre><code>SHOW STATUS LIKE &apos;innodb_row_lock%&apos;
</code></pre><p><strong>5.1 InnoDB的行锁模式和加锁方法</strong><br><br>InnoDB实现两种类型行锁：1.共享锁，允许一个事务去读一行，阻止其它事务获得相同数据集的排它锁。2.排它锁，允许获得排它锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排它写锁。</p>
<p><strong>5.2 InnoDB行锁实现方式</strong><br><br>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来记录加锁。</p>
<pre><code>1.Record lock：对索引项加锁
2.Gap lock：对索引之间的间隙加锁，第一条记录前或者最后一条记录之后的间隙加锁
3.Next-key lock：前两种的组合，对记录及其前面的间隙加锁
</code></pre><blockquote>
<p>提示：InnoDB这种行锁实现的特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：在实际应用过程中需要注意InnoDB行锁的这一特性，否则将导致大量的锁冲突。</p>
</blockquote>
</blockquote>
<pre><code>1.在不通过索引条件查询时，InnoDB会锁定表中的所有记录 
2.因为MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。
3.当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不管是使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁
4.有些时候，即使在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全盘扫描效率高，其就不会使用索引，这时InnoDB会对所有记录加锁。
</code></pre><p><strong>5.3 什么时候使用表锁</strong><br><br>对于InnoDB表，绝大部分时间都使用行级锁，因为事务和行级锁往往使我们选择InnoDB的理由。</p>
<pre><code>1.如果事务需要更新大部分或者全部数据，表比较大，这种情况可以使用表锁来提高效率。
2.事务涉及多个表，复杂，容易引起死锁。这种情况使用表锁。
</code></pre><p><strong>5.4 避免死锁</strong><br></p>
<pre><code>1.如果不同程序并发存取多个表，尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
2.程序批量处理数据的时候，如果事先对数据排序，保证每个线程按照固定的顺序来处理记录，也可以降低出现死锁的机会。
</code></pre>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="1-Caused-by-org-apache-ibatis-exceptions-TooManyResultsException-Expected-one-result-or-null-to-be-returned-by-selectOne-but-found-5"><a href="#1-Caused-by-org-apache-ibatis-exceptions-TooManyResultsException-Expected-one-result-or-null-to-be-returned-by-selectOne-but-found-5" class="headerlink" title="1. Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 5"></a>1. Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 5</h4><p>解：该错误时因为查询到的记录是多条，而返回的类型值允许是一条或者没有，所以出错。所以在数据返回的时候将返回类型变为List集合，那么就能正确执行。</p>
<h4 id="2-Zero-date-value-prohibited-nested-exception-is-java-sql-SQLException-Zero-date-value-prohibited"><a href="#2-Zero-date-value-prohibited-nested-exception-is-java-sql-SQLException-Zero-date-value-prohibited" class="headerlink" title="2.Zero date value prohibited; nested exception is java.sql.SQLException: Zero date value prohibited"></a>2.Zero date value prohibited; nested exception is java.sql.SQLException: Zero date value prohibited</h4><p>解：在数据库连接的URL之后加上 <code>&amp;zeroDateTimeBehavior=convertToNull</code>。这种方法的值一共有三种：</p>
<pre><code>1.exception：默认值，会抛出异常。
2.CONVERT_TO_NULL：将出错的那个0000-00-00字段的值转为null
3.round：转成0001-01-01 14:00:00
</code></pre><p>或者将数据表中对应的值将其改成null</p>
<h4 id="3-Cause-java-sql-SQLIntegrityConstraintViolationException-Column-‘email’-in-where-clause-is-ambiguous"><a href="#3-Cause-java-sql-SQLIntegrityConstraintViolationException-Column-‘email’-in-where-clause-is-ambiguous" class="headerlink" title="3.Cause: java.sql.SQLIntegrityConstraintViolationException: Column ‘email’ in where clause is ambiguous"></a>3.Cause: java.sql.SQLIntegrityConstraintViolationException: Column ‘email’ in where clause is ambiguous</h4><p>这里表示数据查询过程中查询的列重复了，没有指定哪个表的中的列被查询，指定之后就不会出现这样的错误。</p>
<p>或者在服务实现时候，用正确的列名替换错误的列名。</p>
<h4 id="org-springframework-beans-factory-BeanCreationException"><a href="#org-springframework-beans-factory-BeanCreationException" class="headerlink" title="org.springframework.beans.factory.BeanCreationException"></a>org.springframework.beans.factory.BeanCreationException</h4><p>出现此类异常的情况有很多：</p>
<pre><code>1.可能是你的数据库类名称引用错误。
</code></pre><h4 id="maven-jetty启动很慢的问题-报错：Timeout-scanning-annotations"><a href="#maven-jetty启动很慢的问题-报错：Timeout-scanning-annotations" class="headerlink" title="maven jetty启动很慢的问题 报错：Timeout scanning annotations"></a>maven jetty启动很慢的问题 报错：Timeout scanning annotations</h4><blockquote>
<p>原因：</p>
</blockquote>
<pre><code>The Jetty8 have to scan all the jar files to search those &quot;Servlet3&quot; features (web-fragment / annotations ... etc ) 
</code></pre><blockquote>
<p>解决：</p>
</blockquote>
<pre><code>1.在web.xml中的&lt;web-app&gt;末尾加上metadata-complete=&quot;true&quot;，此段程序一般没有效果。

2.1 创建一个文件jetty-context.xml文件，将之放置到java路径下的resources文件目录下。

&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;http://www.eclipse.org/jetty/configure.dtd&quot;&gt;
&lt;Configure class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt;
    &lt;Call name=&quot;setAttribute&quot;&gt;
        &lt;Arg&gt;org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern&lt;/Arg&gt;
        &lt;Arg&gt;.*/.*jsp-api-[^/]\.jar$|./.*jsp-[^/]\.jar$|./.*taglibs[^/]*\.jar$
        &lt;/Arg&gt;
    &lt;/Call&gt;
&lt;/Configure&gt;

2.2 然后将pom.xml中的jetty依赖换掉

&lt;plugin&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;9.3.10.v20160621&lt;/version&gt;
  &lt;configuration&gt;
    &lt;contextXml&gt;src/main/resources/jetty-contexts.xml&lt;/contextXml&gt;
    &lt;webAppConfig&gt;
      &lt;defaultsDescriptor&gt;src/main/resources/jetty-contexts.xml&lt;/defaultsDescriptor&gt;
      &lt;contextPath&gt;/solr&lt;/contextPath&gt;
    &lt;/webAppConfig&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;

2.3 然后重启jetty-run就可以啦
</code></pre><h4 id="jetty-run-Dorg-eclipse-jetty-annotations-maxWait-120"><a href="#jetty-run-Dorg-eclipse-jetty-annotations-maxWait-120" class="headerlink" title="jetty:run -Dorg.eclipse.jetty.annotations.maxWait=120"></a>jetty:run -Dorg.eclipse.jetty.annotations.maxWait=120</h4><p>这里表示的是在maven jetty:run 启动命令之后追加参数。</p>
<h4 id="org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘org-springframework-web-servlet-resource-DefaultServletHttpRequestHandler-0’-Initialization-of-bean-failed"><a href="#org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘org-springframework-web-servlet-resource-DefaultServletHttpRequestHandler-0’-Initialization-of-bean-failed" class="headerlink" title="org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler#0’: Initialization of bean failed;"></a>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler#0’: Initialization of bean failed;</h4><p>解决：在springmvc.xml中在<a href="mvc:default-servlet-handler/" target="_blank" rel="noopener">mvc:default-servlet-handler/</a>添加上在web.xml中的<servlet-name>效果如下：<br>&lt;mvc:default-servlet-handler default-servlet-name=”SpringMVC”/&gt;</servlet-name></p>
<h4 id="org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘configController’-Injection-of-autowired-dependencies-failed"><a href="#org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘configController’-Injection-of-autowired-dependencies-failed" class="headerlink" title="org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘configController’: Injection of autowired dependencies failed;"></a>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘configController’: Injection of autowired dependencies failed;</h4><p>解决：因为在Service实现类里面没有添加@Service标签，发生这种错误的原因要么是注解问题，要么是配置文件多写什么或者少写什么。</p>
<h4 id="No-mapping-found-for-HTTP-request-with-URI-teacher-teacher-exam-export-in-DispatcherServlet-with-name-‘B’"><a href="#No-mapping-found-for-HTTP-request-with-URI-teacher-teacher-exam-export-in-DispatcherServlet-with-name-‘B’" class="headerlink" title="No mapping found for HTTP request with URI [/teacher/teacher/exam/export] in DispatcherServlet with name ‘B’"></a>No mapping found for HTTP request with URI [/teacher/teacher/exam/export] in DispatcherServlet with name ‘B’</h4><p>解决：原因是因为Controller没有加载到资源，没有找到资源，原因可能是配置文件没有配置扫描到对应的controller或者是web.xml中没有配置，然后还有一种情况就是在Controller中的对应的方法路径写错。</p>
<h4 id="java-lang-ArrayIndexOutOfBoundsException-数据下标越界错误"><a href="#java-lang-ArrayIndexOutOfBoundsException-数据下标越界错误" class="headerlink" title="java.lang.ArrayIndexOutOfBoundsException 数据下标越界错误"></a>java.lang.ArrayIndexOutOfBoundsException 数据下标越界错误</h4><p>解决：查看为什么会数组下标越界，一般都是最后面的一个元素访问的时候访问了本不存在的数组下标值的元素。</p>
<h4 id="can-not-be-referenced-from-a-static-context-此错误表示不能在静态上下文引用类"><a href="#can-not-be-referenced-from-a-static-context-此错误表示不能在静态上下文引用类" class="headerlink" title="can not be referenced from a static context 此错误表示不能在静态上下文引用类"></a>can not be referenced from a static context 此错误表示不能在静态上下文引用类</h4><p>解决：此时是因为没有在static方法中声明类对象，然后在声明类对象之后再引用该声明对象的方法就能够使用该方法啦。</p>
<h4 id="Error-querying-database-Cause-java-sql-SQLSyntaxErrorException-Unknown-column-‘name’-in-‘field-list’"><a href="#Error-querying-database-Cause-java-sql-SQLSyntaxErrorException-Unknown-column-‘name’-in-‘field-list’" class="headerlink" title="### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘name’ in ‘field list’"></a>### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘name’ in ‘field list’</h4><p>解决：</p>
<h4 id="javax-servlet-ServletException-Could-not-resolve-view-with-name"><a href="#javax-servlet-ServletException-Could-not-resolve-view-with-name" class="headerlink" title="javax.servlet.ServletException: Could not resolve view with name"></a>javax.servlet.ServletException: Could not resolve view with name</h4><p>解决：此问题可能是因为在写springmvc的时候少写一些东西导致的问题。认真检查springmvc的程序是否正确。</p>
<h4 id="Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘course-section-‘1-2’"><a href="#Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘course-section-‘1-2’" class="headerlink" title="### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘course_section = ‘1-2’"></a>### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘course_section = ‘1-2’</h4><p>解决：此错误可能是因为mapper.xml中的文件少写了一些东西，比如：逗号，名称与主体或者数据库里面的名称不一致导致。此时应该注意检查xml文件的问题。</p>
<h4 id="Cannot-determine-value-type-from-string-‘B楼-114’-nested-exception-is-java-sql-SQLDataException-Cannot-determine-value-type-from-string-‘B楼-114’"><a href="#Cannot-determine-value-type-from-string-‘B楼-114’-nested-exception-is-java-sql-SQLDataException-Cannot-determine-value-type-from-string-‘B楼-114’" class="headerlink" title="Cannot determine value type from string ‘B楼#114’; nested exception is java.sql.SQLDataException: Cannot determine value type from string ‘B楼#114’"></a>Cannot determine value type from string ‘B楼#114’; nested exception is java.sql.SQLDataException: Cannot determine value type from string ‘B楼#114’</h4><p>解决：可能是因为xml文件的字段拼写或者是语法错误，认真检查。</p>
<h4 id="org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found"><a href="#org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found" class="headerlink" title="org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)"></a>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</h4><p>解决：要么是接口或者xml文件找不到，要么是两者之间不匹配</p>
<h4 id="Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘-VALUES-‘胡邦金’-’-at-line-34"><a href="#Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘-VALUES-‘胡邦金’-’-at-line-34" class="headerlink" title="### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘)VALUES(‘胡邦金’,’ at line 34"></a>### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘)VALUES(‘胡邦金’,’ at line 34</h4><p>解决：这样的错误可能是因为在sql语句中逗号的原因，所以使用<trim>关键字解决。</trim></p>
<h4 id="org-springframework-beans-InvalidPropertyException-Invalid-property-‘courseTeacher-’-of-bean-class-cn-edu-xidian-see-entity-AppointmentCourse-Property-referenced-in-indexed-property-path-‘courseTeacher-’-is-neither-an-array-nor-a-List-nor-a-Map-returned-value-was"><a href="#org-springframework-beans-InvalidPropertyException-Invalid-property-‘courseTeacher-’-of-bean-class-cn-edu-xidian-see-entity-AppointmentCourse-Property-referenced-in-indexed-property-path-‘courseTeacher-’-is-neither-an-array-nor-a-List-nor-a-Map-returned-value-was" class="headerlink" title="org.springframework.beans.InvalidPropertyException: Invalid property ‘courseTeacher[]’ of bean class [cn.edu.xidian.see.entity.AppointmentCourse]: Property referenced in indexed property path ‘courseTeacher[]’ is neither an array nor a List nor a Map; returned value was []"></a>org.springframework.beans.InvalidPropertyException: Invalid property ‘courseTeacher[]’ of bean class [cn.edu.xidian.see.entity.AppointmentCourse]: Property referenced in indexed property path ‘courseTeacher[]’ is neither an array nor a List nor a Map; returned value was []</h4><p>解决：对于这样的错误可能是因为在数据库表中设置该字段的值不为空，然后前台传参进去是为空的，所以导致两者不一致而产生错误。所以检查前台或者数据库表中字段值是否设置得当。</p>
<h4 id="Error-updating-database-Cause-java-sql-SQLIntegrityConstraintViolationException-Duplicate-entry-‘14020310013’-for-key-‘u-sno’"><a href="#Error-updating-database-Cause-java-sql-SQLIntegrityConstraintViolationException-Duplicate-entry-‘14020310013’-for-key-‘u-sno’" class="headerlink" title="### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry ‘14020310013’ for key ‘u_sno’"></a>### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry ‘14020310013’ for key ‘u_sno’</h4><p>解决：确保在开发过程中索引唯一性，也就是在插入数据的时候，具有唯一性约束条件的列的值有重复。</p>
<h4 id="echarts-js-11954-Uncaught-Error-series-type-should-be-specified"><a href="#echarts-js-11954-Uncaught-Error-series-type-should-be-specified" class="headerlink" title="echarts.js:11954 Uncaught Error: series.type should be specified."></a>echarts.js:11954 Uncaught Error: series.type should be specified.</h4><p>解决：这里需要自己加载option，就是自己定义的option。                majorChart.setOption(optionMajor);然后就不会报错了。</p>
<h4 id="1054-Unknown-column-‘雷达信号处理国家重点实验室’-in-‘where-clause’"><a href="#1054-Unknown-column-‘雷达信号处理国家重点实验室’-in-‘where-clause’" class="headerlink" title="1054 - Unknown column ‘雷达信号处理国家重点实验室’ in ‘where clause’"></a>1054 - Unknown column ‘雷达信号处理国家重点实验室’ in ‘where clause’</h4><p>解决：需要注意的是该列是字符串类型，需要加上单引号。双引号解析为字段变量或关键字，单引号解析为字段的值。</p>
<h4 id="bad-SQL-grammar-nested-exception-is-java-sql-SQLSyntaxErrorException-Unknown-column-‘电路CAD研究所’-in-‘where-clause’"><a href="#bad-SQL-grammar-nested-exception-is-java-sql-SQLSyntaxErrorException-Unknown-column-‘电路CAD研究所’-in-‘where-clause’" class="headerlink" title="; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: Unknown column ‘电路CAD研究所’ in ‘where clause’"></a>; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: Unknown column ‘电路CAD研究所’ in ‘where clause’</h4><p>解决：将最后的字段用单引号括起来。</p>
<h4 id="后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了"><a href="#后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了" class="headerlink" title="后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了"></a>后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了</h4><h4 id="使用datatables分页数据的时候报错413-full-head"><a href="#使用datatables分页数据的时候报错413-full-head" class="headerlink" title="使用datatables分页数据的时候报错413 full head"></a>使用datatables分页数据的时候报错413 full head</h4><p>解决：这里是因为请求的实体过大的缘故，将请求方式get改为post。</p>
<blockquote>
<p>注意：在为了避免此错误出现，尽量减少请求主体的大小。</p>
</blockquote>
<h4 id="Property-referenced-in-indexed-property-path-‘columns-0-data-’-is-neither-a"><a href="#Property-referenced-in-indexed-property-path-‘columns-0-data-’-is-neither-a" class="headerlink" title="Property referenced in indexed property path ‘columns[0][data]’ is neither a"></a>Property referenced in indexed property path ‘columns[0][data]’ is neither a</h4><p>解决：这里是因为在datatable中没有设置datatable的声明类。在配置文件中要配置其声明类DataTableArgumentResolver。</p>
<h4 id="Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25"><a href="#Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25" class="headerlink" title="Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25"></a>Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25</h4><p>解决：使用jetty:run-war</p>
<h4 id="在导入的mysql数据文件出现中文乱码时候，在mysql-sql源文件中设置编码-set-names-‘utf8’-问题解决。"><a href="#在导入的mysql数据文件出现中文乱码时候，在mysql-sql源文件中设置编码-set-names-‘utf8’-问题解决。" class="headerlink" title="在导入的mysql数据文件出现中文乱码时候，在mysql.sql源文件中设置编码 set names ‘utf8’; 问题解决。"></a>在导入的mysql数据文件出现中文乱码时候，在mysql.sql源文件中设置编码 set names ‘utf8’; 问题解决。</h4><h4 id="time-zone-错误，直接在数据库链接后面加上-serverTimezone-UTC-即可。"><a href="#time-zone-错误，直接在数据库链接后面加上-serverTimezone-UTC-即可。" class="headerlink" title="time_zone 错误，直接在数据库链接后面加上 ?serverTimezone=UTC 即可。"></a>time_zone 错误，直接在数据库链接后面加上 ?serverTimezone=UTC 即可。</h4><p>解决：jdbc.url=jdbc:mysql://127.0.0.1:3306/bilibili?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</p>
<h4 id="Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25-run-default-cli-on-project-BodyCheck-Failure"><a href="#Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25-run-default-cli-on-project-BodyCheck-Failure" class="headerlink" title="Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25:run (default-cli) on project BodyCheck: Failure"></a>Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25:run (default-cli) on project BodyCheck: Failure</h4><p>解决：根据错误日志可以知道是因为项目端口号被占用，换用其它端口号或者停掉当前端口号。</p>
<h4 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h4><p>解决：这个错误一般出现在断点续传中，含义是请求范围错误，例如：</p>
<p>一个文件的大小是10000000 byte，你请求起始点大于或等于10000000 时，即会返回416</p>
<pre><code>&lt;form action=&quot;&quot; method=&quot;post&quot; class=&quot;form-horizontal&quot; enctype=&quot;application/x-www-form-urlencoded&quot; &gt;
</code></pre><p>在页面上加入上面的程序，请求的链接的页面会解决416错误。</p>
<h4 id="416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。"><a href="#416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。" class="headerlink" title="416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。"></a>416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。</h4><p>解决：利用其它服务器，获取其它服务器的视频位置，然后在ckplayer视频路径下添加上，视频能够正常播放。</p>
<h4 id="HTTP-400错误-一般来说是因为前后台之间传递参数不一致所导致的"><a href="#HTTP-400错误-一般来说是因为前后台之间传递参数不一致所导致的" class="headerlink" title="HTTP 400错误 一般来说是因为前后台之间传递参数不一致所导致的"></a>HTTP 400错误 一般来说是因为前后台之间传递参数不一致所导致的</h4><p>解决：这里我要解决的是前台传递一个List&lt;对象&gt;到后台，所以在使用ajax传递之前需要将这样一个List对象转换成String类型，然后将Stirng类型通过ajax方式传递给后台。在后台通过@RequestBody注解接收，还需要类型是List&lt;对象&gt;类型。</p>
<h4 id="如何解决在mybatis中加入java-util-List类型的数据"><a href="#如何解决在mybatis中加入java-util-List类型的数据" class="headerlink" title="如何解决在mybatis中加入java.util.List类型的数据"></a>如何解决在mybatis中加入java.util.List类型的数据</h4><h4 id="报错-jetty-server-exiting"><a href="#报错-jetty-server-exiting" class="headerlink" title="报错 jetty server exiting"></a>报错 jetty server exiting</h4><p>解决：将Java虚拟机停掉重新启动项目便可。</p>
<h4 id="PreparedStatementCallback-uncategorized-SQLException-for-SQL-Incorrect-integer-value-‘’-for-column-‘payment-status’-at-row-1"><a href="#PreparedStatementCallback-uncategorized-SQLException-for-SQL-Incorrect-integer-value-‘’-for-column-‘payment-status’-at-row-1" class="headerlink" title="PreparedStatementCallback; uncategorized SQLException for SQL Incorrect integer value: ‘’ for column ‘payment_status’ at row 1"></a>PreparedStatementCallback; uncategorized SQLException for SQL Incorrect integer value: ‘’ for column ‘payment_status’ at row 1</h4><p>解决：将数据表里面的对应的Integer类型转换成varchar类型。报错消失。</p>
<h4 id="DataTables插件不能正常使用的时候，排查前端是否写对。中是否包含-lt-list-gt"><a href="#DataTables插件不能正常使用的时候，排查前端是否写对。中是否包含-lt-list-gt" class="headerlink" title="DataTables插件不能正常使用的时候，排查前端是否写对。中是否包含&lt;#list&gt;"></a>DataTables插件不能正常使用的时候，排查前端是否写对。<tbody></tbody>中是否包含&lt;#list&gt;</h4><h4 id="Truncated-incorrect-DOUBLE-value-‘2019-12-13-15-52-20’"><a href="#Truncated-incorrect-DOUBLE-value-‘2019-12-13-15-52-20’" class="headerlink" title="Truncated incorrect DOUBLE value: ‘2019-12-13 15:52:20’"></a>Truncated incorrect DOUBLE value: ‘2019-12-13 15:52:20’</h4><p>解决：将UPDATE teacher_employment_post_feedback SET ctime = “2019-12-13 15:52:20” and utime = “2020-01-03 15:43:20”语句中的and改为’,’</p>
<h4 id="nested-exception-is-org-apache-ibatis-reflection-ReflectionException-There-is-no-getter-for-property-named-‘condition’-in-‘class-com-llq-DataTables-condition-DTCondition’"><a href="#nested-exception-is-org-apache-ibatis-reflection-ReflectionException-There-is-no-getter-for-property-named-‘condition’-in-‘class-com-llq-DataTables-condition-DTCondition’" class="headerlink" title="nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named ‘condition’ in ‘class com.llq.DataTables.condition.DTCondition’"></a>nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named ‘condition’ in ‘class com.llq.DataTables.condition.DTCondition’</h4><p>解决：在写程序的时候出现错误，在传递的参数中没有condition变量，也就是在.xml文件中不用condition.where这样的来引用。直接${where}来引用即可。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>

---
title: Java程序开发项目经验
tags:
  - 项目开发
categories: 
  - 学习笔记
copyright: true
showdonate: true
date: 2018-06-05 09:22:26
comments: true
password: 
---
<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="1-Tomcat与jetty"><a href="#1-Tomcat与jetty" class="headerlink" title="1.Tomcat与jetty"></a>1.Tomcat与jetty</h3><p>jetty和Tomcat是两款著名的开源webserver/servlet容器。</p>
<pre><code>两者之间的比较：

    1.jetty更加的轻量级
    2.jetty更加灵活，表现在可扩展性
</code></pre><hr>
<h3 id="2-web-xml文件配置"><a href="#2-web-xml文件配置" class="headerlink" title="2.web.xml文件配置"></a>2.web.xml文件配置</h3><p>修改在<code>webapp</code>路径下的<code>web.xml</code>文件需要根据规定的顺序添加操作权限，否则会报错。或者将<code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</code>这一段校验代码删掉，问题就解决了。这时因为我们添加的部分的代码符合<code>xml</code>文档规范，但是不符合<code>web-app_2_3.dtd</code>所定义的规范。</p>
<hr>
<a id="more"></a>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><blockquote>
<p>注意：在使用IDEA开发的时候，mapper类只能建立在resource目录下，不能建立在Java的包下面，不然会映射不了。</p>
</blockquote>
<pre><code>1.首先编写entity
2.然后编写接口
3.接下来使用mapper
4.最后编写测试用例，直接使用junit测试
    //测试dao层
    // 使用Springtest测试框架
    @RunWith(SpringJUnit4ClassRunner.class)
    // 加载配置
    @ContextConfiguration(&quot;/spring/spring-*.xml&quot;) 
    public class MyBatisTest {
        @Autowired
        private ScoreDao scoreDao;

        @Test
        public void testAddScore() {
            Score score = new Score();
            score.setChangeType(&quot;充钱钱&quot;);
            score.setScore(10);
            int insert = scoreDao.insertScore(score);
            System.out.print(&quot;insert :&quot;+insert);
        }
    }

5.测试整个框架(使用SpringMVC)
    1.编写业务逻辑接口
    2.然后编写业务逻辑接口的实现类
    3.然后编写controller将springmvc的解析视图解析出来
</code></pre><hr>
<h3 id="4-Redis-单机版以及测试版"><a href="#4-Redis-单机版以及测试版" class="headerlink" title="4.Redis 单机版以及测试版"></a>4.Redis 单机版以及测试版</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - Java集成</title>
    <url>/undefined/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="1-Tomcat与jetty"><a href="#1-Tomcat与jetty" class="headerlink" title="1.Tomcat与jetty"></a>1.Tomcat与jetty</h3><p>jetty和Tomcat是两款著名的开源webserver/servlet容器。</p>
<pre><code>两者之间的比较：

    1.jetty更加的轻量级
    2.jetty更加灵活，表现在可扩展性
</code></pre><hr>
<h3 id="2-web-xml文件配置"><a href="#2-web-xml文件配置" class="headerlink" title="2.web.xml文件配置"></a>2.web.xml文件配置</h3><p>修改在<code>webapp</code>路径下的<code>web.xml</code>文件需要根据规定的顺序添加操作权限，否则会报错。或者将<code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</code>这一段校验代码删掉，问题就解决了。这时因为我们添加的部分的代码符合<code>xml</code>文档规范，但是不符合<code>web-app_2_3.dtd</code>所定义的规范。</p>
<hr>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><blockquote>
<p>注意：在使用IDEA开发的时候，mapper类只能建立在resource目录下，不能建立在Java的包下面，不然会映射不了。</p>
</blockquote>
<pre><code>1.首先编写entity
2.然后编写接口
3.接下来使用mapper
4.最后编写测试用例，直接使用junit测试
    //测试dao层
    // 使用Springtest测试框架
    @RunWith(SpringJUnit4ClassRunner.class)
    // 加载配置
    @ContextConfiguration(&quot;/spring/spring-*.xml&quot;) 
    public class MyBatisTest {
        @Autowired
        private ScoreDao scoreDao;

        @Test
        public void testAddScore() {
            Score score = new Score();
            score.setChangeType(&quot;充钱钱&quot;);
            score.setScore(10);
            int insert = scoreDao.insertScore(score);
            System.out.print(&quot;insert :&quot;+insert);
        }
    }

5.测试整个框架(使用SpringMVC)
    1.编写业务逻辑接口
    2.然后编写业务逻辑接口的实现类
    3.然后编写controller将springmvc的解析视图解析出来
</code></pre><hr>
<h3 id="4-Redis-单机版以及测试版"><a href="#4-Redis-单机版以及测试版" class="headerlink" title="4.Redis 单机版以及测试版"></a>4.Redis 单机版以及测试版</h3><hr>
<h3 id="5-SSM-项目开发"><a href="#5-SSM-项目开发" class="headerlink" title="5.SSM 项目开发"></a>5.SSM 项目开发</h3><h4 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h4><h4 id="Service接口文件与ServiceImpl实现类文件"><a href="#Service接口文件与ServiceImpl实现类文件" class="headerlink" title="Service接口文件与ServiceImpl实现类文件"></a>Service接口文件与ServiceImpl实现类文件</h4><p>1.ServiceImpl文件<br>对于ServiceImpl中的文件只是实现Service接口中的方法函数，在Service接口的返回类型：<br>1.一般表示操作(删除/更新/添加)的方法函数返回Boolean类型。<br>2.表示查找返回其需要的类型(实体类型/实体类型的List)。<br><br>实现步骤：<br><br>    1.在接口类实现之前添加@Service注解<br><br>    2.然后在class中注入相关的mapper接口<br><br>    3.最后实现相关的方法函数</p>
<p>2.Service文件<br><br>对于Service文件只是声明此文件中将要实现的方法函数。</p>
<hr>
<h4 id="1-http-400-error"><a href="#1-http-400-error" class="headerlink" title="1.http 400 error"></a>1.http 400 error</h4><p>http 400 错误表示请求无效(bad request) 在ajax请求后台数据时会报http 400 错误，表示这个请求没有进入后台服务里。</p>
<ul>
<li><p>原因：<br>  1.前端提交数据的字段名称或者或者字段类型和后台的实体类不一致，或者前端提交的参数跟后台需要的参数不一致，导致参数无法封装。<br>  2.前端提交到后台的数据应该是JSON字符串类型，而前端没有将此对象转化为字符串类型。</p>
</li>
<li><p>解决方案：<br>  1.对照字段名称、类型保证一致性。<br>  2.使用stringify将前端传递的对象转化为字符串 如：data:JSON.stringify(param);</p>
</li>
</ul>
<hr>
<p>1.<code>JSON.toJSON()</code>方法可以将Date对象转换为字符串，并格式化为JSON数据格式。</p>
<pre><code>var Date = new Date();
var Date_New = Date.toJSON();
</code></pre><p>2.<code>JSON.toJSONString()</code>方法将对象转换为JSON格式数据。</p>
<hr>
<h2 id="Spring-开发注解"><a href="#Spring-开发注解" class="headerlink" title="Spring 开发注解"></a>Spring 开发注解</h2><pre><code>1.@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT) 表示该类需要Spring加入事务，propagation=Propagation.REQUIRED 属性指有事务就处于当前事务中，没有事务就创建一个事务。isolation=Isolation.DEFAULT 表示使用事务的默认隔离级别。
</code></pre><hr>
<h4 id="tld文件"><a href="#tld文件" class="headerlink" title=".tld文件"></a>.tld文件</h4><hr>
<h2 id="调试错误-状态码-400-404等"><a href="#调试错误-状态码-400-404等" class="headerlink" title="调试错误 状态码(400 404等)"></a>调试错误 状态码(400 404等)</h2><h4 id="1-http-400-Bad-request"><a href="#1-http-400-Bad-request" class="headerlink" title="1. http 400(Bad request)"></a>1. http 400(Bad request)</h4><p>在ajax请求后台数据时有时会报 HTTP 400 错误 - 请求无效 (Badrequest)，出现这个请求无效报错说明<code>请求没有进入到后台服务</code>里。</p>
<p><strong>原因：</strong></p>
<pre><code>1）前端提交数据的字段名称或者是字段类型和后台的实体类不一致，导致无法封装。
2）前端提交的到后台的数据应该是json字符串类型，而前端没有将对象转化为字符串类型。
</code></pre><p><strong>解决方案：</strong></p>
<pre><code>1）对照字段名称，类型保证一致性
2）使用stringify将前端传递的对象转化为字符串
    data: JSON.stringify(param)。
</code></pre><h4 id="2-空指针异常"><a href="#2-空指针异常" class="headerlink" title="2. 空指针异常"></a>2. 空指针异常</h4><p><strong>1.空指针异常发生情况</strong></p>
<pre><code>1.字符串变量没有初始化
2.接口类型的对象没有用具体的类初始化
    如：
        List list;//这个就会报错
        List list = new ArrayList();//这就不会报错

3.在一个对象的值为空，而我们没有判断为空的情况时会报错
</code></pre><p><strong>2.空指针异常解决方案</strong><br><br>重点关注报错发生在的行，通过空指针异常产生的两条主要原因诊断具体的错误。同时为了避免空指针的发生，最好在做判断处理时将“null”或者空值放于设定的值之前。</p>
<blockquote>
<p>注意：大多数的空指针异常都是与对象的操作相关</p>
</blockquote>
<h4 id="3-springmvc"><a href="#3-springmvc" class="headerlink" title="3. springmvc"></a>3. springmvc</h4><pre><code>//判断obj是否空指针，如果是则抛出空指针异常
Objects.requireNonNull(obj);
</code></pre><p><strong>1.修</strong><br></p>
<pre><code>//这表示修改之前首先获取到需要修改的信息，返回给前台
@RequestMapping(&quot;/student/mod/{sid}&quot;)
public String student_modify(@PathVariable(&quot;sid&quot;) Integer sid, Model model, HttpSession session) {
    Objects.requireNonNull(sid);

    Student student = studentService.findById(sid);
    Integer tid = (Integer) session.getAttribute(Constant.SESSION_KEY_FOR_TEACHER_ID);
    Teacher admin = teacherService.findById(tid);

    model.addAttribute(&quot;student&quot;, student);
    model.addAttribute(&quot;admin&quot;, admin);
    return &quot;admin/student_mod&quot;;
}

//表示在上面的获取修改的值之后，在这里执行修改操作
@RequestMapping(&quot;/student/mod/do&quot;)
public String student_modify_do(Student student) {

    LOG.info(&quot;modify: &quot; + student);
    student.setYear(Integer.valueOf(student.getGrade()) + 4 + &quot;&quot;);
    studentService.saveOrUpdate(student);

    return &quot;redirect:/admin/student&quot;;
}
</code></pre><p><strong>2.删</strong><br></p>
<pre><code>//这里表示根据所在项的id值删除该项
@RequestMapping(&quot;/student/dlt/{sid}&quot;)
@ResponseBody
public Object student_delete(@PathVariable(&quot;sid&quot;) Integer sid, Model model) {
    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();

    LOG.info(&quot;delete student: sid = &quot; + sid);
    Student student = studentService.findById(sid);
    try {
        studentService.delete(sid);
        LOG.info(&quot;delete student = &quot; + student);
        result.put(&quot;code&quot;, ResultCodeEnum.SUCCESS.getVal());
    } catch (Exception e) {
        result.put(&quot;code&quot;, ResultCodeEnum.FAILED.getVal());
    }
    return result;
}
</code></pre><p><strong>3.增</strong><br></p>
<pre><code>//首先给出添加页面
@RequestMapping(&quot;/student/add&quot;)
public String student_add(Model model, HttpSession session) {
    Integer tid = (Integer) session.getAttribute(Constant.SESSION_KEY_FOR_TEACHER_ID);
    Teacher admin = teacherService.findById(tid);

    model.addAttribute(&quot;admin&quot;, admin);
    return &quot;admin/student_add&quot;;
}

//增加操作
@RequestMapping(&quot;/student/add/do&quot;)
public String student_add_do(Student student) {

    LOG.info(&quot;add student = &quot; + student);
    studentService.saveOrUpdate(student);

    return &quot;redirect:/admin/student&quot;;
}
</code></pre><p><strong>4.DataTables分页插件</strong><br></p>
<pre><code>@RequestMapping(value = &quot;/thesis-varify/process/{year}/{modify}&quot;, produces = {&quot;application/json;charset=UTF-8&quot;})
@ResponseBody
public Object thesisVarifyProcess(@PathVariable(&quot;year&quot;) String year,
                                  @PathVariable(&quot;modify&quot;) Integer modify,
                                  //这标签的作用是将其绑定在request上面
                                  @DataTableArgument DataTableRequest dtRequest,
                                  @RequestParam(value = &quot;showColumns[]&quot;, required = false) String[] showColumns) {

    //新建的接收前台的数据容器
    DataTableResponse&lt;ThesisVarifyVo&gt; dtResponse = new DataTableResponse&lt;&gt;();
    if (modify == -1) modify = null;
    List&lt;ThesisVarifyVo&gt; thesisVarifyVos = adminService
            .queryThesisVarifyVoForDataTable(dtRequest, showColumns, year, modify);
    //然后将从数据库中查询到的数据封装到返回前台的容器中
    dtResponse.setData(thesisVarifyVos);
    //表示查询的数据
    dtResponse.setRecordsFiltered(adminService
            .countFilteredThesisVarifyVoForDataTable(dtRequest, showColumns, year, modify));
    //表示总的记录
    dtResponse.setRecordsTotal(adminService.countTotalThesisVarifyVoForDataTable());
    dtResponse.setDraw(dtRequest.getDraw());

    return JSON.toJSONString(dtResponse);
}
</code></pre><p><strong>5.DataTables服务端参数</strong><br></p>
<pre><code>1.发送到服务器端的参数
    draw 计数器，返回数据用这个记录
    start 开始记录
    length 每页条数
    search[value] 检索文字
    order[i][column] int 排列列的序号，i表示有几个排序 order[0][column]表示有一个服务器端
    order[i][dir] 排序方式“desc” “asc”

    注：下面comuns中的i取值从0~columns.length，所有的columns信息都发送到了服务器
        columns[i][data]：columns上定义的data属性值
        columns[i][name]：columns上定义的name属性值
        columns[i][searchable]：列能不能检索
        columns[i][orderable]：列能不能排序
        columns[i][search][value]：列的检索值 string

2.服务器返回的数据
    draw：和Request的draw设定成一样的值
    recordsTotal：所有的总件数
    recordsFiltered：筛选后的总件数
    data：返回的数据
        每一行数据上面，可以包含这几个可选项
            DT_RowId：加在行上的ID值
            DT_RowClass：加在行上的Class
            DT_RowData：加在行上的额外数据（object）
            DT_RowAttr：加在行上的属性（object）
            error:如果有错误，就设定这个值，没有错误，不要包含这个值
</code></pre><hr>
<h2 id="前台向后端传参数"><a href="#前台向后端传参数" class="headerlink" title="前台向后端传参数"></a>前台向后端传参数</h2><h4 id="1-get方式"><a href="#1-get方式" class="headerlink" title="1.get方式"></a>1.get方式</h4><pre><code>&lt;a href=&quot;/teacher/coursework/export?courseName=${tWorks.courseName}&quot; class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; 下载《${tWorks.courseName}》作业表&lt;/a&gt;
</code></pre><h4 id="2-post方式"><a href="#2-post方式" class="headerlink" title="2.post方式"></a>2.post方式</h4><hr>
<h2 id="mysql联合查询-3表联合查询"><a href="#mysql联合查询-3表联合查询" class="headerlink" title="mysql联合查询(3表联合查询)"></a>mysql联合查询(3表联合查询)</h2><pre><code>//最开始的mysql 3表联合查询语句
SELECT
    student_course_work.sclass,
    student.sname,
    student.sno,
    student_course_work.submit_time,
    teacher_course_work.course_name
FROM
    student_course_work
INNER JOIN student ON student.id = student_course_work.sid
INNER JOIN teacher_course_work ON teacher_course_work.tid = student_course_work.tid
WHERE
    course_id = #{courseId}
</code></pre><blockquote>
<p>注意：这里需要说明一点的就是，这里的联合查询会出现重复的结果，所以在这种情况下的查询是不能使用的。</p>
</blockquote>
<pre><code>//修改后的mysql联合查询语句
SELECT
    student_course_work.sclass,
    student.sname,
    student.sno,
    student_course_work.submit_time,
    teacher_course_work.course_name
FROM
    student_course_work
INNER JOIN student ON student.id = student_course_work.sid
INNER JOIN teacher_course_work ON teacher_course_work.id = student_course_work.course_id
WHERE
    course_id = #{courseId}
</code></pre><hr>
<h2 id="FreeMarker-contains-amp-seq-contains"><a href="#FreeMarker-contains-amp-seq-contains" class="headerlink" title="FreeMarker - contains &amp; seq_contains"></a>FreeMarker - contains &amp; seq_contains</h2><h4 id="1-contains"><a href="#1-contains" class="headerlink" title="1.contains"></a>1.contains</h4><p>该字段是String上的方法，作用与字符串上，主要用来查找字符串或者字符是否存在在指定的字符串中，返回true or false。</p>
<h4 id="2-seq-contains"><a href="#2-seq-contains" class="headerlink" title="2.seq_contains"></a>2.seq_contains</h4><p>如果要判断序列中是否包含某个指定的元素，可以使用序列的内建函数seq_contains。</p>
<blockquote>
<p>注1：seq_contains这个内建函数从FreeMarker 2.3.1 版本开始可用。而在2.3版本中不存在。</p>
<blockquote>
<p>注2：在开发过程中，该查找的参数大多数情况下都是返回数据，需要注意数据类型一致，如果数据类型不一致会报错。</p>
</blockquote>
</blockquote>
<hr>
<h2 id="权限-Permissions"><a href="#权限-Permissions" class="headerlink" title="权限 Permissions"></a>权限 Permissions</h2><p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p>
<pre><code>1.在执行视图的dispatch()方法前，会先进行视图访问权限的判断
2.在通过get_object()获取具体对象时，会进行对象访问权限的判断
</code></pre><hr>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>在向map中插入值的时候，注意前后类型的区别。</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
//key和value值的类型都是String
map.put(&quot;name&quot;,name);

Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
//key和value的值分别是String和Integer
map.put(&quot;sno&quot;,sno);

Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
//key的类型必须是String，而sno的类型可以是任意的，Integer，String等。
map.put(&quot;sno&quot;,sno);
</code></pre><hr>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>获取List集合中的一行，使用<code>list.get(i)</code>，然后再获取该行中的某一列<code>list.get(i).getName();</code></p>
<hr>
<h2 id="Ajax提交表单-SpringMVC接收"><a href="#Ajax提交表单-SpringMVC接收" class="headerlink" title="Ajax提交表单 SpringMVC接收"></a>Ajax提交表单 SpringMVC接收</h2><h4 id="1-serialize-方法"><a href="#1-serialize-方法" class="headerlink" title="1.serialize()方法"></a>1.serialize()方法</h4><p><strong>1.1 前台JavaScript的编写</strong><br></p>
<pre><code>function insert(){
    $.ajax({
        type:&quot;POST&quot;,
        url:&quot;${pageContext.request.contextPath}/order/insert&quot;,
        data : $(&quot;#fom&quot;).serialize(),             
        success  :function (res) {
            console.log(res); 
        error:function () {                
        }
    });
}
</code></pre><p><strong>1.2 后台SpringMVC的数据接收</strong><br></p>
<pre><code>@RequestMapping(value = &quot;/insert&quot;,method = RequestMethod.POST)
public String insert( Order order){
   int result=this.orderSerivce.insert(order);
   if(result==1){
       System.out.println(&quot;添加失败&quot;);
       return &quot;101&quot;;
   }
   return &quot;100&quot;;
}
</code></pre><blockquote>
<p>注意：后台SpringMVC用对象参数接收，可以自动转换为对象，需要注意name要和对象中的参数名相同。</p>
</blockquote>
<h4 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2.JSON.stringify()"></a>2.JSON.stringify()</h4><p><strong>2.1 前台程序的编写</strong><br></p>
<pre><code>function insert(){
    $.ajax({
        type:&quot;POST&quot;,
        url:&quot;${pageContext.request.contextPath}/user/insert&quot;,
        async:false,
        data :JSON.stringify({
            username : $(&quot;input[name=&apos;username&apos;]&quot;).val(),
            password: $(&quot;input[name=&apos;password&apos;]&quot;).val(),
            role : {
                id : &quot;&quot;,
                name: $(&quot;select[name=&apos;name&apos;]&quot;).val()
            }
        }),
        contentType: &quot;application/json;charset=UTF-8&quot;,
      /*如果不写这个,仔细看后台会出现Content type &apos;application/x-www-form-urlencoded;charset=UTF-8&apos; not supported   */ 
        dataType:&quot;json&quot;,
        success  :function (res) {
            console.log(res);
            if(res==100){
                $(&quot;#msg&quot;).html(&quot;&lt;font size=&apos;60px&apos;&gt; success &lt;/font&gt;&quot;).show(700).delay(3000).hide(500);
            }else {
                $(&quot;#msg&quot;).html(&quot;&lt;font size=&apos;60px&apos;&gt;  fail &lt;/font&gt;&quot;).show(700).delay(3000).hide(500);
            }
            window.location.href=&quot;http://localhost:8080/user/findall?page=1&quot;
        },
        error:function () {
            $(&quot;#msg&quot;).html(&quot;&lt;font size=&apos;60px&apos;&gt;  fail &lt;/font&gt;&quot;).show(700).delay(3000).hide(500);
            window.location.href=&quot;http://localhost:8080/user/findall?page=1&quot;
        }
    });
}
</code></pre><p><strong>2.2 后台程序的编写</strong><br></p>
<pre><code>@ResponseBody
@RequestMapping(value = &quot;/insert&quot;,method = RequestMethod.POST)
public String insert(@RequestBody User user){
   int result=this.userSerivce.insert(user);
   if(result==0){
       return &quot;101&quot;;
   }
   return &quot;100&quot;;
}
</code></pre><blockquote>
<p>注意：后台用@RequestBody接收, @RequestBody只接收JSON对象的字符串，所以在前台开始的时候需要将json格式对象转换成json格式对象的字符串格式。</p>
</blockquote>
<p><strong>2.3 JSON.parseObject() | JSON.toJSONString() 区别</strong><br><br>JSON.parseObject，是将Json字符串转化为相应的对象；JSON.toJSONString则是将对象转化为Json字符串。</p>
<hr>
<h2 id="SpringMVC-项目开发经验"><a href="#SpringMVC-项目开发经验" class="headerlink" title="SpringMVC 项目开发经验"></a>SpringMVC 项目开发经验</h2><h2 id="Java-文件流"><a href="#Java-文件流" class="headerlink" title="Java 文件流"></a>Java 文件流</h2><p>我们衡量输入、输出时总是站在运行本程序所在内存的角度。</p>
<hr>
<h3 id="javascript-–-gt-replace-g-“-“-g-是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。"><a href="#javascript-–-gt-replace-g-“-“-g-是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。" class="headerlink" title="javascript –&gt; replace(/-/g, “/“) /-/g 是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。"></a>javascript –&gt; replace(/-/g, “/“) /-/g 是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。</h3><hr>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/undefined/Redis/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>[TOC]</p>
<h3 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h3><ul>
<li>IDEA集成Redis可视化插件，直接在IDEA的setting的plugin中下载Iedis安装就行(付费)。</li>
<li>Redis可视化工具 RedisDestopManager</li>
</ul>
<p>Redis 是一个基于内存的高性能key-value数据库，通过提供多种键值数据类型来适应不同场景下的存储需求。<br></p>
<blockquote>
<p>应用场景：1.会话缓存(session cache)(数据查询、短链接、新闻内容、商品内容等) 2.全页缓存(FPC) 3.任务队列(秒杀、抢购、12306) 4.排行榜/计数器 5.发布/订阅 6.分布式集群架构中的session分离 7.数据过期处理</p>
</blockquote>
<blockquote>
<p>扩展：为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。NoSQL：not-Only SQL表示非关系型数据库，作为关系型数据库的良好补充。</p>
</blockquote>
<h4 id="1-Redis特点"><a href="#1-Redis特点" class="headerlink" title="1.Redis特点"></a>1.Redis特点</h4><p>优点：<br><br>1.速度快，因为数据都是存储在内存中的，类似于HashMap，HashMap的优势就在于查找和操作的时间复杂度都为O(1)。Redis在本质上是一个<code>KEY-VALUE</code>类型的内存数据库，很像<code>memcached</code>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。<br></p>
<p>2.由于其是纯内存操作，所以性能非常好，是已知性能最快的key-value DB。<br></p>
<p>3.reids支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached只能保存1MB数据。<br></p>
<p>4.支持丰富的数据类型，支持string，list，set，sorted set，hash。</p>
<p>5.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>6.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<p>缺点：<br><br>7.reids的缺点主要是，数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h4 id="2-Redis支持的数据类型"><a href="#2-Redis支持的数据类型" class="headerlink" title="2.Redis支持的数据类型"></a>2.Redis支持的数据类型</h4><ul>
<li>String  可以是字符串，整数或浮点数，对整个字符串或者字符串中的一部分执行操作。</li>
<li>List 表示一个链表</li>
<li>Sets 求交集/并集</li>
<li>Sorted Set</li>
<li>hashs</li>
</ul>
<h4 id="3-Redis需要将所有数据放到内存中的原因"><a href="#3-Redis需要将所有数据放到内存中的原因" class="headerlink" title="3.Redis需要将所有数据放到内存中的原因"></a>3.Redis需要将所有数据放到内存中的原因</h4><p>1.Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。<br><br>2.如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br><br>3.如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<blockquote>
<p>注意：1.reids是单进程单线程的，利用队列技术将并发访问变成串行访问，消除传统数据库串行控制的开销。<br>2.</p>
</blockquote>
<h4 id="4-Redis常见性能问题解决"><a href="#4-Redis常见性能问题解决" class="headerlink" title="4.Redis常见性能问题解决"></a>4.Redis常见性能问题解决</h4><p>1.master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。<br><br>2.如果数据比较重要，某个<code>Slave</code>开启<code>AOF</code>备份数据，策略设置为每秒同步一次。(slave?aof?是啥)<br><br>3.为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。<br><br>4.尽量避免在压力很大的主库上增加从库。<br><br>5.从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3等，这样的结构方便解决单点故障问题，实现Slave对Master的替换，如果Master挂了可以立刻启用Slave1做Master，其他不变。</p>
<h4 id="5-Redis与memcached的区别"><a href="#5-Redis与memcached的区别" class="headerlink" title="5.Redis与memcached的区别"></a>5.Redis与memcached的区别</h4><p>1.memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。<br><br>2.redis的速度比memcached快很多。<br><br>3.redis可以持久化其数据。(数据的持久化就是将内存中的数据模型转化为存储模型，数据模型是任何的数据结构或者是对象，存储模型可以是关系型/xml文件/二进制流) </p>
<p>狭义：持久化仅仅是将对象数据永久保存在数据库中。</p>
<p>广义：持久化包括和数据库相关的各种操作，封装数据访问细节，为大部分业务逻辑提供面向对象的API。</p>
<h4 id="6-Redis持久化方案区别-优缺点"><a href="#6-Redis持久化方案区别-优缺点" class="headerlink" title="6.Redis持久化方案区别/优缺点"></a>6.Redis持久化方案区别/优缺点</h4><p>首先我们知道，Redis为我们提供两种持久化的方式，RDB(Redis DataBase)/AOF(Append Only File)。<br>1.RDB方式：快照式的持久化方法，将某一时刻的数据持久化到磁盘中。</p>
<pre><code>1.因为Redis在持久化的过程中，会首先将数据写入到一临时文件中，在持久化过程都结束之后才会用此临时文件替换已经持久化好的文件。所以因为这个特性让我随时进行备份。
2.于RDB方式，Redis单独创建一个子进程来进行持久化，主进程不会进行任何IO操作，这就确保Redis很好的性能。
3.如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
</code></pre><p>2.AOF方式：将执行过的 <code>写指令</code> 记录下来，在数据恢复时按照<code>从前到后</code>的顺序再将指令执行一遍。</p>
<pre><code>1.AOF 命令以Redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。默认的 AOF 持久化策略是每秒钟 fsync 一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。

2.如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。

3.因为此种是采用追加的方式，所以如果我们不做任何处理的话，AOF文件会变得越来越大。所以在此Redis提供AOF文件重写机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

4.在进行AOF重写时，我们仍然采用是先写临时文件，最后在全部完成之后再替换掉的流程，所以在断电、磁盘满等问题都不会影响AOF文件的可用性。
</code></pre><h4 id="7-如何维护集群之间的关系-集群之间如何建立连接"><a href="#7-如何维护集群之间的关系-集群之间如何建立连接" class="headerlink" title="7.如何维护集群之间的关系(集群之间如何建立连接)"></a>7.如何维护集群之间的关系(集群之间如何建立连接)</h4><h4 id="8-Redis存取实体的方式"><a href="#8-Redis存取实体的方式" class="headerlink" title="8.Redis存取实体的方式"></a>8.Redis存取实体的方式</h4><p>在存储的时候需要将实体 <code>序列化</code> ，然后可以当字符串一样存储，取数据也一样，取出来的数据要 <code>反序列化</code> 。</p>
<h4 id="9-Redis保留时间"><a href="#9-Redis保留时间" class="headerlink" title="9.Redis保留时间"></a>9.Redis保留时间</h4><p>Redis保留时间在未设置的情况下会一直存在，除非服务停掉且没有保存到磁盘。如果已手动或自动保存过，则再次启动服务还会存在。</p>
<hr>
<h3 id="将Redis配置成服务"><a href="#将Redis配置成服务" class="headerlink" title="将Redis配置成服务"></a>将Redis配置成服务</h3><p>将redis做成服务之后，后面就可以直接在cmd中输入命令 redis-server –service-start 启动</p>
<pre><code>redis-server --service-install redis-windows-conf 在redis的目录执行，将redis做成服务
</code></pre><h3 id="cmd命令框进入Redis目录，输入-redis-server-exe-redis-windows-conf-命令启动redis服务"><a href="#cmd命令框进入Redis目录，输入-redis-server-exe-redis-windows-conf-命令启动redis服务" class="headerlink" title="cmd命令框进入Redis目录，输入 redis-server.exe  redis.windows.conf 命令启动redis服务"></a>cmd命令框进入Redis目录，输入 redis-server.exe  redis.windows.conf 命令启动redis服务</h3><hr>
<blockquote>
<p>提示：Redis虽然是作为数据库开发，但是还可以作为缓存、队列系统使用。Redis可以为每个键设置生存时间TTL，到时间之后就是自动删除。</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>所谓事务就是一组命令的集合，事务同命令一样都是Redis最小执行单位，一个事务中的命令要么执行，要么都不执行。</p>
<h2 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>NoSql是一种解决高并发、高可用、高可扩展性以及大数据存储等系列问题的解决方案。</p>
<blockquote>
<p>提示：NoSql是非关系型数据库，不能代替关系型数据库，只是关系型数据库的一个良好补充。</p>
</blockquote>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><pre><code>1.键值存储（key-value）

2.列存储

3.文档数据库（mogondb）

4.图形数据库
</code></pre><h4 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h4><p>缓存、分布式集群架构session分离、任务队列等。然后它的应用场景真的很多。</p>
<h4 id="Redis处理逻辑"><a href="#Redis处理逻辑" class="headerlink" title="Redis处理逻辑"></a>Redis处理逻辑</h4><p>用户请求过来之后，首先判断Redis里面是否存在，如果存在则直接返回Redis中的数据给用户，没有则查询数据库。如果数据库中不存在则返回空或者提醒用户。</p>
<p><strong>1.添加操作</strong><br><br>如果是需要放入缓存的数据，那么在向mysql数据库中插入成功后，生成对应的key值，并存入Redis中。</p>
<p><strong>2.修改操作</strong><br><br>向mysql数据库中修改成功后，修改Redis中的数据，但是Redis并没有更新语句，所以只能先删除，再添加完成更新操作。</p>
<blockquote>
<p>注意：程序操作Redis的操作可能会失败，那么此时mysql中的数据已经修改，但是Redis中的数据依旧是上一次的数据，从而导致数据不一致的问题，所以是先操作Redis还是mysql需要注意。</p>
</blockquote>
<p><strong>3.删除操作</strong><br><br>和修改操作一样，先删除数据，然后再更新缓存，但是还得注意数据一致性的问题。</p>
<p><strong>4.查询操作</strong><br><br>首先通过Redis查询，如果缓存中已经存在数据则直接返回即可，此时就不再需要通过mysql数据库来获取数据，减少对mysql的请求，如果缓存中不存在数据，则依然通过mysql数据库查询，查询到数据后，存入Redis缓存中。</p>
<h4 id="缓存存储策略"><a href="#缓存存储策略" class="headerlink" title="缓存存储策略"></a>缓存存储策略</h4><p><strong>1.缓存数据特点</strong><br></p>
<pre><code>1.热点数据
2.实时性要求不高数据
3.业务逻辑简单数据
</code></pre><p><strong>2.缓存失效策略</strong><br></p>
<ul>
<li>定时删除，在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</li>
<li>惰性删除，key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期则删除，返回null。</li>
<li>定期删除，每隔一段时间执行一次删除过期key操作。</li>
<li></li>
</ul>
<hr>
<blockquote>
<p>在Linux中安装并配置好redis之后启动</p>
</blockquote>
<pre><code>1. ./redis-server 命令只是前端启动，在启动之后不能做任何操作

    ctrl + c 停止启动前端模式

2. ./redis-server ./redis.conf 这里的redis配置文件已经修改过

3. ./bin/redis-cli shutdown 停止redis客户端

4. ./bin/redis-cli 进入当前redis的客户端
</code></pre><hr>
<h2 id="Redis可执行文件说明"><a href="#Redis可执行文件说明" class="headerlink" title="Redis可执行文件说明"></a>Redis可执行文件说明</h2><pre><code>命令名 | 命令说明
---|---
redis-server | redis服务器
redis-cli | redis命令行客户端
redis-benchmark | redis性能测试工具
redis-check-aof | aof文件修复工具
redis-check-dump | RDB文件检查工具
redis-sentinel | sentinel服务器（2.8以后）
</code></pre><hr>
<h2 id="Redis-API的理解和使用"><a href="#Redis-API的理解和使用" class="headerlink" title="Redis API的理解和使用"></a>Redis API的理解和使用</h2><pre><code>1.keys[pattern] 遍历所有key，时间复杂度是O(N)
2.dbsize 遍历所有key，时间复杂度O(1)
3.expire key seconds key在seconds秒后过期，时间复杂度是O(1)
4.ttl key 查看key剩余的过期时间 时间复杂度是O(1)
5.persist key 去掉key的过期时间    O(1)
6.exists 检查key是否存在 O(1)
7.del key 删除指定的key-value O(1)
</code></pre><hr>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1.String（字符串）"></a>1.String（字符串）</h4><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
<pre><code>字符串常用的命令：

    1.赋值

        1. set key value

    2.取值

        1. get key

    3.先获取值在设置值

        1. getset key value

    4.删除

        1. del key

    5.数值的增减

        1. incr key 将指定的key的value递增1，如果该值不存在则初始化为0之后再incr后为1，如果value值不能转换成整型，操作失败

        2. decr key 将指定的key的value递减1，如果该值不存在则初始化为0之后再decr后为-1，如果value值不能转换成整型，操作失败

    6.扩展命令

        1. incrby key m 将指定的key的value值递增m，其它的类似上面的操作

        2. decrby key m 将指定的key的value值递减m，其它的类似上面的操作

        3. append key m 将在指定的key之后追加m，然后返回的是该字符串的长度（3 + 5 = 35）
</code></pre><h4 id="2-Hash（哈希）"><a href="#2-Hash（哈希）" class="headerlink" title="2.Hash（哈希）"></a>2.Hash（哈希）</h4><p>Redis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<blockquote>
<p>提示：可以看作是具有string的key和string的value的类型的map容器</p>
</blockquote>
<pre><code>哈希常用命令：

    1. 存储

        1. hset key keyOne value 表示在名字为key的哈希中存放一个键值对（keyOne，value）

        2. hmset key keyOne valueOne keyTwo valueTwo 表示在名字为key的哈希中一次性存放多个键值对

    2. 取值

        1. hget key keyone 表示在key的哈希中取到哪个属性

        2. hmget key keyone keytwo 表示一次性可以取得多个属性值

        3. hgetall key 获取key中的所有属性和属性值

    3. 删除

        1. hdel key keyone 删除一个或多个

        2. del key 删除整个集合

    4. 数值的增加

        1. hincrby key value m 表示给key集合中的value值增加m

    5. 自学命令

        1. hexists key keyOne 判断哈希key中的keyone是否存在，存在返回1

        2. hlen key 得到哈希key中有多少个属性

        3. hkeys key 获取所有的属性

        4. hvals key 获取key集合里面所有的值
</code></pre><blockquote>
<p>提示： Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。每个 hash 可以存储 2^32 -1 键值对（40多亿）。</p>
</blockquote>
<h4 id="3-List（列表）"><a href="#3-List（列表）" class="headerlink" title="3.List（列表）"></a>3.List（列表）</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<pre><code>链表常用命令：

    1. 两端添加

        1. lpush key valueOne valueTwo valueThree ... 从左端向list中添加数据

        2. rpush key valone valtwo valthree ... 从右侧向list中添加数据

    2. 查看列表

        1. lrange key m n 查看m到n之间的数据元素

    3. 两端弹出

        1. lpop key 左端弹出

        2. rpop key 右端弹出

    4. 获取列表元素个数

        1. llen key 获取列表中元素的个数

    5. 扩展命令

        1. lpushx key x 只有在key列表存在的时候才会向其头部插入x

        2. rpush key x ...右侧insert

        3. lrem key count keyone 在list列表中删除count个keyone，当count为0时，删除里面所有的keyone

        4. lset key count keytwo 在list列表中指定的count角标处插入某一个值keytwo

        5. linsert key before keyOne valueOne 在key列表中的keyone之前插入valueone（之后只需要before改成after）

        6. rpoplpush listOne listTwo 将listone里面的尾部数据弹出压入到listTwo的头部
</code></pre><h4 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4.Set（集合）"></a>4.Set（集合）</h4><p>Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<blockquote>
<p>sadd 命令 添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p>
</blockquote>
<pre><code>set常用命令：

    1. 添加

        1. sadd key value1 value2 value3 ... 向set中添加值

    2. 删除

        1. srem key value1 value2 ... 删除set中存在的value


    3. 获得集合中元素

        2. smembers key 查看key的set中有哪些元素

        3. sismember key m 判断m是否存在set集合中 

    4. 集合中差集的运算

        1. sdiff setone settwo 比较两个set集合中的差集

    5. 集合的交集运算

        1. sinter setone settwo 比较两个set集合中相同的部分

    6. 集合的并集运算

        1. sunion setone settwo 并集操作

    7. 扩展命令

        1. scard setOne 获取set集合中的元素个数

        2. srandmember setone 随机获取set集合中的元素

        3. sdiffstore setstore setOne setTwo 将setOne与setTwo集合之间相差的值存储到setstore中

        4. sinterstore ... 求两个集合的交集然后存储到新的set中去

        5. sunionstore ... 求两个集合的并集然后存储到新的set中去
</code></pre><h4 id="5-zset-sorted-set：有序集合"><a href="#5-zset-sorted-set：有序集合" class="headerlink" title="5.zset(sorted set：有序集合)"></a>5.zset(sorted set：有序集合)</h4><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<blockquote>
<p>zadd 命令 添加元素到集合，元素在集合中存在则更新对应score</p>
</blockquote>
<pre><code>常用命令：

    1. 添加

        1. zadd keyset socre keyOne ... 向zset中添加元素

    2. 获取

        1. zscore keyset keyone 获取keyone的分数

        2. zcard keyset 获取keyset中具体的成员数量

    3. 删除

        1. zrem keyset keyOne 删除keyone这个元素

        2. zremrangebyrank keyset 0 4 按照范围来进行删除

        3. zremrangebyscore keyset 80 100 按照分数进行删除，删除80-100之间的元素



    4. 查看

        1. zrange keyset 0 -1 查看所有的元素

        2. zrange keyset 0 -1 withscores 查看所有带有分数的元素

    5. 扩展命令

        1. zincrby keyset count keyOne 将keyOne的值加上count

        2. zcount keyset 80 90 查看80-90之间成员的个数

        3. 
</code></pre><h4 id="6-Redis的keys的通用操作"><a href="#6-Redis的keys的通用操作" class="headerlink" title="6.Redis的keys的通用操作"></a>6.Redis的keys的通用操作</h4><pre><code>常用命令：

    1. keys * 查看所有key

    2. keys keyset? 查看keyset开头的key名称

    3. expire key 1000 设置时间

    4. type keyset 查看类型

    5. ttl keyset 查看ttl
</code></pre><h4 id="7-Redis事务特性"><a href="#7-Redis事务特性" class="headerlink" title="7.Redis事务特性"></a>7.Redis事务特性</h4><pre><code>1. multi 开启事务

2. exec 提交事务

3. discard 回滚事务

4. watch 是一个乐观锁，可以在执行exec命令之前监视任意数量的数据库键，在exec命令执行时，检查被监视的键是否有一个是否已经被修改，如果是则服务器拒绝执行事务。
</code></pre><h4 id="8-Redis脚本命令"><a href="#8-Redis脚本命令" class="headerlink" title="8.Redis脚本命令"></a>8.Redis脚本命令</h4><p>Redis 脚本使用 Lua 解释器来执行脚本。 Reids 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>
<pre><code>脚本常用命令：

    1. 
</code></pre><h4 id="9-数据备份与恢复"><a href="#9-数据备份与恢复" class="headerlink" title="9.数据备份与恢复"></a>9.数据备份与恢复</h4><p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<h4 id="10-Redis管道技术"><a href="#10-Redis管道技术" class="headerlink" title="10.Redis管道技术"></a>10.Redis管道技术</h4><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。</p>
<p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p>
<h4 id="11-Redis数据库"><a href="#11-Redis数据库" class="headerlink" title="11.Redis数据库"></a>11.Redis数据库</h4><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中。</p>
<blockquote>
<p>提示：dbnum属性的值由服务器配置的database选项决定，默认情况下是16，所以Redis服务器默认会创建16个数据库。</p>
</blockquote>
<p><strong>1.切换数据库</strong><br></p>
<pre><code>1.默认情况下会选择0号数据库，SELECT 命令来切换到目标数据库

    通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能，这是SELECT命令的实现原理。


2.清空整个数据库的 flushdb 命令，通过删除键空间中所有键值对实现。
</code></pre><p><strong>4.设置键的生存时间或过期时间</strong><br></p>
<pre><code>1. 设置过期时间

    通过expire命令或者pexpipe命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间TTL，在经过指定的时间之后服务器会删除生存时间为0的键。

    1. expire key ttl 将key的生存时间设置为ttl秒

    2. pexpire key ttl 将key的生存时间设置为ttl毫秒

    3. expireat key timestamp 将key过期时间设置为timestamp所指定的秒数时间戳

    4. pexpireat key timestamp 将key过期时间设置为timestamp所指定的毫秒数时间戳

    提示：pexpire、expire、expireat命令在最终转换之后的执行效果与pexpireat命令一样

2. 保存过期时间

    1. 

3. 移除过期时间

    1. persist命令可以移除一个键的过期时间 persist key

4. 计算并返回剩余生存时间

    1. TTL 命令以秒为单位返回键的剩余生存时间

    2. PTTL 命令以毫秒为单位返回键的剩余生存时间

5. 过期键的判定

    步骤：

        1. 检查给定键是否存在于过期字典，如果存在则取得键的过期时间

        2. 检查当前Unix时间戳是否大于键的过期时间，大于则过期，否则未过期
</code></pre><p><strong>5.过期键的删除策略</strong><br></p>
<pre><code>1. 定时删除，设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。

2. 惰性删除，放任键过期不管，但是每次获取键时，都检查取得的键是否过期，过期则删除

3. 定期删除，每隔一段时间都对数据库进行一次检查，删除里面的过期键
</code></pre><p><strong>6.AOF | RDB和复制功能对过期键的处理</strong><br></p>
<pre><code>1. 生存RDB文件

    在执行save命令或者bgsave命令创建新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

2. 载入RDB文件


3. AOF文件写入

    过期键在被惰性删除或定期删除之后，程序会向AOF文件追加一个del命令，显式记录该键已经被删除。
</code></pre><hr>
<h2 id="第9章-数据库"><a href="#第9章-数据库" class="headerlink" title="第9章 数据库"></a>第9章 数据库</h2><p>服务器中的数据库，服务器将素有数据库都保存在服务器状态 redis.h/redisServer结构的db数组中。</p>
<h3 id="9-1-切换数据库"><a href="#9-1-切换数据库" class="headerlink" title="9.1 切换数据库"></a>9.1 切换数据库</h3><p>Redis客户端在默认情况下，目标数据库是0号数据库，但客户端可以通过执行 SELECT 命令来切换目标数据库。</p>
<h3 id="9-4-设置键的生存时间或过期时间"><a href="#9-4-设置键的生存时间或过期时间" class="headerlink" title="9.4 设置键的生存时间或过期时间"></a>9.4 设置键的生存时间或过期时间</h3><p>通过 EXPIRE 命令或者 PEXPIRE 命令客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（TTL），在经过指定的秒数或毫秒数之后，服务器会自动删除生存时间为0的键。</p>
<p>SETEX 命令可以在设置一个字符串键的同时为键设置过期时间。</p>
<h3 id="9-5-过期键删除策略"><a href="#9-5-过期键删除策略" class="headerlink" title="9.5 过期键删除策略"></a>9.5 过期键删除策略</h3><p>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器的过期时间来临时，立即执行对键的删除操作。</p>
<p>…</p>
<hr>
<h2 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a>Redis持久化方案</h2><h4 id="1-Rdb方式"><a href="#1-Rdb方式" class="headerlink" title="1.Rdb方式"></a>1.Rdb方式</h4><p>这种方式是Redis默认的方式，redis通过快照来将数据持久化到磁盘。恢复时直接将快照文件读到内存中，来达到恢复数据。RDB持久化是指在==指定的时间间隔内将内存中的数据集快照写入磁盘。== 这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p>
<pre><code>命令生成RDB文件

    1. SAVE 该命令会阻塞Redis服务器进程，直到RDB文件创建完毕，在服务器阻塞期间，不能处理任何命令请求

    2. BGSAVE 该命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求

        BGSAVE命令被触发的条件：

            1.服务器在900秒内，对数据库进行至少一次操作

                save 900 1  #900秒内如果超过1个key被修改，则发起快照保存

            2.服务器在300秒内，对数据库进行至少10次操作

                save 300 10 #300秒内容如超过10个key被修改，则发起快照保存

            3.服务器在60秒内，对数据库进行至少10000次操作

                save 60 10000
1.优点

    1. 如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。

    2. RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。

    3. RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。
</code></pre><blockquote>
<p>注意：如果redis非法关闭，那么就会丢失最后一次持久化之后的数据。如果数据不重要，则可以不用关心。如果数据不允许丢失，那么使用aof方式。</p>
</blockquote>
<h4 id="2-Aof方式"><a href="#2-Aof方式" class="headerlink" title="2.Aof方式"></a>2.Aof方式</h4><p>Redis默认不使用该方式持久化，Aof方式的持久化，是操作一次Redis数据库，则将操作的记录存储到aof持久化文件中。将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)。当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p>
<pre><code>默认的保存配置：

    appendonly yes              //启用aof持久化方式

    # appendfsync always      //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用

    appendfsync everysec     //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐

    # appendfsync no    //完全依赖os，性能最好,持久化没保证
</code></pre><p>RDB持久化保存数据库状态的方法是将msg/fruits/numbers三个键的键值对保存到RDB文件中。</p>
<p>AOF持久化则是将服务器执行的SET/SADD/RPUSH三个命令保存到AOF文件。</p>
<p>AOF持久化功能可以分为：命令追加（append）、文件写入、文件同步（sync）。</p>
<hr>
<h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><p>Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis客户端在我们之前下载的的 redis 的安装包中。</p>
<h4 id="1-redis-cli"><a href="#1-redis-cli" class="headerlink" title="1.$ redis-cli"></a>1.$ redis-cli</h4><p>启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。如果需要在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。</p>
<pre><code>语法：$ redis-cli -h host -p port -a password
</code></pre><hr>
<h2 id="Redis-键-key"><a href="#Redis-键-key" class="headerlink" title="Redis 键(key)"></a>Redis 键(key)</h2><p>Redis 键命令用于管理 redis 的键。</p>
<pre><code>1.DEL key 该命令用于在 key 存在时删除 key。
2.DUMP key  序列化给定 key ，并返回被序列化的值。
3.EXISTS key 检查给定 key 是否存在。
4.EXPIRE key seconds 为给定 key 设置过期时间，以秒计。
5.EXPIREAT key timestamp  EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。
6.PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。
7.PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计
8.KEYS pattern  查找所有符合给定模式( pattern)的 key 。
9.MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。
10.PERSIST key  移除 key 的过期时间，key 将持久保持。
11.PTTL key  以毫秒为单位返回 key 的剩余的过期时间。
12.TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。
13.RANDOMKEY 从当前数据库中随机返回一个 key 。
14.RENAME key newkey  修改 key 的名称
15.RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。
16.TYPE key 返回 key 所储存的值的类型。
</code></pre><hr>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>执行slaveof命令或者设置slaveof选项，让一个服务器去复制另一个服务器，称被复制的服务器是主服务器（master），而对主服务器进行复制的服务器是从服务器（slave）。</p>
<pre><code>1. 主服务器：能够进行读写操作

2. 从服务器：只能进行读操作
</code></pre><h4 id="1-主从复制的优点"><a href="#1-主从复制的优点" class="headerlink" title="1. 主从复制的优点"></a>1. 主从复制的优点</h4><pre><code>1. 数据冗余，实现数据的热备份

2. 故障恢复，避免单点故障带来的服务不可用

3. 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量

4. 高可用基础，是哨兵机制和集群实现的基础
</code></pre><h4 id="2-主从复制的配置"><a href="#2-主从复制的配置" class="headerlink" title="2. 主从复制的配置"></a>2. 主从复制的配置</h4><pre><code>1. 首先在xshell中建立三个连接窗口，并将redis.conf配置文件复制三份，将它们的端口改掉

2. 然后分别启动三个端口的redis客户端

3. info 命令查看每个redis服务在小型集群中扮演的角色

4. 然后在master中设置name值为name，那么在slave中也能得到name的值
</code></pre><h4 id="3-主从复制的实现原理"><a href="#3-主从复制的实现原理" class="headerlink" title="3. 主从复制的实现原理"></a>3. 主从复制的实现原理</h4><p>主从复制可以分为三个阶段：1.连接建立 2.数据同步 3.命令传播。</p>
<pre><code>1. 连接建立

    1. slaveof命令之后，从服务器根据设置的master的ip地址和端口号，创建连向主服务器的socket套接字连接。

    2. 然后确认是否主服务器可用，发送ping命令。

    3. 身份验证，如果主服务器设置了requirepass选项，那么从服务器必须配置masterauth选项。

    4. 在身份验证完之后，从服务器会发送自己的监听端口，主服务器会保存下来。

2. 数据同步

    在主服务器与从服务器连接确认各自身份之后，就开始同步数据，从服务器向主服务器发送 PSYNC 命令，执行同步操作，并将自己的数据库状态更新到主服务器的数据库状态。主要分为完整重同步和部分重同步。

    1. 完整重同步

        1. slave连接上master第一次复制的时候是完整同步

        2. 如果当主从断线，重新连接复制的时候有可能是完成重同步。

    2. 部分重同步

        用于处理断线后重复制的情况

3. 命令传播

    在完成数据同步之后，主从服务器的数据暂时达到一定状态，在主服务器执行了客户端的写命令之后，主从数据库不再一致。所以此时为了保持一致性，每执行一个命令都会向从服务器发送同样的写命令。

4. 心跳检测

    在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送命令：

        REPLCONF ACK &lt;replication_offset&gt; replication_offset是从服务器当前的复制偏移量。

        发送replconf ack对于主服务器作用：

            1. 检测主从服务器的网络连接状态
            2. 辅助实现min-slave选项
            3. 检测命令丢失
</code></pre><hr>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>岗哨、哨兵是Redis的高可用性解决方案，其可以监视任意多个主服务器以及这些主服务器下的从服务器。</p>
<pre><code>1. 监控：哨兵会不断的检查master和slave是否运行正常

2. 提醒：当被监控的某个redis异常，哨兵可以通过API或者其它应用程序发送通知

3. 自动故障迁移：当一个master不能正常工作时，哨兵会开始一次自动故障迁移操作，会将失效的master的其中一个slave升级为新的master。
</code></pre><blockquote>
<p>提示：只靠redis主从复制和哨兵机制不足以实现redis高可用，理由是：因为如果某一节点死机之后，不会实现自动重启。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：最稳健实现高可用的方式，redis主从复制+哨兵监控（监控、提醒、自动故障迁移）+keepalived（自动重启），如果重启多次仍然不成功可以通过邮件或短信方式提醒。</p>
</blockquote>
</blockquote>
<h4 id="1-检测主观下线状态"><a href="#1-检测主观下线状态" class="headerlink" title="1. 检测主观下线状态"></a>1. 检测主观下线状态</h4><p>在默认的情况下，sentinel会以每秒一次的频率向所有与它创建了命令连接的实例发送ping命令，并通过ping命令回复来判断实例是否在线。</p>
<p>down-after-milliseconds选项值不仅会被sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器属下的所有从服务器，以及其他的主观下线状态。</p>
<h4 id="2-检测客观下线状态"><a href="#2-检测客观下线状态" class="headerlink" title="2. 检测客观下线状态"></a>2. 检测客观下线状态</h4><p>当sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线，它会向同样监视这一主服务器的其它sentinel进行询问，其它监控是否回答认为主服务器已经进入下线状态。</p>
<h4 id="3-选举领头羊"><a href="#3-选举领头羊" class="headerlink" title="3. 选举领头羊"></a>3. 选举领头羊</h4><p>在判断主服务器下线时，监视这个下线主服务器的各个sentinel会进行协商，选举出一个领头sentinel，并由领头sentinel对下线主服务器执行故障转移操作。</p>
<h4 id="4-故障转移"><a href="#4-故障转移" class="headerlink" title="4. 故障转移"></a>4. 故障转移</h4><p>在选举产生出领头sentinel之后，领头sentinel将对已下线的主服务器执行故障转移操作，该操作包括：</p>
<pre><code>1. 在已下线的主服务器属下的所有从服务器里面挑选出一个从服务器，并将其转换成主服务器。

2. 让已下线的主服务器属下的所有从服务器改为复制新的主服务器。

3. 将已下线的主服务器设置为新的主服务器的从服务器。
</code></pre><hr>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过==分片来进行数据共享，并提供复制符故障转移功能。==</p>
<pre><code>优点：

    1. 将数据自动切分到多个节点的能力

    2. 当集群中一部分节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力

    3. 支持动态扩容

数据共享：

    Redis使用数据分片而非一致性哈希

主从复制：

    集群中的每个节点都有1-n个复制品

一致性保证：

    集群不保证数据的强一致性，在特定条件下，Redis集群可能会丢失已经被执行过的写命令。
</code></pre><h3 id="1-节点"><a href="#1-节点" class="headerlink" title="1.节点"></a>1.节点</h3><p>一个redis集群通常由多个节点组成，要组建一个真正意思上的集群需要将各个独立节点连接起来，构成一个包含多个节点的集群。</p>
<p>连接各个节点的工作可以使用 CLUSTER MEET 命令完成。</p>
<pre><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;
</code></pre><p>CLUSTER NODES 命令查看集群中的各个节点。</p>
<p>一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据 cluster-enable 配置选项是否为 yes 来决定是否开启服务器的集群模式。</p>
<h3 id="2-槽指派"><a href="#2-槽指派" class="headerlink" title="2. 槽指派"></a>2. 槽指派</h3><p>Redis集群==通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这些槽中的其中一个，集群中每个节点可以处理0个或最多16384个槽。==</p>
<p>集群中内置这些槽之后，会将所有的物理节点映射到这些槽上，或者说将这些槽均等的分配给各个节点。当需要在Redis集群中存放一个数据（key-value）时，Redis会先对key进行crc16算法，然后得到一个结果，再将这个结果对16384取余，这个余数则对应【0-16383】中的一个槽，然后决定key-value存放在哪个节点中，所以某一个节点挂了，那么该节点对应的槽就无法使用，从而导致集群无法正常工作。</p>
<p>通过向节点发送 CLUSTER ADDSLOTS 命令，可以将一个或多个槽指派给节点负责。</p>
<h3 id="3-重新分片"><a href="#3-重新分片" class="headerlink" title="3. 重新分片"></a>3. 重新分片</h3><p>重新分片操作可以将任意数量的已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p>
<hr>
<h3 id="Linux集群搭建"><a href="#Linux集群搭建" class="headerlink" title="Linux集群搭建"></a>Linux集群搭建</h3><pre><code>1. 新建目录cluster存放将要配置的文件

    1. conf：存放配置文件
    2. data：存放数据
    3. logs：存放日志
    4. script：存放脚本

2. 配置redis.conf文件，配置端口号、cluster-enabled yes 的注释打开、然后配置文件的logs等。

3. 启动redis服务器

4. 查看是否启动服务器进程

    ps aux|grep redis

5. redis 5.0之后支持cluster

    ./bin/redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006
</code></pre><h2 id="Pipeline-流水线"><a href="#Pipeline-流水线" class="headerlink" title="Pipeline 流水线"></a>Pipeline 流水线</h2><h4 id="1-1次网络命令通信模型"><a href="#1-1次网络命令通信模型" class="headerlink" title="1. 1次网络命令通信模型"></a>1. 1次网络命令通信模型</h4><p>在客户端将命令通过网路传递到服务器，然后服务器经过计算之后返回结果给客户端的过程所用的时间为：</p>
<pre><code>1次时间 = 1次网络时间 + 1次命令时间
</code></pre><h4 id="2-批量网络命令模型"><a href="#2-批量网络命令模型" class="headerlink" title="2.批量网络命令模型"></a>2.批量网络命令模型</h4><p>表示在1次网络命令通信模型的迭代n次。那么在这过程中所用掉的时间时：</p>
<pre><code>n次时间 = n次网络时间 + n次命令时间
</code></pre><h4 id="3-流水线"><a href="#3-流水线" class="headerlink" title="3.流水线"></a>3.流水线</h4><p>在这里使用流水线技术，那么就是将所有命令打包在一起，然后用掉一次网络时间将所有的命令传递到服务器，然后服务器用掉n此命令时间处理计算这些命令，然后将计算结果返回给客户端。</p>
<pre><code>1次pipeline(n条命令) = 1次网络时间 + n次命令时间
</code></pre><blockquote>
<p>注意：Redis的命令时间时微秒级的。然后pipeline每次条数需要控制。</p>
</blockquote>
<blockquote>
<p>提示：pipeline只能作用在一个redis节点上面。</p>
</blockquote>
<hr>
<h2 id="第18章-Redis-发布-订阅"><a href="#第18章-Redis-发布-订阅" class="headerlink" title="第18章 Redis 发布/订阅"></a>第18章 Redis 发布/订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。这中机制类似于电台的发布，用户可以订阅多个电台的消息，然后电台发布消息供用户读取。</p>
<blockquote>
<p>理解：实现订阅和发布，那么在这里就有消息的发送方和接收方。</p>
<blockquote>
<p>发送方：1.通过JedisConnection的Pub/Sub相关的方法来向Redis服务发布消息。2.通过RedisTemplate的convertAndSend方法来实现这一功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>接收方：在接收方包括监听消息并输出，需要实现消息监听类，并且在xml中注册实现此类。</p>
</blockquote>
</blockquote>
<p><strong>1.两种方式实现监听类</strong><br></p>
<pre><code>1.实现MessageListener接口，实现onMessage()方法。
2.使用自定义的类。
</code></pre><h4 id="发布订阅和消息队列"><a href="#发布订阅和消息队列" class="headerlink" title="发布订阅和消息队列"></a>发布订阅和消息队列</h4><p>通过执行SUBSCRIBE命令客户端可以订阅一个或多个频道，从而成为这些频道的订阅者。</p>
<p>通过命令 UNSUBSCRIBE 命令退订某个或某些频道。</p>
<p>PUBSUB CHANNELS [pattern] 命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的。</p>
<p>PUBSUB NUMSUB [channel-1 channel-2 ..] 命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量</p>
<h2 id="PUBSUB-NUMPAT-命令用于返回服务器当前被订阅模式的数量。"><a href="#PUBSUB-NUMPAT-命令用于返回服务器当前被订阅模式的数量。" class="headerlink" title="PUBSUB NUMPAT 命令用于返回服务器当前被订阅模式的数量。"></a>PUBSUB NUMPAT 命令用于返回服务器当前被订阅模式的数量。</h2><h2 id="第19章-Redis-事务"><a href="#第19章-Redis-事务" class="headerlink" title="第19章 Redis 事务"></a>第19章 Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<pre><code>批量操作在发送 EXEC 命令前被放入队列缓存。
收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。
</code></pre><p>一个事务从开始到执行会经历以下三个阶段：</p>
<pre><code>开始事务。
命令入队。
执行事务。
</code></pre><p>MULTI 命令表示一个事务的开始。WATCH命令是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过，如果是，服务器拒绝执行事务，并返回执行失败的空回复。</p>
<p>当一个处于事务状态的客户端向服务器发送EXEC命令时，该EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p>
<p>DISCARD命令表示关闭事务操作。</p>
<hr>
<h2 id="第20章-Redis-Lua脚本"><a href="#第20章-Redis-Lua脚本" class="headerlink" title="第20章 Redis Lua脚本"></a>第20章 Redis Lua脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>
<p>EVALSHA命令可以根据脚本的SHA1校验来对脚本进行求职，但这个命令要求校验和对应的脚本必须至少被EVAL命令执行过一次。</p>
<hr>
<h2 id="第21章-排序"><a href="#第21章-排序" class="headerlink" title="第21章 排序"></a>第21章 排序</h2><p>Redis的sort命令可以对==列表键、集合或有序集合的值==进行排序。</p>
<pre><code>1. lrange：按插入顺序进行排序

    lrange numbers 0 -1

2. sort：按值从小到大进行排序

    sort numbers

    1. sort alphabet ALPHA sort命令使用ALPHA选项对一个包含字符串值的集合键进行排序

    2. sort &lt;key&gt; ASC 命令执行升序排序

    3. sort &lt;key&gt; DESC 命令执行降序排序
</code></pre><hr>
<h2 id="第22章-二进制位数组"><a href="#第22章-二进制位数组" class="headerlink" title="第22章 二进制位数组"></a>第22章 二进制位数组</h2><p>Redis提供了setbit/getbit/bitcount/bitop四个命令用于处理二进制位数组（位数组）。</p>
<pre><code>1. setbit 命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值为0或1。

2. getbit 命令获取位数组指定偏移量上的二进制位的值。

3. bitcount 命令用于统计位数组里面值为1的二进制位的数量。

4. bitop 命令用于对多个位数组进行按位与|或|异或运算。
</code></pre><hr>
<h2 id="第23章-慢查询日志"><a href="#第23章-慢查询日志" class="headerlink" title="第23章 慢查询日志"></a>第23章 慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可通过该功能产生的日志监视和优化查询速度。</p>
<pre><code>1. 配置慢查询日志

    1. 指定执行时间超过多少微秒的命令请求会被记录到日志中

        CONFIG SET slowlog-log-slower-than 0

    2. 指定服务器最多保存多少条慢查询日志

        CONFIG SET slowlog-max-len 5

2. 输入查询命令

    set msg &quot;...&quot;

    set num 000

    set database &quot;redis&quot;

3. slowlog get 命令查看服务器所保存的慢查询日志
</code></pre><hr>
<h2 id="第24章-监控器"><a href="#第24章-监控器" class="headerlink" title="第24章 监控器"></a>第24章 监控器</h2><p>通过monitor命令，客户端可以将自己变为一个监视器，实时接收并打印出服务器当前处理的命令请求相关信息。</p>
<hr>
<h2 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p>
<h2 id="Redis-服务器"><a href="#Redis-服务器" class="headerlink" title="Redis 服务器"></a>Redis 服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p>
<hr>
<h2 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h2><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令</p>
<pre><code>redis 127.0.0.1:6379&gt; CONFIG GET dir
</code></pre><h4 id="Bgsave"><a href="#Bgsave" class="headerlink" title="Bgsave"></a>Bgsave</h4><p>创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</p>
<hr>
<h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p>
<h4 id="设置密码与否"><a href="#设置密码与否" class="headerlink" title="设置密码与否"></a>设置密码与否</h4><pre><code>127.0.0.1:6379&gt; CONFIG get requirepass
</code></pre><h4 id="修改密码参数"><a href="#修改密码参数" class="headerlink" title="修改密码参数"></a>修改密码参数</h4><pre><code>127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;
127.0.0.1:6379&gt; CONFIG get requirepass
</code></pre><h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><pre><code>127.0.0.1:6379&gt; AUTH password
</code></pre><hr>
<h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<pre><code>命令：redis-benchmark [option] [option value]
</code></pre><h2 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h2><hr>
<h2 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h4 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h4><pre><code>通过利用多台计算机内存的和值，允许我们构造更大的数据库。
通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。
</code></pre><h4 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h4><hr>
<h2 id="Java使用Redis"><a href="#Java使用Redis" class="headerlink" title="Java使用Redis"></a>Java使用Redis</h2><p>在Java使用Redis之前要确定已经安装Redis服务以及Java Redis驱动</p>
<h4 id="1-连接到Redis服务"><a href="#1-连接到Redis服务" class="headerlink" title="1.连接到Redis服务"></a>1.连接到Redis服务</h4><pre><code>//Java程序连接到redis服务 在编写完下面的程序之后编译便可
import redis.clients.jedis.Jedis;

public class RedisJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);
        //查看服务是否运行
        System.out.println(&quot;服务正在运行: &quot;+jedis.ping());
    }
}
</code></pre><h4 id="2-Java使用redis服务实例"><a href="#2-Java使用redis服务实例" class="headerlink" title="2.Java使用redis服务实例"></a>2.Java使用redis服务实例</h4><pre><code>//redis Java String 实例
import redis.clients.jedis.Jedis;

public class RedisStringJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);
        //设置 redis 字符串数据
        jedis.set(&quot;runoobkey&quot;, &quot;www.runoob.com&quot;);
        // 获取存储的数据并输出
        System.out.println(&quot;redis 存储的字符串为: &quot;+ jedis.get(&quot;runoobkey&quot;));
    }
}

//Redis Java List(列表) 实例
import java.util.List;
import redis.clients.jedis.Jedis;

public class RedisListJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);
        //存储数据到列表中
        jedis.lpush(&quot;site-list&quot;, &quot;Runoob&quot;);
        jedis.lpush(&quot;site-list&quot;, &quot;Google&quot;);
        jedis.lpush(&quot;site-list&quot;, &quot;Taobao&quot;);
        // 获取存储的数据并输出
        List&lt;String&gt; list = jedis.lrange(&quot;site-list&quot;, 0 ,2);
        for(int i=0; i&lt;list.size(); i++) {
            System.out.println(&quot;列表项为: &quot;+list.get(i));
        }
    }
}

//Redis Java Keys 实例
import java.util.Iterator;
import java.util.Set;
import redis.clients.jedis.Jedis;

public class RedisKeyJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);

        // 获取数据并输出
        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); 
        Iterator&lt;String&gt; it=keys.iterator() ;   
        while(it.hasNext()){   
            String key = it.next();   
            System.out.println(key);   
        }
    }
}
</code></pre><hr>
<h4 id="1-单实例连接Redis"><a href="#1-单实例连接Redis" class="headerlink" title="1.单实例连接Redis"></a>1.单实例连接Redis</h4><pre><code>@Test
public void JedisClient(){
    //Jedis
    Jedis jedis = new Jedis(&quot;localhost&quot;,6379);
    //通过redis赋值
    jedis.set(&quot;s2&quot;,&quot;222&quot;);
    //通过redis取值
    String result = jedis.get(&quot;s2&quot;);
    System.out.println(result);
    //关闭jedis
    jedis.close();
}
</code></pre><h4 id="2-使用Jedis连接池连接Redis服务器"><a href="#2-使用Jedis连接池连接Redis服务器" class="headerlink" title="2.使用Jedis连接池连接Redis服务器"></a>2.使用Jedis连接池连接Redis服务器</h4><pre><code>@Test
public void JedisPool(){
    //JedisPool
    JedisPool pool = new JedisPool(&quot;localhost&quot;,6379);
    //通过连接池获取jedis对象
    Jedis jedis = pool.getResource();
    jedis.set(&quot;s4&quot;,&quot;12&quot;);
    String result = jedis.get(&quot;s4&quot;);
    System.out.println(result);

    //关闭Jedis客户端
    jedis.close();
    //关闭连接池
    pool.close();
}
</code></pre><h4 id="3-Spring整合JedisPool"><a href="#3-Spring整合JedisPool" class="headerlink" title="3.Spring整合JedisPool"></a>3.Spring整合JedisPool</h4><p><strong>3.1 pom.xml添加依赖</strong><br></p>
<p><strong>3.2 applicationContext.xml配置文件</strong><br></p>
<pre><code>&lt;!--1.首先是连接池配置--&gt;
&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
    &lt;!--1.1 最大连接数--&gt;
    ...
    //这些需要配置的东西可以得到，略
&lt;/bean&gt;

&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt;
    ...
&lt;/bean&gt;
</code></pre><h4 id="4-测试实例"><a href="#4-测试实例" class="headerlink" title="4.测试实例"></a>4.测试实例</h4><pre><code>@Test
public void JedisPoolTest(){
    JedisPool pool = (JedisPool) applicationContext.getBean(&quot;jedisPool&quot;);
    Jedis jedis = null;
    try{
        jedis = pool.getResource();
        jedis.set(&quot;name&quot;,&quot;lisi&quot;);
        String name = jedis.get(&quot;name&quot;);
        System.out.println(name);
    }catch(Exception e){
        e.printStackTrace();
    }finally{
        if(jedis != null){
            jedis.close();
        }
    }
}
</code></pre><hr>
<hr>
<p>前言：1.声明式缓存注解：Spring提供四个注解来声明缓存规则。</p>
<pre><code>@Cacheable 在方法执行前Spring先查看缓存中是否有数据。如果有数据则直接返回缓存数据，没有则调用方法返回值放入缓存中。

@CachePut 无论如何都会将方法的返回值放入缓存中。

@CacheEvict 将一条或多条数据从缓存中删除。

@Caching 可通过@Caching 注解组合多个注解策略在一个方法上。
</code></pre><blockquote>
<p>注意：@Cacheable | @CachePut | @CacheEvict 都有 value 属性，指定的是要使用的缓存名称。key 属性指定的是数据在缓存中存储的键。</p>
</blockquote>
<hr>
<h2 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h2><h3 id="SpringMVC集成Redis"><a href="#SpringMVC集成Redis" class="headerlink" title="SpringMVC集成Redis"></a>SpringMVC集成Redis</h3><p>一般的思路是首先加载配置文件，创建redis连接池，然后实例化RedisTemplate对象，最后持有这个实例开始读写操作。</p>
<h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1.pom.xml"></a>1.pom.xml</h4><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
  &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
  &lt;version&gt;1.0.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;redis.clients&lt;/groupId&gt;
  &lt;artifactId&gt;jedis&lt;/artifactId&gt;
  &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="2-spring-mybatis-xml-spring-dao-xml"><a href="#2-spring-mybatis-xml-spring-dao-xml" class="headerlink" title="2.spring-mybatis.xml(spring-dao.xml)"></a>2.spring-mybatis.xml(spring-dao.xml)</h4><pre><code>&lt;!--Jedis配置--&gt;
&lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
    &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;
    &lt;property name=&quot;maxActive&quot; value=&quot;${redis.maxActive}&quot; /&gt;
    &lt;property name=&quot;maxWait&quot; value=&quot;${redis.maxWait}&quot; /&gt;
    &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;
&lt;/bean&gt;

&lt;!--Redis服务器配置相关信息--&gt;
&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;
      p:host-name=&quot;${redis.host}&quot;
      p:port=&quot;${redis.port}&quot;
      p:password=&quot;${redis.pass}&quot;
      p:pool-config-ref=&quot;poolConfig&quot;/&gt;

&lt;!--Redis操作模板，面向对象的模板--&gt;
&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;
    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;
    &lt;!--如果不配置Serializer，那么存储的时候只能使用String，如果使用对象类型存储会提示错误--&gt;
    &lt;property name=&quot;keySerializer&quot;&gt;
        &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt;
    &lt;/property&gt;
    &lt;property name=&quot;valueSerializer&quot;&gt;
        &lt;bean class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot; /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<blockquote>
<p>提示：Spring Data Redis提供了RedisTemplate 和 StringRedisTemplate模板。模板封装了对redis操作，提供了较高级的数据访问方案。从名字可以看出后者只关注字符串类型，当redis的key和value都是字符串时候建议使用StringRedisTemplate。RedisTemplate的很多功能以子API的形式提供，他们区分了单个值和集合值得场景。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：在使用Redis的时候首先是注入了RedisTemplate对象，我们可以根据Spring中的JdbcTemplate，RedisTemplate封装了RedisConnection，具有连接管理，序列化和Redis操作等功能。还有针对String的支持对象StringRedisTemplate。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：Redis操作视图接口类是 ValueOperations，对应的Redis String/value操作。还有其他的操作视图：ListOperations | SetOperations | ZSetOperations 和 HashOperations 。ValueOperations 插入缓存是可以设置失效时间，这里设置的失效时间是 10 s。</p>
</blockquote>
</blockquote>
<h4 id="3-使用key和value的序列化器"><a href="#3-使用key和value的序列化器" class="headerlink" title="3.使用key和value的序列化器"></a>3.使用key和value的序列化器</h4><p>当某个key-value保存到Redis存储的时候，key和value都会使用Redis序列化器进行序列化。这一步已经在上面的配置文件中配置过。</p>
<pre><code>1.JdkSerializationRedisSerializer POJO对象的存取场景，使用JDK本身序列化机制，然后将普通POJO类进行序列化操作。

2.StringRedisSerializer key或者value是字符串的场景，将会根据指定charset对数据的字节序列编码成string。

3.JacksonJsonRedisSerializer Jackson-Json工具提供了JavaBean与Json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。

4.OxmSerializer 提供了将JavaBean与xml之间的转换能力，目前可用的三方支持包括jaxb,apache-xmlbeans。redis存储的数据将是xml工具。
</code></pre><blockquote>
<p>注意：RedisTemplate中需要声明4种serializer，默认为“JdkSerializationRedisSerializer”：</p>
</blockquote>
<pre><code>a) keySerializer ：对于普通K-V操作时，key采取的序列化策略
b) valueSerializer：value采取的序列化策略
c) hashKeySerializer： 在hash数据结构中，hash-key的序列化策略
d) hashValueSerializer：hash-value的序列化策略
</code></pre><blockquote>
<blockquote>
<p>注意：同样地，StringRedisTemplate也需要申明4中serializer，但是默认为“StringRedisSerializer”。</p>
</blockquote>
</blockquote>
<h4 id="4-RedisTemplate-使用"><a href="#4-RedisTemplate-使用" class="headerlink" title="4.RedisTemplate 使用"></a>4.RedisTemplate 使用</h4><p><strong>1.opsForXXX</strong><br><br>这里可以针对不同的数据结构(String, List, ZSet, Hash）读封装了比较使用的调用方式 opsForXXX。</p>
<h4 id="4-Util"><a href="#4-Util" class="headerlink" title="4.Util"></a>4.Util</h4><p><strong>1.RedisCache</strong><br></p>
<pre><code>package cn.edu.xidian.B.redis;

//这一工具类的实现是为能够使用redis的客户端操作数据
public class RedisCache implements Cache {

    private static JedisConnectionFactory jedisConnectionFactory;

    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //Redis客户端
    @Autowired
    private Jedis redisClient = createClient();

    private String id;

    public RedisCache(final String id){
        if (id == null){
            throw new IllegalArgumentException(&quot;此处必须传入参数id&quot;);
        }
        System.out.println(&quot;id:&quot; + id);
        this.id = id;
    }

    @Override
    public String getId() {
        return this.id;
    }

    @Override
    public void putObject(Object key, Object value) {
        redisClient.set(SerializeUtil.serialize(key.toString()), SerializeUtil.serialize(value));

    }

    @Override
    public Object getObject(Object o) {
        byte[] ob = redisClient.get(SerializeUtil.serialize(o.toString()));
        if (ob == null) {
            return null;
        }
        Object value = SerializeUtil.unSerialize(ob);
        return value;
    }

    @Override
    public Object removeObject(Object key) {
        return redisClient.expire(SerializeUtil.serialize(key.toString()), 0);
    }

    @Override
    public void clear() {
        redisClient.flushDB();

    }

    @Override
    public int getSize() {
        return Integer.valueOf(redisClient.dbSize().toString());
    }

    @Override
    public ReadWriteLock getReadWriteLock() {
        return readWriteLock;
    }

    protected static Jedis createClient(){
        try {
            @SuppressWarnings(&quot;resource&quot;)
            JedisPool pool = new JedisPool(new JedisPoolConfig(), &quot;127.0.0.1&quot;, 6379);
            return pool.getResource();
        }catch (Exception e){
            e.printStackTrace();
        }
        throw new RuntimeException(&quot;初始化连接池错误！&quot;);
    }

    public static void setJedisConnectionFactory(JedisConnectionFactory jedisConnectionFactory){
        RedisCache.jedisConnectionFactory = jedisConnectionFactory;
    }
}
</code></pre><p><strong>2.RedisCacheTransfer</strong><br></p>
<pre><code>package cn.edu.xidian.B.redis;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
//此中实现的是为了将bean里面注入的给到rediscache
public class RedisCacheTransfer {
    @Autowired
    public void setJedisConnectionFactory(JedisConnectionFactory jedisConnectionFactory){
        RedisCache.setJedisConnectionFactory(jedisConnectionFactory);
    }
}
</code></pre><p><strong>3.SerializeUtil</strong><br></p>
<pre><code>package cn.edu.xidian.B.redis;

import java.io.*;
//此类实现的是存储数据的序列化与反序列化
public class SerializeUtil {

    /**
     * 序列化
     * @param object
     * @return
     */
    public static byte[] serialize(Object object){
        ObjectOutputStream oos = null;
        ByteArrayOutputStream baos = null;
        try {
            baos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(baos);

            oos.writeObject(object);
            byte[] bytes = baos.toByteArray();
            return bytes;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 反序列化
     * @param bytes
     * @return
     */
    public static Object unSerialize(byte[] bytes){
        ByteArrayInputStream bais = null;
        try {
            bais = new ByteArrayInputStream(bytes);
            ObjectInputStream ois = new ObjectInputStream(bais);
            return ois.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre><h4 id="5-entity"><a href="#5-entity" class="headerlink" title="5.entity"></a>5.entity</h4><pre><code>User.java
package cn.edu.xidian.B.entity;

import java.io.Serializable;
//这里的User.java类作序列化为了后面能够持久化数据
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private Integer id;
    private String userName;
    private String password;
    private Integer age;

    public static long getSerialVersionUID() {
        return serialVersionUID;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, userName=&apos;&quot; + userName + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;}&apos;;
    }
}
</code></pre><h4 id="6-Service"><a href="#6-Service" class="headerlink" title="6.Service"></a>6.Service</h4><p><strong>1.Service接口</strong><br></p>
<pre><code>package cn.edu.xidian.B.service;

import cn.edu.xidian.B.entity.User;
//在此接口中只声明了一个方法
public interface UserService {
    User selectByPrimaryKey(Integer id);
}
</code></pre><p><strong>2.Service实现类</strong><br></p>
<pre><code>package cn.edu.xidian.B.service.impl;

import cn.edu.xidian.B.entity.User;
import cn.edu.xidian.B.mapper.UserMapper;
import cn.edu.xidian.B.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public User selectByPrimaryKey(Integer id) {
        return userMapper.selectByPrimaryKey(id);
    }
}
</code></pre><h4 id="7-mapper"><a href="#7-mapper" class="headerlink" title="7.mapper"></a>7.mapper</h4><p><strong>1.接口</strong><br></p>
<pre><code>package cn.edu.xidian.B.mapper;

import cn.edu.xidian.B.entity.User;
import org.springframework.stereotype.Component;

@Component
public interface UserMapper {
    User selectByPrimaryKey(Integer id);
}
</code></pre><p><strong>2.xml文件</strong><br></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;cn.edu.xidian.B.mapper.UserMapper&quot;&gt;
    &lt;cache type=&quot;cn.edu.xidian.B.redis.RedisCache&quot;/&gt;
    &lt;resultMap id=&quot;BaseResultMapper&quot; type=&quot;cn.edu.xidian.B.entity.User&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
        &lt;result property=&quot;userName&quot; column=&quot;username&quot;/&gt;
        &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
        &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;
            resultMap=&quot;BaseResultMapper&quot;&gt;
        select
        id,username,password,age
        from user
        where id = #{id}
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre><h4 id="8-controller"><a href="#8-controller" class="headerlink" title="8.controller"></a>8.controller</h4><pre><code>package cn.edu.xidian.B.controller;

import cn.edu.xidian.B.entity.User;
import cn.edu.xidian.B.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    @RequestMapping(&quot;/showuser&quot;)
    public String toIndex(HttpServletRequest request, Model model){
//        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));
        int userId = 1;
        User user = userService.selectByPrimaryKey(userId);

        model.addAttribute(&quot;user&quot;,user);
        return &quot;/showuser&quot;;
    }
}
</code></pre><hr>
<blockquote>
<p>注意：上面的系列步骤是将数据库的数据存储到redis中，然后查询相关的数据时候直接到redis中查询。</p>
</blockquote>
<hr>
<h2 id="Redis-查询数据"><a href="#Redis-查询数据" class="headerlink" title="Redis 查询数据"></a>Redis 查询数据</h2><p>此方法配置文件都和上面的一样，只是在工具类实现上与上面方法不一致。是使用redis自带的StringRedisTemplate实现的数据增删改查。</p>
<h4 id="1-RedisCacheUtil"><a href="#1-RedisCacheUtil" class="headerlink" title="1.RedisCacheUtil"></a>1.RedisCacheUtil</h4><pre><code>package cn.edu.xidian.B.util;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component(&quot;redisCache&quot;)
public class RedisCacheUtil {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 此方法表示向Hash中添加值
     * @param key 对应数据库表名
     * @param field 对应数据表中唯一索引
     * @param value 存入redis的值
     */
    public void hashSet(String key, String field, String value){
        if (key == null || &quot;&quot;.equals(key)){
            return;
        }
        stringRedisTemplate.opsForHash().put(key,field,value);
    }

    /**
     * 此方法表示从redis中取值
     * @param key
     * @param filed
     * @return
     */
    public String hashGet(String key, String filed){
        if (key == null || &quot;&quot;.equals(key)){
            return null;
        }
        return (String) stringRedisTemplate.opsForHash().get(key,filed);
    }

    /**
     * 此方法是判断存在key以及hash key
     * @param key
     * @param field
     * @return
     */
    public boolean hashExists(String key, String field){
        if (key == null || &quot;&quot;.equals(key)){
            return false;
        }
        return stringRedisTemplate.opsForHash().hasKey(key,field);
    }

    /**
     * 此方法查询key中对应多少条数据
     * @param key
     * @return
     */
    public long hashSize(String key){
        if (key == null || &quot;&quot;.equals(key)){
            return 0L;
        }
        return stringRedisTemplate.opsForHash().size(key);
    }

    public void hashDel(String key, String field){
        if (key == null || &quot;&quot;.equals(key)){
            return;
        }
        stringRedisTemplate.opsForHash().delete(key,field);
    }
}
</code></pre><h4 id="2-Controller"><a href="#2-Controller" class="headerlink" title="2.Controller"></a>2.Controller</h4><pre><code>package cn.edu.xidian.B.controller;

import cn.edu.xidian.B.util.RedisCacheUtil;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Controller
@RequestMapping(&quot;/redis&quot;)
public class RedisController {
    @Resource
    private RedisCacheUtil redisCacheUtil;

    @RequestMapping(&quot;/list&quot;)
    @ResponseBody
    public String getList(HttpServletResponse response, HttpServletRequest request){
        String redis = redisCacheUtil.hashGet(&quot;student&quot;,&quot;test&quot;);
        System.out.println(redis);
        return &quot;success&quot;;
    }

    @RequestMapping(&quot;/add&quot;)
    @ResponseBody
    public String add(HttpServletResponse response, HttpServletRequest request){
        redisCacheUtil.hashSet(&quot;student&quot;, &quot;test&quot;, &quot;小明&quot;);
        return &quot;success&quot;;
    }
}
</code></pre><hr>
<h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><h4 id="1-开启声明缓存支持"><a href="#1-开启声明缓存支持" class="headerlink" title="1.开启声明缓存支持"></a>1.开启声明缓存支持</h4><p>在配置类上使用 @EnableCaching 注解。</p>
<pre><code>@Configuration
@EnableCaching
public class AppConfig{
    //....
}
</code></pre><h4 id="2-SpringBoot的支持"><a href="#2-SpringBoot的支持" class="headerlink" title="2.SpringBoot的支持"></a>2.SpringBoot的支持</h4>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/undefined/Servlet/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p>开发步骤：</p>
</blockquote>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器</li>
</ul>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html" target="_blank" rel="noopener">Servlet API Documentation</a></p>
</blockquote>
<h4 id="生命周期相关方法-life-cycle-methods"><a href="#生命周期相关方法-life-cycle-methods" class="headerlink" title="生命周期相关方法(life-cycle methods)"></a>生命周期相关方法(life-cycle methods)</h4><p>Servlet的生命周期通过<code>java.servlet.Servlet</code>接口中的<code>init()</code>、<code>service()</code>、和<code>destroy()</code>方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。（见文末【参考链接】）</p>
<h4 id="手动编写第一个servlet"><a href="#手动编写第一个servlet" class="headerlink" title="手动编写第一个servlet"></a>手动编写第一个servlet</h4><p>1.在tomcat中新建一个web应用<code>hello</code>，在web应用中新建一个<code>WEB-INF/classes</code>目录</p>
<p>2.在<code>classes</code>目录新建一个<code>FirstServlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span><span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"hello servlet!!!"</span>.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编译，<code>javac -cp %CATALINA_HOME%/lib/servlet-api.jar  -d . FirstServlet.java</code>,命令行手动编译参考<a href="http://www.iitshare.com/under-the-cmd-compile-the-java.html" target="_blank" rel="noopener">这里</a></p>
<p>4.在<code>WEB-INF</code>目录中新建一个<code>web.xml</code>文件，配置servlet的对外访问路径</p>
<p>5.启动tomcat访问</p>
<h4 id="servlet的调用过程和生命周期"><a href="#servlet的调用过程和生命周期" class="headerlink" title="servlet的调用过程和生命周期"></a>servlet的调用过程和生命周期</h4><p>时序图 -&gt; servlet的调用过程和生命周期</p>
<h4 id="servlet的开发细节"><a href="#servlet的开发细节" class="headerlink" title="servlet的开发细节"></a>servlet的开发细节</h4><ul>
<li><strong>标签</strong>:<code>&lt;servlet&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，<code>&lt;servlet-mapping&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code></li>
<li><strong>映射</strong>:<code>web.xml</code>中一个<code>&lt;servlet&gt;</code>可对应多个<code>&lt;servlet-mapping&gt;</code></li>
<li><p><strong>通配符</strong>:<code>&lt;servlet-mapping&gt;</code>的<code>&lt;url-pattern&gt;</code>可以使用通配符，两种固定格式：<code>*.扩展名</code>；以<code>/</code>开头，以<code>/*</code>结尾</p>
</li>
<li><p><strong>对象</strong>:servlet由servlet引擎调用，不能独立运行。客户端多次请求，服务器只创建一个servlet实例，之后驻留内存中继续服务直至web容器退出才销毁它。</p>
</li>
<li><strong>请求</strong>:服务器针对客户端的每一次请求都会创建新的<code>request</code>和<code>response</code>对象(它们的生命周期很短)，传给<code>service</code>方法。</li>
<li><strong>加载</strong>:servlet实例的创建和<code>init</code>方法的调用是在第一次请求时，而非服务器启动时，除非在<code>&lt;servlet&gt;</code>标签配置<code>&lt;load-on-start-up&gt;</code>,数字越小优先级越高</li>
<li><strong>缺省</strong>:映射路径为正斜杠<code>/</code>，则为当前web应用的缺省servlet,不匹配的都交给缺省</li>
<li><strong>线程安全</strong>:访问同一资源会引发线程安全问题; <code>SingleThreadModel</code>标记接口(已弃用)</li>
<li><strong>ServletConfig</strong>:在<code>&lt;servlet&gt;</code>标签配置<code>&lt;init-param&gt;</code>，通过<code>getServletConfig</code>方法获得配置。可配置输出字符集，读哪个配置文件等等。</li>
<li><strong>ServletContext</strong>:代表当前web应用，含有一些web应用全局性方法，实现web资源共享、servlet转发等。通过<code>ServletConfig.getServletContext</code>方法获得，在<code>&lt;context-param&gt;</code>标签配置。</li>
</ul>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>API:<a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/ServletContext.html" target="_blank" rel="noopener">Interface ServletContext</a></p>
<p><strong>概念</strong><br></p>
<p>一个web应用所有servlet共享同一个ServletContext对象，可实现数据共享。ServletContext被称为context<strong>域</strong>对象。</p>
<p>域：作用范围 context域：整个应用程序范围。</p>
<p>ServletContext域：</p>
<ol>
<li>这是一个容器</li>
<li>说明了这个容器的作用范围，也就是应用程序范围</li>
</ol>
<p>转发:客户机一次请求；重定向：客户机两次请求</p>
<p>作用</p>
<ul>
<li>获取web应用的初始化参数</li>
<li>实现servlet转发</li>
<li>利用ServletContext对象读取资源文件<ul>
<li>获得文件路径</li>
<li>读取资源文件的三种方式</li>
<li>.properties文件（属性文件）</li>
</ul>
</li>
</ul>
<p>配置文件：properties文件和xml文件；数据有关系使用xml文件，没有关系则使用properties文件。</p>
<p>1.通过<code>ServletContext</code>的<code>getResourceAsStream</code>方法，读取properties文件</p>
<p>模板代码(注意文件位置不同写路径会不同)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/org/iot/servlet/db.properties"</span>);</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();<span class="comment">//map</span></span><br><span class="line">properties.load(in);</span><br></pre></td></tr></table></figure>
<p>2.通过<code>servletContext</code>的<code>getRealPath</code>方法得到资源的绝对路径，再通过传统方式(<code>FileInputStream</code>)读取</p>
<p>3.通过类装载器去读，<code>ClassLoader</code>的<code>getResourceAsStream</code>(如果读取资源文件的程序不是servlet)，文件不能太大。<strong>只装载一次</strong>，所以如要读到更新后的数据，通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据（用<code>getResource</code>得到path，再用<code>FileInputStream</code>）</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://blog.csdn.net/evankaka/article/details/46673051" target="_blank" rel="noopener">servlet和Jsp生命周期解读</a></p>
</blockquote>
<hr>
<p>Servlet </p>
<pre><code>1.Servlet程序编写  生命周期
2.ServletAPI Request Response 
3.Cookie 和 Session 
</code></pre><p>1.理论<br>    Servlet 用来开发 动态web资源</p>
<pre><code>静态web资源 ： 固定数据文件
动态web资源 ： 通过程序动态生成数据文件 

注意：Servlet技术基于Request-Response编程模型  HTTP协议也是基于请求响应 模型。Servlet技术 用来 开发基于HTTP web 应用程序 

接触 JavaEE API 程序接口和已经实现接口类的使用 JavaEE：Java Platform, Enterprise Edition 缩写 
</code></pre><p>2.Servlet快速入门<br>    1.创建web project<br>    2.编写 class 继承 HttpServlet<br>    3.在web.xml 配置Servlet程序虚拟访问路径<br>      用户在浏览器上通过这个路径访问编写Servlet程序</p>
<pre><code>4.覆盖doGet或者doPost方法进行输出 (表示输出函数是doPost/doGet方法)

总结：Servlet 动态生成网页文件 
</code></pre><p>3.Servlet执行过程</p>
<pre><code>1.用户在客户端发起url请求 ： http://localhost/day05/hello   web.xml /hello 映射 HelloServlet程序

  在servlet写好之后，通过在web.xml文件中配置相应路径响应的servlet，然后将其映射过去。

2.用户提交请求时，get方式提交 执行 HelloServlet的 doGet 方法   post方式提交 执行 HelloServlet的 doPost 方法 

  用户在前台提交表单的方式 method=&quot;post/get&quot; 对应在servlet中执行相应的doPost/doPost方法
</code></pre><p>4.Servlet程序在编写和运行时，需要 javaee 类库 （API支持）</p>
<pre><code>* 在学习javase  List 需要 import java.util.List  需要 jre/lib/rt.jar 
* MyEclipse 自动导入 javaee5 liberary  存在 javaee.jar  提供 Servlet 需要类 API支持 （开发环境使Servlet程序正常编译）
* Serlvet程序运行tomcat环境中 没有javaee.jar , 在 tomcat/lib/servlet-api.jar 提供Servlet程序运行需要 类API 支持 （运行环境需要的）
</code></pre><p>5.手动编写Servlet运行</p>
<pre><code>1.在webapps 新建 day05test目录   此为虚拟应用
2.在day05test 新建 WEB-INF/classes
3.将编写Servlet的java源码文件 放入 classes ，在 WEB-INF 配置web.xml 
4.编译Servlet的 java程序 

// 通过 -classpath 指定 Servlet需要jar 包
javac -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java
//生成Servlet package结构    
javac -d . -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java
</code></pre><p>6.Servlet运行原理分析</p>
<pre><code>编写Servlet程序没有 main函数，tomcat调用Servlet程序执行

通过myeclipse向导创建 Servlet   在创建Servlet程序的同时，生成 web.xml 配置

* 生成Servlet信息非常复杂，想生成 Servlet 内容整洁一些，精简一些的话就修改Servlet模板 
    1、myeclipse工具   安装目录 common / plugins
    com.genuitec.eclipse.wizards_8.5.0.me201003052220.jar
    2、解压缩 templates/Servlet.java  这个就是Servlet模板 
</code></pre><p>7.通过API Servlet继承关系<br>    Servlet接口<br>    实现类 ： GenericServlet<br>    子类 HttpServlet 编写Servlet 继承HttpServlet </p>
<pre><code>* 编写Servlet 间接 实现 Servlet 接口  （简化开发）

Servlet接口 提出，为了解决基于请求-响应模型数据处理 （并没有涉及与HTTP协议相关 API）
GenericServlet 实现接口 通用Servlet 也没有提供与 HTTP协议相关 API 
HttpServlet 引入与 协议相关 API 
</code></pre><p>8.Servlet生命周期 </p>
<pre><code>init(ServletConfig config)  初始化 
service(ServletRequest req, ServletResponse res)  提供服务方法
destroy()  销毁 

1、tomcat服务器启动时，没有创建Servlet对象

2、第一次访问时，tomcat构造Servlet对象，调用 init，执行service 

3、从第二次以后访问 tomcat 不会从新创建Servlet对象，也不会调用init   每一次访问都会调用service

4、当服务器重启或正常关闭时 调用destroy （正常关闭 shutdown.bat）

注意：Servlet对象是tomcat创建的，每次请求调用Servlet中service方法，tomcat服务器会在每次调用Servlet的service方法时，为该方法创建Request对象和Response对象

* 在 JavaEE API 中没有Request和Response实现类   实现类由Servlet服务器提供的，tomcat提供实现类 weblogic 提供实现类 


service方法 和 HttpServlet doGet/doPost 关系区别（必须阅读HttpServlet源代码） 

在HttpServlet代码实现中，根据请求方式不同 调用相应doXXX方法 get方式请求  doGet  post方式   doPost 

配置Servlet随tomcat服务器启动时 进行初始化   &lt;load-on-startup &gt;(web.xml中配置)  *&lt;load-on-startup &gt; 参数可以是一个数字 0-9 代表服务器加载优先级 0 最高 

例如：在tomcat启动时，想通过Servlet加载一些框架配置文件 配置随服务器启动 （struts1 ）

结论：
    1、编写Servlet 继承HttpServlet
    2、编写Servlet 不需要覆盖service方法，只需要覆盖doGet和doPost 方法

    Servlet初始化时覆盖init() ，无需覆盖init(config) ？？ 
    * init(Config) 调用 init() 

注意：当doGet和doPost代码逻辑相同时，可以相互调用，简化编程
</code></pre><p>9.一个Servlet可以配置多个 url-pattern (web.xml)</p>
<pre><code>URL 配置格式 三种：
    1、完全路径匹配  (以/开始 ) 例如：/hello /init 
        * 当前工程没有被正确发布，访问该工程所有静态资源、动态资源而发生404错误  表示工程启动时出错了 
        * 查看错误时 分析错误
            1) 单一错误 ： 从上到下 查看第一行你自己写的代码 （有的错误与代码无关，查看错误信息）
            2）复合错误 Caused by ---- 查看最后一个Caused by 
            * Invalid &lt;url-pattern&gt; init2 in servlet mapping 

    2、目录匹配 (以/开始) 例如：/*  /abc/* 
        / 代表网站根目录 

    3、扩展名 (不能以/开始) 例如：*.do *.action 
        典型错误 /*.do 

    优先级：完全匹配 &gt; 目录匹配 &gt; 扩展名匹配 
</code></pre><p>10.路径问题：编写九九乘法表</p>
<pre><code>1、需要用户在客户端输入一个数字
2、Servlet接收客户输入数字 打印对应乘法表 
</code></pre><p>例如：在chengfabiao.html 通过 action 访问 ChengfabiaoServlet  路径可以用绝对路径和相对路径 </p>
<pre><code>1.相对路径：相对当前网页地址 路径  例如 chengfabiao  ./chengfabiao  ../chengfabiao
    例如： http://localhost/day05/chengfabiao.html  提交 action=&quot;chengfabiao&quot; 

* 将url最后地址换成相对路径 
结果： http://localhost/day05/chengfabiao    服务器端 /chengfabiao

    例如： http://localhost/day05/aaa/chengfabiao.html 提交 action=&quot;chengfabiao&quot;
    结果： http://localhost/day05/aaa/chengfabiao    服务器 /chengfabiao 
        * /aaa/chengfabiao 与服务器 /chengfabiao 不匹配 出现404 

    http://localhost/day05/aaa/chengfabiao.html 提供 action=&quot;../chengfabiao&quot; 
    结果：http://localhost/day05/aaa/../chengfabiao   ..和/aaa抵消 http://localhost/day05/chengfabiao 可以匹配服务器 /chengfabiao

结论：如果用相对路径提交请求，考虑当前路径， 当前访问服务器资源路径不同   相对路径写法不同

绝对路径 解决相对路径，会根据当前地址改变问题。 
例如： /day05/chengfabiao 、http://localhost/day05/chengfabiao

绝对路径 以/开始 /访问服务器根目录 
例如： 客户端访问服务器，不管当前路径是什么   / 服务器根目录 http://localhost/day05   找到虚拟目录day05工程  /day05/chengfabiao  找到 day05工程下配置 虚拟路径/chengfabiao

结论： 客户端路径 /工程虚拟目录/servlet虚拟路径 例如：/day05/chengfabiao
服务器端 配置web.xml 不需要写工程虚拟目录  只要直接写/servlet虚拟路径  例如：/chengfabiao 
</code></pre><hr>
<h4 id="掌握Servlet程序编写"><a href="#掌握Servlet程序编写" class="headerlink" title="掌握Servlet程序编写"></a>掌握Servlet程序编写</h4><pre><code>通过路径 访问Servlet 程序
    * Servlet 生命周期

    init 程序初始化
    service 程序业务层
    destroy 程序销毁    
</code></pre><p>1.学习init方法  init(ServletConfig)  通过ServletConfig 获得Servlet初始化参数</p>
<p>  1、创建一个Servlet</p>
<p>  2、在 web.xml 中 <servlet> 标签内通过 <init-param> 标签为Servlet配置初始化参数<br>    <init-param><br>        <param-name>itcast</param-name><br>        <param-value>传智播客</param-value><br>    </init-param></init-param></servlet></p>
<p>  3、在Servlet程序中通过ServletConfig对象获得itcast对应数据<br>    getInitParameter —— 通过name获得value<br>    getInitParameterNames  —– 获得所有name </p>
<ul>
<li><p>思考 ：如何在 doGet 或 doPost 方法中获得 Servlet 初始化参数？ </p>
<p>1.将ServletConfig对象保存实例成员变量<br>2.GenericServlet 已经将 ServletConfig 保存成员变量，在子类中通过 getServletConfig() 方法获得初始化参数</p>
<p>结论：子类Servlet不需要覆盖 init(ServletConfig) 只需要通过GenericServlet中 getServletConfig() 获得ServletConfig对象<br>应用：在init-param 指定配置文件位置和名称，配置Servlet随服务器启动创建 load-on-startup  </p>
</li>
<li><p>ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得 每个Servlet程序都对应一个ServletConfig对象 </p>
</li>
<li><p>ServletContext 是Servlet上下文对象，每一个工程都会创建单独ServletContext对象，这个对象代表当前web工程，操作ServletContext，必须通过 ServletConfig 获得对象 </p>
<p>应用：</p>
<pre><code>1、 获得整个web应用初始化参数
2、 实现全局数据共享
3、 实现服务器端转发功能
4、 读取web工程资源文件
</code></pre></li>
</ul>
<hr>
<p>1.获取WEB应用的初始化参数 和 ServletConfig 对象不同 </p>
<ul>
<li>ServletConfig对象配置参数，只对配置Servlet有效，如果配置参数，所有Servlet都可以访问 通过ServletContext<br><context-param></context-param></li>
</ul>
<p>2.通过 ServletContext 在多个Servlet间 共享数据<br>    案例：在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1 </p>
<pre><code>    在CountServlet 初始化过程中，向ServletContext 保存访问次数 方法：ServletContext  setAttribute 

    每次访问次数 +1  数据存放ServletContext中 所有Servlet都可以获得该数据

* 在ServletContext中保存数据，所有Servlet都可以访问 
</code></pre><p>3.通过 ServletContext 完成服务器程序转发 </p>
<pre><code>什么是转发？ 转发和重定向区别 ？
getRequestDispatcher(java.lang.String path)  完成转发

使用转发还是重定向？ 转发性能好于重定向，请求次数好 

案例：统计字母次数
    request.getParameter(&quot;content&quot;) 获得form 提交内容 content 就是 textarea name属性
</code></pre><p>4.利用ServletContext对象读取资源文件</p>
<pre><code>1.使用java application 读取文件，读取当前工程下所有文件  使用相对路径读取文件

2.使用Servlet读取文件 只能读取WebRoot下所有文件  必须使用绝对磁盘路径读取文件 

3.通过站点根目录绝对路径 获得磁盘绝对路径 getServletContext().getRealPath(“/WEB-INF/info.txt”)

注意：因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，通过Class类对象读取该目录下文件 
    String filename3 = c.getResource(&quot;/a1.txt&quot;).getFile();  表示： / 代表 /WEB-INF/classes 

结论：在WEB工程中，必须将文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx  getServletContext().getRealPath(&quot;/xxx&quot;);   /代表WebRoot 
如果读取文件恰好位于 WEB-INF/classes 通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径   / 代表 /WEB-INF/classes 
</code></pre><p>注意：<br>    缺省Servlet 功能：处理其他Servlet都不处理请求<br>    tomcat/conf/web.xml  org.apache.catalina.servlets.DefaultServlet 作为缺省Servlet </p>
<pre><code>总结：
    1、编写Servlet HelloServlet
    2、修改Servlet模板 
    3、Servlet生命周期 理论重点掌握
    4、Servlet url三种写法 完全、目录、扩展名
    5、路径问题：绝对路径   案例 九九乘法表
           将web.xml 配置路径复制到网页 在路径前 /工程名
    6、ServletConfig 和ServletContext 读取初始化参数区别 ？
    7、ServletContext数据共享案例   统计访问次数
    8、ServletContext转发案例   统计字母出现次数
    9、读取web工程中资源文件   绝对路径
        在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx   getServletContext().getRealPath(&quot;/xxx&quot;);  /代表WebRoot 
        如果读取文件 恰好位于 WEB-INF/classes   通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes 
    10、缺省Servlet 了解功能将静态资源数据内容读取写给客户端 
</code></pre><hr>
<h4 id="HttpServletResponse-HttpServletRequest-关键：了解HTTP协议"><a href="#HttpServletResponse-HttpServletRequest-关键：了解HTTP协议" class="headerlink" title="HttpServletResponse HttpServletRequest(关键：了解HTTP协议)"></a>HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</h4><p>Web服务器(TOMCAT)收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象和代表响应的response对象。所以获取客户端提交的数据，只需要找到request对象即可，然后如果需要向容器输出数据，只需要找response对象即可。</p>
<p><strong>1.HttpServletResponse</strong><br></p>
<pre><code>1.响应行 setStatus(int sc);//设置相应状态码 HTTP/1.1 200
2.响应头 setHeader(String name,String value);//设置响应头信息 
      请求重定向 sendRedirect(String location);

  浏览器使用的码表(告知)
    response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

  告知客户端不缓存
    response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
    response.setDataHeader(&quot;expires&quot;,0);
3.相应正文
    setCharacterEncoding(String charset);//告知服务器使用什么编码
    setContentType(String type);
</code></pre><p><strong>2.HttpServletRequest</strong><br></p>
<pre><code>1.请求行
  Get方式 URL链接：http://localhost:8080/day09/servlet/req1?username=zs  协议：http/1.1

    getMethod(); 获得请求方式
    getRequestURL();返回客户端发出请求时的完整URL。
    getRequestURI(); 返回请求行中的资源名部分。
    getContextPath(); 当前应用的虚拟目录 /day09_01_request
    getQueryString() ; 返回请求行中的参数部分。

2.请求消息头

  String getHeader(String name)  根据头名称得到头信息值
  Enumeration   getHeaderNames()  得到所有头信息name
  Enumeration   getHeaders(String name)  根据头名称得到相同名称头信息值

3.请求正文

获取表单数据相关的方法
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  getParameter(name) 根据表单中name属性的名，获取value属性的值方法 
  getParameterValues（String name）专为复选框提供的方法
  getParameterNames() 得到表单提交的所有name的方法 
  getParameterMap 到表单提交的所有值的方法   //做框架用，非常实用
  getInputStream  以字节流的方式得到所有表单数据

扩展：
    操作非表单数据相关的方法(request是一个域对象)
        void setAttribute(String name, Object value);
        Object getAttribute(String name);
        void removeAttribute(String name);

    请求转发相关方法

        //得到请求转发或请求包含的协助对象
        RequestDispatcher getRequestDispatcher(String path)
        forward(ServletRequest request, ServletResponse response) //转发的方法
        include(ServletRequest request, ServletResponse response) //请求包含

    请求编码相关方法

        //解决post方式编码
        request.setCharacterEncoding(&quot;UTF-8&quot;); //告诉服务器客户端什么编码,只能处理post请求方式

        //解决get方式编码
        String name = new String(name.getBytes(“iso-8859-1”),”UTF-8”);
</code></pre><hr>
<h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2><p>两条主线<br>    1、HTTP协议<br>    2、Servlet生命周期 </p>
<p>1.init()方法中参数 ServletConfig 对象的使用</p>
<p>  通过 ServletConfig 获得 ServletContext 对象来使用</p>
<p>2.service()方法 含有两个参数对象 ServletRequest ServletResponse </p>
<p>  在实际开发Servlet过程中不需要覆盖service,HttpServlet 根据请求方式自动调用 doGet 或者 doPost doGet和doPost参数 HttpServletRequest 和 HttpServletResponse </p>
<hr>
<p>3.HttpServletRequest HttpServletResponse (学习重点)</p>
<p>  客户端每次请求都会创建request对象和response对象 作用：被传递service / doGet / doPost </p>
<p>  1.HttpServletRequest 封装客户端相关信息，服务器Servlet程序可以 通过request对象 操作客户端信息<br>  2.HttpServletResponse 封装服务器向客户端发送响应数据信息，Servlet程序 通过response对象 向客户端发送响应</p>
<p>4.Response常用的API</p>
<pre><code>1.setStatus 设置响应行 当中 状态码
2.setHeader 设置响应头信息
3.getOutputStream 获得字节流 ---- 输出响应体内容
4.getWriter 获得字符流 ---- 输出响应体内容
</code></pre><p>注意：</p>
<ul>
<li>HttpServletResponse 继承 ServletResponse 接口 ，ServletResponse 并没有提供与HTTP协议相关API ，HttpServletResponse 添加了与协议相关 API</li>
<li>JavaEE API 中并没有提供 HttpServletResponse 实现类 —- 实现类由tomcat服务器提供的</li>
</ul>
<p>5.服务器常用状态码 ： 200 302 304 404 500 </p>
<pre><code>200 请求处理成功
302 客户端重定向
304 客户端访问资源没有被修改，客户端访问本地缓存
404 访问资源不存在
500 服务器内部出错
</code></pre><p>6.案例：</p>
<pre><code>1.通过302 + Location 头信息实现页面重定向效果 
    response.setStatus(302);
    response.setHeader(&quot;Location&quot;, &quot;/day06/welcome.html&quot;); // 相对路径 和 绝对路径

注意：* / 由客户端定向服务器，代表客户端 / , 必须添加工程虚拟目录 

   头信息存在多个值

    Accept-Encoding: gzip, deflate --- key:value1,value2 
    response.addHeader 用于设置响应头有多个值 ------ 不常用 
重点：setHeader 

在Response API 中提供sendRedirect ---- 完成302+Location重定向效果 
例如： response.sendRedirect(&quot;/day06/welcome.html&quot;);

2.登陆重定向


3.自动刷新网页 

* 登陆成功，5秒后自动跳转XX页面 
原理：通过refresh 头信息 
格式 -----   refresh: 时间;url=跳转路径
例如： refresh:3;url=http://www.itcast.cn -------- 3秒后自动跳转http://www.itcast.cn 网站 

注意：* HTML 页面中存在一类非常特殊标签 &lt;meta&gt; ，&lt;meta&gt; 起到设置头信息作用 
&lt;meta content=&quot;3;url=/day06/response/demo3/result.html&quot; http-equiv=&quot;refresh&quot;&gt; ---- 完成自动跳转 

4.通过response头信息设置 浏览器禁止缓存

原理：和禁用缓存相关头信息 三个 
Cache-Control:no-cache
Expires:Thu, 01 Dec 1994 16:00:00 GMT  ----- setDateHeader(&quot;expires&quot;,-1);
Pragma : no-cache

IE 工具---Internet选项 ---常规 --- 设置 --- 查看文件
对于Servlet生成HTML页面，经常需要改变，禁止Servlet动态程序缓存 
注意：* 设置Expires时，通常 setDateHeader 为过期时间设置一个毫秒值，生成HTTP响应时，会自动转换日期字符串表示 
</code></pre><p>通过response 生成 客户端响应体，通过字节流和字符流两种输出方式 </p>
<pre><code>* 哪些情况用字节流？ 哪些情况用字符流 ？ 
    文件拷贝 ---- 字节流 
    分析文件内容 --- 字符流 （中文操作 字符流）

5.输出中文信息

对中文信息进行编码 
response.setCharacterEncoding(&quot;utf-8&quot;);
response.setContentType(&quot;text/html;charset=utf-8&quot;); 

setCharacterEncodig 和 setContentType 区别 ？

结论：开发中只需要使用setContentType 就可以了
</code></pre><blockquote>
<p>注意：<br>    1、getOutputStream和getWriter 不能同时使用<br>    2、必须在getOutputStream和getWriter 之前 设置响应 编码<br>    3、getOutputStream和getWriter 输出内容 是 HTTP响应体<br>    4、getOutputStream和getWriter 存在缓冲区的 ，在service方法结束时，自动关闭流，flush缓冲区内容</p>
</blockquote>
<pre><code>6.文件下载
第一种：通过超链接 完成文件下载 
* 如果浏览器可以识别该文件格式，直接打开，只有链接文件浏览器不识别文件格式，才会实现下载 

第二种：通过Servlet程序实现下载 
原理：通过Servlet读取目标程序，将资源返回客户端
通过程序下载文件 设置两个头信息 Content-Type Content-Disposition 
response.setContentType(getServletContext().getMimeType(filename));  ---- 设置文件类型 
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+ filename); ---- 设置文件以附件形式下载（对于浏览器识别格式文件）

7.验证码输出案例 
Java图形API 生成验证码图片 ----- 了解 
为什么需要验证码 ？防止有人通过程序恶意攻击网站 
验证码为什么是图片 ？为什么雪花或者干扰线？  
常用验证码 ： 字母和数字 

验证码旋转效果 
rotate(double theta, double x, double y)  ----- 参数 theta 旋转弧度 
2PI 弧度 = 360 角度 

-30 ---- 30 角度 

验证码看不清楚，点击切换验证码 ---- 编写JavaScript程序 
方法一：设置验证码图片不缓存
方法二：每次访问使url 不同 ----- url?new Date().getTime() 当前时间 
</code></pre><hr>
<p>HttpServletRequest 分为四个部分</p>
<pre><code>HttpServletRequest 想比 ServletRequest 添加与协议相关 API

1、获取客户机信息
    URI和URL区别
    url:http://localhost/day06/request1  --- 完整
    uri:/day06/request1  ---- 部分

    URI 包含 URL的 ，URL 一定完成路径，URI可以相对路径 
    http://localhost/day06/request1 是一个URL 同时也是 URI
    ./hello  /day06/request1 ---- 都是URI 不是URL 

获得ip ： request.getRemoteAddr();

获得当前访问资源路径 ： request.getRequestURI().substring(request.getContextPath().length());


2、获取请求头信息
    getHeader 获得头信息的值，转换一个字符串
    getHeaders 获得头信息值 ，获得Enumeration
    getHeaderNames 获得所有头信息名称  返回 Enumeration

    * 掌握getHeader使用，遍历Enumeration 获得所有头信息

    编写防盗链程序，存在合法referer不是盗链，否则控制目标资源无法访问 ！
    * 通过URL 绕过盗链判断

3、获取请求参数

    请求参数：指用户通过请求提交服务器一些数据

        &lt;a href=&quot;url?xxx=xxx&quot; &gt;
        &lt;form method=&quot;get&quot;&gt;
        &lt;form method=&quot;post&quot;&gt;

    如：/day06/request4?name=zhangsan&amp;city=beijing  这一路径中包括两个参数的 name 和 city 

request常用API四个

    getParameter
    getParameterValues
    getParameterNames
    getParameterMap 

非空校验
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {} //短路 

乱码问题
    post方法：request.setCharacterEncoding(&quot;客户端编码集&quot;);

    get乱码手动解决
        username = URLEncoder.encode(username, &quot;ISO-8859-1&quot;);// 用ISO编码
        username = URLDecoder.decode(username, &quot;utf-8&quot;); // 用utf-8解码
        简化上面写法 ： username = new String(username.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);

get乱码 配置tomcat默认解码字符集
    在tomcat/conf/server.xml 
    Connector中 添加一个属性 URIEncoding=&quot;utf-8&quot;

结论：开发时，尽量不要修改tomcat默认解码集 ，提交请求请尽量使用post ，如果非要使用get ，手动编码

问题：http://localhost/day06/servlet?username=zhangsan+lisi
在服务器端 通过 request.getParameter(&quot;username&quot;) 结果是 ？？？ ----- zhangsan lisi 


4、利用请求域传递对象
    HttpServletRequest 和 ServletContext 类似 都是数据域对象 ， 以Map方式保持数据

    区分：存活时间不同 

    ServletContext对象 服务器启动对象创建，服务器停止对象销毁
    ServletRequest对象 当产生一次请求时 创建，当响应结束后，对象销毁 

    通过request转发请求，request保存数据进行Servlet之间传递 ---- 应用？
    Servlet进行数据处理 --- 生成结果 --- 转发结果给JSP显示 
</code></pre><p>注意：</p>
<pre><code>1、在使用forward之前 不能将响应内容传输到客户端
    情况一 response输出流执行flush 
    情况二 同一个Servlet不能连续使用forward 和 redirect
2、在执行forward 和 redirect时，清除之前写入响应流数据 
3、ServletContext进行转发 路径必须/开始，request进行转发路径可以使用相对路径 

转发和重定向区别
    1、转发一次请求、一次响应 重定向 两次请求 两次响应
    2、转发只能跳转站内程序，重定向定向任何站点 
    3、转发 URL地址不变 ，重定向URL地址改变 
    4、转发 对客户端不可见，重定向对客户端可见 
    5、转发共享同一个Request中数据，重定向两次请求，不同Request对象，不能共享Request数据 
</code></pre><ul>
<li>request.setAttribute 必须和 request.getRequestDispatcher().forward 一起使用 </li>
</ul>
<p>RequestDispatcher 的 include 方法 用来做页面布局 —— &lt;%@include%&gt; <a href="jsp:include" target="_blank" rel="noopener">jsp:include</a><br>将页面公共部分抽取出来，通过include 引用到页面中 —- 更加方便维护 </p>
<hr>
<p>总结：<br>    1、Response 四个必须 API setStatus setHeader getOutputStream getWriter<br>    setStatus 状态码<br>    setHeader 头信息<br>    getOutputStream getWriter  响应体</p>
<pre><code>2、重定向 302 + Location ---- 简写 sendRedirect 
案例 用户登录重定向 

3、refresh自动刷新网页 
&lt;meta&gt; 标签使用 

4、禁用浏览器缓存 三个头字段 

5、响应中文乱码 ---- 都使用setContentType

6、文件下载 超链接和Servlet程序 
    Servlet程序 设置两个头字段 Content-Type Content-Disposition

7、验证码程序 （写完整存档）
    * 验证码点击切换 两种方法 

8、request请求行相关API getRequestURI getContextPath getRemoteAddr getMethod  
    思考：获得访问资源路径 

9、request头信息获得（不重要） ---- 掌握防盗链案例

10、获得请求参数 乱码解决 get 、post  （超级重要）

11、转发共享request数据 、include进行页面布局 ---- 了解即可
</code></pre><hr>
<p>POST编码与GET编码</p>
<p>1.POST编码<br>  &lt;%@page pageEncoding=”UTF-8”%&gt; 浏览器当前是什么编码就以什么编码提交<br>  Servlet：因为客户端没有告诉服务器，请求正文的编码，于是服务器默认用ISO-8859-1进行编码，从而出现乱码<br>  解决方法：告诉服务器请求正文的数据应该使用的编码是什么(request.setCharacterEncoding(“UTF-8”);)</p>
<p>2.GET编码<br>  &lt;%@page pageEncoding=”UTF-8”%&gt; 浏览器当前是什么编码就以什么编码提交<br>  Servlet：URL地址后的参数服务器默认用ISO-8859-1进行编码，这样会产生乱码<br>  解决方法：如果依照POST的解决乱码的方法，结果是无效的。需要拿到原始的二进制数据，然后用UTF-8进行重新编码</p>
<p>  byte b[] = name.getBytes(“ISO-8859-1”);//1010101<br>  String name = new String(b,”UTF-8”);//解决</p>
<hr>
<p>Request Response对象解决乱码的应用</p>
<pre><code>1.服务器解决乱码
response.setContentType(&quot;text/html;charset=gbk&quot;);
2.浏览器解决乱码
request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre><hr>
<p>Servlet技术</p>
<pre><code>1、Servlet程序编写 ----- 生命周期
2、ServletAPI Request Response 
3、Cookie 和 Session 
</code></pre><p>注意：Servlet 用来 动态web资源 开发<br>    静态web资源 ： 固定数据文件<br>    动态web资源 ： 通过程序动态生成数据文件 </p>
<pre><code>Servlet技术基于Request-Response编程模型 ---- HTTP协议也是基于请求响应 模型 
* Servlet技术 用来 开发基于HTTP web 应用程序 

接触 JavaEE API ------ 程序 接口 和 已经实现接口 类的 使用 
JavaEE ---- Java Platform, Enterprise Edition  缩写 
</code></pre><hr>
<p>Servlet快速入门<br>    1、创建web project<br>    2、编写 class 继承 HttpServlet<br>    3、在web.xml 配置 Servlet程序 虚拟访问路径 </p>
<pre><code>    * 用户在浏览器上通过这个路径 访问编写Servlet程序 
4、覆盖doGet或者doPost方法 进行输出 

* Servlet 动态生成 网页文件 

执行过程
    1、用户在客户端发起url请求 ： http://localhost/day05/hello ----- web.xml /hello 映射 HelloServlet程序
    2、用户提交请求时，get方式提交 执行 HelloServlet的 doGet方法 post方式提交 执行 HelloServlet的doPost 方法 

Servlet程序在编写和运行时，需要javaee 类库 （API支持）
    * 在学习javase  List 需要 import java.util.List  需要 jre/lib/rt.jar 
    * MyEclipse 自动导入 javaee5 liberary  存在 javaee.jar  提供 Servlet 需要类 API支持 （开发环境使Servlet程序正常编译）
    * Serlvet程序运行tomcat环境中 没有javaee.jar , 在 tomcat/lib/servlet-api.jar 提供Servlet程序运行需要 类API 支持 （运行环境需要的）

手动编写Servlet运行
    1、在webapps 新建 day05test目录 --- 虚拟应用
    2、在day05test 新建 WEB-INF/classes
    3、将编写Servlet的java源码文件 放入 classes ，在 WEB-INF 配置web.xml 
    4、编译Servlet的 java程序 

设置classpath路径
    javac -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java  // 通过 -classpath 指定 Servlet需要jar 包

生成Servlet package结构 
    javac -d . -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java


Servlet运行原理分析
    编写Servlet程序没有 main函数 ---- tomcat调用Servlet程序执行

    通过myeclipse向导 创建Servlet ---- 创建Servlet程序，生成web.xml 配置 
        * 生成Servlet信息非常复杂，想生成Servlet 内容整洁一些，精简一些 ------ 修改Servlet模板 
        1、myeclipse工具 ---- 安装目录 common / plugins
            com.genuitec.eclipse.wizards_8.5.0.me201003052220.jar

        2、解压缩 templates/Servlet.java --- 这个就是Servlet模板 

通过API Servlet继承关系 
    Servlet接口 ---- 实现类 ： GenericServlet ------ 子类 HttpServlet  ------ 编写Servlet 继承HttpServlet 
        * 编写Servlet 间接 实现 Servlet 接口  （简化开发）
    Servlet接口 提出，为了解决基于请求-响应模型数据处理 （并没有涉及与HTTP协议相关 API）
    GenericServlet 实现接口 通用Servlet 也没有提供与 HTTP协议相关 API 
    HttpServlet 引入与 协议相关 API 
</code></pre><hr>
<p>Servlet生命周期 </p>
<pre><code>1.init(ServletConfig config)  初始化 
2.service(ServletRequest req, ServletResponse res)  提供服务方法
3.destroy()  销毁 

1、tomcat服务器启动时，没有创建Servlet对象

//默认第一次请求时创建servlet实例，应用存在实例就存在，在实例被卸载，实例就销毁
2、第一次访问时，tomcat构造Servlet对象，调用 init，执行service 

3、从第二次以后访问 tomcat 不会从新创建Servlet对象，也不会调用init  每一次访问都会调用service 
4、当服务器重启或正常关闭时 调用destroy （正常关闭 shutdown.bat）

Servlet对象是tomcat创建的，每次请求调用Servlet中service方法，tomcat服务器会在每次调用Servlet的service方法时，为该方法创建Request对象和Response对象 
* 在 JavaEE API 中没有Request和Response实现类   实现类由Servlet服务器提供的，tomcat提供实现类 weblogic 提供实现类 

service方法 和 HttpServlet doGet/doPost 关系区别？ 必须阅读HttpServlet源代码 
在HttpServlet代码实现中，根据请求方式不同 调用相应doXXX方法 get方式请求 --- doGet  post方式 --- doPost 

配置Servlet随tomcat服务器启动时 进行初始化   &lt;load-on-startup &gt;
*&lt;load-on-startup &gt; 参数可以是一个数字 0-9 代表服务器加载优先级 0 最高 
例如：在tomcat启动时，想通过Servlet加载一些框架配置文件 配置随服务器启动 （struts1 ）
</code></pre><p>结论：<br>    1、编写Servlet 继承HttpServlet<br>    2、编写Servlet 不需要覆盖service方法，只需要覆盖doGet和doPost 方法</p>
<pre><code>Servlet初始化时覆盖init() ，无需覆盖init(config) ？？ 
* init(Config) 调用 init() 

当doGet和doPost代码逻辑相同时，可以相互调用，简化编程
</code></pre><hr>
<p>Servlet的三种创建方式</p>
<pre><code>1.实现javax.servlet.Servlet接口

2.实现javax.servlet.GenericServlet类(适配器模式)

3.继承javax.servlet.http.HttpServlet类(模板方法设计模式) 这种方式是开发中常用的方法

public class ServletDemo extends HttpServlet{
    protected void doGet(HttpServletRequest req,HttpServleResponse resp) throws ServletException,IOExcption{
        System.out.println(&quot;get方法实现&quot;);
        }
    protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException,IOException{
        System.out.println(&quot;doPost方法实现&quot;);
        }
    }
</code></pre><hr>
<pre><code>web.xml映射细节

    1.配置多个映射路径（配置多个&lt;servlet-mapping&gt;）：

        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;

    2.通配符*代表任意字符串

        1.url-pattern: *.do  以*.字符串的请求都可以访问   注：不要加/ (扩展名匹配)
        2.url-pattern: /*  任意字符串都可以访问 (绝对匹配)
        3.url-pattern：/action/* 以/action开头的请求都可以访问 (开头匹配)

    注意：如果url-pattern的值是/，表示执行默认映射。所有资源都是servlet
</code></pre><hr>
<p>一个Servlet可以配置多个url-pattern </p>
<p>URL 配置格式 三种：<br>    1、完全路径匹配  (以/开始 ) 例如：/hello /init </p>
<pre><code>    * 当前工程没有被正确发布，访问该工程所有静态资源、动态资源 发生404 ----- 工程启动时出错了 
    * 查看错误时 分析错误
1) 单一错误 ： 从上到下 查看第一行你自己写代码 （有的错误与代码无关，查看错误信息）
2）复合错误 Caused by ---- 查看最后一个Caused by 
* Invalid &lt;url-pattern&gt; init2 in servlet mapping 

2、目录匹配 (以/开始) 例如：/*  /abc/* 
/ 代表网站根目录 

3、扩展名 (不能以/开始) 例如：*.do *.action 
典型错误 /*.do 

优先级：完全匹配&gt;目录匹配 &gt; 扩展名匹配 
</code></pre><p>路径问题：编写九九乘法表<br>    1、需要用户在客户端输入一个数字<br>    2、Servlet接收客户输入数字 打印对应乘法表 </p>
<pre><code>在chengfabiao.html 通过 action 访问 ChengfabiaoServlet  路径可以用绝对路径和相对路径 

相对路径：相对当前网页地址 路径  例如 chengfabiao  ./chengfabiao ../chengfabiao
例如： http://localhost/day05/chengfabiao.html  提交 action=&quot;chengfabiao&quot;

* 将url最后地址换成相对路径 
结果： http://localhost/day05/chengfabiao  ----- 服务器端 /chengfabiao

例如： http://localhost/day05/aaa/chengfabiao.html 提交 action=&quot;chengfabiao&quot;
结果： http://localhost/day05/aaa/chengfabiao  ----- 服务器 /chengfabiao 
* /aaa/chengfabiao 与服务器 /chengfabiao 不匹配 出现404 

http://localhost/day05/aaa/chengfabiao.html 提供 action=&quot;../chengfabiao&quot; 
结果：http://localhost/day05/aaa/../chengfabiao ---- &gt; ..和/aaa抵消 http://localhost/day05/chengfabiao 可以匹配服务器 /chengfabiao

结论：如果用相对路径提交请求，考虑当前路径， 当前访问服务器资源路径不同 ---- 相对路径写法不同

绝对路径 解决相对路径，会根据当前地址改变问题。 例如： /day05/chengfabiao 、http://localhost/day05/chengfabiao
绝对路径 以/开始 /访问服务器根目录 
例如： 客户端访问服务器，不管当前路径是什么 --- / 服务器根目录 http://localhost
/day05 --- 找到虚拟目录day05工程  /day05/chengfabiao --- 找到 day05工程下配置 虚拟路径/chengfabiao

结论： 客户端路径 /工程虚拟目录/servlet虚拟路径 例如：/day05/chengfabiao
服务器端 配置web.xml 不需要写工程虚拟目录  只要直接写/servlet虚拟路径  例如：/chengfabiao 
</code></pre><hr>
<p>掌握Servlet程序编写</p>
<pre><code>通过路径 访问Servlet 程序
</code></pre><ul>
<li><p>Servlet 生命周期</p>
<p>  init<br>  service<br>  destroy </p>
</li>
</ul>
<p>学习init方法   init(ServletConfig)   通过ServletConfig 获得Servlet初始化参数</p>
<pre><code>1、创建一个Servlet
2、在web.xml 中 &lt;servlet&gt; 标签内 通过 &lt;init-param&gt; 标签 为Servlet配置初始化参数
        &lt;init-param&gt;
            &lt;param-name&gt;itcast&lt;/param-name&gt;
            &lt;param-value&gt;传智播客&lt;/param-value&gt;
        &lt;/init-param&gt;

3、在Servlet程序中通过ServletConfig对象 获得itcast对应数据 
    getInitParameter   通过name获得value
    getInitParameterNames  获得所有name 

  Servlet获取配置信息

    ServletConfig作用：

        1.获取servlet配置信息
        2.获取ServletContext对象 ServletContext对象代表整个应用，且一个应用应用只有一个ServletContext对象 作用：在一定范围之内使得多个Servlet共享数据

* 思考 ：如何在doGet 或 doPost 方法中 获得 Servlet初始化参数 
    1.将ServletConfig对象保存实例成员变量 
    2.GenericServlet 已经将ServletConfig 保存成员变量   在子类中通过 getServletConfig方法 获得 初始化参数

结论：子类Servlet不需要覆盖 init(ServletConfig) , 只需要通过GenericServlet中 getServletConfig() 获得ServletConfig对象 

应用：在init-param 指定配置文件位置和名称，配置Servlet随服务器启动创建 load-on-startup  

* ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得   每个Servlet程序都对应一个ServletConfig对象 

ServletContext 是Servlet上下文对象 
    每一个工程 对会创建 单独ServletContext对象，这个对象代表当前web工程 
    操作ServletContext 必须通过ServletConfig 获得对象 
</code></pre><p>应用：<br>    1、 获得整个web应用初始化参数<br>    2、 实现全局数据共享<br>    3、 实现服务器端转发功能<br>    4、 读取web工程资源文件</p>
<pre><code>1、获取WEB应用的初始化参数 和 ServletConfig 对象不同 
* ServletConfig对象 配置参数，只对配置Servlet有效，如果配置参数，所有Servlet都可以访问 通过ServletContext
    &lt;context-param&gt;

2、通过ServletContext 在多个Servlet间 共享数据 
    在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1 
    在CountServlet 初始化过程中，向ServletContext 保存访问次数   0    ServletContext  setAttribute 

      每次访问次数 +1  数据存放ServletContext中  所有Servlet都可以获得该数据

    * 在ServletContext中保存数据，所有Servlet都可以访问 

3、通过ServletContext 完成服务器程序转发 
    什么是转发？ 转发和重定向区别 ？
    getRequestDispatcher(java.lang.String path)   完成转发

    使用转发还是重定向？   转发性能好于重定向，请求次数好 

    统计字母次数
    request.getParameter(&quot;content&quot;) 获得form 提交内容 content 就是 textarea name属性

4、利用ServletContext对象读取资源文件

    使用java application 读取文件，读取当前工程下所有文件    使用相对路径读取文件
    使用Servlet读取文件 只能读取WebRoot下所有文件    必须使用绝对磁盘路径读取文件 

    通过站点根目录绝对路径 获得磁盘绝对路径   getServletContext().getRealPath(“/WEB-INF/info.txt”)

    * 因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，通过Class类对象读取 该目录下文件 
    String filename3 = c.getResource(&quot;/a1.txt&quot;).getFile();    / 代表 /WEB-INF/classes 

结论：在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx     getServletContext().getRealPath(&quot;/xxx&quot;);  /代表WebRoot 
      如果读取文件 恰好位于 WEB-INF/classes   通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes 


    缺省Servlet 功能：处理其他Servlet都不处理请求 
    tomcat/conf/web.xml  org.apache.catalina.servlets.DefaultServlet 作为缺省Servlet 
</code></pre><p>总结：<br>    1、编写Servlet HelloServlet<br>    2、修改Servlet模板<br>    3、Servlet生命周期 理论重点掌握<br>    4、Servlet url三种写法 完全、目录、扩展名<br>    5、路径问题：绝对路径      案例 九九乘法表<br>        将web.xml 配置路径复制到网页 在路径前 /工程名<br>    6、ServletConfig 和ServletContext 读取初始化参数区别 ？<br>    7、ServletContext数据共享案例      统计访问次数<br>    8、ServletContext转发案例   统计字母出现次数<br>    9、读取web工程中资源文件    绝对路径<br>        在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx    getServletContext().getRealPath(“/xxx”);  /代表WebRoot<br>        如果读取文件 恰好位于 WEB-INF/classes    通过 类名.class.getResource(“/文件名”).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes<br>    10、缺省Servlet 了解功能将静态资源数据内容读取写给客户端 </p>
<hr>
<h4 id="Servlet-基本训练"><a href="#Servlet-基本训练" class="headerlink" title="Servlet 基本训练"></a>Servlet 基本训练</h4><pre><code>1.在Servlet中实现请求转发

    在Servlet中实现页面转发，使用的是RequestDispatcher对象的 forward（）方法。可以在Servlet中通过 forward（）方法将当前的请求转发到其他web组件（Servlet、JSP、HTML）。

2.在Servlet中处理表单提交的数据

    Java Web的核心组件Servlet的主要功能就是处理客户端的表单请求数据，然后再Servlet中首先对这些数据进行验证，然后可能会封装到JavaBean。
    接下来调用数据库的业务逻辑方法将数据保存或者进行其他操作，最后Servlet控制将响应结果返回到客户端。

    注意：在实际开发中，Servlet处理完表单数据之后，通常会根据表单数据更新数据库，最后再由Servlet进行控制转发

3.在Servlet中实现页面重定向

    实现页面重定向主要应用在HttpServletResponse对象的sendRedirect()方法

4.动态生成HTML文档

5.在Servlet中向客户端写cookie信息
</code></pre><hr>
<p>HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</p>
<pre><code>Web服务器(TOMCAT)收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。
所以既然response/request对象代表请求和响应，那么获取客户端提交过来的数据只需要找request对象就可以，然后向容器输出数据，只需要找response对象就可以了。
</code></pre><p>1.HttpServletResponse(该对象代表服务器的响应 此对象中封装了向客户端发送数据、发送响应头、发送响应状态码的方法)</p>
<pre><code>1.响应行 setStatus(int sc);//设置相应状态码 HTTP/1.1 200
2.相应头 setHeader(String name,String value);//设置响应头信息 
      请求重定向 sendRedirect(String location);

  浏览器使用的码表(告知)
    response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

  告知客户端不缓存
    response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
    response.setDataHeader(&quot;expires&quot;,0);
3.相应正文
    setCharacterEncoding(String charset);//告知服务器使用什么编码
    setContentType(String type);

扩展：response常见应用

    向客户端输出中文数据：response.getOutputStream().write(“中国”.getBytes()));//以默认编码发送数据

    注意：当浏览器中出现乱码，通过以下方法：response.setContentType(&quot;text/html;charset=UTF-8&quot;); 解决
    总结：程序以什么编码输出就需要告诉客户端以什么编码显示

    response细节：

        1.getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。
        2.getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。  会抛异常。
        3.Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 
        4.Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。 
</code></pre><p>2.HttpServletRequest(代表客户端的请求，当客户端通过HTTP协议访问服务器时，Http请求头中的所有信息都封装到这对象，开发人员通过此对象的方法获取客户的这些信息)</p>
<pre><code>1.请求行
  Get方式 URL链接：http://localhost:8080/day09/servlet/req1?username=zs  协议：http/1.1

    getMethod(); 获得请求方式
    getRequestURL();返回客户端发出请求时的完整URL。
    getRequestURI(); 返回请求行中的资源名部分。
    getContextPath(); 当前应用的虚拟目录 /day09_01_request
    getQueryString() ; 返回请求行中的参数部分。

2.请求消息头

  String getHeader(String name)  根据头名称得到头信息值
  Enumeration   getHeaderNames()  得到所有头信息name
  Enumeration   getHeaders(String name)  根据头名称得到相同名称头信息值

3.请求正文

获取表单数据相关的方法
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  getParameter(name) 根据表单中name属性的名，获取value属性的值方法 
  getParameterValues（String name）专业为复选框取取提供的方法
  getParameterNames() 得到表单提交的所有name的方法 
  getParameterMap 到表单提交的所有值的方法   //做框架用，非常实用
  getInputStream  以字节流的方式得到所有表单数据

扩展：
    操作非表单数据相关的方法(request是一个域对象)
        void setAttribute(String name, Object value);
        Object getAttribute(String name);
        void removeAttribute(String name);

    请求转发相关方法

        //得到请求转发或请求包含的协助对象
        RequestDispatcher getRequestDispatcher(String path)
        forward(ServletRequest request, ServletResponse response) //转发的方法
        include(ServletRequest request, ServletResponse response) //请求包含

    请求编码相关方法

        //解决post方式编码
        request.setCharacterEncoding(&quot;UTF-8&quot;); //告诉服务器客户端什么编码,只能处理post请求方式

        //解决get方式编码
        String name = new String(name.getBytes(“iso-8859-1”),”UTF-8”);
</code></pre><hr>
<p>一、什么Servlet？</p>
<pre><code>servlet 是运行在 Web 服务器中的小型 Java 程序（即：服务器端的小应用程序）。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。
</code></pre><p>1.1、编写一个servlet程序：<br>a、写一个java类，实现servlet接口</p>
<pre><code>public class ServletDemo implements Servlet{
    //接收用户请求，并作出响应
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        response.getWriter().write(&quot;hello ServletDemo&quot;);
    }
}
</code></pre><p>b、修改web.xml文件，给servlet提供一个可访问的URI地址</p>
<pre><code>&lt;!--创建Servlet实例--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servletDemo的实现类&lt;/servlet-class&gt;
&lt;/sevlet&gt;

&lt;!--给servlet提供(映射)一个可以访问的URI地址--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>c、部署应用到tomcat服务器</p>
<p>d、测试：<a href="http://locahost:8080/day08_servlet/demo1" target="_blank" rel="noopener">http://locahost:8080/day08_servlet/demo1</a></p>
<p>二、执行过程</p>
<pre><code>1.首先在浏览器输入地址，然后地址转到Tomcat找到servlet应用
2.然后在servlet应用中找到相应的访问的demo
3.在找到对应的demo之后实例化后调用初始化方法
4.然后再次调用service方法
5.最后将信息响应给客户端并调用distory方法
</code></pre><p>三、Servlet生命周期（重要）<br>    实例化–&gt;初始化–&gt;服务-&gt;销毁<br>出生：（实例化–&gt;初始化）第一次访问Servlet就出生（默认情况下）<br>活着：（服务）应用活着，servlet就活着<br>死亡：（销毁）应用卸载了servlet就销毁。</p>
<pre><code>//默认第一次请求，创建Servlet实例，当应用存在那么实例就存在，应用卸载，相应的实例就销毁
public class ServletDemo implements Servlet{
    //生命周期的方法：实例化对象
    //第一次被访问时调用
    public ServletDemo(){
        System.out.println(&quot;ServletDemo被调用&quot;);
    }
    //生命周期的方法：初始化方法
    //第一次被访问时调用
    public void init(ServletConfig config) throws ServletException{
        System.out.println(&quot;init方法被调用&quot;);
    }
    //生命周期方法：服务方法
    //接受用户请求，并做出相应
    //每次请求都被调用
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;service方法被调用&quot;);
    }
    //生命周期的方法：销毁
    //当应用被卸载时调用
    public void destroy(){
        System.out.println(&quot;destroy被调用&quot;);
    }
}
</code></pre><p>小知识：<br>如何让servlet在服务器启动时就创建。</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servletDemo的实现类&lt;/servlet-class&gt;
    &lt;!--使得当前servlet在服务器启动时创建--&gt;
    &lt;load-on-startup&gt;2&lt;/load-no-startup&gt;
&lt;/sevlet&gt;
</code></pre><p>四、Servlet的三种创建方式<br>4.1、实现javax.servlet.Servlet接口（参见：编写一个servlet程序：）</p>
<p>4.2、继承javax.servet.GenericServlet类(适配器模式)</p>
<pre><code>public class ServletDemo extends GenericServlet{
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;servletDemo&quot;);
    }
}
</code></pre><p>4.3、继承javax.servlet.http.HttpServlet类（模板方法设计模式）<br>(开发中常用方式)</p>
<pre><code>//不要重写父类的service方法
public class ServletDemo extends HttpServlet{
    protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;servletDemo doGet方法被调用&quot;);
    }
    protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{

    }
}
</code></pre><p>Servlet –&gt; GenericServlet –&gt; HttpServlet  (继承HttpServlet)<br>曾祖父     爷爷        爸爸     孙子</p>
<p>小技巧：使生成的servlet更清新一些<br>找到：MyEclipse\Common\plugins目录<br>把com.genuitec.eclipse.wizards_9.0.0.me201108091322.jar复制到上面目录<br>servet映射细节：<br>servet映射细节1：</p>
<pre><code>&lt;!--配置多个映射路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo3&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>servet映射细节2: 通配符<em> 代表任意字符串<br>url-pattern: </em>.do  以<em>.字符串的请求都可以访问 注：不要加/<br>url-pattern: /</em>  任意字符串都可以访问<br>url-pattern： /action/* 以/action开头的请求都可以访问<br>匹配规则：<br>优先级：从高到低<br>绝对匹配–&gt;  /开头匹配 –&gt; 扩展名方式匹配</p>
<p>如果url-pattern的值是/，表示执行默认映射。所有资源都是servlet</p>
<p>五、Servlet的线程安全<br>单实例：每次访问多线程<br>解决线程安全问题的最佳办法，不要写全局变量，而写局部变量。</p>
<p>六、Servlet获取配置信息<br>ServletConfig的使用<br>作用1：可以获取servlet配置信息<br>方式1：</p>
<pre><code>private ServletConfig config;
//使用初始化方法回复到ServletConfig对象，此对象由服务器创建
public void init(ServletConfig config) throws ServletException{
    this.config = config;
}

public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{
    String value = config.getInitParameter(&quot;encoding&quot;);//根据配置文件中的名，得到值
    System.out.println(value);
}
</code></pre><p>方式2：</p>
<pre><code>//通过使用继承父类的方法得到ServletConfig对象
String value = this.getServletConfig().getInitParameter(&quot;encoding&quot;);
System.out.println(value);
</code></pre><p>方式3：</p>
<pre><code>String value = this.getInitParameter(&quot;encoding&quot;);
System.out.println(value);
</code></pre><p>作用2：可以获得ServletContext对象</p>
<p>七、ServletContext（重要）<br>ServletContext: 代表的是整个应用。一个应用只有一个ServletContext对象。单实例。<br>作用：<br>域对象：在一定范围内（当前应用），使多个Servlet共享数据。<br>常用方法：<br>void setAttribute(String name,object value);//向ServletContext对象的map中添加数据<br>Object getAttribute(String name);//从ServletContext对象的map中取数据<br>void rmoveAttribute(String name);//根据name去移除数据</p>
<p>获取全局配置信息：</p>
<p>修改web.xml文件：</p>
<pre><code>&lt;!--配置当前应用的全局信息--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>String getInitParameter(String name) //根据配置文件中的key得到value</p>
<pre><code>//获取全局配置信息
String encoding = sc.getInitParameter(&quot;encoding&quot;);
System.out.println(encoding);
</code></pre><p>获取资源路径：<br>String  getRealPath(String path);//根据资源名称得到资源的绝对路径.<br>可以得到当前应用任何位置的任何资源。</p>
<p>实现Servlet的转发。</p>
<p> RequestDispatcher  getRequestDispatcher(String path) ;//参数表示要跳转到哪去</p>
<hr>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h4 id="题目1-在Servlet中实现请求转发"><a href="#题目1-在Servlet中实现请求转发" class="headerlink" title="题目1 在Servlet中实现请求转发"></a>题目1 在Servlet中实现请求转发</h4><pre><code>1.index.jsp
&lt;form action=&quot;forward&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

   2.forwardServlet.java
   public class ForwardServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);//设置请求的字符编码格式
        String name = request.getParameter(&quot;name&quot;);    //获得请求表单中的用户名
        String pwd = request.getParameter(&quot;pwd&quot;);//获得请求表单的密码
        if ((name != null &amp;&amp; !name.equals(&quot;&quot;))&amp;&amp; (pwd != null &amp;&amp; !pwd.equals(&quot;&quot;))) {
            if (name.equals(&quot;zhaoyanliang&quot;) &amp;&amp; pwd.equals(&quot;123&quot;)) {
                request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request,response);    //使用RequestDispatcher对象将页面请求转发到success.jsp页
            } else {
                request.getRequestDispatcher(&quot;error.jsp&quot;).forward(request,response);
            }
        }else {

        }
    }
}

3.web.xml
&lt;servlet&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;cn.itcast.servlet.ForwardServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/forward&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><hr>
<h4 id="题目2-在Servlet中处理表单提交的数据"><a href="#题目2-在Servlet中处理表单提交的数据" class="headerlink" title="题目2 在Servlet中处理表单提交的数据"></a>题目2 在Servlet中处理表单提交的数据</h4><pre><code>1.index.jsp
&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;性别：&lt;/td&gt;
               &lt;td&gt;
                   &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; /&gt;男
                   &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女
               &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;年龄：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;Email：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;
                   &lt;input type=&quot;submit&quot; value=&quot;注 册&quot; /&gt;
                   &lt;input type=&quot;reset&quot; value=&quot;重 置&quot; /&gt;
               &lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.LoginServlet.java
public class LoginServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;GBK&quot;);            //设置请求的字符编码格式
        String name = request.getParameter(&quot;name&quot;);        //获得用户名
        String pwd = request.getParameter(&quot;pwd&quot;);        //获得密码
        String sex = request.getParameter(&quot;sex&quot;);        //获得性别
        String age = request.getParameter(&quot;age&quot;);        //获得年龄
        String email = request.getParameter(&quot;email&quot;);    //获得Email
        request.getRequestDispatcher(&quot;logininfo.jsp&quot;).forward(request, response);
    }
}

3.logininfo.jsp
&lt;table align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;用户名：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;name&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;密码：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;pwd&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;性别：&lt;/td&gt;
        &lt;td&gt;
            &lt;%=request.getParameter(&quot;sex&quot;)%&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;年龄：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;age&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Email：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;email&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
   &lt;/table&gt;
</code></pre><hr>
<h4 id="题目3-在Servlet中实现页面重定向"><a href="#题目3-在Servlet中实现页面重定向" class="headerlink" title="题目3 在Servlet中实现页面重定向"></a>题目3 在Servlet中实现页面重定向</h4><pre><code>1.index.jsp
&lt;form action=&quot;redirect&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.RedirectServlet.java
public class RedirectServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);        //设置请求数据的字符编码格式
        String name = request.getParameter(&quot;name&quot;); //获得请求表单中的用户名
        String pwd = request.getParameter(&quot;pwd&quot;);    //获得请求表单中的密码
        if((name!=null&amp;&amp;!name.equals(&quot;&quot;))&amp;&amp;(pwd!=null&amp;&amp;!pwd.equals(&quot;&quot;))){
            if(name.equals(&quot;mr&quot;)&amp;&amp;pwd.equals(&quot;123&quot;)){
                //使用SendRedirect()方法将页面重定向到success.jsp
                response.sendRedirect(&quot;success.jsp&quot;);
            }else{
                //使用SendRedirect()方法将页面重定向到error.jsp
                response.sendRedirect(&quot;error.jsp&quot;);
            }
        }
    }
}
</code></pre><hr>
<h4 id="题目4-动态生成HTML文档"><a href="#题目4-动态生成HTML文档" class="headerlink" title="题目4 动态生成HTML文档"></a>题目4 动态生成HTML文档</h4><pre><code>public class ServletHTML extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        //设置响应的字符集格式为UTF-8
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        //设置响应正文的MIME类型
        response.setContentType(&quot;text/html&quot;);
        //返回一个PrintWriter对象，Servlet使用它来输出字符串形式的正文数据
        PrintWriter out = response.getWriter();
        //以下为输出的HTML正文数据
        out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;&quot;);
        out.println(&quot;&lt;HTML&gt;&quot;);
        out.println(&quot;&lt;HEAD&gt;&lt;TITLE&gt;动态生成HTML文档&lt;/TITLE&gt;&quot;);
        out.println(&quot;&lt;link rel=;stylesheet&apos; type=&apos;text/css&apos; href=&apos;css/style.css&apos;&gt;&quot;);
        out.println(&quot;&lt;/HEAD&gt;&quot;);
        out.println(&quot;&lt;BODY&gt;&quot;);
        out.println(&quot;&lt;table border=&apos;1&apos; align=&apos;center&apos;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&lt;td&gt;动态生成HTMl文档&lt;/td&gt;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&lt;td&gt;表格&lt;/td&gt;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;/BODY&gt;&quot;);
        out.println(&quot;&lt;/HTML&gt;&quot;);
        out.flush();
        out.close();
    }

}
</code></pre><hr>
<h4 id="题目5-在Servlet中向客户端写Cookie信息"><a href="#题目5-在Servlet中向客户端写Cookie信息" class="headerlink" title="题目5 在Servlet中向客户端写Cookie信息"></a>题目5 在Servlet中向客户端写Cookie信息</h4><pre><code>1.index.jsp
&lt;form action=&quot;cookieservlet&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;
               &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
               &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.CookieServlet.java
public class CookieServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);
        String name = request.getParameter(&quot;name&quot;);            // 获取用户名
        //创建一个Cookie对象，并将用户名保存到Cookie对象中
        Cookie nameCookie = new Cookie(&quot;userName&quot;, name);
        //设置Cookie过期之前的时间，单位为秒
        nameCookie.setMaxAge(60);
        //通过response的addCookie()方法将此Cookie对象保存到客户端浏览器的Cookie中
        response.addCookie(nameCookie);
        request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request, response);
    }
}

3.在index.jsp中读取所有客户端的Cookie，通过循环Cookie数组找到保存用户名的Cookie
&lt;%
      String userName=null;//用于保存从cookie中读取出的用户名
      Cookie cookieArr[] = request.getCookies();//获取客户端的所有Cookie
      if(cookieArr!=null&amp;&amp;cookieArr.length&gt;0){
          for(Cookie c:cookieArr){
              if(c.getName().equals(&quot;userName&quot;)){ //如果Cookie中有一个名为
                                                           userName的Cookie
                  userName =c.getValue();            //获得此cookie的值 
              }
          }
      }
%&gt;   

4.将获取到的用户名Cookie的值赋值给用户名文本框
&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&lt;%if(userName!=null){out.print(userName);}%&gt;&quot;/&gt;
</code></pre><blockquote>
<p>注意：在创建Cookie对象时，由于不可以直接将中文字符作为Cookie的值，因此在将中文字符保存到Cookie对象之前，应该使用java.net.URLEncoder类的encode()方法对中文字符进行编码。在获取该Cookie对象中的值时，需要使用java.net.URLDecoder类的decode()方法对已经编码过的字符进行解码，还原字符串的初始值。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲</title>
    <url>/undefined/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2%20%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗"><a href="#谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗" class="headerlink" title="谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?"></a>谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?</h4><ul>
<li>一次编译、到处运行”说的是Java语言跨平台的特性,Java的跨平台特性与Java虚拟机的存在密不可分,可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK,安装 好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异,并不是说Java语言可以跨平台,而是在不同的平台都有可以让Java语言运行的环境而已,所以 才有了Java一次编译,到处运行这样的效果。</li>
<li>程序从源代码到运行的三个阶段:编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的:首先是将Java源代码转化成.CLASS文件字节码,这是第 一次编译。.class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码,这是是由JVM来执行的,即Java的第二次编译。</li>
<li>Java是解析运行吗? 不正确! Java源代码经过Javac编译成.class文件 .class文件经JVM解析或编译运行。</li>
</ul>
<h4 id="Exception和Error有什么区别"><a href="#Exception和Error有什么区别" class="headerlink" title="Exception和Error有什么区别?"></a>Exception和Error有什么区别?</h4><ul>
<li><code>Exception</code>和<code>Error</code>都是继承了<code>Throwable</code>类,在Java中只有<code>Throwable</code>类型的实例才可以被抛出(throw)或者捕获(catch),它是异常处理机制的基本组成类型。</li>
<li><code>Exception</code>是程序正常运行中,可以预料的意外情况,可能并且应该被捕获,进行相应处理。</li>
<li><code>Error</code>是指在正常情况下,不大可能出现的情况,绝大部分的Error都会导致程序(比如JVM自身)处于非正常的、不可恢复状态。既然是非正常情况,所以不便于也不需要捕获,常 见的比如<code>OutOfMemoryError</code>之类,都是<code>Error</code>的子类。</li>
<li><code>Exception</code>又分为<code>可检查(checked)</code>异常和<code>不检查(unchecked)</code>异常,可检查异常在源代码里必须显式地进行捕获处理,这是编译期检查的一部分</li>
<li>不检查异常就是所谓的运行时异常,类似 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>之类,通常是可以编码避免的逻辑错误,具体根据需要来判断是否需要捕 获,并不会在编译期强制要求。<br><img src="https://img-blog.csdnimg.cn/20190406111450760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""><blockquote>
<p><code>异常处理的基本原则</code>:<br>尽量不要捕获类似Exception这样的通用异常,而是应该捕获特定异常<br>不要生吞(swallow)异常。这是异常处理中要特别注意的事情,因为很可能会导致非常难以诊断的诡异情况。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="谈谈final、finally、-finalize有什么不同？"><a href="#谈谈final、finally、-finalize有什么不同？" class="headerlink" title="谈谈final、finally、 finalize有什么不同？"></a>谈谈final、finally、 finalize有什么不同？</h4><ul>
<li><p><code>final</code>可以用来修饰类、方法、变量,分别有不同的意义,<code>final</code>修饰的<code>class</code>代表不可以继承扩展,fnal的变量是不可以修改的,而fnal的方法也是不可以重写的(override)。</p>
</li>
<li><p><code>finally</code>则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</p>
</li>
<li><p><code>finalize</code>是基础类java.lang.Object的一个方法,它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。fnalize机制现在已经不推荐使用,并且在JDK 9开始被标记 为deprecated。</p>
</li>
</ul>
<blockquote>
<p>提示：final变量产生了某种程度的不可变效果，所以可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可<br>以省去一些防御性拷贝的必要。</p>
</blockquote>
<hr>
<h4 id="强引用、软引用、弱引用、幻象引用有什么区别"><a href="#强引用、软引用、弱引用、幻象引用有什么区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别?"></a>强引用、软引用、弱引用、幻象引用有什么区别?</h4><ul>
<li><code>强引用</code>:我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足,JVM宁愿抛出OutOfMemoryError运 行时错误(OOM),使程序异常终止,也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象,如果没有其他的引用关系,只要超过了引用的作用域或者显式 地将相应(强)引用赋值为 null,就是可以被垃圾收集的了,具体回收时机还是要看垃圾收集策略。</li>
</ul>
<ul>
<li><code>软引用</code>:软引用通过<code>SoftReference</code>类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时,才会去试图回收软引用指向的对象:即JVM 会确保在抛出 OutOfMemoryError 之前,清理软引用指向的对象。软引用可以和一个引用队列(ReferenceQueue)联合使用,如果软引用所引用的对象被垃圾回收器回收,Java虚拟机就会把这个软引用加入到与之关联的引用 队列中。后续,我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空,将返回一个null,否则该方法返回队列中前面的一个Reference对象</li>
</ul>
<ul>
<li><code>弱引用</code> 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中,一旦发现了具有弱引用的对象,不管当前内存空间足够与否,都会 回收它的内存。由于垃圾回收器是一个优先级很低的线程,因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列(ReferenceQueue)联合使用,如果弱引用所引用的对象被垃圾 回收,Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。弱应用同样可用于内存敏感的缓存。</li>
</ul>
<ul>
<li><code>幻象引用</code>,有时候也翻译成虚引用,你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被fnalize以后,做某些事情的机制。如果 一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 (ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时,如 果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中。</li>
</ul>
<hr>
<h4 id="String、StringBufer、StringBuilder有什么区别"><a href="#String、StringBufer、StringBuilder有什么区别" class="headerlink" title="String、StringBufer、StringBuilder有什么区别?"></a>String、StringBufer、StringBuilder有什么区别?</h4><ul>
<li><p><code>String</code>被声明成为fnal class,所有属性也都是fnal的。也由于它的不可 变性,类似拼接、裁剪字符串等动作,都会产生新的String对象。Java为了避免在一个系统中产生大量的String对象,引入了字符串常量池，创建一个字符串时,首先检查池中是否有值相同的字符串对 象,如果有则不需要创建直接从池中刚查找到的对象引用;如果没有则新建字符串对象,返回对象引用,并且将新创建的对象放入池中。但是,通过new方法创建的String对象是不检查字符串 池的,而是直接在堆区或栈区创建一个新的对象,也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。<code>String</code>提供了<code>inter</code>()方法。调用该方法时,如果常量池中包括了一个等于此String对象的字符串(<code>由equals方法确定</code>),则返回池中的字符串。否则,将此String对象添加到池中,并且 返回此池中对象的引用</p>
</li>
<li><p><code>StringBufer和StringBuilder</code>都实现了<code>AbstractStringBuilder</code>抽象类,拥有几乎一致对外提供的调用接口;其底层在内存中的存储方式与String相同,都是以一个有序的字符序列(char类型 的数组)进行存储,不同点是<code>StringBufer/StringBuilder</code>对象的<code>值是可以改变</code>的,并且值改变以后,对象引用不会发生改变;两者对象在构造过程中,首先按照默认大小申请一个字符数组,由 于会不断加入新数据,<code>当超过默认大小后</code>,会创建一个更大的数组,并将原先的数组内容复制过来,再丢弃旧的数组。因此,对于较大对象的扩容会涉及大量的内存复制操作,如果能够预先评估大小,可提升性能。</p>
</li>
<li><p>唯一需要注意的是:<code>StringBufer是线程安全</code>的,但是<code>StringBuilder</code>是<code>线程不安全</code>的。可参看Java标准类库的源代码,<code>StringBufer</code>类中方法定义前面都会有<code>synchronize</code>关键字。为 此,StringBufer的性能要远低于StringBuilder。</p>
</li>
</ul>
<h4 id="谈谈Java反射机制-动态代理是基于什么原理"><a href="#谈谈Java反射机制-动态代理是基于什么原理" class="headerlink" title="谈谈Java反射机制,动态代理是基于什么原理"></a>谈谈Java反射机制,动态代理是基于什么原理</h4><ul>
<li><p><code>反射机制</code>是Java语言提供的一种基础功能,赋予程序在运行时自省(introspect,官方用语)的能力。通过反射我们可以直接操作类或者对象,比如获取某个对象的类定义,获取类 声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。</p>
</li>
<li><p><code>动态代理</code>是一种方便运行时动态构建代理、动态处理代理方法调用的机制,很多场景都是利用类似机制做到的,比如用来包装RPC调用、面向切面的编程(AOP)。</p>
</li>
<li><p><code>JDK</code>动态代理:基于Java反射机制实现,必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。</p>
</li>
<li><p><code>cglib</code>动态代理:基于ASM机制实现,通过生成业务类的子类作为代理类。</p>
</li>
</ul>
<hr>
<h4 id="int和Integer有什么区别-谈谈Integer的值缓存范围。"><a href="#int和Integer有什么区别-谈谈Integer的值缓存范围。" class="headerlink" title="int和Integer有什么区别?谈谈Integer的值缓存范围。"></a>int和Integer有什么区别?谈谈Integer的值缓存范围。</h4><ul>
<li><p><code>int</code>是我们常说的整形数字,是Java的8个原始数据类型(Primitive Types,boolean、byte 、short、char、int、foat、double、long)之一。Java语言虽然号称一切都是对象, 但原始数据类型是例外。</p>
</li>
<li><p><code>Integer</code>是int对应的包装类,它有一个int类型的字段存储数据,并且提供了基本操作,比如数学运算、int和字符串之间转换等。在Java 5中,引入了自动装箱和自动拆箱功能 (boxing/unboxing),Java可以根据上下文,自动进行转换,极大地简化了相关编程。</p>
</li>
<li><p>Integer的值默认缓存 是-128到127之间。缓存上限值实际是可以根据需要调整的,JVM提供了参数设置: <code>-XX:AutoBoxCacheMax=N</code>。</p>
</li>
<li><p>不管是Integer还Boolean等,都被声明为“private fnal”,所以,它们同样是不可变类型!</p>
</li>
</ul>
<hr>
<h4 id="对比Vector、ArrayList、LinkedList有何区别"><a href="#对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="对比Vector、ArrayList、LinkedList有何区别?"></a>对比Vector、ArrayList、LinkedList有何区别?</h4><p>三者都实现集合框架中的List，所谓的有序集合。</p>
<ul>
<li><p><code>Vector</code>是线程安全的动态数组,。<code>Vector</code>内部是使用对象数组来保存数据,可以根据需要自动增加 容量,当数组已满时,会创建新的数组,并拷贝原有数组数据。Vector在扩容时会<code>提高1倍</code>。</p>
</li>
<li><p><code>ArrayList</code>是动态数组实现,不是线程安全的,性能要好很多。与Vector近似,ArrayList也是可以根据需要调整容量,不过两者的调整逻辑有所区 别。ArrayList扩容时是增加50%。</p>
</li>
<li><p><code>Vector和ArrayList作为动态数组</code>,其内部元素以数组形式顺序存储的,所以非常适合随机访问的场合。除了尾部插入和删除元素,往往性能会相对较差,比如我们在中间位置插 入一个元素,需要移动后续所有元素。</p>
</li>
<li><p><code>LinkedList</code>是Java提供的双向链表,它不需要像上面两种那样调整容量,也不是线程安全的。LinkedList进行节点插入、删除却要高效得多,但是随机访问性能则要比动态数组慢。</p>
</li>
</ul>
<blockquote>
<p>提示：在实际开发过程中，可以预先估计应用操作偏向于插入、删除，还是随机访问的多，可以进行针对性的选择。</p>
</blockquote>
<p>扩展：</p>
<blockquote>
<p><code>TreeSet</code> 支持自然顺序访问,但是添加、删除、包含等操作要相对低效(log(n)时间)。</p>
</blockquote>
<blockquote>
<p><code>HashSet</code>则是利用哈希算法,理想情况下,如果哈希散列正常,可以提供常数时间的添加、删除、包含等操作,但是它不保证有序。</p>
</blockquote>
<blockquote>
<p><code>LinkedHashSet</code>,内部构建了一个记录插入顺序的双向链表,因此提供了按照插入顺序遍历的能力,与此同时,也保证了常数时间的添加、删除、包含等操作,这些操作性能略 低于HashSet,因为需要维护链表的开销。</p>
</blockquote>
<blockquote>
<p>在遍历元素时,<code>HashSet</code>性能受自身容量影响,所以初始化时,除非有必要,不然不要将其背后的HashMap容量设置过大。而对于LinkedHashSet,由于其内部链表提供的方便,遍历性能只和元素多少有关系。</p>
</blockquote>
<blockquote>
<p><code>Java提供的默认排序算法</code>:<br>对于原始数据类型,目前使用的是所谓双轴快速排序,是一种改进的快速排序算法,早期版本是相对传统的快速排序<br>对于对象数据类型,目前则是使用TimSort,思想上也是一种归并和二分插入排序结合的优化排序算法</p>
</blockquote>
<hr>
<h4 id="对比Hashtable、HashMap、TreeMap-有什么不同"><a href="#对比Hashtable、HashMap、TreeMap-有什么不同" class="headerlink" title="对比Hashtable、HashMap、TreeMap 有什么不同?"></a>对比Hashtable、HashMap、TreeMap 有什么不同?</h4><ul>
<li><p><code>元素特性</code>：Hashtable 中的key、value都不能为null;HashMap中的key、value可以为null,很显然只能有一个key为null的键值对,但是允许有多个值为null的键值对;TreeMap是基于红黑树的一种提供顺序访问的Map,和HashMap不一样，它的get、put、<br>remove 之类操作都是 O（log(n)）的时间复杂度，TreeMap中当未实现 Comparator 接口时,key 不可以为null;当实现 Comparator 接口时,若未对null情况进行判断,则key不可以为null,反之亦然。</p>
</li>
<li><p><code>顺序特性</code>：HashTable 、HashMap具有无序特性。TreeMap 是利用红黑树来实现的(树中的每个节点的值,都会大于或等于它的左子树中的所有节点的值,并且小于或等于它的右子树中的所有节点的 值),实现了SortMap接口,能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap 来进行,默认为升序排序方式(深度优先搜索),可自定义实现Comparator接口 实现排序方式。</p>
</li>
<li><p><code>初始化与增长方式</code>：初始化时:Hashtable 在不指定容量的情况下的默认容量为11,且不要求底层数组的容量一定要为2的整数次幂;HashMap默认容量为16,且要求容量一定为2的整数次幂。 扩容时:Hashtable将容量变为原来的2倍加1;HashMap扩容将容量变为原来的2倍。</p>
</li>
<li><p><code>HashMap</code>基于哈希思想,实现对数据的读写。当我们将键值对传递给<code>put()</code>方法时,它调用<code>键对象的hashCode()</code>方法来计算<code>hashcode</code>,然后找到<code>bucket</code>位置来储存值对象。当获取对象时, 通过键对象的<code>equals()方法找到正确的键值对,然后返回值对象</code>。HashMap使用<code>链表来解决碰撞问题</code>,当发生碰撞了,对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时,它们会储存在同一个bucket位置的链表中,可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值 (TREEIFY_THRESHOLD, 8),链表就会被改造为树形结构(红黑树)。</p>
</li>
</ul>
<blockquote>
<p>提示：hashcode和equals的一些基本约定：1.equals相等，hashcode一定要相等。2.重写了hashCode也要重写equals。3.hashCode需要保持一致性，状态改变返回的哈希值仍然要一致。4.equals的对称、反射、传递等特性。</p>
</blockquote>
<blockquote>
<p>解决哈希冲突有哪些典型方法呢?<br><code>开放定址法</code>：当关键字key的哈希地址p=H(key)出现冲突时,以p为基础,产生另一个哈希地址p1,如果p1仍然冲突,再以p为基础,产生另一个哈希地址p2,…,直到找出一个不冲突的哈 希地址pi ,将相应元素存入其中。<br><code>再哈希法</code>：当哈希地址Hi=RH1(key)发生冲突时,再计算Hi=RH2(key)……,直到冲突不再产生。这种方法不易产生聚集,但增加了计算时间。<br><code>链地址法</code>：这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表,并将单链表的头指针存在哈希表的第i个单元中,因而查找、插入和删除主要在同义词链中进行。链地址法适用 于经常进行插入和删除的情况。</p>
</blockquote>
<hr>
<h4 id="如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？"><a href="#如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？" class="headerlink" title="如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？"></a>如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？</h4><p><strong>1.为什么需要 ConcurrentHashMap？</strong><br></p>
<p>Hashtable本身比较低效，因为其基本实现基本就是将 put、get、size等各种方法加上“synchronized”。简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。Hashtable或者同步包装版本都只是适合在非高度并发的场景下。</p>
<p><strong>2.ConcurrentHashMap分析</strong><br></p>
<p>早期 ConcurrentHashMap 其实现是基于：</p>
<pre><code>1.分离锁，即将内部进行分段，里面则是HashEntry的数组，和HashMap类似，哈希相同的条目也是以链表的形式存放。

2.HashEntry内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。
</code></pre><blockquote>
<p>注意：在进行并发操作的时候，核心利用分段设计，只需要锁定相应段就能够有效的避免类似 Hashtable 整体同步问题，提高性能。</p>
</blockquote>
<p>在进行并发写操作时：</p>
<pre><code>1.
</code></pre><hr>
<h4 id="Java有几种文件拷贝方式？哪一种最高效？"><a href="#Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="Java有几种文件拷贝方式？哪一种最高效？"></a>Java有几种文件拷贝方式？哪一种最高效？</h4><p>Java有多种比较典型的文件拷贝实现方式：</p>
<pre><code>1.利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作。

    public static void copyFileByStream(File source, File dest) throws IOException {
        try(InputStream is = new FileInputStream(source);
            OutputStream os = new FileOutputStream(dest);){

            byte[] buffer = new byte[1024];
            int length;
            while((length = is.read(buffer)) &gt; 0){
                os.write(buffer, o, length);
            }

        }
    }

2.利用java.nio类库提供的transferTo或者transferFrom方法实现

    public static void copyFileByChannel(File source, File dest) throws IOException {
        try (FileChannel sourceChannel = new FileInputStream(source).getChannel();
            FileChannel targetChannel = new FileOutputStream(dest).getChannel();){
                for (long count = sourceChannel.size() ;count&gt;0 ;) {
                    long transferred = sourceChannel.transferTo(sourceChannel.position(), count, targetChannel); 
                    sourceChcount -= transferred;
                }
            }
        }
</code></pre><blockquote>
<p>提示：Java标准类库也提供了几种Files.copy()的实现。对应Copy的效率，其实与操作系统和配置等情况有关，总体来说，NIO transferTo/From的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
</blockquote>
<p><strong>1.拷贝实现机制分析</strong><br></p>
<p>首先我们应该清楚用户态空间和内核态空间，这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权，用户态空间则是给普通应用和服务使用。</p>
<p>1.当使用输入输出流进行读写过程时，在实际上进行了多次的上下文切换。如：应用读取数据时，现在内核态将数据从磁盘读取到内核缓存，在切换到用户态将数据从内核缓存读取到用户缓存。（写入步骤相反）。所以这种方式会带来一定的额外开销，可能会降低IO效率。</p>
<p>2.基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。</p>
<blockquote>
<p>注意：transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。</p>
</blockquote>
<p><strong>2.Java IO/NIO源码结构</strong><br></p>
<p>Java标准库提供了文件拷贝方法（java.nio.file.Files.copy）。</p>
<pre><code>public static Path copy(Path source, Path target, CopyOption... options) throws IOException

public static long copy(InputStream in, Path target, CopyOption... options) throws IOException

public static long copy(Path source, OutputStream out) throws IOException
</code></pre><p>这里我们可以看出，copy不仅支持文件之间的操作。</p>
<p><strong>3.NIO Buffer</strong><br></p>
<p>Buffer是NIO操作数据的基本工具，Java为每种原始数据类型都提供了相应的Buffer实现。特别注意Direct Buffer等使用，因为其在垃圾收集方面的特殊性。</p>
<pre><code>Buffer的基本属性：

    1.capcity buffer的大小，即数组的长度
    2.postion 操作的数据的起始位置
    3.limit 操作的限额
    4.mark 记录上一次postion的位置，默认是0

Buffer的基本操作：

    1.我们创建了一个 ByteBuffer，准备放入数据，capcity 当然就是缓冲区大小，而 position 就是 0，limit 默认就是 capcity 的大小。
    2.当我们写入几个字节的数据时，position 就会跟着水涨船高，但是它不可能超过 limit 的大小。
    3.如果我们想把前面写入的数据读出来，需要调用 flip 方法，将 position 设置为 0，limit 设置为以前的 position 那里。

    ...
</code></pre><p><strong>4.Direct Buffer 和垃圾收集</strong><br></p>
<p><strong>5.跟踪和诊断 Direct Buffer 内存占用？</strong></p>
<hr>
<h4 id="Java提供了哪些IO方式-NIO如何实现多路复用"><a href="#Java提供了哪些IO方式-NIO如何实现多路复用" class="headerlink" title="Java提供了哪些IO方式? NIO如何实现多路复用?"></a>Java提供了哪些IO方式? NIO如何实现多路复用?</h4><ul>
<li><p><code>传统的java.io包,它基于流模型实现</code>,提供了我们最熟知的一些IO功能,比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。</p>
</li>
<li><p>很多时候,人们也把java.net下面提供的部分网络API,比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库,因为网络通信同样是IO行为。</p>
</li>
<li><p><code>在Java 1.4中引入了NIO框架(java.nio包)</code>,提供了Channel、Selector、Bufer等新的抽象,可以构建多路复用的、<code>同步非阻塞IO程序</code>,同时提供了更接近操作系统底层 的高性能数据操作方式。</p>
</li>
<li><p><code>在Java 7中,NIO有了进一步的改进,也就是NIO 2</code>,引入了异<code>步非阻塞IO方式</code>,也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制,可以简单 理解为,应用操作直接返回,而不会阻塞在那里,当后台处理完成,操作系统会通知相应线程进行后续工作。</p>
</li>
</ul>
<blockquote>
<p><code>NIO多路复用的局限性是什么呢?</code><br>由于nio实际上是<code>同步非阻塞io</code>,是一个线程在同步的进行事件处理,当一组事channel处理完毕以后,去检查有没有又可以处理的channel。这也就是同步+非阻塞。同步,指每个准备好 的channel处理是依次进行的,非阻塞,是指线程不会傻傻的等待读。只有当channel准备好后,才会进行。那么就会有这样一个问题,当每个channel所进行的都是耗时操作时,由于是同步操 作,就会积压很多channel任务,从而完成影响。那么就需要对nio进行类似负载均衡的操作,如用线程池去进行管理读写,将channel分给其他的线程去执行,这样既充分利用了每一个线程,又不至于都堆积在一个线程中,等待执行</p>
</blockquote>
<h4 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h4><ul>
<li><p><code>接口</code>是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员,同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。 Java标准类库中，定义了非常多的接口，比如java.util.List。</p>
</li>
<li><p><code>抽象类</code>是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可<br>以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。 Java标准库中，比如collection框架，很多通用<br>部分就被抽取成为抽象类，例如java.util.AbstractList。</p>
</li>
</ul>
<blockquote>
<p>进行面向对象编程，掌握基本的设计原则是必须的，最通用的部分，也就是所谓的<code>S.O.L.I.D</code>原则。</p>
</blockquote>
<blockquote>
<p><code>单一职责</code>类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>开关原则</code>设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>里氏替换</code>这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>接口分离</code>我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>依赖反转</code>实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝</p>
</blockquote>
<hr>
<h4 id="谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？"><a href="#谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？" class="headerlink" title="谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？"></a>谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？</h4><ul>
<li><p>设计模式可以分为创建型模式、结构型模式和行为型模式。</p>
</li>
<li><p><code>创建型模式</code>，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、 Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</p>
</li>
<li><p><code>结构型模式</code>，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</p>
</li>
<li><p><code>行为型模式</code>，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</p>
</li>
</ul>
<blockquote>
<ul>
<li><code>InputStream</code>是一个抽象类，标准类库中提供了FileInputStream、 ByteArrayInputStream等各种不同的子类，分别从不同角度对InputStream进行了功能扩展，这是典型的装饰器模式应用案例。识别装饰器模式，可以通过识别类设计特征来进行判断，也就是其类构造函数以相同的抽象类或者接口为输入参数</li>
</ul>
</blockquote>
<blockquote>
<p><code>创建型模式</code>尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的API设计实践。比如， JDK最新版本中 HTTP/2 Client API，下面这个创建HttpRequest的过程，就是典型的构建器模式（Builder），通常会被实现成fuent风格的API，也有人叫它方法链。使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</p>
</blockquote>
<blockquote>
<p><code>Spring等如何在API设计中使用设计模式</code></p>
</blockquote>
<blockquote>
<p>BeanFactory和ApplicationContext应用了工厂模式</p>
</blockquote>
<blockquote>
<p>在Bean的创建中， Spring也为不同scope定义的对象，提供了单例和原型等模式实现。</p>
</blockquote>
<blockquote>
<p>AOP领域则是使用了代理模式、装饰器模式、适配器模式等。</p>
</blockquote>
<blockquote>
<p>各种事件监听器，是观察者模式的典型应用。</p>
</blockquote>
<blockquote>
<p>类似JdbcTemplate等则是应用了模板模式。</p>
</blockquote>
<hr>
<h4 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h4><ul>
<li><p><code>synchronized</code>是Java内建的同步机制,它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>
</li>
<li><p><code>ReentrantLock</code>，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时， ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</p>
</li>
</ul>
<h4 id="synchronized底层如何实现？什么是锁的升级、降级？"><a href="#synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="synchronized底层如何实现？什么是锁的升级、降级？"></a>synchronized底层如何实现？什么是锁的升级、降级？</h4><ul>
<li><p><code>synchronized</code>代码块是由一对儿<code>monitorenter/monitorexit</code>指令实现的， Monitor对象是同步的基本实现单元。在Java 6之前， Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle） JDK中， JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
</li>
<li><p>所谓锁的升级、降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>
</li>
<li><p>当没有竞争出现时，<code>默认会使用偏斜锁</code>。 <code>JVM</code>会利用<code>CAS</code>操作，在对象头上的<code>Mark Word</code>部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
</li>
<li><p>如果有另外的线程试图锁定某个已经被偏斜过的对象， JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
</li>
</ul>
<blockquote>
<p><code>你知道“自旋锁”是做什么的吗？它的使用场景是什么？</code><br><code>自旋锁</code>:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br><code>适用场景</code>:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费<br><code>在单核CPU上，自旋锁是无用</code>，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行，<br>同时由于其他线程无法运行，所以当前线程无法释放锁。</p>
</blockquote>
<h4 id="一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。"><a href="#一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。"></a>一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。</h4><ul>
<li>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</li>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。 Thread.join()也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本</li>
</ul>
<h4 id="什么情况下Java程序会产生死锁-如何定位、修复"><a href="#什么情况下Java程序会产生死锁-如何定位、修复" class="headerlink" title="什么情况下Java程序会产生死锁?如何定位、修复?"></a>什么情况下Java程序会产生死锁?如何定位、修复?</h4><ul>
<li><code>死锁</code>是一种特定的程序状态,在实体之间,由于<code>循环依赖导致</code>彼此一直处于等待之中,没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生,存在资源独占的进程之间同样也可能出现死锁。通常来说,我们大多是聚焦在多线程场景中的死锁,指两个或多个线程之间,由于互<code>相持有对方需要的锁</code>,而永久处于阻塞的状态。<br><img src="https://img-blog.csdnimg.cn/20190408224832820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></li>
<li><code>定位死锁</code>最常见的方式就是利用<code>jstack</code>等工具<code>获取线程栈</code>,然后定位互相之间的依赖关系,进而找到死锁。如果是比较明显的死锁,往往jstack等就能直接定位,类似JConsole甚至 可以在图形界面进行有限的死锁检测。</li>
<li>使用Java提供的标准管理API,ThreadMXBean,其直接就提供 fndDeadlockedThreads﻿()方法用于定位死锁。但是要注意的是,对线程进行快照本身是一个相对重量级的操作,还是要慎重选择频度和时机。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMXBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line"></span><br><span class="line">        Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">                <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                    System.out.println(<span class="string">"Detected deadlock threads:"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                        System.out.println(threadInfo.getThreadName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService scheduler =Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 稍等5秒,然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        Test1  t=<span class="keyword">new</span> Test1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">        Object obj1=<span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":    obj1--------"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   obj2--------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"    t2  obj2--------"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   t2  obj1--------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如<code>何在编程中尽量预防死锁呢?</code><br>尽量避免使用多个锁,并且只有需要时才持有锁<br>如果必须使用多个锁,尽量设计好锁的获取顺序<br>使用带超时的方法,为程序带来更多可控性。<br><code>有时候并不是阻塞导致的死锁,只是某个线程进入了死循环,导致其他线程一直等待,这种问题如何诊断呢?</code><br>可以通过linux下top命令查看cpu使用率较高的java进程,进而用<code>top -Hp pid</code>查看该java进程下cpu使用率较高的线程。再用jstack命令查看线程具体调用情况,排查问题</p>
</blockquote>
<h4 id="Java并发包提供了哪些并发工具类？"><a href="#Java并发包提供了哪些并发工具类？" class="headerlink" title="Java并发包提供了哪些并发工具类？"></a>Java并发包提供了哪些并发工具类？</h4><ul>
<li>提供了比synchronized更加高级的各种同步结构，包括<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、 <code>Semaphore</code>等。CountDownLatch，允许一个或多个线程等待某些操作完成。CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。Semaphore， Java版本的信号量实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。</li>
<li>各种<code>线程安全的容器</code>，比如最常见的<code>ConcurrentHashMap</code>、有序的<code>ConcunrrentSkipListMap</code>，或者通过类似快照机制，实现线程安全的动态数组<code>CopyOnWriteArrayList</code>等。</li>
<li>各种<code>并发队列</code>实现，如各种<code>BlockedQueue</code>实现，比较典型的<code>ArrayBlockingQueue</code>、 <code>SynchorousQueue</code>或针对特定场景的<code>PriorityBlockingQueue</code>等。</li>
<li>强大的<code>Executor</code>框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<blockquote>
<p><code>你使用过类似CountDownLatch的同步结构解决实际问题吗？</code><br>一个页面有A,B,C三个网络请求，其中请求C需要请求A和请求B的返回数据作为参数，用过CountdownLatch解决。<br>需求是每个对象一个线程，分别在每个线程里计算各自的数据，最终等到所有线程计算完毕，我还需要将每个有共通的对象进行合并，所以用它很合适。</p>
</blockquote>
<h4 id="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h4><p><img src="https://img-blog.csdnimg.cn/20190409124720516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="线程安全队列一览"></p>
<ul>
<li><code>Concurrent</code>类型基于<code>lock-free</code>，在常见的多线程访问场景，一般可以提供较高吞吐量。而<code>LinkedBlockingQueue</code>内部则是<code>基于锁</code>，并提供了<code>BlockingQueue</code>的等待性方法。</li>
<li><code>ArrayBlockingQueue</code>是最典型的的有界队列，其内部以<code>fnal</code>的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建ArrayBlockingQueue时，都要指定容量</li>
<li><code>LinkedBlockingQueue</code>，容易被<code>误解为无边界</code>，但其实其行为和内部代码都是<code>基于有界的逻辑实现</code>的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为<code>Integer.MAX_VALUE</code>，成为了无界队列。</li>
<li><code>SynchronousQueue</code>，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。其内<code>部容量是0</code></li>
<li><code>PriorityBlockingQueue</code>是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响</li>
<li><code>DelayedQueue</code>和<code>LinkedTransferQueue</code>同样是<code>无边界的队列</code>。对于无边界的队列，有一个自然的结果，就是put操作永远也不会发生其他<code>BlockingQueue</code>的那种等待情况。</li>
</ul>
<blockquote>
<p><code>在日常的应用开发中，如何进行选择呢？</code><br>考虑应用场景中<code>对队列边界的要求</code>。 ArrayBlockingQueue是有明确的容量限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定， SynchronousQueue则干脆不能缓存任何元素。<br><code>从空间利用角度</code>，数组结构的ArrayBlockingQueue要比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。<br><code>通用场景中</code>， LinkedBlockingQueue的吞吐量一般优于ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。<br>ArrayBlockingQueue实现比较简单，性能更好预测，属于表现稳定的“选手”。<br>如果我们需要实现的是两个线程之间接力性（handof）的场景，你可能会选择CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</p>
</blockquote>
<h4 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h4><p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li><code>newCachedThreadPool()</code>，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用<code>SynchronousQueue</code>作为工作队列。</li>
<li><code>newFixedThreadPool(int nThreads)</code>，重用<code>指定数目</code>（nThreads）的线程，其背后使用的是<code>无界的工作队列</code>，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
<li><code>newSingleThreadExecutor()</code>，它的特点在于<code>工作线程数目被限制为1</code>，操作一个<code>无界的工作队列</code>，所以它保证了所有任务的都是被<code>顺序执行</code>，最多会有<code>一个任务处于活动状态</code>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li><code>newSingleThreadScheduledExecutor()</code>和<code>newScheduledThreadPool(int corePoolSize)</code>，创建的是<code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程</li>
<li><code>newWorkStealingPool(int parallelism)</code>，这是一个经常被人忽略的线程池， <code>Java 8才加入这个创建方法</code>，其内部会构建<code>ForkJoinPool</code>，利用<code>Work-Stealing算法</code>，并行地处理任务，不保证处理顺序。</li>
</ul>
<blockquote>
<p><code>ThreadPoolExecutor参数详解</code><br>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目。于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool会将其设置为nThreads，而对于newCachedThreadPool则是为0。<br>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数<br>keepAliveTime和TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。<br>workQueue，工作队列，必须是BlockingQueue。<br><code>线程池大小的选择策略：</code><br>如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源。如果线程太多，反倒可能导致大量<br>的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。<br>如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：<code>线程数 = CPU核数 × （1 + 平均等待时间/平均工作时间）</code></p>
</blockquote>
<hr>
<h3 id="深入理解Java虚拟机问题"><a href="#深入理解Java虚拟机问题" class="headerlink" title="深入理解Java虚拟机问题"></a>深入理解Java虚拟机问题</h3><h4 id="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h4><ul>
<li><p><code>AtomicIntger</code>是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于<code>CAS（compare-and-swap）</code>技术。</p>
</li>
<li><p>所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p>
</li>
<li><p>于CAS的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区。</p>
</li>
</ul>
<hr>
<h4 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h4><ul>
<li><p>一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里有非常详细的定义。</p>
</li>
<li><p><code>首先是加载阶段</code>（Loading），它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、 class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
</li>
<li><p><code>第二阶段是链接</code>（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入JVM运行的过程中。这里可进一步细分为三个步骤：</p>
</li>
</ul>
<blockquote>
<p><code>验证</code>: 这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息害JVM的运行，验证阶段有可能触发更多class的加载。</p>
</blockquote>
<blockquote>
<p><code>准备</code>，创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令</p>
</blockquote>
<blockquote>
<p><code>解析</code>，在这一步会将常量池中的<code>符号引用</code>替换为<code>直接引用</code>。在Java虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
</blockquote>
<ul>
<li><p><code>最后是初始化阶段</code>（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
</li>
<li><p>再来谈谈<code>双亲委派模型</code>，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。<br><img src="https://img-blog.csdnimg.cn/20190409151248407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="双亲委派模型"></p>
</li>
</ul>
<hr>
<h4 id="有哪些方法可以在运行时动态生成一个Java类？"><a href="#有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类？"></a>有哪些方法可以在运行时动态生成一个Java类？</h4><ul>
<li><p>我们可以从常见的Java类来源分析，通常的开发过程是，开发者编写Java代码，调用javac编译成class文件，然后通过类加载机制载入JVM，就成为应用运行时可以使用的Java类了。</p>
</li>
<li><p>有一种笨办法，直接用ProcessBuilder之类启动javac进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
</li>
<li><p>你可以考虑使用Java Compiler API，这是JDK提供的标准API，里面提供了与javac对等的编译器功能，具体请参考java.compiler相关文档。</p>
</li>
</ul>
<hr>
<h4 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？</h4><ul>
<li>通常可以把<code>JVM</code>内存区域分为下面几个方面，其中，有的区域是<code>以线程为单位</code>，而有的区域则是<code>整个JVM</code>进程唯一的。</li>
<li><code>程序计数器</code>：在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefned）。</li>
<li><code>Java虚拟机栈</code>：早期也叫<code>Java栈</code>。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧</code>（Stack Frame），对应着一次次的Java方法调用。前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作<code>当前帧</code>，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。 JVM直接对Java栈的操作只有两个，就是对栈帧的<code>压栈和出栈</code>。栈帧中存储着<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法正常退出</code>或者<code>异常退出</code>的定义等</li>
<li><code>堆（Heap）</code>，它是Java内存管理的核心区域，用来<code>放置Java对象实例</code>，几乎所有创建的Java<code>对象实例都是被直接分配在堆上</code>。堆被<code>所有的线程共享</code>，在虚拟机启动时，我们指定的<code>“Xmx”</code>之类参数就是用来指定最大堆空间等指标。堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是<code>新生代</code>、老<code>年代</code>的划分。</li>
<li><code>方法区（Method Area）</code>。这也是所有<code>线程共享的一块内存区域</code>，用于存储所谓的<code>元（Meta）数据</code>，例如<code>类结构信息</code>，以及对应的<code>运行时常量池</code>、<code>字段</code>、<code>方法代码</code>等。由于早期的Hotspot JVM实现，很多人习惯于将方法区称为永久代， Oracle JDK 8中将永久代移除，同时<code>增加了元数据区</code>（Metaspace）</li>
<li><code>运行时常量池</code>，这是<code>方法区的一部分</code>。如果仔细分析过反编译的类文件结构，你能看到<code>版本号</code>、<code>字段</code>、<code>方法</code>、<code>超类</code>、<code>接口</code>等各种信息，还有一项信息就是<code>常量池</code>。 Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</li>
<li><code>本地方法栈</code>（Native Method Stack）。它和Java虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409170529393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<hr>
<h4 id="Java对象是不是都创建在堆上的呢？"><a href="#Java对象是不是都创建在堆上的呢？" class="headerlink" title="Java对象是不是都创建在堆上的呢？"></a>Java对象是不是都创建在堆上的呢？</h4><ul>
<li>有一些观点，认为通过逃逸分析， JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择</li>
<li>目前很多书籍还是基于JDK 7以前的版本， JDK已经发生了很大变化， Intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是， Intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合对象实例都是分配在堆上。</li>
</ul>
<hr>
<h4 id="什么是OOM问题，它可能在哪些内存区域发生？"><a href="#什么是OOM问题，它可能在哪些内存区域发生？" class="headerlink" title="什么是OOM问题，它可能在哪些内存区域发生？"></a>什么是OOM问题，它可能在哪些内存区域发生？</h4><ul>
<li>OOM如果通俗点儿说，就是JVM内存不够用了， javadoc中对<code>OutOfMemoryError</code>的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。当然，也不是在任何情况下垃圾收集器都会被触发的。比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值， JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。</li>
</ul>
<blockquote>
<p>提示：从我前面分析的数据区的角度，除了程序计数器，其他区域都有可能会因为可能的空间不足发OutOfMemoryError，简单总结如下：</p>
</blockquote>
<ul>
<li><p><code>堆内存不足是最常见的OOM原因之一</code>，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪。例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小；或者出现JVM处理引用不及时，导致堆积起来，内存无法释放等。</p>
</li>
<li><p>而对于Java虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况， JVM实际会抛出StackOverFlowError；当然，如果JVM试图去扩展栈空间的的时候失败，则会抛出OutOfMemoryError。</p>
</li>
<li><p><code>对于老版本的Oracle JDK</code>，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（<code>如，常量池回收、卸载不再需要的类型</code>）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code>也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似Intern字符串缓存占用太多空间，也会导致<code>OOM</code>问题。对应的异常信息，会标记出来和永久代相关： “<code>java.lang.OutOfMemoryError: PermGen space</code>”。</p>
</li>
<li><p><code>随着元数据区的引入</code>，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了： “<code>java.lang.OutOfMemoryError: Metaspace</code>”。</p>
</li>
<li><p>直接内存不足，也会导致OOM。</p>
</li>
</ul>
<blockquote>
<p>面试问题：我在试图分配一个100M bytes大数组的时候发生了OOME，但是GC日志显示，明明堆上还有远不止100M的空间，你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p>
</blockquote>
<ul>
<li><p>从不同的垃圾收集器角度来看：首先，数组的分配是需要连续的内存空间的。所以对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。</p>
</li>
<li><p>对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。</p>
</li>
</ul>
<hr>
<h4 id="如何监控和诊断JVM堆内和堆外内存使用？"><a href="#如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用？"></a>如何监控和诊断JVM堆内和堆外内存使用？</h4><ul>
<li>可以使用综合性的图形化工具，如JConsole、 VisualVM（注意，从Oracle JDK 9开始， VisualVM已经不再包含在JDK安装包中）等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。</li>
</ul>
<blockquote>
<p>以JConsole为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。</p>
</blockquote>
<ul>
<li><p>也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。</p>
</li>
<li><p>或者，也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。</p>
</li>
<li><p>如果你使用的是Tomcat、 Weblogic等Java EE服务器，这些服务器同样提供了内存管理相关的功能。</p>
</li>
<li><p>另外，从某种程度上来说， GC日志等输出，同样包含着丰富的信息。</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">JConsole官方教程</a>。我这里特别推荐<a href="https://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html" target="_blank" rel="noopener">Java Mission Control（JMC）</a>，这是一个非常强大的工具，不仅仅能够使用JMX进行普通的管理、监控任务，还可以配合Java Flight Recorder（JFR）技术，以非常低的开销，收集和分析JVM底层的Profling和事件等信息。</p>
</li>
</ul>
<p><strong>堆内部是什么结构？</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190409174432758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""><br>你可以看到，按照通常的GC年代方式划分， Java堆内分为：</p>
<p><strong>新生代</strong></p>
<ul>
<li><p>新生代是大部分对象创建和销毁的区域，在通常的Java应用中，绝大部分对象生命周期都是很短暂的。其内部又分为Eden区域，作为对象初始分配的区域；两个Survivor，有时候也叫from、 to区域，被用来放置从Minor GC中保留下来的对象。</p>
</li>
<li><p>JVM会随意选取一个Survivor区域作为“to”，然后会在GC过程中进行区域间拷贝，也就是将Eden中存活下来的对象和from区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
</li>
<li><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分， Hotspot JVM还有一个概念叫做（TLAB）。这是JVM为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，TLAB仍然在堆上，它是分配在Eden区域内的。其内部结构比较直观易懂， start、 end就是起始地址， top（指针）则表示已经分配到哪里了。所以我们分配新对象， JVM就会移动top，当top和end相遇时，即表示该缓存已满， JVM会试图再从Eden里分配一块儿。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409174715206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>老年代</strong></p>
<ul>
<li>放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大， JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间， JVM就会直接分配到老年代。</li>
</ul>
<p><strong>永久代</strong></p>
<ul>
<li>这部分就是早期Hotspot JVM的方法区实现方式了，储存Java类元数据、常量池、Intern字符串缓存，在JDK 8之后就不存在永久代这块儿了。</li>
</ul>
<p><strong>利用JVM参数，直接影响堆和内部区域的大小</strong></p>
<ul>
<li><p>最大堆体积：<code>-Xmx value</code></p>
</li>
<li><p>初始的最小堆体积：<code>-Xms value</code></p>
</li>
<li><p>老年代和新生代的比例：<code>-XX:NewRatio=value</code>。默认情况下，这个数值是3，意味着老年代是新生代的3倍大；换句话说，新生代是堆大小的1/4。也可以不用比例的方式调整新生代的大小，直接<code>-XX:NewSize=value</code>参数，设定具体的内存大小数值。</p>
</li>
</ul>
<hr>
<h4 id="谈谈你的GC调优思路？"><a href="#谈谈你的GC调优思路？" class="headerlink" title="谈谈你的GC调优思路？"></a>谈谈你的GC调优思路？</h4><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p>
<p>基本的调优思路总结：</p>
<pre><code>1.理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。

2.掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。

3.这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。

4.通过分析确定具体调整的参数或者软硬件配置。

5.验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。
</code></pre><blockquote>
<p>提示：GC调优问题是JVM调优的一个基础，很多JVM调优需求，最终都落实在GC调优上或者与其相关。</p>
</blockquote>
<blockquote>
<p>扩展 (G1 GC)</p>
</blockquote>
<p><strong>1.了解一下 G1 GC 的内部结构和主要机制</strong><br></p>
<p>从内存角度我们知道，G1 GC存在这年代的概念，但是与前面介绍的内存结构不一样，其内部类似棋盘状的一个个region。</p>
<p>…</p>
<hr>
<h4 id="Java常见的垃圾收集器-GC-有哪些？"><a href="#Java常见的垃圾收集器-GC-有哪些？" class="headerlink" title="Java常见的垃圾收集器(GC)有哪些？"></a>Java常见的垃圾收集器(GC)有哪些？</h4><ul>
<li><p>1.<code>Serial GC</code>，它是最古老的垃圾收集器， “Serial”体现在其收集<code>工作是单线程</code>的，并且在进行垃圾收集过程中，会进入臭名昭著的<code>“Stop-The-World”</code>状态。当然，其<code>单线程设计</code>也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。</p>
</li>
<li><p>2.从年代的角度，通常将其老年代实现单独称作<code>Serial Old</code>，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC的对应JVM参数是：<code>-XX:+UseSerialGC</code>。</p>
</li>
<li><p>3.<code>ParNew GC</code>，很明显是个<code>新生代GC</code>实现，它实际<code>是Serial GC的多线程版本</code>，最常见的应用场景是配合老年代的CMS GC工作，下面是对应参数 <code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code>。</p>
</li>
<li><p>4.<code>CMS GC</code>，基于标记-清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是，CMS采用的<code>标记-清除算法</code>，存在着<code>内存碎片化</code>问题，所以难以避免在长时间运行等情况下发生<code>full GC</code>，导致恶劣的停顿。另外，既然强调了并发（Concurrent）， CMS会<code>占用更多CPU资源</code>，并和用户线程争抢。</p>
</li>
<li><p>5.<code>Parrallel GC</code>，在早期JDK 8等版本中，它是server模式JVM的默认GC选择,也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是<code>新生代和老年代GC都是并行进行</code>的，在常见的服务器环境中更加高效。开启选项是：<code>-XX:+UseParallelGC</code>。另外， Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标， JVM会自动进行适应性调整，例如下面参数：</p>
</li>
</ul>
<blockquote>
<p><code>-XX:MaxGCPauseMillis=value</code></p>
</blockquote>
<blockquote>
<p>-XX:GCTimeRatio=N         //GC时间和用户时间比例 = 1 / (N+1)</p>
</blockquote>
<blockquote>
<p><code>查看jdk垃圾收集器</code>：java -XX:+PrintCommandLineFlags -version  </p>
</blockquote>
<ul>
<li><p>6.<code>G1 GC</code>这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
<li><p>6.1 <code>G1 GC</code>仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个region。Region之间是复制算法，但整体上实际可看作是标记-整理（MarkCompact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候， G1的优势更加明显。</p>
</li>
<li><p>6.2 G1吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得你深入掌握。</p>
</li>
</ul>
<blockquote>
<p>扩展</p>
</blockquote>
<p><strong>1.垃圾收集的原理和基础概念</strong><br></p>
<p>1.自动垃圾收集的前提是清楚哪些内存可以被释放。这一点可以结合我前面对 Java 类加载和内存结构的分析，来思考一下。</p>
<pre><code>主要是两个方面：

    1.对象实例（最主要部分）：对象实例都是存储在堆上面的。

    2.方法区中的元数据等信息：如类型不再使用，卸载该Java类似乎很合理。
</code></pre><p>2.JVM提供的收集器很多，特征不一样，适用于不同的业务场景：</p>
<pre><code>Serial收集器：串行运行；作用于新生代；复制算法；响应速度优先；适用于单CPU环境下的client模式。

ParNew收集器：并行运行；作用于新生代；复制算法；响应速度优先；多CPU环境Server模式下与CMS配合使用。

Parallel Scavenge收集器：并行运行；作用于新生代；复制算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。

Serial Old收集器：串行运行；作用于老年代；标记-整理算法；响应速度优先；单CPU环境下的Client模式。

Parallel Old收集器：并行运行；作用于老年代；标记-整理算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。

CMS收集器：并发运行；作用于老年代；标记-清除算法；响应速度优先；适用于互联网或B/S业务。
</code></pre><hr>
<h4 id="如何判断一个对象是否可以回收？"><a href="#如何判断一个对象是否可以回收？" class="headerlink" title="如何判断一个对象是否可以回收？"></a>如何判断一个对象是否可以回收？</h4><p>主要是两种基本算法， 引用计数和可达性分析：</p>
<pre><code>1.`引用计数算法`，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收。Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。

2.`Java选择的可达性分析`，Java的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，这种类型的垃圾收集通常叫作追踪性垃圾收集。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 `GC Roots`，然后跟踪引用链条，如果一个对象和`GC Roots之间不可达`，也就是不存在引用链条，那么即可认为是可回收对象。 JVM会把虚拟机栈和本地方法栈中正在引用的`对象、静态属性引用的对象和常量，作为GC Roots`。
</code></pre><p>方法区元数据的回收比较复杂，还记得我对类加载器的分类吧，一般来说初始化类加载器加载的类型是不会进行类卸载（unload）的；而普通的类型的卸载，往往是要求相应自定义类加载器本身被回收，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会 OOM。在 8u40 以后的 JDK 中，下面参数已经是默认的：</p>
<pre><code>-XX:+ClassUnloadingWithConcurrentMark
</code></pre><hr>
<h4 id="常见的垃圾收集算法？"><a href="#常见的垃圾收集算法？" class="headerlink" title="常见的垃圾收集算法？"></a>常见的垃圾收集算法？</h4><ul>
<li><p><code>复制（Copying）算法</code>：将活着的对象复制到to区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于G1这种分拆成为大量regio GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。</p>
</li>
<li><p><code>标记-清除（Mark-Sweep）算法</code>，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受。</p>
</li>
<li><p><code>标记-整理（Mark-Compact）</code>，类似于标记-清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</p>
</li>
</ul>
<blockquote>
<p>提示：这些都只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>
</blockquote>
<hr>
<h4 id="在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？"><a href="#在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？" class="headerlink" title="在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？"></a>在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？</h4><p>这实际上取决于具体的GC方式，先来熟悉一下通常的垃圾收集流程，我画了一系列示意图，希望能有助于你理解清楚这个过程。</p>
<pre><code>1.Java应用不断创建对象，通常都是分配在Eden区域，当其空间占用达到一定阈值时，触发minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到JVM选择的Survivor区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字1”，这是为了表明对象的存活时间。
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190409183348554.png" alt=""></p>
<pre><code>2.经过一次`Minor GC`， Eden就会空闲下来，直到再次达到`Minor GC`触发条件，这时候，另外一个`Survivor`区域则会成为`to`区域，`Eden`区域的存活对象和`From`区域对象，都会被复制到`to`区域，并且存活的年龄计数会被加`1`。
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190409183455640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<pre><code>3.类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：`-XX:MaxTenuringThreshold=&lt;N&gt;`
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190409183559189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<pre><code>4.后面就是`老年代GC`，具体取决于选择的`GC`选项，对应不同的算法。通常我们把`老年代GC`叫作`Major GC，`将对整个`堆进行的清理`叫作`Full GC`，但是这个也没有那么绝对，因为不同的老年代GC算法其实表现差异很大，例如`CMS`。 `“concurrent”`就体现在清理工作是与工作线程一起并发运行的。
</code></pre><p><strong>JDK又增加了两种全新的GC方式，分别是：</strong></p>
<ul>
<li><p><code>Epsilon GC</code>，简单说就是个<code>不做垃圾收集的GC</code>，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断GC本身产生了多大的开销，这就是其典型应用场景。</p>
</li>
<li><p><code>ZGC</code>，这是Oracle开源出来的一个<code>超级GC</code>实现，具备令人惊讶的扩展能力，比如支持<code>T bytes级</code>别的堆大小，并且保证绝大部分情况下，<code>延迟都不会超过10 ms</code>。虽然目前还处于<code>实验阶段</code>，仅支持Linux 64位的平台，但其已经表现出的能力和潜力都非常令人期待。</p>
</li>
</ul>
<hr>
<h4 id="Java内存模型中的happen-before是什么？"><a href="#Java内存模型中的happen-before是什么？" class="headerlink" title="Java内存模型中的happen-before是什么？"></a>Java内存模型中的happen-before是什么？</h4><p>1.典型回答</p>
<p>Happen-before关系，是Java内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面。如：</p>
<ul>
<li><p>线程内执行的每个操作，都保证happen-before后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</p>
</li>
<li><p>对于volatile变量，对它的写操作，保证happen-before在随后对该变量的读取操作。</p>
</li>
<li><p>对于一个锁的解锁操作，保证happen-before加锁操作。</p>
</li>
<li><p>对象构建完成，保证happen-before于fnalizer的开始动作。</p>
</li>
<li><p>甚至是类似线程内部操作的完成，保证happen-before其他Thread.join()的线程等。</p>
</li>
<li><p>这些happen-before关系是存在着传递性的，如果满足a happen-before b和b happen-before c，那么a happen-before c也成立。</p>
</li>
<li><p>JMM内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种happen-before规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。</p>
</li>
</ul>
<blockquote>
<p><code>可从四个维度去理解JMM</code></p>
</blockquote>
<ul>
<li><p>从JVM运行时视角来看， JVM内存可分为JVM栈、本地方法栈、 PC计数器、方法区、堆；其中前三区是线程所私有的，后两者则是所有线程共有的</p>
</li>
<li><p>从JVM内存功能视角来看， JVM可分为堆内存、非堆内存与其他。其中堆内存对应于上述的堆区；非堆内存对应于上述的JVM栈、本地方法栈、 PC计数器、方法区；其他则对应于直接内存</p>
</li>
<li><p>从线程运行视角来看， JVM可分为主内存与线程工作内存。 Java内存模型规定了所有的变量都存储在主内存中；每个线程的工作内存保存了被该线程使用到的变量，这些变量是主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</p>
</li>
<li><p>从垃圾回收视角来看， JVM中的堆区=新生代+老年代。新生代主要用于存放新创建的对象与存活时长小的对象，新生代=E+S1+S2；老年代则用于存放存活时间长的对象</p>
</li>
</ul>
<h4 id="JVM优化Java代码时都做了什么"><a href="#JVM优化Java代码时都做了什么" class="headerlink" title="JVM优化Java代码时都做了什么?"></a>JVM优化Java代码时都做了什么?</h4><ul>
<li>JVM在对代码执行的优化可分为<code>运行时化</code>和<code>即时编译器优化</code>。<code>运行时优化主要是</code>解析执行和动态编译通用的一些机制,比如说锁机制(<code>如偏向锁</code>)、内存分配机制(<code>如TLAB</code>)。除此之外，还有一些专门优化器执行效率的，比如说模板解析器，内联缓存。</li>
<li>J<code>VM的即时编译器优化</code>是指将热点代码以方法为单位转换成机器码,直接运行在底层硬件之上。它采用了多种优化方式,包括静态编译器可以使用的如方法内联、逃逸分析,也􏰂包括基于程序运行<code>profle</code>的投机性优化，这个怎么理解了?比如我有一条<code>instanceof</code>指令,在编译之前的运行过程中,测试对像的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回<code>instanceof</code>的结果。如果出现了其他类,那么就抛弃这段编译后的机器码,并且切换回解析执行。</li>
</ul>
<h4 id="谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响"><a href="#谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响" class="headerlink" title="谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?"></a>谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?</h4><ul>
<li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用,但是在扩展性和可靠性等方面存在局限性。</li>
<li>基于Twitter 早期开源的Snowflake的实现,以及相关改动方案。<br><img src="https://img-blog.csdnimg.cn/20190409221903872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></li>
<li>整体长度通常是64 (1 + 41 + 10+ 12 = 64)位,适合使用Java语言中的long类型来存储。</li>
<li>头部是1位的正负标识位。跟着的高位部分包含41位时间戳,通常使用<code>System.currentTimeMillis()</code></li>
<li>后面是<code>10位</code>的<code>WorkerID</code>,标准定义是5位数据中心 + 5位机器ID,组成了机器编􏱆号，以区分不同的集群节点。</li>
<li>最后的12位就是单位毫秒内可生成的序列号数目的理论极限。</li>
</ul>
]]></content>
      <categories>
        <category>Java核心技术36讲</category>
      </categories>
      <tags>
        <tag>Java核心技术36讲</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/undefined/Spring%20MVC/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Spring-MVC-FD"><a href="#Spring-MVC-FD" class="headerlink" title="Spring MVC - FD"></a>Spring MVC - FD</h1><h2 id="1-Spring-MVC-中Controller层"><a href="#1-Spring-MVC-中Controller层" class="headerlink" title="1.Spring MVC 中Controller层"></a>1.Spring MVC 中Controller层</h2><p>SpringMVC中的Controller方法的参数可以是Integer，Double，自定义对象，ServletRequest，ServletResponse，ModelAndView等。</p>
<h3 id="MVC控制层作用："><a href="#MVC控制层作用：" class="headerlink" title="MVC控制层作用："></a>MVC控制层作用：</h3><p>接收客户端的请求，然后调用Service层业务逻辑，获取到数据，传递给视图（客户端）用于视觉呈现</p>
<blockquote>
<p>实现步骤：</p>
</blockquote>
<pre><code>1.在类上使用@Controller注解
  作用： 告诉springmvc的dispatcherServlet这是一个Controller然后被dispatcherServlet的上下文所管理，并且完成它的依赖注入

2.在类上使用@RequestMapping注解 @RequestMapping 该注解可以用指定的URL路径访问本控制层
  例如：@RequestMapping(“/user”) 
  作用： Controller负责处理的，根目录下的URL ，/user/** 下的所有路径都会被Controller所拦截

3.在方法上使用 @RequestMapping
  例如：@RequestMapping(value = “login.do”, method = RequestMethod.POST)
  作用：使该方法负责处理/user/login.do 这个url 并且是由post方法方法传递过来的请求

4.在方法的参数前绑定@RequestParam/@PathVariable/@Param注解
  @RequestParam 根据参数名从URL中取得参数值

   作用：负责把请求传入的参数，绑定到方法中的参数上，使方法中的参数值为请求传入的参数值
  例如这条请求：/user/login.do？username=”admin” &amp;password=”admin”

  @Param 该注解的作用是作为Dao层的注解，作用是用于传递参数，一般参数在2-5个时使用最佳。
</code></pre><h2 id="2-Spring-MVC-DispatchServlet"><a href="#2-Spring-MVC-DispatchServlet" class="headerlink" title="2.Spring MVC  DispatchServlet"></a>2.Spring MVC  DispatchServlet</h2><p>在整个Spring MVC框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。</p>
<p>在看 DispatcherServlet 类之前，我们先来看一下请求处理的大致流程:</p>
<pre><code>1.Tomcat服务器启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化。在这个初始化过程中完成了：

对 web.xml 中初始化参数的加载；建立 WebApplicationContext (SpringMVC的IOC容器)，进行组件的初始化。

2.客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml 中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理。

3.DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping 接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler (执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器) 封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler 则退出循环。

4.DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有 HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象。

5.执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用 HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的 postHandler() 方法。

6.利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成 View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面。

7.最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。
</code></pre><h2 id="3-SpringMVC源码分析"><a href="#3-SpringMVC源码分析" class="headerlink" title="3.SpringMVC源码分析"></a>3.SpringMVC源码分析</h2><p>SpringMVC中有两个重要的接口，HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler，在两个接口是在Spring3.1版本之后加入的。</p>
<h4 id="3-1-SpringMVC处理请求的大致过程："><a href="#3-1-SpringMVC处理请求的大致过程：" class="headerlink" title="3.1 SpringMVC处理请求的大致过程："></a>3.1 SpringMVC处理请求的大致过程：</h4><pre><code>1.首先被DispatcherServlet截获，DispatcherServlet通过HandlerMapping获得HandlerExecutionChain，然后获得HandlerAdapter。

  注意：前端控制器DispatcherServlet是整个SpringMVC的核心，负责统一分发所有请求，在web.xml中进行配置。

    1.拦截符合特定格式的URL请求
      拦截规则：
        1. *.xxx，指定要拦截的特定类型，最简单实用的方式，并且不会拦截静态文件
        2. /，使用REST风格进行拦截，但是会导致静态文件被拦截不能正常显示
        3. /*，不能像Struts那样使用，会导致不能访问jsp
    注意：如果使用/进行拦截，并且希望正常访问静态文件，可以在DispatcherServlet之前，使用DefaultServlet先拦截特定类型的请求（如：*.js、*.css等）。
    2.初始化DispatcherServlet上下文对应的WebApplicationContext，并与业务层、持久化层建立联系
    3.初始化SpringMVC的各个组件，并装配到DispatcherServlet中

2.HandlerMapping(处理器映射)

  负责完成请求到控制器的映射。在servlet的配置文件中，进行uri与控制器的映射。同时，还可以对控制器进行拦截。
    1.SpringMVC默认的处理器映射，直接将uri与实现类进行绑定，书写方便，但是耦合性高(使用BeanNameUrlHandlerMapping类)
    2.使用SimpleUrlHandlerMapping，将uri与类的id进行绑定，彼此的耦合性低，更加灵活。
      注意：对控制器进行声明，首先应该声明拦截器，然后利用SimpleUrlHandlerMapping映射拦截器与控制器。

3.控制器Controller
  负责处理用户请求，完成之后返回ModelAndView对象给前端控制器。因为需要考虑并发，所以必须保证线程安全并且可重用。

  注意：SpringMVC中的Controller与Struts中的Action基本相同。通过实现Controller接口或继承父类的方式编写控制器

实现步骤：
    1.实现Controller接口
      public class HelloController implements Controller {
          // 相当于servlet的doGet和doPost方法
          public ModelAndView handleRequest(HttpServletRequest request,HttpServletResponse response) throws Exception {
            // 接收数据
            // 调用服务层
            return new ModelAndView(&quot;success&quot;,&quot;username&quot;,&quot;sean&quot;);
              }
        }

    2.继承类的实现
      1.继承AbstractController类，与接口类似需要重写里面的方法
      2.继承MultiActionController类，可以实现多个方法，处理多个请求
        public class MultiController extends MultiActionController {
              // 自定义处理请求的方法
              public ModelAndView insert(HttpServletRequest request,HttpServletResponse response) throws Exception {
                        return new ModelAndView(&quot;insertSuccess&quot;);
                  }
              public ModelAndView update(HttpServletRequest request,HttpServletResponse response) throws Exception {
                        return new ModelAndView(&quot;updateSuccess&quot;);
                  }
            }

        注意：在把实现类编写之后需要配置相应的配置文件
      3.继承AbstractCommandController类，用于获取页面的参数，将参数封装到指定的对象模型中。

4.HandlerAdapter在内部对于每个请求，都会实例化一个ServletInvocableHandlerMethod进行处理，ServletInvocableHandlerMethod在进行处理的时候，会分两部分别对请求跟响应进行处理。

5.然后HandlerAdapter得到ModelAndView，然后做相应的处理。

6.视图解析器ViewResolver
  负责对ModelAndView对象的解析，并查找对应的View对象。SpringMVC框架默认通过转发进行页面跳转，如果想通过重定向的方式进行跳转(直接跳转：return &quot;redirect:/index.jsp&quot;)。

注意：如果一个配置文件中出现多个视图解析器，可以通过设置order属性来设置优先级，值越低，优先级越高。
</code></pre><blockquote>
<p>总结：1.在web.xml中配置<code>DispatcherServlet</code>核心控制器<br><br>       2.在WEB-INF文件夹下创建springmvc-servlet.xml配置文件<br><br>       3.学会<code>@Controller</code>、<code>@RequestMapping</code>、<code>@RequestParam</code>以及<code>@Model</code>域对象的使用<br><br>       4.表单以post方式、get方式提交都是可以的</p>
</blockquote>
<h4 id="3-2-Spring-MVC-的工作原理"><a href="#3-2-Spring-MVC-的工作原理" class="headerlink" title="3.2 Spring MVC 的工作原理"></a>3.2 Spring MVC 的工作原理</h4><pre><code>1.将客户端请求提交给DispatcherServlet
2.根据&lt;servlet-name&gt;servlet.xml的配置，查找HandlerMapping
3.通过HandlerMapping找到处理请求的具体Controller
4.Controller调用业务逻辑处理
5.处理完成之后，返回ModelAndView对象给DispatcherServlet
6.通过ViewResolver找到负责显示的具体View
7.由View将结果渲染到客户端
</code></pre><h2 id="4-SpringMVC重要注解-ModelAttribute"><a href="#4-SpringMVC重要注解-ModelAttribute" class="headerlink" title="4.SpringMVC重要注解(@ModelAttribute)"></a>4.SpringMVC重要注解(<code>@ModelAttribute</code>)</h2><p>该注解的作用是将请求参数绑定到Model对象。值得注意的是，该注解只支持一个属性value，类型为String，表示参数绑定的属性名称。而且此注解注释的方法在controller每个方法执行前都会执行。在 <code>SpringMVC</code> 的 <code>Controller</code> 中使用 <code>@ModelAttribute</code> 时，应用位置包括下面几种：</p>
<pre><code>1.应用在方法上 
  注意：在被 @ModelAttribute 注解的方法会在Controller每个方法执行之前都执行，因此对于一个Controller中包含多个URL的时候，要谨慎使用。

1)使用 @ModelAttribute 注解无返回值的方法
@Controller
@RequestMapping(&quot;/modelattributeTest&quot;)
public class ModelAttributeTestController1 {

        @ModelAttribute//使用ModelAttribute注解无返回值的方法
        public void myModel(@RequestParam(required = false) String abc, Model model) {
            model.addAttribute(&quot;attributeName&quot;, abc);
       }
        @RequestMapping(value = &quot;/test1&quot;)
        public String test1() {
            return &quot;modelattributetest/test1&quot;;
            }
    }
</code></pre><blockquote>
<p>注意：最常用的方法是将上面的mymodel与test1合在一起使用，也是最常用的方法。</p>
</blockquote>
<pre><code>@RequestMapping(value = &quot;/test2&quot;)
public String test1(@RequestParam(required = false) String abc, Model model) {
        model.addAttribute(&quot;attributeName&quot;, abc);
        return &quot;modelattributetest/test1&quot;;
}

2)使用@ModelAttribute 注解带有返回值的方法
  @ModelAttribute
  public String myModel(@RequestParam(required = false) String abc) {
        return abc;
  }

  @ModelAttribute
  public Student myModel(@RequestParam(required = false) String abc) {
        Student stu = new Student(abc);
         return stu;
  }


  @ModelAttribute
  public int myModel(@RequestParam(required = false) int number) {
         return number;
  }

 上面的三种情况等同于
 model.addAttribute(&quot;string&quot;, abc);
 model.addAttribute(&quot;int&quot;, number);
 model.addAttribute(&quot;student&quot;, stu);


 自定义，给@ModelAttribute添加value属性
 @ModelAttribute(value = &quot;num&quot;)
  public int myModel(@RequestParam(required = false) int number) {
        return number;
 }
 相当于：model.addAttribute(“num”, number);


2.应用在方法的参数上(使用@ModelAttribute注解方法的参数)
  @Controller
  @RequestMapping(&quot;/modelattributeTest3&quot;)
  public class ModelAttributeTestController3 {

      @ModelAttribute(value = &quot;attributeName&quot;)
      public String myModel(@RequestParam(required = false) String abc) {
            return abc;
        }

       @ModelAttribute
      public void myModel3(Model model) {
        model.addAttribute(&quot;name&quot;, &quot;SHANHY&quot;);
        model.addAttribute(&quot;age&quot;, &quot;28&quot;);
      }

      @RequestMapping(value = &quot;/test1&quot;)
      public String test1(@ModelAttribute(&quot;attributeName&quot;) String str, 
        @ModelAttribute(&quot;name&quot;) String str2,
        @ModelAttribute(&quot;age&quot;) String str3) {
            return &quot;modelattributetest/test1&quot;;
        }
}
</code></pre><blockquote>
<p>注意：从上面的程序中可以看出，使用@ModelAttribute注解的参数，表示从前面的Model中提取对应名称的属性</p>
</blockquote>
<pre><code>3.应用在方法上，并且方法也使用了@RequestMapping
  @Controller
  @RequestMapping(&quot;/modelattributeTest4&quot;)
  public class ModelAttributeTestController4 {

      @RequestMapping(value = &quot;/test1&quot;)
      @ModelAttribute(&quot;name&quot;)
      public String test1(@RequestParam(required = false) String name) {
            return name;
        }
}
</code></pre><blockquote>
<p>注意：这种情况下，返回值String（或者其他对象，就不再是视图。还是我们上面将到的放入 Model 中的值，此时对应的页面就是 @RequestMapping的值 test1。</p>
</blockquote>
<blockquote>
<p>总结：@Controller 相当于创建了一个bean对象<br>       @RequestMapping(value=”..”) 就是一个请求映射，返回值return返回一个页面(前缀+逻辑视图+后缀)</p>
</blockquote>
<hr>
<h2 id="4-1-Spring-MVC-的常用注解"><a href="#4-1-Spring-MVC-的常用注解" class="headerlink" title="4.1 Spring MVC 的常用注解"></a>4.1 Spring MVC 的常用注解</h2><pre><code>@Controller：声明Action组件，负责注册bean到Spring上下文

@RequestMapping：用于为控制器指定可以处理的url请求(Springmvc页面向controller传递参数的方式)

@RequestParam：用于指定参数的name属性(Springmvc页面(ftl)向controller层传递参数的方式)


@RequestBody：用于读取Request请求的body部分数据
解释：
1. @requestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。
2. 通过@RequestBody可以将请求体中的JSON字符串绑定到相应的bean上，也可以将其绑定到对应的字符串上。
3. @RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为JSON、XML等格式的数据并绑定到Controller方法的参数上。

4. 最新解释：该注解将@Controller中方法的返回对象，根据request中头部(header)的accept的内容通过适当的转换，转换为指定的格式后输出到response对象。

5. 使用时机：返回数据不是HTML标签页，是其他格式数据(如：JSON/XML等)。


@ResponseBody：用于将控制器方法返回的对象写入到Response对象的body数据区
解释：
1. 将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或XML数据。
2. @ResponseBody注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据(JSON/XML)通过response响应给客户端。
3. @ResponseBody注解可被应用于方法上，标志该方法的返回值应该被直接写回到HTTP响应体中去(不会被放置到Model中或解释为一个视图名)。在实际开发中，返回JSON是最常见的一种方式。
原理：当一个处理请求的方法被标记为@ResponseBody时，就说明该方法需要输出其他视图(JSON/XML),Spring MVC通过已经定义的转化器做转化输出，默认输出JSON。
</code></pre><blockquote>
<p>注意：在使用此注解之后不会再走视图处理器（ViewResolver）是直接将数据写入到输入流中，等同于通过response对象输出指定格式的数据。</p>
</blockquote>
<blockquote>
<p>注意：@RequestBody是写在方法参数前，作用于方法参数。@ResponseBody是写在方法上，作用于方法返回值。 因为采用的是JSON格式进行数据交互。</p>
</blockquote>
<blockquote>
<p>重要：使用 <code>@ResponseBody</code> 注解，返回值直接作为http响应的内容的响应体部分发送给客户端，可以让我们将想要返回的内容直接返回给客户端。</p>
</blockquote>
<pre><code>@PathVariable：用于指定url作为参数 用来获得请求URL中的动态参数的，将请求URL的模板变量映射到功能处理方法的参数上。

@Resource：用于注入( 由J2EE提供 ) 默认按名称装配

@Autowired ：用于注入(由spring提供) 默认按类型装配

@ExceptionHandler：用于异常处理的方法
@ControllerAdvice：用于使控制器成为全局的异常处理类

@ModelAttribute：用于优先调用被注解的方法，或注解参数中的隐藏对象

@JsonFormat：用于将后台返回前台的Date变量转换为字符串类型，还可以实现前台到后台的类型转换(注：@JsonFormat注解的作用就是完成JSON字符串到Java对象的转换工作，与参数传递方向无关)
@DateTimeFormat：用于将前台传递到后台字符串变量转换成Date类型
</code></pre><blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>@RequestMapping 注解的六个属性
1.value/method
    value：指定请求的实际地址
    method：指定请求的method类型 get/post/put/delete等
2.consumes/produces
    consumes：指定处理请求的提交内容类型(content-type)，如：application/json text/html
    produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回
3.params/headers
    params：指定request中必须包含某些参数值时，才让该方法处理
    headers：指定request中必须包含某些指定的headers值，才让该方法处理请求
</code></pre><hr>
<p>@Deprecated、@Override、@SuppressWarnings这三个注解的@Retention注解的属性值分别是：</p>
<hr>
<hr>
<h2 id="4-3-ViewResolver接口实现类"><a href="#4-3-ViewResolver接口实现类" class="headerlink" title="4.3 ViewResolver接口实现类"></a>4.3 ViewResolver接口实现类</h2><pre><code>InternalResourceViewResolver类(加入JSTL支持)
</code></pre><h2 id="4-4-springmvc-xml配置文件"><a href="#4-4-springmvc-xml配置文件" class="headerlink" title="4.4 springmvc.xml配置文件"></a>4.4 springmvc.xml配置文件</h2><pre><code>&lt;!--在最开始应该引入springmvc的约束文件--&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

    &lt;!-- 配置databaseSource--&gt;
    &lt;!-- ================== 方式1 ==================== --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/storemanager?characterEncoding=utf-8&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
        &lt;!-- 连接池初始化连接个数 --&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;3&quot; /&gt;
        &lt;!-- 连接池的最大值 --&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;
        &lt;!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt;
        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;
        &lt;!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt;
        &lt;property name=&quot;minIdle&quot; value=&quot;2&quot; /&gt;
        &lt;!-- 获取连接最大等待时间 --&gt;
        &lt;!-- &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; --&gt;

        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
        &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;
        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
        &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;25200000&quot; /&gt;
        &lt;!-- 打开removeAbandoned功能 --&gt;
        &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot; /&gt;
        &lt;!-- 1800秒，也就是30分钟 --&gt;
        &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;1800&quot; /&gt;
        &lt;!-- 关闭abanded连接时输出错误日志 --&gt;
        &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt;
        &lt;!-- 监控数据库 --&gt;
        &lt;!-- &lt;property name=&quot;filters&quot; value=&quot;mergeStat&quot; /&gt; --&gt;
        &lt;!-- &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; --&gt;
    &lt;/bean&gt;

    &lt;!-- ====================== 方式2 ========================== --&gt;
    &lt;!-- 2.创建数据源 添加连接池则改变数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 配置sessionFactory,用于获取session --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;sessionFactory&quot;
        class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot;&gt;
            &lt;ref bean=&quot;dataSource&quot; /&gt;
        &lt;/property&gt;
        &lt;property name=&quot;mappingResources&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;com/kl/napchen/store/bean/User.hbm.xml&lt;/value&gt;
                &lt;value&gt;com/kl/napchen/store/bean/ProductIn.hbm.xml&lt;/value&gt;
                &lt;value&gt;com/kl/napchen/store/bean/ProductOut.hbm.xml&lt;/value&gt;
                &lt;value&gt;com/kl/napchen/store/bean/ProductType.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name=&quot;hibernateProperties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;hibernate.dialect&quot;&gt;
                    org.hibernate.dialect.MySQL5Dialect
                &lt;/prop&gt;
                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;current_session_context_class&quot;&gt;thread&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

        &lt;!-- 自动扫描注解方式配置的hibernate类文件 --&gt;
        &lt;!-- &lt;property name=&quot;packagesToScan&quot;&gt; --&gt;
        &lt;!-- &lt;list&gt; --&gt;
        &lt;!-- &lt;value&gt;light.mvc.model&lt;/value&gt; --&gt;
        &lt;!-- &lt;/list&gt; --&gt;
        &lt;!-- &lt;/property&gt; --&gt;
    &lt;/bean&gt;

    &lt;!-- 配置事务管理器 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;transactionManager&quot;
        class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;
        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
        &lt;!-- &lt;property name=&quot;rollbackOnCommitFailure&quot; value=&quot;true&quot; /&gt; --&gt;
    &lt;/bean&gt;

    &lt;!-- 注解方式配置事物 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; --&gt;

    &lt;!-- AOP方式配置事物 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; --&gt;
            &lt;!-- &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; --&gt;
            &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot; /&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;transactionPointcut&quot;
            expression=&quot;execution(* com.kl.napchen.store.impl..*.*(..))&quot; /&gt;
        &lt;aop:advisor pointcut-ref=&quot;transactionPointcut&quot;
            advice-ref=&quot;transactionAdvice&quot; /&gt;
    &lt;/aop:config&gt;

    &lt;!-- 启用aspectj注解自动代理 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;aop:aspectj-autoproxy /&gt;

    &lt;!-- 配置代理bean --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;adviceLog&quot; class=&quot;com.kl.napchen.store.annotation.AdviceLog&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;adviceUserLog&quot; class=&quot;com.kl.napchen.store.annotation.AdviceUserLog&quot;&gt;&lt;/bean&gt;

    &lt;!-- 配置Bean --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.kl.napchen.store.bean.User&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productIn&quot; class=&quot;com.kl.napchen.store.bean.ProductIn&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productOut&quot; class=&quot;com.kl.napchen.store.bean.ProductOut&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productType&quot; class=&quot;com.kl.napchen.store.bean.ProductType&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;sessionInfo&quot; class=&quot;com.kl.napchen.store.global.SessionInfo&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;pageGrid&quot; class=&quot;com.kl.napchen.store.page.PageGrid&quot;&gt;&lt;/bean&gt;

    &lt;!-- 配置操作数据的Dao --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.kl.napchen.store.dao.UserDao&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productInDao&quot; class=&quot;com.kl.napchen.store.dao.ProductInDao&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productOutDao&quot; class=&quot;com.kl.napchen.store.dao.ProductOutDao&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productTypeDao&quot; class=&quot;com.kl.napchen.store.dao.ProductTypeDao&quot;&gt;&lt;/bean&gt;

    &lt;!-- 配置业务处理的service --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;userImpl&quot; class=&quot;com.kl.napchen.store.impl.UserImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productInImpl&quot; class=&quot;com.kl.napchen.store.impl.ProductInImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productOutImpl&quot; class=&quot;com.kl.napchen.store.impl.ProductOutImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;productTypeImpl&quot; class=&quot;com.kl.napchen.store.impl.ProductTypeImpl&quot;&gt;&lt;/bean&gt;

    &lt;!-- 配置控制流程的controller --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- &lt;bean id=&quot;userController&quot; class=&quot;com.kl.napchen.store.controller.UserController&quot;&gt;&lt;/bean&gt; --&gt;
    &lt;!-- &lt;bean id=&quot;productInController&quot; class=&quot;com.kl.napchen.store.controller.ProductInController&quot;&gt;&lt;/bean&gt; --&gt;
    &lt;!-- &lt;bean id=&quot;productOutController&quot; class=&quot;com.kl.napchen.store.controller.ProductOutController&quot;&gt;&lt;/bean&gt; --&gt;
    &lt;!-- &lt;bean id=&quot;productTypeController&quot; class=&quot;com.kl.napchen.store.controller.ProductTypeController&quot;&gt;&lt;/bean&gt; --&gt;


    &lt;!-- 配置获取spring容器中Bean的工具Bean --&gt;
    &lt;!-- 由于持有ApplicationContext, --&gt;
    &lt;!-- 可以使用SpringContextHolder.getBean(&apos;xx&apos;)的静态方法得到spring bean对象 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- &lt;bean class=&quot;com.kl.napchen.storeManagerSystem.contextHolder.SpringContextHolder&quot; 
        lazy-init=&quot;false&quot; /&gt; --&gt;

    &lt;!-- 对静态资源文件的访问 方案一 （二选一） --&gt;
    &lt;!-- 使用&quot;*.do&quot;配置DispatcherServlet时不存在静态资源访问问题 ，拦截器将不会拦截静态资源的URL --&gt;
    &lt;!-- 使用&quot;/&quot;配置DispatcherServlet时存在静态资源访问问题,采用以下两种方案解决 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;mvc:default-servlet-handler /&gt;

    &lt;!-- 对静态资源文件的访问 方案二 （二选一） --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- 静态资源映射 --&gt;
    &lt;!-- &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/js/&quot; /&gt; --&gt;
    &lt;!-- &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/css/&quot; /&gt; --&gt;
    &lt;!-- &lt;mvc:resources mapping=&quot;/fonts/**&quot; location=&quot;/WEB-INF/fonts/&quot; /&gt; --&gt;
    &lt;!-- &lt;mvc:resources mapping=&quot;/plugins/**&quot; location=&quot;/WEB-INF/plugins/&quot; /&gt; --&gt;
    &lt;!-- &lt;mvc:resources mapping=&quot;images/**&quot; location=&quot;/WEB-INF/images/&quot; /&gt; --&gt;

    &lt;!-- 默认的注解映射的支持 --&gt;
    &lt;!-- 采用这下面种方式将自动装配DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter --&gt;
    &lt;!-- 采用这下面种方式将无法在 DefaultAnnotationHandlerMapping配置拦截器 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 配置 DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- &lt;bean --&gt;
    &lt;!-- class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;&gt; --&gt;
    &lt;!-- 配置拦截器 --&gt;
    &lt;!-- &lt;property name=&quot;interceptors&quot;&gt; --&gt;
    &lt;!-- &lt;list&gt; --&gt;
    &lt;!-- &lt;bean class=&quot;com/kl/napchen/storeManagerSystem/interceptor/MyInterceptor&quot;&gt;&lt;/bean&gt; --&gt;
    &lt;!-- &lt;/list&gt; --&gt;
    &lt;!-- &lt;/property&gt; --&gt;
    &lt;!-- &lt;/bean&gt; --&gt;
    &lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; 
        &lt;/bean&gt; --&gt;

    &lt;!-- 隐式地向 Spring容器注册这4个BeanPostProcessor --&gt;
    &lt;!-- AutowiredAnnotationBeanPostProcessor、 --&gt;
    &lt;!-- RequiredAnnotationBeanPostProcessor、 --&gt;
    &lt;!-- CommonAnnotationBeanPostProcessor、 --&gt;
    &lt;!-- PersistenceAnnotationBeanPostProcessor --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- &lt;context:annotation-config /&gt; --&gt;


    &lt;!-- 设置使用注解的类所在的jar包 ,使用这种即可省去上面的声明 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;context:component-scan base-package=&quot;com.kl.napchen.store.controller&quot; /&gt;
    &lt;context:component-scan base-package=&quot;com.kl.napchen.store.impl&quot; /&gt;
    &lt;context:component-scan base-package=&quot;com.kl.napchen.store.baseService&quot; /&gt;


    &lt;!-- 映射“/”的url --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;!-- &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;forward:/index2&quot; /&gt; --&gt;

    &lt;!-- configure the InternalResourceViewResolver --&gt;
    &lt;bean
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
        id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; 
            /&gt; --&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 自定义拦截器 （近似-总拦截器） --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;mvc:interceptors&gt;
        &lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt;
        &lt;bean class=&quot;com.kl.napchen.store.interceptor.MyInterceptor&quot; /&gt;
    &lt;/mvc:interceptors&gt;


    &lt;!-- 总错误处理 --&gt;
    &lt;!-- ====================================== --&gt;
    &lt;bean id=&quot;exceptionResolver&quot;
        class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
        &lt;!-- 配置不同类别的错误对应的view和状态码 --&gt;
        &lt;property name=&quot;exceptionMappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;java.lang.Exception&quot;&gt;errors/error&lt;/prop&gt;
                &lt;prop key=&quot;java.lang.Throwable&quot;&gt;errors/error&lt;/prop&gt;
                &lt;!-- 上传文件大于最大尺寸后转向出错页面 --&gt;
                &lt;!-- ====================================== --&gt;
                &lt;prop
                    key=&quot;org.springframework.web.multipart.MaxUploadSizeExceededException&quot;&gt;errors/uploadError
                &lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name=&quot;statusCodes&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;errors/error&quot;&gt;500&lt;/prop&gt;
                &lt;prop key=&quot;errors/404&quot;&gt;404&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;!-- 设置日志输出级别，不定义则默认不输出警告等错误日志信息 --&gt;
        &lt;property name=&quot;warnLogCategory&quot;&gt;
            &lt;value&gt;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver
            &lt;/value&gt;
        &lt;/property&gt;
        &lt;!-- 默认错误页面，当找不到上面mappings中指定的异常对应视图时，使用本默认配置 --&gt;
        &lt;property name=&quot;defaultErrorView&quot; value=&quot;errors/error&quot;&gt;&lt;/property&gt;
        &lt;!-- 默认HTTP状态码 --&gt;
        &lt;property name=&quot;defaultStatusCode&quot; value=&quot;500&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><hr>
<h1 id="5-Spring-MVC向页面传送参数的四种方式"><a href="#5-Spring-MVC向页面传送参数的四种方式" class="headerlink" title="5.Spring MVC向页面传送参数的四种方式"></a>5.Spring MVC向页面传送参数的四种方式</h1><p>1.使用<code>HttpServletRequest</code>和<code>Session</code>，然后<code>setAttribute()</code>（与Servlet一样） <code>request.setAttribute(&quot;user&quot;,user_data);</code>。</p>
<p>2.使用<code>ModelAndView</code>对象</p>
<pre><code>@RequestMapping(&quot;/login.do&quot;)   
public ModelAndView login(String name,String pass){   
    User user = userService.login(name,pwd); 
       Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();   
    data.put(&quot;user&quot;,user);   
    return newModelAndView(&quot;success&quot;,data); 
} 
</code></pre><p>3.使用<code>ModelMap</code>对象 <code>ModelMap</code> 数据会利用<code>HttpServletRequest</code>的<code>Attribute</code>传值到<code>success.jsp</code>中。</p>
<pre><code>@RequestMapping(&quot;/login.do&quot;) 
  public String login(String name,String pass ,ModelMap modelMap){
    User user = userService.login(name,pwd);//调用service层的login方法
    modelMap.addAttribute(&quot;user&quot;,user);  
    modelMap.put(&quot;name&quot;,name);  
    return &quot;success&quot;;  
 }  
</code></pre><p>4.使用<code>@ModelAttribute</code>注解 <code>@ModelAttribute</code> 数据会利用<code>HttpServletRequest</code>的<code>Attribute</code>传值到<code>success.jsp</code>中。</p>
<pre><code>@RequestMapping(&quot;/login.do&quot;)    
public String login(@ModelAttribute(&quot;user&quot;) User user) {    
    return &quot;success&quot;;   
}   
      @ModelAttribute(&quot;name&quot;)  
     public String getName(){
        return name;  
}
</code></pre><blockquote>
<p>注意：Spring MVC默认是采用转发来定位视图，如果要使用定向来转发视图，可以使用redirect前缀。</p>
</blockquote>
<pre><code>  public String login(){
    return &quot;redirect:registe.do&quot;;
}
</code></pre><hr>
<h1 id="6-Spring-MVC-的执行流程"><a href="#6-Spring-MVC-的执行流程" class="headerlink" title="6.Spring MVC 的执行流程"></a>6.Spring MVC 的执行流程</h1><pre><code>1.(前端)控制层(Controller)：接收请求、转发请求
2.(后端)控制层(Controller)：struts(action)：接受请求、处理请求数据
</code></pre><blockquote>
<p>注意：<code>Spring MVC</code>就是<code>Spring</code>，所以其<code>约束</code>与<code>Spring的约束</code>一致。</p>
<blockquote>
<p>查找方法：<br>    SpringMVC约束的查找是在..\jar\spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html路径下查找然后复制粘贴。</p>
</blockquote>
</blockquote>
<pre><code>3.程序实现流程
  1.配置默认处理器映射器(BeanNameUrlHandlerMapping)：映射器会将请求映射到Controller(根据bean(自定义Controller)的name属性的url去寻找执行类Controller)

  2.配置默认处理器适配器(SimpleUrlHandlerMapping)：负责执行UserController(依赖自定义的控制器bean，表示多个*.do文件可以访问一个或多个Controller)

  3.配置ControllerClassNameHandlerMapping：这个Mapping配置之后我们便能够使用Controller的【类名.do】来访问这个Controller

  4.SimpleControllerHandlerAdapter


4.代码层面的实现流程
  1.配置web.xml(配置前端控制器：DispatcherServlet)

  2.配置springmvc.xml
    1.配置处理器映射器(默认：BeanNameUrlHandlerMapping：根据自定义Controller的name属性的URL去寻找Handler(相当于Struts2中的Action))

    2.配置处理器适配器执行Controller(默认：SimpleControllerHandlerAdapter(执行Controller))

    3.配置自定义的Controller

    4.配置SpringMVC视图解析器：解析逻辑视图 后台返回逻辑视图(视图解析器解析出真正的物理视图：前缀+逻辑视图+后缀===/WEB-INF/jsps/index.jsp)

  3.自定义Controller(UserController implements Controller)

  4.配置自定义的Controller的bean(在springmvc.xml配置文件中配置Controller，表示这个对象交给Spring来创建)
  &lt;bean name=&quot;/hello.do&quot; class=&quot;cn.itcast.controller.UserController&quot;&gt;&lt;/bean&gt;（在bean中定义的name属性就是URL访问地址）

  5.配置视图解析器(如果Controller使用逻辑视图，必须配置视图解析器)

  6.访问 项目名+自定义的Controller的name属性URL
    http://localhost:8080/springmvc/hello.do
</code></pre><hr>
<h2 id="Struts2与SpringMVC的区别"><a href="#Struts2与SpringMVC的区别" class="headerlink" title="Struts2与SpringMVC的区别"></a>Struts2与SpringMVC的区别</h2><pre><code>1.实现机制
  Struts2底层是过滤器，是基于过滤器实现
  SpringMVC是基于Servlet实现的

2.执行速度
  Struts2是多列的，而SpringMVC是单列的，执行速度快。

3.参数封装
  Struts2参数封装是基于属性封装
  SpringMVC是基于方法封装的，颗粒更细
</code></pre><hr>
<h1 id="Spring-MVC-SD"><a href="#Spring-MVC-SD" class="headerlink" title="Spring MVC - SD"></a>Spring MVC - SD</h1><h2 id="Spring-MVC-的页面参数回显"><a href="#Spring-MVC-的页面参数回显" class="headerlink" title="Spring MVC 的页面参数回显"></a>Spring MVC 的页面参数回显</h2><p><code>SpringMVC</code>使用<code>Model</code>对象，<code>Model</code>对象相当于<code>application</code>(注意：application对象中数据可以是EL表达式进行获取)。</p>
<h4 id="1-JSON数据交互"><a href="#1-JSON数据交互" class="headerlink" title="1.JSON数据交互"></a>1.JSON数据交互</h4><p>输入json串，输出是json串和输入key/value，输出是json串两种情况下的交互。</p>
<pre><code>1.添加JSON转换的依赖

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.7.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
    &lt;version&gt;1.9.13&lt;/version&gt;
&lt;/dependency&gt;

2.配置JSON转换器(在注解适配器中加入messageConverters)

&lt;!--注解适配器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;list&gt;
    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>注意：如果使用<a href="mvc:annnotation-driven/" target="_blank" rel="noopener">mvc:annnotation-driven/</a>注解便不需要上面的配置。</p>
</blockquote>
<pre><code>3.交互测试

&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;json交互测试&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //请求json，输出是json
        function requestJson(){     省略    }
        //请求key/value，输出是json
        function responseJson(){    省略    }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;
&lt;input type=&quot;button&quot; onclick=&quot;responseJson()&quot; value=&quot;请求key/value，输出是json&quot;/&gt;
&lt;/body&gt;
</code></pre><blockquote>
<p>4.Controller</p>
</blockquote>
<pre><code>//请求json串(商品信息)，输出json(商品信息)
//@RequestBody将请求的商品信息的json串转成itemsCustom对象
//@ResponseBody将itemsCustom转成json输出
@RequestMapping(&quot;/requestJson&quot;)
public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom){
    //@ResponseBody将itemsCustom转成json输出
    return itemsCustom;
}
</code></pre><blockquote>
<p>5.输入json串，输出json串</p>
</blockquote>
<pre><code>//使用jQuery的ajax方法提交json串，对输出的json结果进行解析
//jsp页面
//请求json，输出json
function requesetJson(){
    $.ajax({
        type:&apos;post&apos;,
        url:&apos;${pageContext.request.contextPath}/requestJson.action&apos;,
        contentType:&apos;application/json;charset=utf-8&apos;,
        //数据格式是json串
        data:&apos;{&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:&quot;255&quot;}&apos;,
        success:function(data){
            //操作成功返回结果
            alert(data);
        }  
    });
}
</code></pre><blockquote>
<p>6.输入key/value，输出是JSON串</p>
</blockquote>
<pre><code>//请求key/value，输出是json
function responseJson(){
    $.ajax({
        type:&apos;post&apos;,
        url:&apos;${pageContext.request.contextPath }/responseJson.action&apos;,
        //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型
        //contentType:&apos;application/json;charset=utf-8&apos;,
        //数据格式是json串，商品信息
        data:&apos;name=手机&amp;price=999&apos;,
        success:function(data){//返回json结果
            alert(data.name);
        }
    });
}

7.Controller
/请求key/value，输出json
@RequestMapping(&quot;/responseJson&quot;)
public @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom){
    //@ResponseBody将itemsCustom转成json输出
    return itemsCustom;
}
</code></pre><h4 id="2-数据回显"><a href="#2-数据回显" class="headerlink" title="2.数据回显"></a>2.数据回显</h4><p><strong>1.POJO数据回显方法(springmvc 默认对POJO对象进行回显)</strong><br><br>POJO数据传入Controller方法之后，springmvc自动将POJO数据放到request域，key等于POJO类型。使用<code>@ModelAttribute</code>指定POJO回显页面在request中的key。</p>
<p><strong>2.@ModelAttribute将返回值传到页面</strong><br></p>
<pre><code>// 商品分类
// itemtypes表示最终将方法返回值放在request中的key
@ModelAttribute(&quot;itemtypes&quot;)
public Map&lt;String, String&gt; getItemTypes() {
    Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;();
    itemTypes.put(&quot;101&quot;, &quot;数码&quot;);
    itemTypes.put(&quot;102&quot;, &quot;母婴&quot;);

    return itemTypes;
}

//页面上获得itemTypes数据
&lt;td&gt;
    商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt;
    商品类型：
    &lt;select name=&quot;itemtype&quot;&gt;
        &lt;c:forEach items=&quot;${itemtypes}&quot; var=&quot;itemtype&quot;&gt;
            &lt;option value=&quot;${itemtype.key }&quot;&gt;${itemtype.value }&lt;/option&gt;
        &lt;/c:forEach&gt;
    &lt;/select&gt;
&lt;/td&gt;
</code></pre><p><strong>3.简单类型数据回显</strong><br></p>
<pre><code>//这里使用最简单的方法：model
model.addAttribute(&quot;id&quot;,id);//参数回显
</code></pre><hr>
<h2 id="Spring-MVC-的URL模板映射"><a href="#Spring-MVC-的URL模板映射" class="headerlink" title="Spring MVC 的URL模板映射"></a>Spring MVC 的URL模板映射</h2><p>主要是为请求<code>restfull</code>(软件架构设计模式，请求更简洁、更安全，方便于搜索引擎收录)设计模式</p>
<blockquote>
<p>扩展：如果一个架构符合REST原则，就称它为RESTful架构。REST:表现层状态转化</p>
</blockquote>
<hr>
<h2 id="SpringMVC开发中Model的解释"><a href="#SpringMVC开发中Model的解释" class="headerlink" title="SpringMVC开发中Model的解释"></a>SpringMVC开发中Model的解释</h2><p>在<code>SpringMVC</code>开发中，<code>Model</code>是一种概念，而不是一种具体的参数或者是其他的具体的体现，<code>MVC</code>是软件工程中一种常见的规范的设计模式(model(模型层) view(视图层) Controller(控制层))</p>
<pre><code>1.Model(模型)包括：数据模型(POJO或Bean之类的东西)和业务逻辑(登录、注册操作等)，是用来从后台封装数据到页面的(后台定的实体类)。
</code></pre><blockquote>
<p>注意：POJO是一个域对象，用来接收并封装前台页面传递过来的数据。</p>
</blockquote>
<pre><code>2.Controller(控制)：使得Model层能在View层表示出来
</code></pre><h4 id="SpringMVC的model"><a href="#SpringMVC的model" class="headerlink" title="SpringMVC的model"></a>SpringMVC的model</h4><p>1.springmvc接收参数的时候可以自动注入<code>model</code>或者<code>modelAndView</code>这两个类 </p>
<pre><code>@RequestMapping(&quot;/aa&quot;)
public String aa(Model model) {
    model.addAttribute(&quot;key&quot;,&quot;value&quot;);
    return &quot;HH&quot;;
}
</code></pre><p>2.然后在页面中，这些value可以通过key取出来。这便就是简化了的<code>springmvc</code>的工作过程。</p>
<hr>
<p>3..RequestMapping</p>
<p>  注意：根路径就是用来隔离Controller里面的相同的方法</p>
<p>4.SpringMVC封装参数</p>
<blockquote>
<p>注意：SpringMVC没有成员变量，将需要传递参数对象放入方法中，当请求这个方法的时候，这个方法里面对象会被自动创建，需要封装的参数自动被封装到方法的对象中。</p>
</blockquote>
<hr>
<h2 id="Spring-MVC-的转发与重定向-springmvc-forward-redirect"><a href="#Spring-MVC-的转发与重定向-springmvc-forward-redirect" class="headerlink" title="Spring MVC 的转发与重定向(springmvc forward/redirect)"></a>Spring MVC 的转发与重定向(springmvc forward/redirect)</h2><p>语法：</p>
<pre><code>1.return &quot;forward:/index.do&quot;;//forward在跳转后可以去到值 forward跳转后地址栏URL不会改变
2.return &quot;redirect:/register.do&quot;;//redirect在跳转后无法取到值 redirect跳转后地址栏URL会改变
</code></pre><hr>
<h2 id="spring-mvc-的配置文件内容"><a href="#spring-mvc-的配置文件内容" class="headerlink" title="spring mvc 的配置文件内容"></a>spring mvc 的配置文件内容</h2><p><code>&lt;mvc:annotation-driven/&gt;</code>：默认创建多个对象 <code>RequestMappingHandlerMapping</code>(处理器映射器)/<code>RequestMappingHandlerAdapter</code>(处理器适配器)，默认提供<code>json</code>数据格式的支持。</p>
<blockquote>
<p>注意：以后在创建SpringMVC处理器映射器与适配器的时候可以直接使用<code>&lt;mvc:annnotation-driven/&gt;</code>作创建<code>springMVC</code>相关的操作。</p>
<blockquote>
<p>注意：<code>JavaBean</code>不能添加<code>@XmlRootElement</code>(这个只提供对xml的视图支持)</p>
</blockquote>
</blockquote>
<hr>
<p>注解@RequestBody、@ResponseBody</p>
<pre><code>1.@RequestBody作用：把前台页面传送json格式数据强制转换为JavaBean，可以将请求体中的JSON字符串绑定到响应的Bean上，也可以将其绑定在对应的字符串上面。

2.@ResponseBody作用：在后台将JavaBean转换成json格式的数据返回页面，是将Controller的方法返回的对象通过适当的转换器转换成指定的格式之后，写入到response对象的body区。
</code></pre><blockquote>
<p>注意：这两个注解不能直接使用，需要依赖于JACKson的jar包。</p>
</blockquote>
<p>开发实现步骤：</p>
<pre><code>1.导入jar包
  Jackson-core-asl-1.9.11.jar
  Jackson-mapper-asl-1.9.11.jar

2.配置json格式转换
  &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;bean class=&quot;MappingJacksonHttpMessageConverter.class&quot;&gt;
  &lt;/property&gt;
</code></pre><hr>
<h5 id="浅谈-RequestMapping-ResponseBody-和-RequestBody-注解的用法与区别"><a href="#浅谈-RequestMapping-ResponseBody-和-RequestBody-注解的用法与区别" class="headerlink" title="浅谈 @RequestMapping @ResponseBody 和 @RequestBody 注解的用法与区别"></a>浅谈 <code>@RequestMapping</code> <code>@ResponseBody</code> 和 <code>@RequestBody</code> 注解的用法与区别</h5><pre><code>1.@RequestMapping
  @RequestMapping是用来处理请求地址映射的注解，可用于类或方法上。
     用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；
  用于方法上，表示在类的父路径下追加方法上注解中的地址将会访问到该方法，此处需注意@RequestMapping用在类上可以没用，但是用在方法上必须有。

  例：原理也非常好了解，其对应的 action 就是“ （父路径） controller/（父路径下方法路经）method ”
  在类上注释的是@RequestMapping(value = &quot;/Controllers&quot;)
  在方法上注释的是 @RequestMapping(value = &quot;/method&quot;)
</code></pre><blockquote>
<p>注意： @PathVariable 注解，其用来获取请求路径（url）中的动态参数。</p>
</blockquote>
<pre><code>2.@ResponseBody
  @ResponseBody注解表示该方法的返回的结果直接写入 HTTP 响应正文（ResponseBody）中，一般在异步获取数据时使用，通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入HTTP 响应正文中。

  作用：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConvert转换为指定的格式后，写入到Response对象的body数据区
</code></pre><blockquote>
<p>注意：异步获取json数据，加上@Responsebody注解后，就会直接返回json数据</p>
</blockquote>
<pre><code>3.@RequestBody
  @RequestBody注解则是将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。

作用：

  1) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上。 
  2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。
</code></pre><hr>
<blockquote>
<p>@ResponseBody(将后台pojo转换成json对象，返回到页面)</p>
<blockquote>
<p>@RequestBody(接收前台json数据，将json数据自动封装到JavaBean)</p>
</blockquote>
</blockquote>
<p>上面两者的开发实现步骤：</p>
<pre><code>1.导入jar包（Jackson-core-asl-1.9.11.jar Jackson-mapper-asl-1.9.11.jar） 
2.修改springmvc.xml文件
  1.在springmvc.xml文件中的处理器适配器下配置我们的json转换对象(messageConverters)
    &lt;bean class=&quot;RequestMappingHandlerAdapter.class这个类&quot;&gt;
        &lt;property name=&quot;messageConverters&quot;&gt;
        &lt;bean class=&quot;MappingJacksonHttpMessageConverter这个类&quot;&gt;&lt;/bean&gt;//要转换的json格式的类数据
    &lt;/bean&gt;
3.页面传递json格式数据
  1.使用ajax传递json格式数据

4.自定义Controller类里面(后台)

  //1.请求json格式数据，返回json
  @RequestMapping(&quot;requestJson&quot;)
  public @ResponseBody(转换为json格式) User requestJson(@RequestBody(封装在user对象里面) User user){
        System.out.println(user);//测试user对象输出的值是否正确
        return user;
    }

  //2.跳转到RequestJson页面
  @RequestMapping(&quot;toJson&quot;)
  public String toJson(){
    return &quot;requestJson&quot;;
}

5.toJson.do(前台)

  1.首先引入在JSP页面引入js
    function requestJson(){
    //模拟json格式数据
    var jsonObj = JSON.stringify({&quot;username&quot;:&quot;张三&quot;，&quot;sex&quot;:&quot;男&quot;,&quot;address&quot;:&quot;东北那嘎达&quot;});

    $.ajax({
        type:&apos;POST&apos;,
        url:&apos;/springmvc19_day01_02/user/requestJson.do&apos;,
        contentType:&apos;qpplication/json;charset=utf-8&apos;,
        data:jsonObj,
        success:function(data){
            alert(data);
            }
        })
    }

另：请求Pojo，返回json
</code></pre><hr>
<h2 id="SpringMVC多视图"><a href="#SpringMVC多视图" class="headerlink" title="SpringMVC多视图"></a>SpringMVC多视图</h2><pre><code>开发步骤：
1.导入xml格式支持的jar包
spring-oxm-3.2.0.RELEASE.jar

2.配置springmvc.xml文件支持多视图
  &lt;bean class=&quot;ContentNegotiatingViewResolver这个对象的类&quot;&gt;
    //配置支持的媒体类型
    &lt;property name=&quot;contentNegotiationManager&quot;&gt;
        &lt;bean class=&quot;ContentNegotiationManagerFactory这个对象的类&quot;&gt;&lt;/bean&gt;
        &lt;property name=&quot;mediaTypes&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;json&quot; value=&quot;application/json&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;

    //指定默认视图
    &lt;property name=&quot;defaultViews&quot;&gt;
        //支持多个视图
        &lt;list&gt;
            //对json格式视图支持
            &lt;bean class=&quot;MappingJacksonJsonView这个类的URL&quot;&gt;&lt;/bean&gt;
            //对xml格式视图的支持
            &lt;bean class=&quot;MarshallingView这个类的URL&quot;&gt;
            &lt;constructor-arg&gt;
                &lt;bean class=&quot;Jaxb2Marshaller这个类URL&quot;&gt;
                    &lt;property name=&quot;classesToBeBound&quot;&gt;
                        &lt;list&gt;
                            &lt;value&gt; ... &lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/constructor-arg&gt;
        &lt;/list&gt;

    &lt;/property&gt;
  &lt;/bean&gt;


3.编写自定义UserController类
  @RequestMapping(&quot;multiView&quot;)
  public User multiView(){
    User user = new User();
    user1.setId(1);
    user1.setSex(&quot;男&quot;);
    user1.setUsername(&quot;张三丰&quot;);
    user1.setAddress(&quot;武当山&quot;);
    user1.setBirthday(new Date());

    return user1;

    }

4.访问
  约定rest目录下的所有以json和xml扩展名都支持相应的视图
</code></pre><hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><p>开发步骤：<br>    1.导入jar包(导入spring(包含springMVC)/mybatis/mybatis-spring整合)数据库驱动、JSTL、c3p0管理数据源、log4j。</p>
<pre><code>2.配置web.xml文件
</code></pre><p>后续添加…………….</p>
<hr>
<h2 id="Spring-MVC-的页面缓存"><a href="#Spring-MVC-的页面缓存" class="headerlink" title="Spring MVC 的页面缓存"></a>Spring MVC 的页面缓存</h2><p>使用Oscache实现页面缓存</p>
<p>测试页面缓存</p>
<pre><code>实现步骤：
    1.导入相关jar包
</code></pre><hr>
<blockquote>
<p>关于Controller里面的方法中的参数问题</p>
<blockquote>
<p>1.Model model</p>
</blockquote>
</blockquote>
<pre><code>model主要是用来传值的，与request、session的作用效果差不多

model的作用跟request的setAttribute(arg0,arg1)是一样的，都是把值或是对象进行一个保存，然后可以在视图上进行取值，同样都可以使用ognl表达式取值。

springmvc使用model的原因：
request只是一个请求，作用就是从客户端发起一个请求，并且携带客户端发起的这个请求所带的参数，在业务层中进行参数的获取并且做出相对应的处理，到这里这个request请求对象的工作就应该结束了，剩下的就是客户端对这个请求和参数做出处理结果并且生成响应response返回客户端。所以不应该用request进行存值，来达到模型层和视图层的一个连接，所以才使用model或是modelandview这个专门的对象来进行模型层的存在和视图层的取值model会在模型层进行存值，在视图层中，他会去检查model对象中是否用这个属性，有ta就会渲染出来，request请求结束后就会自动清除model的数据。
</code></pre><hr>
<blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>1.JSTL中&lt;c:forEach&gt;标签：forEach标签作用是做一个循环遍历使用

2.model.addAttribute()的作用：往前台传数据,可以传对象,可以传List,通过el表达式 ${}可以获取到，类似于request.setAttribute(&quot;sts&quot;,sts)效果一样

3.@ModelAttribute 用法：1.直接标记在方法上 2.标记在方法的参数上

4.@RequestParam(value=&quot;xxx&quot; required=false) 1.可以对传入参数指定参数名

5.可以通过required=false/true来要求@RequestParam配置的前端参数是否一定要传

6.如果@RequestParam注解的参数是int类型，并且required=false，此时如果不传参数的话会报错。
</code></pre><hr>
<h2 id="第11章-为Spring添加REST功能"><a href="#第11章-为Spring添加REST功能" class="headerlink" title="第11章 为Spring添加REST功能"></a>第11章 为Spring添加REST功能</h2><p>简洁的说<code>REST</code>就是将资源的状态以合适的形式从服务器端转移到客户端&lt;或者反之&gt;。<code>Spring 3</code>对<code>Spring MVC</code>的一些增强功能为<code>REST</code>提供了良好的支持。现在，Spring支持以下方式开发REST资源。</p>
<pre><code>1.控制器可以处理所有的HTTP方法，包括：get、put、delete和post方法

2.新的@PathVariable注解使得控制器能够处理参数化的URL(将变量输入作为URL的一部分)

3.Spring的表单绑定JSP标签库&lt;form:form&gt;标签以及新的HiddenHttpMethodFilter，使得通过HTML表单提交put和delete请求成为可能。

4.通过使用Spring的视图和视图解析器，资源可以以各种形式进行表述，包括将模型数据表现为：XML/JSON/ATOM/RSS的新视图实现。
</code></pre><hr>
<h2 id="Spring-MVC-TD"><a href="#Spring-MVC-TD" class="headerlink" title="Spring MVC - TD"></a>Spring MVC - TD</h2><h2 id="1-MVC概要"><a href="#1-MVC概要" class="headerlink" title="1.MVC概要"></a>1.MVC概要</h2><p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范，用一种将业务逻辑、数据、显示分离的方法组织代码。MVC主要作用是降低了视图与业务逻辑间的双向偶合。MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异</p>
<blockquote>
<p>注意：在WEB开发的早期，通常采用的是Model1(JSP兼顾View和Controller两种角色)，主要分为两层，视图层与模型层。而model2将项目分成三个部分，包括视图、控制、模型。</p>
</blockquote>
<hr>
<h2 id="2-控制器定义与-RequestMapping详解"><a href="#2-控制器定义与-RequestMapping详解" class="headerlink" title="2.控制器定义与@RequestMapping详解"></a>2.控制器定义与@RequestMapping详解</h2><p>控制器：提供访问应用程序的行为，通常通过服务接口定义或注解定义两种方式，控制器解析用户的请求并将其转换为一个模型。</p>
<blockquote>
<p>小结：实现接口Controller定义控制器是较老的办法，缺点是：一个控制器中只有一个Action，如果要多个Action则需要定义多个Controller。定义的方式比较麻烦。Spring 2.5以后采用注解的方式定义解决这些问题。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>@RequestMapping注释用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>路径变量占位、URI模板模式

    在SpringMVC中可是使用@PathVariable注释方法参数的值绑定到URI模板变量

    优点：使得路径名变得更加简洁，获得参数更加方便，框架会自动进行类型转换。
</code></pre><h2 id="3-请求处理方法Action详解"><a href="#3-请求处理方法Action详解" class="headerlink" title="3.请求处理方法Action详解"></a>3.请求处理方法Action详解</h2><p>1.Action参数类型</p>
<pre><code>@ModelAttribute模型特性

@ModelAttribute可以应用在方法参数上或方法上，他的作用主要是当注解在方法中时会将注解的参数对象添加到Model中；
当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会首先调用该方法。
</code></pre><blockquote>
<p>注意：boolean类型的值生成的get/set属性名称前是不带get与set的，这样会引起异常，建议手动修改。</p>
</blockquote>
<hr>
<h2 id="SpringMVC验证器Validator"><a href="#SpringMVC验证器Validator" class="headerlink" title="SpringMVC验证器Validator"></a>SpringMVC验证器Validator</h2><pre><code>SpringMVC验证器Validator是一个接口，通过实现该接口来定义对实体对象的验证。

1.验证器接口

    package org.springframework.validation;

    /**
     * Spring MVC内置的验证器接口
     */
    public interface Validator {

        /**
         * 是否可以验证该类型
         */
        boolean supports(Class&lt;?&gt; clazz);

        /**
         * 执行验证 target表示要验证的对象 error表示错误信息
         */
        void validate(Object target, Errors errors);
    }

2.定义验证器(实现该接口)

    package com.zhangguo.springmvc51.entities;

    import org.springframework.validation.Errors;
    import org.springframework.validation.ValidationUtils;
    import org.springframework.validation.Validator;

    /**
     * 产品验证器
     *
     */
    public class ProductValidator implements Validator {

        //当前验证器可以验证的类型，重写接口中的方法
        @Override
        public boolean supports(Class&lt;?&gt; clazz) {
            return Product.class.isAssignableFrom(clazz);
        }

        //执行校验，重写接口中的方法
        @Override
        public void validate(Object target, Errors errors) {
            //将要验证的对象转换成Product类型
            Product entity=(Product)target;
            //如果产品名称为空或为空格，使用工具类
            ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;name&quot;, &quot;required&quot;, &quot;产品名称必须填写&quot;);
            //价格，手动判断
            if(entity.getPrice()&lt;0){
                errors.rejectValue(&quot;price&quot;, &quot;product.price.gtZero&quot;, &quot;产品价格必须大于等于0&quot;);
            }
            //产品类型必须选择
            if(entity.getProductType().getId()==0){
                errors.rejectValue(&quot;productType.id&quot;, &quot;product.productType.id.required&quot;, &quot;请选择产品类型&quot;);
            }
        }

    }
</code></pre><blockquote>
<p>注意：ValidationUtils是一个工具类，中间有一些方法可以用于判断内容是否有误。</p>
</blockquote>
<pre><code>3.执行校验

    // 新增保存，如果新增成功转回列表页，如果失败回新增页，保持页面数据
    @RequestMapping(&quot;/addSave&quot;)
    public String addSave(Model model, Product product, BindingResult bindingResult) {

        // 创建一个产品验证器
        ProductValidator validator = new ProductValidator();
        // 执行验证，将验证的结果给bindingResult，该类型继承Errors
        validator.validate(product, bindingResult);

        // 获得所有的字段错误信息，非必要
        for (FieldError fielderror : bindingResult.getFieldErrors()) {
            System.out.println(fielderror.getField() + &quot;，&quot; + fielderror.getCode() + &quot;，&quot; + fielderror.getDefaultMessage());
        }

        // 是否存在错误，如果没有，执行添加
        if (!bindingResult.hasErrors()) {
            // 根据类型的编号获得类型对象
            product.setProductType(productTypeService.getProductTypeById(product.getProductType().getId()));
            productService.addProduct(product);
            return &quot;redirect:/&quot;;
        } else {
            // 与form绑定的模型
            model.addAttribute(&quot;product&quot;, product);
            // 用于生成下拉列表
            model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes());
            return &quot;product/add&quot;;
        }
    }
</code></pre><blockquote>
<p>注意：在参数中增加了一个BindingResult类型的对象，该类型继承自Errors，获得绑定结果，承载错误信息，该对象中有一些方法可以获得完整的错误信息，可以使用hasErrors方法判断是否产生了错误。</p>
</blockquote>
<pre><code>4.在UI中添加错误标签

    add.jsp
    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
    &lt;%@taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
    &lt;link href=&quot;styles/main.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;title&gt;新增产品&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;main&quot;&gt;
            &lt;h2 class=&quot;title&quot;&gt;&lt;span&gt;新增产品&lt;/span&gt;&lt;/h2&gt;
            &lt;form:form action=&quot;addSave&quot; modelAttribute=&quot;product&quot;&gt;
            &lt;fieldset&gt;
                &lt;legend&gt;产品&lt;/legend&gt;
                &lt;p&gt;
                    &lt;label for=&quot;name&quot;&gt;产品名称：&lt;/label&gt;
                    &lt;form:input path=&quot;name&quot;/&gt;
                    &lt;form:errors path=&quot;name&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt;
                &lt;/p&gt;
                &lt;p&gt;
                    &lt;label for=&quot;title&quot;&gt;产品类型：&lt;/label&gt;
                    &lt;form:select path=&quot;productType.id&quot;&gt;
                         &lt;form:option value=&quot;0&quot;&gt;--请选择--&lt;/form:option&gt;
                         &lt;form:options items=&quot;${productTypes}&quot;  itemLabel=&quot;name&quot; itemValue=&quot;id&quot;/&gt;
                    &lt;/form:select&gt;
                    &lt;form:errors path=&quot;productType.id&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt;
                &lt;/p&gt;
                &lt;p&gt;
                    &lt;label for=&quot;price&quot;&gt;产品价格：&lt;/label&gt;
                    &lt;form:input path=&quot;price&quot;/&gt;
                    &lt;form:errors path=&quot;price&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt;
                &lt;/p&gt;
                &lt;p&gt;
                  &lt;input type=&quot;submit&quot; value=&quot;保存&quot; class=&quot;btn out&quot;&gt;
                &lt;/p&gt;
            &lt;/fieldset&gt;
            &lt;/form:form&gt;
            &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt;
            &lt;p&gt;
                &lt;a href=&quot;&lt;c:url value=&quot;/&quot; /&gt;&quot;  class=&quot;abtn out&quot;&gt;返回列表&lt;/a&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre><hr>
<h2 id="JSR303验证器"><a href="#JSR303验证器" class="headerlink" title="JSR303验证器"></a>JSR303验证器</h2><p>JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。<br>JSR 303 – Bean Validation 是一个数据验证的规范。JSR303只是一个标准，是一验证规范，对这个标准的实现有：hibernate-validator，Apache BVal等。这里我们使用hibernate-validator实现校验。</p>
<hr>
<h2 id="使用jQuery扩展插件Validate实现前端校验"><a href="#使用jQuery扩展插件Validate实现前端校验" class="headerlink" title="使用jQuery扩展插件Validate实现前端校验"></a>使用jQuery扩展插件Validate实现前端校验</h2><p>jquery.validate是基于jQuery的一个B/S客户端验证插件，借助jQuery的优势，我们可以迅速验证一些常见的输入,大大提高了开发效率</p>
<pre><code>3.1、jQuery扩展插件validate—1基本使用方法 http://www.cnblogs.com/best/archive/2011/09/05/2167723.html
3.2、jQuery扩展插件validate—2通过参数设置验证规则 http://www.cnblogs.com/best/archive/2011/09/05/2167733.html
3.3、jQuery扩展插件validate—3通过参数设置错误信息 http://www.cnblogs.com/best/archive/2011/09/05/2167742.html
3.4、jQuery扩展插件validate—4设置错误提示的样式 http://www.cnblogs.com/best/archive/2011/09/05/2167756.html
3.5、jQuery扩展插件validate—5添加自定义验证方法 http://www.cnblogs.com/best/archive/2011/09/05/2167773.html
3.6、jQuery扩展插件validate—6radio、checkbox、select的验证 http://www.cnblogs.com/best/archive/2011/09/05/2167779.html
</code></pre><blockquote>
<p>注意：validate只是使验证变得方便，简单，本质还是使用js，不论多么强大的js验证，当用户把js禁用或使用机器直接发起请求时都不能确保数据的完整性，所有不要把希望寄托在客户端验证，个人认为每一个客户端验证都要服务器进行再次验证。</p>
</blockquote>
<hr>
<h2 id="Spring-MVC-的文件上传"><a href="#Spring-MVC-的文件上传" class="headerlink" title="Spring MVC 的文件上传"></a>Spring MVC 的文件上传</h2><p>在Spring MVC中有两种实现上传文件的办法，第一种是Servlet3.0以下的版本通过commons-fileupload与commons-io完成的通用上传，第二种是Servlet3.0以上的版本的Spring内置标准上传，不需借助第3方组件。通用上传也兼容Servlet3.0以上的版本。</p>
<pre><code>第一种方法编码上传步骤：
    1.添加上传依赖包
    2.编写上传页面
    3.修改配置文件，增加上传配置
      Spring MVC在默认情况下对文件上传的视图内容是不能解析的，要配置一个特别的解析器解析上传的内容，修改springmvc-servlet.xml配置文件
        springmvc-servlet.xml配置内容：
            &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
                    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt;//默认上传编码utf-8
                    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt;//上传最大限制
                    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt;//缓冲区大小
                &lt;/bean&gt;
    4.
</code></pre><hr>
<h2 id="FreeMark"><a href="#FreeMark" class="headerlink" title="FreeMark"></a>FreeMark</h2><p>FreeMarker是一款模板引擎，即一种基于模板和要改变的数据，并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算，之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据，而在模板之外可以专注于要展示什么数据。</p>
<h4 id="1-设置freemarker的配置文件"><a href="#1-设置freemarker的配置文件" class="headerlink" title="1.设置freemarker的配置文件"></a>1.设置freemarker的配置文件</h4><pre><code>&lt;!-- 设置freeMarker的配置文件路径 --&gt;
&lt;bean id=&quot;freemarkerConfiguration&quot;
    class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt;
    &lt;property name=&quot;location&quot; value=&quot;classpath:freemarker.properties&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;property name=&quot;freemarkerSettings&quot; ref=&quot;freemarkerConfiguration&quot; /&gt; 
    &lt;!--扫描.ftl的模板文件--&gt;
    &lt;property name=&quot;templateLoaderPath&quot;&gt;
        &lt;value&gt;/WEB-INF/freemarker/&lt;/value&gt;
    &lt;/property&gt;
    &lt;!--设置一些常用的全局变量--&gt;
    &lt;property name=&quot;freemarkerVariables&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;xml_escape&quot; value-ref=&quot;fmXmlEscape&quot; /&gt;
            &lt;entry key=&quot;webRoot&quot; value=&quot;/shop&quot;&gt;&lt;/entry&gt;  
            &lt;entry key=&quot;jsRoot&quot; value=&quot;/shop/js&quot;&gt;&lt;/entry&gt;   
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置freeMarker视图解析器 --&gt;
&lt;bean id=&quot;freemarkerViewResolver&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerView&quot; 
        /&gt;
    &lt;property name=&quot;viewNames&quot; value=&quot;*.ftl&quot; /&gt;
    &lt;property name=&quot;contentType&quot; value=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;&quot; /&gt;
 &lt;!--    &lt;property name=&quot;exposeRequestAttributes&quot; value=&quot;true&quot; /&gt;--&gt;
    &lt;!--&lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt;--&gt;
    &lt;!--&lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt; --&gt;
    &lt;property name=&quot;order&quot; value=&quot;0&quot; /&gt;
&lt;/bean&gt;
&lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀 通用解析器 --&gt;
&lt;bean id=&quot;viewResolver&quot;
    class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
    &lt;property name=&quot;viewNames&quot; value=&quot;*.html,*.jsp&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;&quot; /&gt;
    &lt;property name=&quot;viewClass&quot;
        value=&quot;org.springframework.web.servlet.view.InternalResourceView&quot; /&gt;
    &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><hr>
<h2 id="SpringMVC开发详解-总结"><a href="#SpringMVC开发详解-总结" class="headerlink" title="SpringMVC开发详解-总结"></a>SpringMVC开发详解-总结</h2><h4 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1.Controller"></a>1.Controller</h4><blockquote>
<p>注意1：在新建Controller之前应该首先建一个包，因为SpringMVC是没法再默认包下运行的</p>
<blockquote>
<p>注意2：类上的注解@RequestMapping(“/hi”)指定 Url路径前边一部分，方法上的注解@RequestMapping(“/say”)指定 Url路径最后一部分，也可以只把注解写在方法上，比如@RequestMapping(“/hi/say”)</p>
</blockquote>
</blockquote>
<h4 id="2-修改url-pattern-web-xml"><a href="#2-修改url-pattern-web-xml" class="headerlink" title="2.修改url-pattern(web.xml)"></a>2.修改url-pattern(web.xml)</h4><blockquote>
<p>注意：有关于ServletMapping的设置，通过这个设置，可以配置那些类型的url用那些servlet来处理<br>    在开发中我们发现IDEA默认配置一个Dispatcher的Servlet(这个servlet使用org.springframework.web.servlet.DispatcherServlet这个类来处理)，而这个servlet对应的url就是*.form</p>
</blockquote>
<h4 id="3-配置component-scan-dispatcher-servlet-xml"><a href="#3-配置component-scan-dispatcher-servlet-xml" class="headerlink" title="3.配置component-scan(dispatcher-servlet.xml)"></a>3.配置component-scan(dispatcher-servlet.xml)</h4><blockquote>
<p>注意：component-scan就是告诉Servlet去哪里找到相应的Controller</p>
</blockquote>
<h4 id="4-添加视图文件-jsp"><a href="#4-添加视图文件-jsp" class="headerlink" title="4.添加视图文件(.jsp)"></a>4.添加视图文件(.jsp)</h4><blockquote>
<p>注意：因为用户不能访问到WEB-INF路径下的资源，所以将创建好的view视图放在此路径下较安全</p>
</blockquote>
<h4 id="5-配置ViewResolver-dispatcher-servlet-xml"><a href="#5-配置ViewResolver-dispatcher-servlet-xml" class="headerlink" title="5.配置ViewResolver(dispatcher-servlet.xml)"></a>5.配置ViewResolver(dispatcher-servlet.xml)</h4><blockquote>
<p>注意：配置这一参数的原因是因为Controller中的返回值必须是View的绝对路径，所以在Controller中只想返回一个简写的话需要在dispatcher-servlet.xml文件中配置</p>
</blockquote>
<pre><code>&lt;!--指定视图解析器--&gt;
  &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
      &lt;!-- 视图的路径 --&gt;
      &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
      &lt;!-- 视图名称后缀  --&gt;
      &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
  &lt;/bean&gt;
</code></pre><blockquote>
<p>注意：记得修改完之后同步修改的Controller的返回值，不然又会报错404</p>
</blockquote>
<h4 id="6-通过Model向View传值"><a href="#6-通过Model向View传值" class="headerlink" title="6.通过Model向View传值"></a>6.通过Model向View传值</h4><pre><code>通过上面的操作已经完成了MVC中的VC了，所以M的修改开始
1.在Controller类里面修改
    package wormday.springmvc.helloworld;

    import org.springframework.stereotype.Controller;
    import org.springframework.ui.Model; // 这里导入了一个Model类
    import org.springframework.web.bind.annotation.RequestMapping;

    @Controller
    @RequestMapping(&quot;/hi&quot;)
    public class HiController {

            @RequestMapping(&quot;/say&quot;)
            public String say(Model model) { // 参数中传入Model
                model.addAttribute(&quot;name&quot;,&quot;wormday&quot;); // 指定Model的值
                model.addAttribute(&quot;url&quot;,&quot;http://www.cnblogs.com/wormday/p/8435617.html&quot;); // 指定Model的值
                    return &quot;say&quot;;
                    }
            }

2.然后打开View(.jsp)修改其中的值

    &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
    &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        hello world,${name}//添加上JSTL表达式
        &lt;br/&gt;${url}&lt;/body&gt;
    &lt;/html&gt;
</code></pre><h4 id="7-springMVC-Controller返回值的可选类型详解"><a href="#7-springMVC-Controller返回值的可选类型详解" class="headerlink" title="7.springMVC Controller返回值的可选类型详解"></a>7.springMVC Controller返回值的可选类型详解</h4><p><code>Spring MVC</code> 支持<code>ModelAndView/Model/ModelMap/Map/View/String/void</code>返回方式</p>
<pre><code>1.ModelAndView

    @RequestMapping(&quot;/hello&quot;)
      public ModelAndView helloWorld() { 
            String message = &quot;Hello World, Spring 3.x!&quot;;
            return new ModelAndView(&quot;hello&quot;, &quot;message&quot;, message);
      }

总结：通过ModelAndView构造方法可以指定返回页面的名称，同时也可以通过setViewName()方法跳转到指定页面

2.Map

    @RequestMapping(&quot;/demo2/show&quot;) 
      public Map&lt;String, String&gt; getMap() { 
            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); 
            map.put(&quot;key1&quot;, &quot;value-1&quot;); 
            map.put(&quot;key2&quot;, &quot;value-2&quot;); 
            return map; 
      }

总结：在前端页面.jsp页面中通过${key}获得到值，map.put()相当于request.setAttribute方法

3.View

    可以返回文件格式

4.String

    指定返回的视图页面名称，结合设置的返回地址路径加上页面名称后缀便能够访问到

    注意：如果方法上声明了注解@ResponseBody，那么就会直接将返回值输出到前端页面

    1.没有注解@ResponseBody的情况
      @RequestMapping(value=&quot;/showdog&quot;)
        public String hello1(){
            return &quot;hello&quot;;
        }

    2.在Controller控制器中有注解@ResponseBody的情况
      @RequestMapping(value=&quot;/print&quot;)
        @ResponseBody
        public String print(){
            String message = &quot;Hello World, Spring MVC!&quot;;
            return message;//返回前端结果输出界面处理  会直接将返回值输出到前端页面
        }

    3.在Controller控制器中有注解，返回JSON数据(使用Jackson)
      @RequestMapping(&quot;/load1&quot;)
        @ResponseBody
        public String load1(@RequestParam String name,@RequestParam String password) throws IOException{
            System.out.println(name+&quot; : &quot;+password); 
             //return name+&quot; : &quot;+password;
            MyDog dog=new MyDog();
            dog.setName(&quot;小哈&quot;);
            dog.setAge(&quot;1岁&quot;);
            dog.setColor(&quot;深灰&quot;);
            ObjectMapper objectMapper = new ObjectMapper();
            String jsonString=objectMapper.writeValueAsString(dog);
            System.out.println(jsonString);
            return jsonString;
      }

5.void

    如果返回值为空，那么响应的视图(View)页面对应为 访问地址

    @RequestMapping(&quot;/index&quot;)
      public void index() {
            return;//这里表示的返回值为空，那么响应的访问地址是浏览器中输入的访问地址
      }

    总结：所以其对应的逻辑视图名为&quot;index&quot;
</code></pre><blockquote>
<p>总结：</p>
<blockquote>
<p>1.String作为请求处理方法的返回值类型是比较通用的方法，因为这样的逻辑视图名不会和请求的URL绑定，具有很强的灵活性，而模型数据又可以通过ModelMap控制</p>
<blockquote>
<p>2.使用 void/map/Model 时，返回对应的逻辑视图名称真实url为：prefix前缀+视图名称 +suffix后缀组成</p>
<blockquote>
<p>3.使用String,ModelAndView返回视图名称可以不受请求的url绑定，ModelAndView可以设置返回的视图名称</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="Spring-MVC-FOD"><a href="#Spring-MVC-FOD" class="headerlink" title="Spring MVC - FOD"></a>Spring MVC - FOD</h2><h4 id="1-几种Spring-MVC-返回JSON数据比较"><a href="#1-几种Spring-MVC-返回JSON数据比较" class="headerlink" title="1.几种Spring MVC 返回JSON数据比较"></a>1.几种Spring MVC 返回JSON数据比较</h4><p>因为现阶段网站的前后端分离，所以让RESTful 接口开发成为后台开发的核心。JSON作为简单高效的数据交互格式是首选。Spring mvc 提供注解@ResponseBody协助处理返回数据格式，所以可以是JSON/XML</p>
<pre><code>1.后端的配置
  &lt;beans:bean id=&quot;jsonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
    &lt;beans:property name=&quot;supportedMediaTypes&quot;&gt;
        &lt;beans:list&gt;
            &lt;beans:value&gt;application/json;charset=UTF-8&lt;/beans:value&gt;
        &lt;/beans:list&gt;
    &lt;/beans:property&gt;
&lt;/beans:bean&gt;

2.返回格式的比较
  1.map格式

   public @ResponseBody Map&lt;String,Object&gt; getData() {
        return new HashMap&lt;String,Object&gt;;
   }
</code></pre><blockquote>
<p>注意：这种方式数据需要手动添加到map中。</p>
</blockquote>
<pre><code>2.业务类格式

  public @ResponseBody User getData() {
      return new User();
  }
  public @ResponseBody List&lt;User&gt; getData() {
      return new User();
  }
</code></pre><blockquote>
<p>注意：这种方式可以看出返回的业务数据类型，但是如果返回的数据有变动，那么需要变更业务类。</p>
</blockquote>
<pre><code>3.JSON格式

  //手动转换
  public @ResponseBody JSONObject getData(){  
      User user = userDao.getUser(); 
      JSONObject result = new JSONObject();
      result.put(&quot;id&quot;,user.getId());
      result.put(&quot;username&quot;,user.getUsername());
      if(user.getSex()==0){
          result.put(&quot;sex&quot;,&quot;男&quot;);
      }else{
          result.put(&quot;sex&quot;,&quot;女&quot;);
      }
      return result;
  }
  //自动转换
  public @ResponseBody JSONObject getData(){
      User user = userDao.getUser(); 
      JSONObject result = JSONObject.fromObject(user);
      return result;
  }
</code></pre><hr>
<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><h4 id="1-springmvc-xml配置文件-配置multipart类型解析器"><a href="#1-springmvc-xml配置文件-配置multipart类型解析器" class="headerlink" title="1.springmvc.xml配置文件(配置multipart类型解析器)"></a>1.springmvc.xml配置文件(配置multipart类型解析器)</h4><pre><code>&lt;!-- 文件上传 --&gt;
&lt;bean id=&quot;multipartResolver&quot;
      class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;
    &lt;property name=&quot;maxUploadSize&quot;&gt;
        &lt;value&gt;5242880&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2.添加依赖"></a>2.添加依赖</h4><pre><code>&lt;!-- 文件上传 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="3-创建图片虚拟目录存储图片"><a href="#3-创建图片虚拟目录存储图片" class="headerlink" title="3.创建图片虚拟目录存储图片"></a>3.创建图片虚拟目录存储图片</h4><h4 id="4-上传图片程序"><a href="#4-上传图片程序" class="headerlink" title="4.上传图片程序"></a>4.上传图片程序</h4><pre><code>1.页面
&lt;tr&gt;
    &lt;td&gt;商品图片&lt;/td&gt;
    &lt;td&gt;
        &lt;c:if test=&quot;${items.pic !=null}&quot;&gt;
            &lt;img src=&quot;/pic/${items.pic}&quot; width=100 height=100/&gt;
            &lt;br/&gt;
        &lt;/c:if&gt;
        &lt;input type=&quot;file&quot;  name=&quot;items_pic&quot;/&gt;
    &lt;/td&gt;
&lt;/tr&gt;

2.controller

@RequestMapping(&quot;/editItemsSubmit&quot;)
    public String editItemsSubmit(
            Model model,
            HttpServletRequest request,
            Integer id,
            @ModelAttribute(&quot;items&quot;)
            @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,
            BindingResult bindingResult,
            MultipartFile items_pic
    )throws Exception {
    //原始名称
    String originalFilename = items_pic.getOriginalFilename();
    //上传图片
    if(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0){

        //存储图片的物理路径
        String pic_path = &quot;D:\\tmp\\&quot;;


        //新的图片名称
        String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));
        //新图片
        File newFile = new File(pic_path+newFileName);

        //将内存中的数据写入磁盘
        items_pic.transferTo(newFile);

        //将新图片名称写到itemsCustom中
        itemsCustom.setPic(newFileName);

    }
</code></pre><hr>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/undefined/Spring%20Boot/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h1 id="Spring-Boot-入门"><a href="#Spring-Boot-入门" class="headerlink" title="Spring Boot 入门"></a>Spring Boot 入门</h1><h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><blockquote>
<p>简化Spring应用开发的一个框架；</p>
<p>整个Spring技术栈的一个大整合；</p>
<p>J2EE开发的一站式解决方案；</p>
</blockquote>
<h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>2014，martin fowler</p>
<p>微服务：架构风格（服务微化）</p>
<p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p>
<p>单体应用：ALL IN ONE</p>
<p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p>
<p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p>
<h2 id="3、环境准备"><a href="#3、环境准备" class="headerlink" title="3、环境准备"></a>3、环境准备</h2><p><a href="http://www.gulixueyuan.com/" target="_blank" rel="noopener">http://www.gulixueyuan.com/</a> 谷粒学院</p>
<p>环境约束</p>
<p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”</p>
<p>–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9</p>
<p>–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS</p>
<p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p>
<p>统一环境；</p>
<h3 id="1、MAVEN设置；"><a href="#1、MAVEN设置；" class="headerlink" title="1、MAVEN设置；"></a>1、MAVEN设置；</h3><p>给maven 的settings.xml配置文件的profiles标签添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、IDEA设置"><a href="#2、IDEA设置" class="headerlink" title="2、IDEA设置"></a>2、IDEA设置</h3><p>整合maven进来；</p>
<p><img src="images/搜狗截图20180129151045.png" alt="idea设置"></p>
<p><img src="images/搜狗截图20180129151112.png" alt="images/"></p>
<h2 id="4、Spring-Boot-HelloWorld"><a href="#4、Spring-Boot-HelloWorld" class="headerlink" title="4、Spring Boot HelloWorld"></a>4、Spring Boot HelloWorld</h2><p>一个功能：</p>
<p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p>
<h3 id="1、创建一个maven工程；（jar）"><a href="#1、创建一个maven工程；（jar）" class="headerlink" title="1、创建一个maven工程；（jar）"></a>1、创建一个maven工程；（jar）</h3><h3 id="2、导入spring-boot相关的依赖"><a href="#2、导入spring-boot相关的依赖" class="headerlink" title="2、导入spring boot相关的依赖"></a>2、导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、编写一个主程序；启动Spring-Boot应用"><a href="#3、编写一个主程序；启动Spring-Boot应用" class="headerlink" title="3、编写一个主程序；启动Spring Boot应用"></a>3、编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p>
<h2 id="5、Hello-World探究"><a href="#5、Hello-World探究" class="headerlink" title="5、Hello World探究"></a>5、Hello World探究</h2><h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure>
<p>Spring Boot的版本仲裁中心；</p>
<p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p>
<h4 id="2、启动器"><a href="#2、启动器" class="headerlink" title="2、启动器"></a>2、启动器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-boot-starter</strong>-==web==：</p>
<p>​    spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h3 id="2、主程序类，主入口类"><a href="#2、主程序类，主入口类" class="headerlink" title="2、主程序类，主入口类"></a>2、主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>
<p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p>
<p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p>
<p>​        @<strong>Configuration</strong>:配置类上来标注这个注解；</p>
<p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；@Component</p>
<p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p>
<p>​        以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>
<p>​          @<strong>AutoConfigurationPackage</strong>：自动配置包</p>
<p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p>
<p>​        Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p>
<p>==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==</p>
<p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p>
<p>​        给容器中导入组件？</p>
<p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p>
<p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p>
<p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        <img src="images/搜狗截图20180129224104.png" alt="自动配置类"></p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>
<p>​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p>
<p>==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p>
<p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p>
<p>​        </p>
<p>==Spring注解版（谷粒学院）==</p>
<h2 id="6、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#6、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="6、使用Spring Initializer快速创建Spring Boot项目"></a>6、使用Spring Initializer快速创建Spring Boot项目</h2><h3 id="1、IDEA：使用-Spring-Initializer快速创建项目"><a href="#1、IDEA：使用-Spring-Initializer快速创建项目" class="headerlink" title="1、IDEA：使用 Spring Initializer快速创建项目"></a>1、IDEA：使用 Spring Initializer快速创建项目</h3><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>
<p>默认生成的Spring Boot项目；</p>
<ul>
<li>主程序已经生成好了，我们只需要我们自己的逻辑</li>
<li>resources文件夹中目录结构<ul>
<li>static：保存所有的静态资源； js css  images；</li>
<li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li>
<li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li>
</ul>
</li>
</ul>
<h3 id="2、STS使用-Spring-Starter-Project快速创建项目"><a href="#2、STS使用-Spring-Starter-Project快速创建项目" class="headerlink" title="2、STS使用 Spring Starter Project快速创建项目"></a>2、STS使用 Spring Starter Project快速创建项目</h3><hr>
<h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p>
<p>•application.properties</p>
<p>•application.yml</p>
<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p>
<p>YAML（YAML Ain’t Markup Language）</p>
<p>​    YAML  A Markup Language：是一个标记语言</p>
<p>​    YAML   isn’t Markup Language：不是一个标记语言；</p>
<p>标记语言：</p>
<p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p>
<p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p>
<p>​    YAML：配置例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p>​    XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、YAML语法："><a href="#2、YAML语法：" class="headerlink" title="2、YAML语法："></a>2、YAML语法：</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p>
<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>
<p>属性和值也是大小写敏感；</p>
<h3 id="2、值的写法"><a href="#2、值的写法" class="headerlink" title="2、值的写法"></a>2、值的写法</h3><h4 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h4><p>​    k: v：字面直接来写；</p>
<p>​        字符串默认不用加上单引号或者双引号；</p>
<p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
<p>​                name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p>
<p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p>​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p>
<h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p>
<p>​        对象还是k: v的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">		<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">		<span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><p>用- 值表示数组中的一个元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure>
<h2 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h2><p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">    lastName:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">    boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">    maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">    lists:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">    dog:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">      age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>javaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>
<p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1、properties配置文件在idea中默认utf-8可能会乱码"><a href="#1、properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="1、properties配置文件在idea中默认utf-8可能会乱码"></a>1、properties配置文件在idea中默认utf-8可能会乱码</h4><p>调整</p>
<p><img src="images/搜狗截图20180130161620.png" alt="idea配置乱码"></p>
<h4 id="2、-Value获取值和-ConfigurationProperties获取值比较"><a href="#2、-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="2、@Value获取值和@ConfigurationProperties获取值比较"></a>2、@Value获取值和@ConfigurationProperties获取值比较</h4><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>配置文件yml还是properties他们都能获取到值；</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>
<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>
<h4 id="3、配置文件注入值数据校验"><a href="#3、配置文件注入值数据校验" class="headerlink" title="3、配置文件注入值数据校验"></a>3、配置文件注入值数据校验</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>
<h4 id="4、-PropertySource-amp-ImportResource-amp-Bean"><a href="#4、-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="4、@PropertySource&amp;@ImportResource&amp;@Bean"></a>4、@PropertySource&amp;@ImportResource&amp;@Bean</h4><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure>
<p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>
<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure>
<p>不来编写Spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>
<p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p>
<p>2、使用<strong>@Bean</strong>给容器中添加组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、配置文件占位符"><a href="#4、配置文件占位符" class="headerlink" title="4、配置文件占位符"></a>4、配置文件占位符</h2><h3 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、占位符获取之前配置的值，如果没有可以是用-指定默认值"><a href="#2、占位符获取之前配置的值，如果没有可以是用-指定默认值" class="headerlink" title="2、占位符获取之前配置的值，如果没有可以是用:指定默认值"></a>2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.birth=2017/12/15</span><br><span class="line">person.boss=false</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=14</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;_dog</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure>
<h2 id="5、Profile"><a href="#5、Profile" class="headerlink" title="5、Profile"></a>5、Profile</h2><h3 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p>
<p>默认使用application.properties的配置；</p>
<h3 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure>
<h3 id="3、激活指定profile"><a href="#3、激活指定profile" class="headerlink" title="3、激活指定profile"></a>3、激活指定profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p>
<p>​    2、命令行：</p>
<p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p>
<p>​        可以直接在测试的时候，配置传入命令行参数</p>
<p>​    3、虚拟机参数；</p>
<p>​        -Dspring.profiles.active=dev</p>
<h2 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<p>–file:./config/</p>
<p>–file:./</p>
<p>–classpath:/config/</p>
<p>–classpath:/</p>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>
<p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p>
<p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties</p>
<h2 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h2><p><strong>==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置==</strong></p>
<p><strong>1.命令行参数</strong></p>
<p>所有的配置都可以在命令行上进行指定</p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p>
<p>多个配置用空格分开； –配置项=值</p>
<p>2.来自java:comp/env的JNDI属性</p>
<p>3.Java系统属性（System.getProperties()）</p>
<p>4.操作系统环境变量</p>
<p>5.RandomValuePropertySource配置的random.*属性值</p>
<p>==<strong>由jar包外向jar包内进行寻找；</strong>==</p>
<p>==<strong>优先加载带profile</strong>==</p>
<p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p>==<strong>再来加载不带profile</strong>==</p>
<p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p>10.@Configuration注解类上的@PropertySource</p>
<p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p>
<p>所有支持的配置加载来源；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p>
<h2 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p>
<h3 id="1、自动配置原理："><a href="#1、自动配置原理：" class="headerlink" title="1、自动配置原理："></a>1、<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</p>
<p><strong>2）、@EnableAutoConfiguration 作用：</strong></p>
<ul>
<li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li>
</ul>
<ul>
<li><p>可以查看selectImports()方法的内容；</p>
</li>
<li><p>List<string> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</string></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line">扫描所有jar包类路径下  META-INF/spring.factories</span><br><span class="line">把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
<p><strong>==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties.class)  <span class="comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)  <span class="comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter.class) <span class="comment">//判断容器没有这个组件？</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>精髓：</strong></p>
<p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p>
<p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p>
<p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p>
<p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p>
<p>xxxxAutoConfigurartion：自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
<h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><h4 id="1、-Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#1、-Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="1、@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
<p><strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p>我们怎么知道哪些自动配置类生效；</p>
<p><strong>==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h1><h2 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h2><p> 小张；开发一个大型系统；</p>
<p>​        1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p>
<p>​        2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p>
<p>​        3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p>
<p>​        4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p>
<p>​        5、JDBC—数据库驱动；</p>
<p>​            写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p>
<p>​            给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p>
<p><strong>市面上的日志框架；</strong></p>
<p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p>
<table>
<thead>
<tr>
<th>日志门面  （日志的抽象层）</th>
<th>日志实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td>
<td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td>
</tr>
</tbody>
</table>
<p>左边选一个门面（抽象层）、右边来选一个实现；</p>
<p>日志门面：  SLF4J；</p>
<p>日志实现：Logback；</p>
<p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p>
<p>​    <strong>==SpringBoot选用 SLF4j和logback；==</strong></p>
<h2 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h2><h3 id="1、如何在系统中使用SLF4j-https-www-slf4j-org"><a href="#1、如何在系统中使用SLF4j-https-www-slf4j-org" class="headerlink" title="1、如何在系统中使用SLF4j   https://www.slf4j.org"></a>1、如何在系统中使用SLF4j   <a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p>
<p>给系统里面导入slf4j的jar和  logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示；</p>
<p><img src="images/concrete-bindings.png" alt="images/concrete-bindings.png"></p>
<p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p>
<h3 id="2、遗留问题"><a href="#2、遗留问题" class="headerlink" title="2、遗留问题"></a>2、遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p>
<p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p>
<p><img src="images/legacy.png" alt=""></p>
<p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p>
<p>==1、将系统中其他日志框架先排除出去；==</p>
<p>==2、用中间包来替换原有的日志框架；==</p>
<p>==3、我们导入slf4j其他的实现==</p>
<h2 id="3、SpringBoot日志关系"><a href="#3、SpringBoot日志关系" class="headerlink" title="3、SpringBoot日志关系"></a>3、SpringBoot日志关系</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot使用它来做日志功能；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>底层依赖关系</p>
<p><img src="images/搜狗截图20180131220946.png" alt=""></p>
<p>总结：</p>
<p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p>
<p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p>
<p>​    3）、中间替换包？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure>
<p><img src="images/搜狗截图20180131221411.png" alt=""></p>
<p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p>
<p>​            Spring框架用的是commons-logging；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==</strong></p>
<h2 id="4、日志使用；"><a href="#4、日志使用；" class="headerlink" title="4、日志使用；"></a>4、日志使用；</h2><h3 id="1、默认配置"><a href="#1、默认配置" class="headerlink" title="1、默认配置"></a>1、默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//日志的级别；</span></span><br><span class="line">	<span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">	<span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">	logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">	logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line">	<span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">	logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">	logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">	logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>日志输出格式：
    %d表示日期时间，
    %thread表示线程名，
    %-5level：级别从左显示5个字符宽度
    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
    %msg：日志消息，
    %n是换行符
--&gt;
%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
</code></pre><p>SpringBoot修改日志的默认配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.level.com.atguigu=trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#logging.path=</span><br><span class="line"># 不指定路径在当前项目下生成springboot.log日志</span><br><span class="line"># 可以指定完整的路径；</span><br><span class="line">#logging.file=G:/springboot.log</span><br><span class="line"></span><br><span class="line"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><br><span class="line">logging.path=/spring/log</span><br><span class="line"></span><br><span class="line">#  在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中日志输出的格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td>my.log</td>
<td>输出日志到my.log文件</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>/var/log</td>
<td>输出到指定目录的 spring.log 文件中</td>
</tr>
</tbody>
</table>
<h3 id="2、指定配置"><a href="#2、指定配置" class="headerlink" title="2、指定配置"></a>2、指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody>
</table>
<p>logback.xml：直接就被日志框架识别了；</p>
<p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  	可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">			%d表示日期时间，</span></span><br><span class="line"><span class="comment">			%thread表示线程名，</span></span><br><span class="line"><span class="comment">			%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">			%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">			%msg：日志消息，</span></span><br><span class="line"><span class="comment">			%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p>
<p> <code>no applicable action for [springProfile]</code></p>
<h2 id="5、切换日志框架"><a href="#5、切换日志框架" class="headerlink" title="5、切换日志框架"></a>5、切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p>
<p>slf4j+log4j的方式；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>切换为log4j2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发"></a>四、Web开发</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>使用SpringBoot；</p>
<p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p>
<p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></p>
<p><strong>3）、自己编写业务代码；</strong></p>
<p><strong>自动配置原理？</strong></p>
<p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxxxAutoConfiguration：帮我们给容器中自动配置组件；</span><br><span class="line">xxxxProperties:配置类来封装配置文件的内容；</span><br></pre></td></tr></table></figure>
<h2 id="2、SpringBoot对静态资源的映射规则；"><a href="#2、SpringBoot对静态资源的映射规则；" class="headerlink" title="2、SpringBoot对静态资源的映射规则；"></a>2、SpringBoot对静态资源的映射规则；</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebMvcAuotConfiguration：</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">		String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">         	<span class="comment">//静态资源文件夹映射</span></span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(staticPathPattern)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置欢迎页映射</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line">				<span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//配置喜欢的图标</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">			mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">             	<span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">			mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">					faviconRequestHandler()));</span><br><span class="line">			<span class="keyword">return</span> mapping;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">			requestHandler</span><br><span class="line">					.setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line">			<span class="keyword">return</span> requestHandler;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；==</p>
<p>​    webjars：以jar包的方式引入静态资源；</p>
<p><a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></p>
<p><img src="images/搜狗截图20180203181751.png" alt=""></p>
<p>localhost:8080/webjars/jquery/3.3.1/jquery.js</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jquery-webjar--&gt;</span>在访问的时候只需要写webjars下面资源的名称即可</span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot; </span><br><span class="line">&quot;/&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure>
<p>localhost:8080/abc ===  去静态资源文件夹里面找abc</p>
<p>==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；==</p>
<p>​    localhost:8080/   找index页面</p>
<p>==4）、所有的 **/favicon.ico  都是在静态资源文件下找；==</p>
<h2 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf</p>
<p><img src="images/template-engine.png" alt=""></p>
<p>SpringBoot推荐的Thymeleaf；</p>
<p>语法更简单，功能更强大；</p>
<h3 id="1、引入thymeleaf；"><a href="#1、引入thymeleaf；" class="headerlink" title="1、引入thymeleaf；"></a>1、引入thymeleaf；</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          	2.1.6</span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">切换thymeleaf版本</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、Thymeleaf使用"><a href="#2、Thymeleaf使用" class="headerlink" title="2、Thymeleaf使用"></a>2、Thymeleaf使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line">  	<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p>
<p>使用：</p>
<p>1、导入thymeleaf的名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、使用thymeleaf语法；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h3><p>1）、th:text；改变当前元素里面的文本内容；</p>
<p>​    th：任意html属性；来替换原生属性的值</p>
<p><img src="images/2018-02-04_123955.png" alt=""></p>
<p>2）、表达式？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Simple expressions:（表达式语法）</span><br><span class="line">    Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；</span><br><span class="line">    		1）、获取对象的属性、调用方法</span><br><span class="line">    		2）、使用内置的基本对象：</span><br><span class="line">    			#ctx : the context object.</span><br><span class="line">    			#vars: the context variables.</span><br><span class="line">                #locale : the context locale.</span><br><span class="line">                #request : (only in Web Contexts) the HttpServletRequest object.</span><br><span class="line">                #response : (only in Web Contexts) the HttpServletResponse object.</span><br><span class="line">                #session : (only in Web Contexts) the HttpSession object.</span><br><span class="line">                #servletContext : (only in Web Contexts) the ServletContext object.</span><br><span class="line">                </span><br><span class="line">                $&#123;session.foo&#125;</span><br><span class="line">            3）、内置的一些工具对象：</span><br><span class="line">#execInfo : information about the template being processed.</span><br><span class="line">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span><br><span class="line">#uris : methods for escaping parts of URLs/URIs</span><br><span class="line">#conversions : methods for executing the configured conversion service (if any).</span><br><span class="line">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span><br><span class="line">#calendars : analogous to #dates , but for java.util.Calendar objects.</span><br><span class="line">#numbers : methods for formatting numeric objects.</span><br><span class="line">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span><br><span class="line">#objects : methods for objects in general.</span><br><span class="line">#bools : methods for boolean evaluation.</span><br><span class="line">#arrays : methods for arrays.</span><br><span class="line">#lists : methods for lists.</span><br><span class="line">#sets : methods for sets.</span><br><span class="line">#maps : methods for maps.</span><br><span class="line">#aggregates : methods for creating aggregates on arrays or collections.</span><br><span class="line">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span><br><span class="line"></span><br><span class="line">    Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span><br><span class="line">    	补充：配合 th:object=&quot;$&#123;session.user&#125;：</span><br><span class="line">   &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;</span><br><span class="line">    &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    Message Expressions: #&#123;...&#125;：获取国际化内容</span><br><span class="line">    Link URL Expressions: @&#123;...&#125;：定义URL；</span><br><span class="line">    		@&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125;</span><br><span class="line">    Fragment Expressions: ~&#123;...&#125;：片段引用表达式</span><br><span class="line">    		&lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;</span><br><span class="line">    		</span><br><span class="line">Literals（字面量）</span><br><span class="line">      Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,…</span><br><span class="line">      Number literals: 0 , 34 , 3.0 , 12.3 ,…</span><br><span class="line">      Boolean literals: true , false</span><br><span class="line">      Null literal: null</span><br><span class="line">      Literal tokens: one , sometext , main ,…</span><br><span class="line">Text operations:（文本操作）</span><br><span class="line">    String concatenation: +</span><br><span class="line">    Literal substitutions: |The name is $&#123;name&#125;|</span><br><span class="line">Arithmetic operations:（数学运算）</span><br><span class="line">    Binary operators: + , - , * , / , %</span><br><span class="line">    Minus sign (unary operator): -</span><br><span class="line">Boolean operations:（布尔运算）</span><br><span class="line">    Binary operators: and , or</span><br><span class="line">    Boolean negation (unary operator): ! , not</span><br><span class="line">Comparisons and equality:（比较运算）</span><br><span class="line">    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br><span class="line">    Equality operators: == , != ( eq , ne )</span><br><span class="line">Conditional operators:条件运算（三元运算符）</span><br><span class="line">    If-then: (if) ? (then)</span><br><span class="line">    If-then-else: (if) ? (then) : (else)</span><br><span class="line">    Default: (value) ?: (defaultvalue)</span><br><span class="line">Special tokens:</span><br><span class="line">    No-Operation: _</span><br></pre></td></tr></table></figure>
<h2 id="4、SpringMVC自动配置"><a href="#4、SpringMVC自动配置" class="headerlink" title="4、SpringMVC自动配置"></a>4、SpringMVC自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p>
<h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li>
<li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li>
<li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p>
</li>
<li><p>Static <code>index.html</code> support. 静态首页访问</p>
</li>
<li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p>
<p>​</p>
</li>
<li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li>
<li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"date-format"</span>)<span class="comment">//在文件中配置日期格式化的规则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Formatter&lt;Date&gt; <span class="title">dateFormatter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DateFormatter(<span class="keyword">this</span>.mvcProperties.getDateFormat());<span class="comment">//日期格式化组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p>
<ul>
<li><p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p>
</li>
<li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p>
<p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化WebDataBinder；</span><br><span class="line">请求数据=====JavaBean；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==</strong>;</p>
<p>既保留了所有的自动配置，也能用我们扩展的配置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p>
<p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">     <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">             <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">           	<span class="comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span></span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line">             <span class="comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span></span><br><span class="line">              <span class="comment">//       delegate.addViewControllers(registry);</span></span><br><span class="line">              <span class="comment">//   &#125;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p>
<p>​    4）、我们的配置类也会被调用；</p>
<p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p>
<h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p>
<p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<p>为什么@EnableWebMvc自动配置就失效了；</p>
<p>1）@EnableWebMvc的核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br></pre></td></tr></table></figure>
<p>2）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>3）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class,</span><br><span class="line">		WebMvcConfigurerAdapter.class &#125;)</span><br><span class="line"><span class="comment">//容器中没有这个组件的时候，这个自动配置类才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration.class,</span><br><span class="line">		ValidationAutoConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p>
<h2 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h2><p>模式：</p>
<p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p>
<p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>
<h2 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h2><h3 id="1）、默认访问首页"><a href="#1）、默认访问首页" class="headerlink" title="1）、默认访问首页"></a>1）、默认访问首页</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="comment">//@EnableWebMvc   不要接管SpringMVC</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">                registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、国际化"><a href="#2）、国际化" class="headerlink" title="2）、国际化"></a>2）、国际化</h3><p><strong>1）、编写国际化配置文件；</strong></p>
<p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3）、在页面使用fmt:message取出国际化内容</p>
<p>步骤：</p>
<p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p>
<p><img src="images/搜狗截图20180211130721.png" alt=""></p>
<p>2）、SpringBoot自动配置好了管理国际化资源文件的组件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Comma-separated list of basenames (essentially a fully-qualified classpath</span></span><br><span class="line"><span class="comment">	 * location), each following the ResourceBundle convention with relaxed support for</span></span><br><span class="line"><span class="comment">	 * slash based locations. If it doesn't contain a package qualifier (such as</span></span><br><span class="line"><span class="comment">	 * "org.mypackage"), it will be resolved from the classpath root.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String basename = <span class="string">"messages"</span>;  </span><br><span class="line">    <span class="comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.basename)) &#123;</span><br><span class="line">            <span class="comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span></span><br><span class="line">			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">					StringUtils.trimAllWhitespace(<span class="keyword">this</span>.basename)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">			messageSource.setDefaultEncoding(<span class="keyword">this</span>.encoding.name());</span><br><span class="line">		&#125;</span><br><span class="line">		messageSource.setFallbackToSystemLocale(<span class="keyword">this</span>.fallbackToSystemLocale);</span><br><span class="line">		messageSource.setCacheSeconds(<span class="keyword">this</span>.cacheSeconds);</span><br><span class="line">		messageSource.setAlwaysUseMessageFormat(<span class="keyword">this</span>.alwaysUseMessageFormat);</span><br><span class="line">		<span class="keyword">return</span> messageSource;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>3）、去页面获取国际化的值；</p>
<p><img src="images/搜狗截图20180211134506.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/bootstrap.min.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/signin.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/asserts/css/signin.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-signin"</span> <span class="attr">action</span>=<span class="string">"dashboard.html"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"mb-4"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/asserts/img/bootstrap-solid.svg&#125;"</span> <span class="attr">src</span>=<span class="string">"asserts/img/bootstrap-solid.svg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"72"</span> <span class="attr">height</span>=<span class="string">"72"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h3 mb-3 font-weight-normal"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.tip&#125;"</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.username&#125;"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.username&#125;"</span> <span class="attr">required</span>=<span class="string">""</span> <span class="attr">autofocus</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.password&#125;"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.password&#125;"</span> <span class="attr">required</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox mb-3"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">          		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"remember-me"</span>/&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-lg btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.btn&#125;"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"mt-5 mb-3 text-muted"</span>&gt;</span>© 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：根据浏览器语言设置的信息切换了国际化；</p>
<p>原理：</p>
<p>​    国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"locale"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties</span><br><span class="line">					.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">			&#125;</span><br><span class="line">			AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">			localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">			<span class="keyword">return</span> localeResolver;</span><br><span class="line">		&#125;</span><br><span class="line">默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br></pre></td></tr></table></figure>
<p>4）、点击链接切换国际化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以在连接上携带区域信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String l = request.getParameter(<span class="string">"l"</span>);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(l))&#123;</span><br><span class="line">            String[] split = l.split(<span class="string">"_"</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> Locale(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）、登陆"><a href="#3）、登陆" class="headerlink" title="3）、登陆"></a>3）、登陆</h3><p>开发期间模板引擎页面修改以后，要实时生效</p>
<p>1）、禁用模板引擎的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 禁用缓存</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure>
<p>2）、页面修改完成以后ctrl+f9：重新编译；</p>
<p>登陆错误消息的显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4）、拦截器进行登陆检查"><a href="#4）、拦截器进行登陆检查" class="headerlink" title="4）、拦截器进行登陆检查"></a>4）、拦截器进行登陆检查</h3><p>拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆检查，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标方法执行之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"loginUser"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//未登陆，返回登陆页面</span></span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"没有权限请先登陆"</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/index.html"</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已登陆，放行请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">  <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">              registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/main.html"</span>).setViewName(<span class="string">"dashboard"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//注册拦截器</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">              <span class="comment">//静态资源；  *.css , *.js</span></span><br><span class="line">              <span class="comment">//SpringBoot已经做好了静态资源映射</span></span><br><span class="line">              registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                      .excludePathPatterns(<span class="string">"/index.html"</span>,<span class="string">"/"</span>,<span class="string">"/user/login"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5）、CRUD-员工列表"><a href="#5）、CRUD-员工列表" class="headerlink" title="5）、CRUD-员工列表"></a>5）、CRUD-员工列表</h3><p>实验要求：</p>
<p>1）、RestfulCRUD：CRUD满足Rest风格；</p>
<p>URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作</p>
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD（uri来区分操作）</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询</td>
<td>getEmp</td>
<td>emp—GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp—POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id=xxx&amp;xxx=xx</td>
<td>emp/{id}—PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id=1</td>
<td>emp/{id}—DELETE</td>
</tr>
</tbody>
</table>
<p>2）、实验的请求架构;</p>
<table>
<thead>
<tr>
<th>实验功能</th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工(来到修改页面)</td>
<td>emp/1</td>
<td>GET</td>
</tr>
<tr>
<td>来到添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>来到修改页面（查出员工进行信息回显）</td>
<td>emp/1</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/1</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<p>3）、员工列表：</p>
<h4 id="thymeleaf公共页面元素抽取"><a href="#thymeleaf公共页面元素抽取" class="headerlink" title="thymeleaf公共页面元素抽取"></a>thymeleaf公共页面元素抽取</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、抽取公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2、引入公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"~&#123;footer :: copy&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">~&#123;templatename::selector&#125;：模板名::选择器</span><br><span class="line">~&#123;templatename::fragmentname&#125;:模板名::片段名</span><br><span class="line"></span><br><span class="line">3、默认效果：</span><br><span class="line">insert的公共片段在div标签中</span><br><span class="line">如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：</span><br><span class="line">行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；</span><br></pre></td></tr></table></figure>
<p>三种引入公共片段的th属性：</p>
<p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p>
<p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p>
<p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引入方式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:include</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    &amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入片段的时候传入参数： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"col-md-2 d-none d-md-block bg-light sidebar"</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar-sticky"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav flex-column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link active"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">th:class</span>=<span class="string">"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/main.html&#125;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"24"</span> <span class="attr">height</span>=<span class="string">"24"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 24 24"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"currentColor"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke-linecap</span>=<span class="string">"round"</span> <span class="attr">stroke-linejoin</span>=<span class="string">"round"</span> <span class="attr">class</span>=<span class="string">"feather feather-home"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"9 22 9 12 15 12 15 22"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Dashboard <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入侧边栏;传入参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"commons/bar::#sidebar(activeUri='emps')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6）、CRUD-员工添加"><a href="#6）、CRUD-员工添加" class="headerlink" title="6）、CRUD-员工添加"></a>6）、CRUD-员工添加</h3><p>添加页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>5<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提交的数据格式不对：生日：日期；</p>
<p>2017-12-12；2017/12/12；2017.12.12；</p>
<p>日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;</p>
<p>2017-12-12—Date； 类型转换，格式化;</p>
<p>默认日期是按照/的方式；</p>
<h3 id="7）、CRUD-员工修改"><a href="#7）、CRUD-员工修改" class="headerlink" title="7）、CRUD-员工修改"></a>7）、CRUD-员工修改</h3><p>修改添加二合一表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要区分是员工修改还是添加；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/emp&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发送put请求修改员工数据--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）</span></span><br><span class="line"><span class="comment">2、页面创建一个post表单</span></span><br><span class="line"><span class="comment">3、创建一个input项，name="_method";值就是我们指定的请求方式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"put"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--提交的是部门的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"department.id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:selected</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;dept.id&#125;"</span> <span class="attr">th:each</span>=<span class="string">"dept:$&#123;depts&#125;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;dept.departmentName&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"birth"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp!=null&#125;?'修改':'添加'"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="8）、CRUD-员工删除"><a href="#8）、CRUD-员工删除" class="headerlink" title="8）、CRUD-员工删除"></a>8）、CRUD-员工删除</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"emp:$&#123;emps&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;emp.lastName&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.email&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.gender&#125;==0?'女':'男'"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.department.departmentName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-primary"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:attr</span>=<span class="string">"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-danger deleteBtn"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">".deleteBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//删除当前员工的</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#deleteEmpForm"</span>).attr(<span class="string">"action"</span>,$(<span class="keyword">this</span>).attr(<span class="string">"del_uri"</span>)).submit();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="7、错误处理机制"><a href="#7、错误处理机制" class="headerlink" title="7、错误处理机制"></a>7、错误处理机制</h2><h3 id="1）、SpringBoot默认的错误处理机制"><a href="#1）、SpringBoot默认的错误处理机制" class="headerlink" title="1）、SpringBoot默认的错误处理机制"></a>1）、SpringBoot默认的错误处理机制</h3><p>默认效果：</p>
<p>​        1）、浏览器，返回一个默认的错误页面</p>
<p><img src="images/搜狗截图20180226173408.png" alt=""></p>
<p>  浏览器发送请求的请求头：</p>
<p><img src="images/搜狗截图20180226180347.png" alt=""></p>
<p>​        2）、如果是其他客户端，默认响应一个json数据</p>
<p><img src="images/搜狗截图20180226173527.png" alt=""></p>
<p>​        <img src="images/搜狗截图20180226180504.png" alt=""></p>
<p>原理：</p>
<p>​    可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p>
<pre><code>给容器中添加了以下组件
</code></pre><p>​    1、DefaultErrorAttributes：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">帮我们在页面共享信息；</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">		errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">		addStatus(errorAttributes, requestAttributes);</span><br><span class="line">		addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">		addPath(errorAttributes, requestAttributes);</span><br><span class="line">		<span class="keyword">return</span> errorAttributes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    2、BasicErrorController：处理默认/error请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/html"</span>)<span class="comment">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		<span class="keyword">return</span> (modelAndView == <span class="keyword">null</span> ? <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span></span><br><span class="line">	<span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line">	<span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    3、ErrorPageCustomizer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String path = <span class="string">"/error"</span>;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）</span><br></pre></td></tr></table></figure>
<p>​    4、DefaultErrorViewResolver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">		ModelAndView modelAndView = resolve(String.valueOf(status), model);</span><br><span class="line">		<span class="keyword">if</span> (modelAndView == <span class="keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">		String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">		TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders</span><br><span class="line">				.getProvider(errorViewName, <span class="keyword">this</span>.applicationContext);</span><br><span class="line">		<span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line">		<span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    步骤：</p>
<p>​        一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被<strong>BasicErrorController</strong>处理；</p>
<p>​        1）响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的ErrorViewResolver得到ModelAndView</span></span><br><span class="line">   <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="keyword">this</span>.errorViewResolvers) &#123;</span><br><span class="line">      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);</span><br><span class="line">      <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> modelAndView;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、如果定制错误响应："><a href="#2）、如果定制错误响应：" class="headerlink" title="2）、如果定制错误响应："></a>2）、如果定制错误响应：</h3><h4 id="1）、如何定制错误的页面；"><a href="#1）、如何定制错误的页面；" class="headerlink" title="1）、如何定制错误的页面；"></a><strong>1）、如何定制错误的页面；</strong></h4><p>​            <strong>1）、有模板引擎的情况下；error/状态码;</strong> 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；</p>
<p>​            我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；        </p>
<p>​            页面能获取的信息；</p>
<p>​                timestamp：时间戳</p>
<p>​                status：状态码</p>
<p>​                error：错误提示</p>
<p>​                exception：异常对象</p>
<p>​                message：异常消息</p>
<p>​                errors：JSR303数据校验的错误都在这里</p>
<p>​            2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p>
<p>​            3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p>
<h4 id="2）、如何定制错误的json数据；"><a href="#2）、如何定制错误的json数据；" class="headerlink" title="2）、如何定制错误的json数据；"></a>2）、如何定制错误的json数据；</h4><p>​        1）、自定义异常处理&amp;返回定制json数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">        map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有自适应效果...</span></span><br></pre></td></tr></table></figure>
<p>​        2）、转发到/error进行自适应响应效果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Integer statusCode = (Integer) request</span></span><br><span class="line"><span class="comment">        .getAttribute("javax.servlet.error.status_code");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">500</span>);</span><br><span class="line">       map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">       map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">       <span class="comment">//转发到/error</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）、将我们的定制数据携带出去；"><a href="#3）、将我们的定制数据携带出去；" class="headerlink" title="3）、将我们的定制数据携带出去；"></a>3）、将我们的定制数据携带出去；</h4><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p>
<p>​    1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p>
<p>​    2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p>
<p>​            容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p>
<p>自定义ErrorAttributes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">        map.put(<span class="string">"company"</span>,<span class="string">"atguigu"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p>
<p><img src="images/搜狗截图20180228135513.png" alt=""></p>
<h2 id="8、配置嵌入式Servlet容器"><a href="#8、配置嵌入式Servlet容器" class="headerlink" title="8、配置嵌入式Servlet容器"></a>8、配置嵌入式Servlet容器</h2><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p>
<p><img src="images/搜狗截图20180301142915.png" alt=""></p>
<p>问题？</p>
<h3 id="1）、如何定制和修改Servlet容器的相关配置；"><a href="#1）、如何定制和修改Servlet容器的相关配置；" class="headerlink" title="1）、如何定制和修改Servlet容器的相关配置；"></a>1）、如何定制和修改Servlet容器的相关配置；</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port=8081</span><br><span class="line">server.context-path=/crud</span><br><span class="line"></span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line"></span><br><span class="line">//通用的Servlet容器设置</span><br><span class="line">server.xxx</span><br><span class="line">//Tomcat的设置</span><br><span class="line">server.tomcat.xxx</span><br></pre></td></tr></table></figure>
<p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">            container.setPort(<span class="number">8083</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#2）、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="2）、注册Servlet三大组件【Servlet、Filter、Listener】"></a>2）、注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p>
<p>注册三大组件用以下方式</p>
<p>ServletRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册三大组件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletListenerRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p>
<p>DispatcherServletAutoConfiguration中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">         dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">    <span class="comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">    <span class="comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">    </span><br><span class="line">   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">   registration.setLoadOnStartup(</span><br><span class="line">         <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）、SpringBoot能不能支持其他的Servlet容器；</p>
<h3 id="3）、替换为其他嵌入式Servlet容器"><a href="#3）、替换为其他嵌入式Servlet容器" class="headerlink" title="3）、替换为其他嵌入式Servlet容器"></a>3）、替换为其他嵌入式Servlet容器</h3><p><img src="images/搜狗截图20180302114401.png" alt=""></p>
<p>默认支持：</p>
<p>Tomcat（默认使用）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Jetty</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Undertow</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4）、嵌入式Servlet容器自动配置原理；"><a href="#4）、嵌入式Servlet容器自动配置原理；" class="headerlink" title="4）、嵌入式Servlet容器自动配置原理；"></a>4）、嵌入式Servlet容器自动配置原理；</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar.class)</span><br><span class="line"><span class="comment">//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件</span></span><br><span class="line"><span class="comment">//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：</span></span><br><span class="line"><span class="comment">//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Tomcat.class &#125;)<span class="comment">//判断当前是否引入了Tomcat依赖；</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)<span class="comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Server.class, Loader.class,</span><br><span class="line">			WebAppContext.class &#125;)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> JettyEmbeddedServletContainerFactory <span class="title">jettyEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JettyEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedUndertow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="title">undertowEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取嵌入式的Servlet容器</span></span><br><span class="line">   <span class="function">EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletContextInitializer... initializers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/搜狗截图20180302144835.png" alt=""></p>
<p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p>
<p><img src="images/搜狗截图20180302144910.png" alt=""></p>
<p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Tomcat</span></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置Tomcat的基本环节</span></span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">         : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、我们对嵌入式容器的配置修改是怎么生效？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerProperties、EmbeddedServletContainerCustomizer</span><br></pre></td></tr></table></figure>
<p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p>
<p>怎么修改的原理？</p>
<p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span></span><br><span class="line">   <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span></span><br><span class="line">    <span class="keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</span><br><span class="line">        customizer.customize(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="title">getCustomizers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customizers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Look up does not include the parent context</span></span><br><span class="line">        <span class="keyword">this</span>.customizers = <span class="keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory</span><br><span class="line">            <span class="comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span></span><br><span class="line">            <span class="comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span></span><br><span class="line">            .getBeansOfType(EmbeddedServletContainerCustomizer.class,</span><br><span class="line">                            <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br><span class="line">            .values());</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">this</span>.customizers = Collections.unmodifiableList(<span class="keyword">this</span>.customizers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.customizers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerProperties也是定制器</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p>
<p>###5）、嵌入式Servlet容器启动原理；</p>
<p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<p>1）、SpringBoot应用启动运行run方法</p>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<p>​    从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p>
<p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong>==IOC容器启动创建嵌入式的Servlet容器==</strong></p>
<h2 id="9、使用外置的Servlet容器"><a href="#9、使用外置的Servlet容器" class="headerlink" title="9、使用外置的Servlet容器"></a>9、使用外置的Servlet容器</h2><p>嵌入式Servlet容器：应用打成可执行的jar</p>
<p>​        优点：简单、便携；</p>
<p>​        缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p>
<p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p>
<p>2）、将嵌入式的Tomcat指定为provided；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">      <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、启动服务器就可以使用；</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p>
<p>servlet3.0（Spring注解版）：</p>
<p>8.2.4 Shared libraries / runtimes pluggability：</p>
<p>规则：</p>
<p>​    1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p>
<p>​    2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p>
<p>​    3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p>
<p>流程：</p>
<p>1）、启动Tomcat</p>
<p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p>
<p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p>
<p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p>
<p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p>
<p><img src="images/搜狗截图20180302221835.png" alt=""></p>
<p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建SpringApplicationBuilder</span></span><br><span class="line">   SpringApplicationBuilder builder = createSpringApplicationBuilder();</span><br><span class="line">   StandardServletEnvironment environment = <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">   environment.initPropertySources(servletContext, <span class="keyword">null</span>);</span><br><span class="line">   builder.environment(environment);</span><br><span class="line">   builder.main(getClass());</span><br><span class="line">   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);</span><br><span class="line">   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"Root context already created (using as parent)."</span>);</span><br><span class="line">      servletContext.setAttribute(</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">      builder.initializers(<span class="keyword">new</span> ParentContextApplicationContextInitializer(parent));</span><br><span class="line">   &#125;</span><br><span class="line">   builder.initializers(</span><br><span class="line">         <span class="keyword">new</span> ServletContextApplicationContextInitializer(servletContext));</span><br><span class="line">   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span></span><br><span class="line">   builder = configure(builder);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用builder创建一个Spring应用</span></span><br><span class="line">   SpringApplication application = builder.build();</span><br><span class="line">   <span class="keyword">if</span> (application.getSources().isEmpty() &amp;&amp; AnnotationUtils</span><br><span class="line">         .findAnnotation(getClass(), Configuration.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      application.getSources().add(getClass());</span><br><span class="line">   &#125;</span><br><span class="line">   Assert.state(!application.getSources().isEmpty(),</span><br><span class="line">         <span class="string">"No SpringApplication sources have been defined. Either override the "</span></span><br><span class="line">               + <span class="string">"configure method or add an @Configuration annotation"</span>);</span><br><span class="line">   <span class="comment">// Ensure error pages are registered</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registerErrorPageFilter) &#123;</span><br><span class="line">      application.getSources().add(ErrorPageFilterConfiguration.class);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//启动Spring应用</span></span><br><span class="line">   <span class="keyword">return</span> run(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7）、Spring的应用就启动并且创建IOC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//刷新IOC容器</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>==启动Servlet容器，再启动SpringBoot应用==</strong></p>
<h1 id="五、Docker"><a href="#五、Docker" class="headerlink" title="五、Docker"></a>五、Docker</h1><h2 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p>
<p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p>
<p>运行中的这个镜像称为容器，容器启动是非常快速的。</p>
<p><img src="images/搜狗截图20180303145450.png" alt=""></p>
<p><img src="images/搜狗截图20180303145531.png" alt=""></p>
<h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p>
<p>docker客户端(Client)：连接docker主机进行操作；</p>
<p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p>
<p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p>
<p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p>
<p><img src="images/搜狗截图20180303165113.png" alt=""></p>
<p>使用Docker的步骤：</p>
<p>1）、安装Docker</p>
<p>2）、去Docker仓库找到这个软件对应的镜像；</p>
<p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p>
<p>4）、对容器的启动停止就是对软件的启动停止；</p>
<h2 id="3、安装Docker"><a href="#3、安装Docker" class="headerlink" title="3、安装Docker"></a>3、安装Docker</h2><h4 id="1）、安装linux虚拟机"><a href="#1）、安装linux虚拟机" class="headerlink" title="1）、安装linux虚拟机"></a>1）、安装linux虚拟机</h4><p>​    1）、VMWare、VirtualBox（安装）；</p>
<p>​    2）、导入虚拟机文件centos7-atguigu.ova；</p>
<p>​    3）、双击启动linux虚拟机;使用  root/ 123456登陆</p>
<p>​    4）、使用客户端连接linux服务器进行命令操作；</p>
<p>​    5）、设置虚拟机网络；</p>
<p>​        桥接网络===选好网卡====接入网线；</p>
<p>​    6）、设置好网络以后使用命令重启虚拟机的网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p>​    7）、查看linux的ip地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>
<p>​    8）、使用客户端连接linux；</p>
<h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、检查内核版本，必须是3.10及以上</span><br><span class="line">uname -r</span><br><span class="line">2、安装docker</span><br><span class="line">yum install docker</span><br><span class="line">3、输入y确认安装</span><br><span class="line">4、启动docker</span><br><span class="line">[root@localhost ~]# systemctl start docker</span><br><span class="line">[root@localhost ~]# docker -v</span><br><span class="line">Docker version 1.12.6, build 3e8e77d/1.12.6</span><br><span class="line">5、开机启动docker</span><br><span class="line">[root@localhost ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">6、停止docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<h2 id="4、Docker常用命令-amp-操作"><a href="#4、Docker常用命令-amp-操作" class="headerlink" title="4、Docker常用命令&amp;操作"></a>4、Docker常用命令&amp;操作</h2><h3 id="1）、镜像操作"><a href="#1）、镜像操作" class="headerlink" title="1）、镜像操作"></a>1）、镜像操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>检索</td>
<td>docker  search 关键字  eg：docker  search redis</td>
<td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td>
</tr>
<tr>
<td>拉取</td>
<td>docker pull 镜像名:tag</td>
<td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td>
</tr>
<tr>
<td>列表</td>
<td>docker images</td>
<td>查看所有本地镜像</td>
</tr>
<tr>
<td>删除</td>
<td>docker rmi image-id</td>
<td>删除指定的本地镜像</td>
</tr>
</tbody>
</table>
<p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h3 id="2）、容器操作"><a href="#2）、容器操作" class="headerlink" title="2）、容器操作"></a>2）、容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p>
<p>步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、搜索镜像</span><br><span class="line">[root@localhost ~]# docker search tomcat</span><br><span class="line">2、拉取镜像</span><br><span class="line">[root@localhost ~]# docker pull tomcat</span><br><span class="line">3、根据镜像启动容器</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">4、docker ps  </span><br><span class="line">查看运行中的容器</span><br><span class="line">5、 停止运行中的容器</span><br><span class="line">docker stop  容器的id</span><br><span class="line">6、查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line">7、启动容器</span><br><span class="line">docker start 容器id</span><br><span class="line">8、删除一个容器</span><br><span class="line"> docker rm 容器id</span><br><span class="line">9、启动一个做了端口映射的tomcat</span><br><span class="line">[root@localhost ~]# docker run -d -p 8888:8080 tomcat</span><br><span class="line">-d：后台运行</span><br><span class="line">-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口</span><br><span class="line"></span><br><span class="line">10、为了演示简单关闭了linux的防火墙</span><br><span class="line">service firewalld status ；查看防火墙状态</span><br><span class="line">service firewalld stop：关闭防火墙</span><br><span class="line">11、查看容器的日志</span><br><span class="line">docker logs container-name/container-id</span><br><span class="line"></span><br><span class="line">更多命令参看</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/docker/</span><br><span class="line">可以参考每一个镜像的文档</span><br></pre></td></tr></table></figure>
<h3 id="3）、安装MySQL示例"><a href="#3）、安装MySQL示例" class="headerlink" title="3）、安装MySQL示例"></a>3）、安装MySQL示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<p>错误的启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -d mysql</span><br><span class="line">42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846</span><br><span class="line"></span><br><span class="line">mysql退出了</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES</span><br><span class="line">42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01</span><br><span class="line">538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_</span><br><span class="line">goldstine</span><br><span class="line">c4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi</span><br><span class="line">81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//错误日志</span><br><span class="line">[root@localhost ~]# docker logs 42f09819908b</span><br><span class="line">error: database is uninitialized and password option is not specified </span><br><span class="line">  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</span><br></pre></td></tr></table></figure>
<p>正确的启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</span><br></pre></td></tr></table></figure>
<p>做了端口映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</span><br></pre></td></tr></table></figure>
<p>几个其他的高级操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line">把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面</span><br><span class="line">改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）</span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">指定mysql的一些配置参数</span><br></pre></td></tr></table></figure>
<h1 id="六、SpringBoot与数据访问"><a href="#六、SpringBoot与数据访问" class="headerlink" title="六、SpringBoot与数据访问"></a>六、SpringBoot与数据访问</h1><h2 id="1、JDBC"><a href="#1、JDBC" class="headerlink" title="1、JDBC"></a>1、JDBC</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://192.168.15.22:3306/jdbc</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p>​    SpringBoot 2之前：默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p>
<p>​    SpringBoot 2：默认使用com.zaxxer.hikari.HikariDataSource ==Hikari==作为数据源</p>
<p>​    数据源的相关配置都在DataSourceProperties里面；</p>
<p>自动配置原理：</p>
<p>org.springframework.boot.autoconfigure.jdbc：</p>
<p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p>
<p>2、SpringBoot默认可以支持；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、</span><br></pre></td></tr></table></figure>
<p>3、自定义数据源类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(DataSource.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span></span><br><span class="line">      <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、<strong>DataSourceInitializer：ApplicationListener</strong>；</p>
<p>​    作用：</p>
<p>​        1）、runSchemaScripts();运行建表语句；</p>
<p>​        2）、runDataScripts();运行插入数据的sql语句；</p>
<p>默认只需要将文件命名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schema-*.sql、data-*.sql</span><br><span class="line">默认规则：schema.sql，schema-all.sql；</span><br><span class="line">可以使用   </span><br><span class="line">	schema:</span><br><span class="line">      - classpath:department.sql</span><br><span class="line">      指定位置</span><br></pre></td></tr></table></figure>
<p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p>
<h2 id="2、整合Druid数据源"><a href="#2、整合Druid数据源" class="headerlink" title="2、整合Druid数据源"></a>2、整合Druid数据源</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">导入druid数据源</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druid</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Druid的监控</span></span><br><span class="line">    <span class="comment">//1、配置一个管理后台的Servlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>,<span class="string">"admin"</span>);</span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        initParams.put(<span class="string">"allow"</span>,<span class="string">""</span>);<span class="comment">//默认就是允许所有访问</span></span><br><span class="line">        initParams.put(<span class="string">"deny"</span>,<span class="string">"192.168.15.21"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、配置一个web监控的filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>,<span class="string">"*.js,*.css,/druid/*"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="string">"/*"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、整合MyBatis"><a href="#3、整合MyBatis" class="headerlink" title="3、整合MyBatis"></a>3、整合MyBatis</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="images/搜狗截图20180305194443.png" alt=""></p>
<p>步骤：</p>
<p>​    1）、配置数据源相关属性（见上一节Druid）</p>
<p>​    2）、给数据库建表</p>
<p>​    3）、创建JavaBean</p>
<h3 id="4）、注解版"><a href="#4）、注解版" class="headerlink" title="4）、注解版"></a>4）、注解版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定这是一个操作数据库的mapper</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from department where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from department where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>,keyProperty = <span class="string">"id"</span>)</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into department(departmentName) values(#&#123;departmentName&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用MapperScan批量扫描所有的Mapper接口；</span><br><span class="line"><span class="meta">@MapperScan</span>(value = <span class="string">"com.atguigu.springboot.mapper"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot06DataMybatisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5）、配置文件版"><a href="#5）、配置文件版" class="headerlink" title="5）、配置文件版"></a>5）、配置文件版</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  config-location:</span> <span class="attr">classpath:mybatis/mybatis-config.xml</span> <span class="string">指定全局配置文件的位置</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mybatis/mapper/*.xml</span>  <span class="string">指定sql映射文件的位置</span></span><br></pre></td></tr></table></figure>
<p>更多使用参照</p>
<p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p>
<h2 id="4、整合SpringData-JPA"><a href="#4、整合SpringData-JPA" class="headerlink" title="4、整合SpringData JPA"></a>4、整合SpringData JPA</h2><h3 id="1）、SpringData简介"><a href="#1）、SpringData简介" class="headerlink" title="1）、SpringData简介"></a>1）、SpringData简介</h3><p><img src="images/搜狗截图20180306105412.png" alt=""></p>
<h3 id="2）、整合SpringData-JPA"><a href="#2）、整合SpringData-JPA" class="headerlink" title="2）、整合SpringData JPA"></a>2）、整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）；</p>
<p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用JPA注解配置映射关系</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">//告诉JPA这是一个实体类（和数据表映射的类）</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"tbl_user"</span>) <span class="comment">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">//这是一个主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="comment">//自增主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_name"</span>,length = <span class="number">50</span>) <span class="comment">//这是和数据表对应的一个列</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Column</span> <span class="comment">//省略默认列名就是属性名</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure>
<p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承JpaRepository来完成对数据库的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）、基本的配置JpaProperties</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line"><span class="attr"> jpa:</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="comment">#     更新或者创建数据表结构</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="comment">#    控制台显示SQL</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="七、启动配置原理"><a href="#七、启动配置原理" class="headerlink" title="七、启动配置原理"></a>七、启动配置原理</h1><p>几个重要的事件回调机制</p>
<p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<p><strong>SpringApplicationRunListener</strong></p>
<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<p><strong>CommandLineRunner</strong></p>
<p>启动流程：</p>
<h2 id="1、创建SpringApplication对象"><a href="#1、创建SpringApplication对象" class="headerlink" title="1、创建SpringApplication对象"></a><strong>1、创建SpringApplication对象</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initialize(sources);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存主配置类</span></span><br><span class="line">    <span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前是否一个web应用</span></span><br><span class="line">    <span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">    <span class="comment">//从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">        ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">//从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">//从多个配置类中找到有main方法的主配置类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/搜狗截图20180306145727.png" alt=""></p>
<p><img src="images/搜狗截图20180306145855.png" alt=""></p>
<h2 id="2、运行run方法"><a href="#2、运行run方法" class="headerlink" title="2、运行run方法"></a>2、运行run方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories</span></span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">//回调所有的获取SpringApplicationRunListener.starting()方法</span></span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//封装命令行参数</span></span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      <span class="comment">//准备环境</span></span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">       		<span class="comment">//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span></span><br><span class="line">       </span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//创建ApplicationContext；决定创建web的ioc还是普通的ioc</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">       </span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">       <span class="comment">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span></span><br><span class="line">       <span class="comment">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span></span><br><span class="line">       <span class="comment">//回调所有的SpringApplicationRunListener的contextPrepared()；</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       <span class="comment">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span></span><br><span class="line">       <span class="comment">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">       <span class="comment">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span></span><br><span class="line">       <span class="comment">//ApplicationRunner先回调，CommandLineRunner再回调</span></span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">       <span class="comment">//所有的SpringApplicationRunListener回调finished方法</span></span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//整个SpringBoot应用启动完成以后返回启动的ioc容器；</span></span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、事件监听机制"><a href="#3、事件监听机制" class="headerlink" title="3、事件监听机制"></a>3、事件监听机制</h2><p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationContextInitializer...initialize..."</span>+applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringApplicationRunListener</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须有的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloSpringApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...starting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        Object o = environment.getSystemProperties().get(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...environmentPrepared.."</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...contextPrepared..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...contextLoaded..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...finished..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置（META-INF/spring.factories）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.atguigu.springboot.listener.HelloApplicationContextInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">com.atguigu.springboot.listener.HelloSpringApplicationRunListener</span><br></pre></td></tr></table></figure>
<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationRunner...run...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CommandLineRunner</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommandLineRunner...run..."</span>+ Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、自定义starter"><a href="#八、自定义starter" class="headerlink" title="八、自定义starter"></a>八、自定义starter</h1><p>starter：</p>
<p>​    1、这个场景需要使用到的依赖是什么？</p>
<p>​    2、如何编写自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//指定这个类是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnXXX</span>  <span class="comment">//在指定条件成立的情况下自动配置类生效</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>  <span class="comment">//指定自动配置类的顺序</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">//给容器中添加组件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span> <span class="comment">//让xxxProperties生效加入到容器中</span></span><br><span class="line"></span><br><span class="line">自动配置类要能加载</span><br><span class="line">将需要启动就加载的自动配置类，配置在META-INF/spring.factories</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br></pre></td></tr></table></figure>
<p>​    3、模式：</p>
<p>启动器只用来做依赖导入；</p>
<p>专门来写一个自动配置模块；</p>
<p>启动器依赖自动配置；别人只需要引入启动器（starter）</p>
<p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p>
<p>步骤：</p>
<p>1）、启动器模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入自动配置模块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）、自动配置模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"atguigu.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloProperties <span class="title">getHelloProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloProperties</span><span class="params">(HelloProperties helloProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHellAtguigu</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix()+<span class="string">"-"</span> +name + helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//web应用才生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService service = <span class="keyword">new</span> HelloService();</span><br><span class="line">        service.setHelloProperties(helloProperties);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="更多SpringBoot整合示例"><a href="#更多SpringBoot整合示例" class="headerlink" title="更多SpringBoot整合示例"></a>更多SpringBoot整合示例</h1><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发与高并发解决方案</title>
    <url>/undefined/Java%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-并发与高并发解决方案"><a href="#Java-并发与高并发解决方案" class="headerlink" title="Java 并发与高并发解决方案"></a>Java 并发与高并发解决方案</h2><p>[TOC]</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>3种使用线程的方法：</p>
<pre><code>1.实现Runnable接口

2.实现Callable接口

3.继承Thread类
</code></pre><blockquote>
<p>提示：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：实现接口和继承之间，实现接口会好一些。Java不支持多重继承，因此继承了Thread类就无法继承其它类，但是可以实现多个接口。类可能只要求可执行就行，继承整个Thread类开销大。</p>
</blockquote>
</blockquote>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>多个线程操作相同的资源，保证线程安全，合理使用资源。</p>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常指通过设计保证系统能够同时并行处理很多请求。</p>
<p>服务能够同时处理很多请求，提高程序性能。</p>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><p>CPU的频率太快，快到主存跟不上，这样在处理器时钟周期内，CPU经常需要等待主存，浪费资源。所以cache的出现，是为了解决CPU与内存之间速度不匹配的问题。</p>
<h4 id="1-CPU-cache的意义"><a href="#1-CPU-cache的意义" class="headerlink" title="1. CPU cache的意义"></a>1. CPU cache的意义</h4><pre><code>局部性原理：

    1. 时间局部性： 如果某个数据被访问，那么在不久的将来它很可能被再次访问。

    2. 空间局部性： 如果某个数据被访问，那么与它相邻的数据很快也可能被访问。
</code></pre><h4 id="2-CPU多级缓存-缓存一致性（MESI）"><a href="#2-CPU多级缓存-缓存一致性（MESI）" class="headerlink" title="2. CPU多级缓存 - 缓存一致性（MESI）"></a>2. CPU多级缓存 - 缓存一致性（MESI）</h4><p>MESI目的用于保证多个CPU Cache之间缓存共享数据的一致性。</p>
<pre><code>MESI 四种状态各自代表的含义

四种操作：

    1. local read

    2. local write

    3. remote read

    4. remote write
</code></pre><h4 id="3-CPU多级缓存-乱序执行优化"><a href="#3-CPU多级缓存-乱序执行优化" class="headerlink" title="3. CPU多级缓存 - 乱序执行优化"></a>3. CPU多级缓存 - 乱序执行优化</h4><p>乱序执行优化，表示处理器为了提高运算速度而做出违背代码原则原有顺序的优化。</p>
<h4 id="4-Java内存模型-JMM"><a href="#4-Java内存模型-JMM" class="headerlink" title="4. Java内存模型(JMM)"></a>4. Java内存模型(JMM)</h4><pre><code>1. JMM规定


2. 抽象结构


3. 同步八种操作及规则

    1. lock（锁定），作用于主内存的变量，将一个变量标识为一条线程独占状态

    2. unlock（解锁），作用于主内存的变量，将一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定

    3. read（读取），作用于主内存的变量，将一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

    4. load（载入），作用于工作内存的变量，将read操作从主内存中得到的变量值放入工作内存的变量副本中

    5. use（使用），作用于工作内存的变量，将工作内存中的一个变量值传递给执行引擎

    6. assign（赋值），作用于工作内存的变量，将一个从执行引擎接收到的值赋值给工作内存中的变量

    7. store（存储），作用于工作内存的变量，将工作内存中的一个变量的值传送到主内存中，以便随后的write操作

    8. write（写入），作用于主内存的变量，将store操作从工作内存中一个变量的值传送到主内存的变量中

    ---

    1. ...
</code></pre><h3 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h3><h4 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h4><pre><code>1. 速度

    同时处理多个请求，响应更快，复杂的操作可以分成多个进程同时进行

2. 设计

    程序设计在某些情况下更简单，也可以有更多的选择

3. 资源利用

    CPU能够在等待IO的时候做一些其它事情
</code></pre><h4 id="2-风险"><a href="#2-风险" class="headerlink" title="2. 风险"></a>2. 风险</h4><pre><code>1. 安全性

    多个线程共享数据时可能会产生于期望不相符的结果

2. 活跃性

    某个操作无法继续进行下去时，就会发生活跃性问题，如死锁、饥饿等问题。

3. 性能

    线程过多时会使得CPU频繁切换、调度时间增多、同步机制、消耗过多内存
</code></pre><h3 id="并发模拟"><a href="#并发模拟" class="headerlink" title="并发模拟"></a>并发模拟</h3><pre><code>1. Postman HTTP请求工具

2. Apache Bench（AB）Apache附带工具-测试网站性能

3. JMeter Apache组织开发的压力测试工具

    测试工具建议使用Apache-JMeter

4. Semaphore | CountDownLatch等
</code></pre><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多个线程访问某个类时，不管运行的环境采用何种调度方式或这些进程如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都表现出正确的行为，所以这类是线程安全的。</p>
<h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><p>提供互斥访问，同一时刻只能有一个线程对它进行操作</p>
<pre><code>1. Atomic包

    AtomicXXX:CAS | Unsafe.compareAndSwapInt

        AtomicLong | LongAdder

2. 锁

    1. synchronized 依赖于JVM

        1. 修饰代码块：大括号括起来的代码，作用于调用的对象

        2. 修饰方法：整个方法，作用于调用的对象

        3. 修饰静态方法：整个静态方法，作用于所有对象

        4. 修饰类：括号括起来的部分，作用于所有对象

    2. Lock 依赖特殊的CPU指令，代码实现，ReentrantLock
</code></pre><blockquote>
<p>提示：synchronized是不可中断锁，适合竞争不激烈可读性好的业务场景。Lock是可中断锁，多样化同步，竞争激烈时能够维持常态。Atomic竞争激烈时维持常态，比Lock性能好，只能同步一个值。</p>
</blockquote>
<h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><p>一个线程对主内存的修改可以及时的被其它线程观察到。</p>
<p>导致线程共享变量在线程间不可见的原因：1. 线程交叉执行。2.重排序组合线程交叉执行。3.共享变量更新后的值没有在工作内存与主内存间及时更新。</p>
<blockquote>
<p>JMM关于synchronized的两条规定：</p>
</blockquote>
<pre><code>1. 线程解锁前，必须将共享变量的最新值刷新到主内存

2. 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（提示：加锁与解锁是同一把锁）。
</code></pre><blockquote>
<p>volatitle</p>
</blockquote>
<pre><code>通过加入内存屏障和禁止重排序优化来实现。

    1. 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中共享变量值刷新到主内存。

    2. 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。

    注意：volatile的的操作：1. 对变量的写操作不影响当前值。2. 
</code></pre><h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><p>一个线程观察其它线程中的指令执行顺序，由于指令重排序的存在，该结果一般杂乱无序。</p>
<p>Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在并发操作过程中，可以通过 volatile | synchronized | Lock 关键字避免编译器和处理器对指令进行重排序。</p>
<blockquote>
<p>Happens - Before原则</p>
</blockquote>
<pre><code>1. 程序次序原则，一个线程内，按照代码顺序，书写在前面的操作会先发生书写在后面的操作。（单线程内）

2. 锁定规则，一个unlock操作先发生于后面对同一个锁的lock操作。（不论是单线程或多线程）

3. volatile变量规则，对一个变量的写操作先行发生于后面对这个变量的读操作。

4. 传递规则，如果操作A先发生于操作B，而操作B又先发生于操作C，则可以得出操作A先发生于操作C。

5. 线程启动规则，Thread对象的start()方法先发生于此线程的每个动作。

6. 线程中断规则，对线程的interrupt()方法的调用先发生于被中断线程的代码检测到中断事件的发生。

7. 线程终结规则，线程中所有的操作都先发生于线程的终止检测，可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测到线程已经终止。

8. 对象终结规则，一个对象的初始化完成先发生于它的finalize()方法的开始。
</code></pre><h4 id="4-线程安全性-总结"><a href="#4-线程安全性-总结" class="headerlink" title="4. 线程安全性 - 总结"></a>4. 线程安全性 - 总结</h4><p>原子性：Atomic包 | CAS算法 | synchronized | Lock</p>
<p>可见性：synchronized | volatile</p>
<p>有序性：happens-before原则</p>
<hr>
<h3 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h3><p>发布对象，指使一个对象能够被当前范围之外的代码使用。</p>
<pre><code>package com.ccpc.edu.xidian.cn.ccpc.example.publish;

import com.ccpc.edu.xidian.cn.ccpc.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;

@Slf4j
@NotThreadSafe
public class UnsafePublish {

    private String[] states = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};

    public String[] getStates(){
        return states;
    }

    public static void main(String[] args) {
        UnsafePublish unsafePublish = new UnsafePublish();
        log.info(&quot;{}&quot;, Arrays.toString(unsafePublish.getStates()));

        unsafePublish.getStates()[0] = &quot;d&quot;;
        log.info(&quot;{}&quot;, Arrays.toString(unsafePublish.getStates()));

    }
}
</code></pre><p>对象溢出，指一种错误的发布方式，当一个对象还没有构造完成时，就使它被其它线程所见。</p>
<pre><code>package com.ccpc.edu.xidian.cn.ccpc.example.publish;

import com.ccpc.edu.xidian.cn.ccpc.annoations.NotRecommend;
import com.ccpc.edu.xidian.cn.ccpc.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@NotThreadSafe
@NotRecommend
public class Escape {

    private int thisCanBeEscape = 0;

    public Escape(){
        //还未构建完成就发布
        new InnerClass();
    }

    private class InnerClass {
        public InnerClass(){
            log.info(&quot;{}&quot;, Escape.this.thisCanBeEscape);
        }
    }

    public static void main(String[] args) {
        new Escape();
    }
}
</code></pre><h4 id="1-安全发布对象方法"><a href="#1-安全发布对象方法" class="headerlink" title="1. 安全发布对象方法"></a>1. 安全发布对象方法</h4><pre><code>1. 在静态初始化函数中初始化一个对象引用

2. 将对象的引用保存到volatile类型域或者AtomicRefernce对象中

3. 将对象的引用保存到某个正确构造对象的final类型域中

4. 将对象的引用保存到一个由锁保护的域中
</code></pre><h3 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h3><h4 id="1-不可变对象"><a href="#1-不可变对象" class="headerlink" title="1. 不可变对象"></a>1. 不可变对象</h4><pre><code>不可变对象满足的条件：

    1. 对象创建以后其状态不能修改

    2. 对象所有域都是final类型

    3. 对象是正确创建的（在对象创建期间，this引用没有溢出）

final关键字

    修饰类：不能被继承

    修饰方法：效率、锁定方法不能被继承类修改

    修饰变量：基本数据类型变量、引用类型变量

效果类似final的方法（Java 8 提供）

    1. Collections.unmodifiableXXX:Collectino List Set Map

        package com.ccpc.edu.xidian.cn.ccpc.example.immutable;

        import com.ccpc.edu.xidian.cn.ccpc.annoations.ThreadSafe;
        import com.google.common.collect.Maps;
        import lombok.extern.slf4j.Slf4j;

        import java.util.Collections;
        import java.util.Map;

        @Slf4j
        @ThreadSafe
        public class ImmutableExample3 {
            private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();

            static {
                map.put(1, 3);
                map.put(2, 4);
                map.put(3, 5);
                map = Collections.unmodifiableMap(map);
            }

            public static void main(String[] args) {
                map.put(1, 4);
                log.info(&quot;{}&quot;, map.get(1));
            }
        }


    2. Guava：ImmutableXXX:Collection List Set Map ..
</code></pre><blockquote>
<p>总结：在使用的时候尽可能的将一些对象变成不可变对象，那么就不会产生线程不安全问题。</p>
</blockquote>
<h4 id="2-线程封闭"><a href="#2-线程封闭" class="headerlink" title="2. 线程封闭"></a>2. 线程封闭</h4><pre><code>1. Ad-hoc线程封闭：程序控制实现，最糟糕，忽略

2. 堆栈封闭：局部变量，无并发问题

3. ThreadLocal线程封闭：很好的封闭方法
</code></pre><h3 id="线程不安全类"><a href="#线程不安全类" class="headerlink" title="线程不安全类"></a>线程不安全类</h3><pre><code>1. StringBuilder | StringBuffer 

    在多线程环境中使用StringBuffer，是为了安全。但是在不那么在意线程执行安全的时候考虑到上下文切换的开销，那么使用StringBuilder会更有效一些。

2. SimpleDateFormat | JodaTime

3. ArrayList | HashSet | HashMap 等Collections

4. 先检查再执行（if(condition(a)){handle(a);}）//线程非安全
</code></pre><h3 id="线程安全类-同步容器"><a href="#线程安全类-同步容器" class="headerlink" title="线程安全类 - 同步容器"></a>线程安全类 - 同步容器</h3><pre><code>1. ArrayList -&gt; Vector | Stack

2. HashMap -&gt; Hashtable(key|value不能为null)

3. Collections.synchronizedXXX(List | Set | Map)
</code></pre><h3 id="线程安全-并发容器-J-U-C"><a href="#线程安全-并发容器-J-U-C" class="headerlink" title="线程安全 - 并发容器 J.U.C"></a>线程安全 - 并发容器 J.U.C</h3><pre><code>1. ArrayList -&gt; CopyOnWriteArrayList

2. HashSet | TreeSet -&gt; CopyOnWriteArraySet | ConcurrentSkipListSet

3. HashMap | TreeMap -&gt; ConcurrentHashMap | ConcurrentSkipListMap
</code></pre><p>CopyOnWriteArrayList和CopyOnWriteArraySet是线程安全的集合，其中所有的修改线程对底层数组进行复制。如果在集合上迭代的线程数超过修改线程数，这样的安排是很有用的。</p>
<p>当构建一个迭代器的时候，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但集合的数组已经被修改。所以旧的迭代器拥有一致的试图。</p>
<h3 id="安全共享对象策略-总结"><a href="#安全共享对象策略-总结" class="headerlink" title="安全共享对象策略 - 总结"></a>安全共享对象策略 - 总结</h3><pre><code>1. 线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改

2. 共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它

3. 线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所以其它线程无需额外的同步就可以通过公共接口随意访问它

4. 被守护的线程：被守护的线程只能通过获取特定的锁来访问
</code></pre><hr>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><ol>
<li><p>使用Node实现FIFO队列，可以用于构建锁或者其它同步装置的基础框架。</p>
</li>
<li><p>利用一个int类型表示状态</p>
</li>
<li><p>使用方法是继承</p>
</li>
<li><p>子类通过继承并通过实现它的方法管理其它状态（acquire和release）的方法操作状态</p>
</li>
<li><p>可以同时实现排它锁和共享锁模式（独占、共享）</p>
</li>
</ol>
<h4 id="1-JUC-AQS同步组件"><a href="#1-JUC-AQS同步组件" class="headerlink" title="1. JUC - AQS同步组件"></a>1. JUC - AQS同步组件</h4><h5 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h5><h5 id="2-Semaphore"><a href="#2-Semaphore" class="headerlink" title="2. Semaphore"></a>2. Semaphore</h5><h5 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="3. CyclicBarrier"></a>3. CyclicBarrier</h5><h5 id="4-ReentrantLock-与-锁"><a href="#4-ReentrantLock-与-锁" class="headerlink" title="4. ReentrantLock 与 锁"></a>4. ReentrantLock 与 锁</h5><pre><code>1. ReentrantLock | synchronized 之间的区别

    1. 可重入性

    2. 锁的实现

    3. 性能的区别

    4. 功能的区别


    注意：ReentrantLock独有功能

        1. 可指定是公平锁还是非公平锁

        2. 提供了一个Condition类，可以分组唤醒需要唤醒的线程

        3. 提供能够中断等待锁的线程机制，lock.lockInterruptibly()
</code></pre><h4 id="2-JUC-FutureTask"><a href="#2-JUC-FutureTask" class="headerlink" title="2. JUC - FutureTask"></a>2. JUC - FutureTask</h4><h5 id="1-Callable与Runnable接口对比"><a href="#1-Callable与Runnable接口对比" class="headerlink" title="1. Callable与Runnable接口对比"></a>1. Callable与Runnable接口对比</h5><p>Callable是一个泛型，其中有一个call()方法，有返回值。</p>
<p>FutureTask包装器是一种非常便利的机制，可将Callable转换成Future和Runnable。</p>
<h4 id="3-Fork-Join"><a href="#3-Fork-Join" class="headerlink" title="3. Fork | Join"></a>3. Fork | Join</h4><h4 id="4-BlockingQueue-阻塞队列"><a href="#4-BlockingQueue-阻塞队列" class="headerlink" title="4. BlockingQueue 阻塞队列"></a>4. BlockingQueue 阻塞队列</h4><p>该情况用于生产消费模式。</p>
<p>阻塞队列给出4套方法</p>
<table>
<thead>
<tr>
<th>-</th>
<th>Throws Exception</th>
<th>Special Value</th>
<th>Blocks</th>
<th>Times Out </th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o, timeout, timeout)</td>
</tr>
<tr>
<td>remove</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take()</td>
<td>poll(timeout, timeout) </td>
</tr>
<tr>
<td>examine</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>ArrayBlockingQueue </li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<h4 id="5-Condition"><a href="#5-Condition" class="headerlink" title="5. Condition"></a>5. Condition</h4><hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><pre><code>1. new Thread 弊端

    1. 每次都需要new Thread新建对象，性能较差

    2. 线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM

    3. 缺少更多的功能。如：更多执行、定期执行、线程中断

2. 线程池的优势

    1. 重用存在的线程，减少对象创建、消亡的开销，性能优

    2. 可以有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞

    3. 线程池可以提供定时执行、定期执行、单线程、并发数控制等功能
</code></pre><h4 id="1-ThreadPoolExecutor"><a href="#1-ThreadPoolExecutor" class="headerlink" title="1. ThreadPoolExecutor"></a>1. ThreadPoolExecutor</h4><pre><code>1. 参数

    1. corePoolSize 核心线程数量

    2. maximumPoolSize 线程最大线程数

    3. workQueue 阻塞队列，存储等待执行的任务（重要），会对线程池运行过程产生很大影响

    4. keepAliveTime 线程没有任务执行时最多保持多久时间终止

    5. unit keepAliveTime的时间单位

    6. threadFactory 线程工厂，用来创建线程

    7. rejectHandler 当拒绝处理任务时的策略

        源码

2. 方法

    1. execute() 提交任务，交给线程池执行

    2. submit() 提交任务，能够返回执行结果 execute+Future

    3. shutdown() 关闭线程池，等待任务被执行完

    4. shutdownNow() 关闭线程池，不等待任务执行完

    5. getTaskCount() 线程池已经执行或未执行的任务总数

    6. getCompletedTaskCount() 已完成的任务数量

    7. getPoolSize() 线程池当前的线程数量

    8. getActiveCount 当前线程池中正在执行任务的线程数量

    9. 
</code></pre><h4 id="2-Executor框架接口"><a href="#2-Executor框架接口" class="headerlink" title="2. Executor框架接口"></a>2. Executor框架接口</h4><pre><code>1. Executors.newCachedThreadPool

2. Executors.newFixedThreadPool

3. Executors.newScheduledThreadPool

4. Executors.newSingleThreadExecutor
</code></pre><h4 id="3-线程池-合理配置"><a href="#3-线程池-合理配置" class="headerlink" title="3. 线程池 - 合理配置"></a>3. 线程池 - 合理配置</h4><pre><code>1. CPU密集型任务需要尽量压榨CPU，参考值可以设置为NCPU+1

2. IO密集型任务，参考值可以设置为2*NCPU

3. 
</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="1-死锁必要条件"><a href="#1-死锁必要条件" class="headerlink" title="1. 死锁必要条件"></a>1. 死锁必要条件</h4><pre><code>1. 互斥条件

2. 请求和保持条件

3. 不剥夺条件

4. 环路等待条件
</code></pre><hr>
<h3 id="高并发处理"><a href="#高并发处理" class="headerlink" title="高并发处理"></a>高并发处理</h3><h4 id="高并发处理思路手段"><a href="#高并发处理思路手段" class="headerlink" title="高并发处理思路手段"></a>高并发处理思路手段</h4><pre><code>1. 扩容

    1. 垂直扩容，提高系统部件的能力（内存）

    2. 水平扩容，增加更多系统成员来实现（添加多台服务器）

2. 扩容 - 数据库

    1. 读操作扩展

        memcache

        redis

        CDN

    2. 写操作扩展

        Cassandra

        Hbase

3. 缓存

    1. 缓存特征

        1. 命中率

            命中数 / (命中数 + 没有命中数)

        2. 最大元素（空间）

        3. 清空策略

            FIFO（先进先出策略） LFU（最早使用策略） LRU 过期时间 随机等。

    2. Guava Cache


    3. Memcache

    4. Redis 
</code></pre><h4 id="高并发场景下缓存常见问题"><a href="#高并发场景下缓存常见问题" class="headerlink" title="高并发场景下缓存常见问题"></a>高并发场景下缓存常见问题</h4><pre><code>1. 缓存一致性


2. 缓存并发问题



3. 缓存穿透问题



4. 缓存的雪崩现象
</code></pre><h4 id="消息队列-Kafka-RabbitMQ"><a href="#消息队列-Kafka-RabbitMQ" class="headerlink" title="消息队列 Kafka RabbitMQ"></a>消息队列 Kafka RabbitMQ</h4><h3 id="应用拆分"><a href="#应用拆分" class="headerlink" title="应用拆分"></a>应用拆分</h3>]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程</title>
    <url>/undefined/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h1><h2 id="1-并发任务"><a href="#1-并发任务" class="headerlink" title="1 并发任务"></a>1 并发任务</h2><h4 id="1-1-运行任务"><a href="#1-1-运行任务" class="headerlink" title="1.1 运行任务"></a>1.1 运行任务</h4><p>在Java中，Runnable接口描述一个想要运行的任务，通常与其它任务并行运行。</p>
<pre><code>public interface Runnable {
    //该方法在线程中执行
    void run();
}

//两个并行任务同时进行
public static void main(String[] args){
    Runnable hellos = () -&gt; {
        for(int i = 0; i &lt;= 100; i++){
            System.out.println(&quot;hello&quot; + i);
        }
    };

    Runnable goodbyes = () -&gt; {
        for(int i = 1; i &lt;= 1000; i++){
            System.out.println(&quot;goodbye&quot; + i);
        }
    };

    //调用该对象会产生一个针对很多短暂任务或者任务大多数时间处于等待状态的程序优化过的executor。

    ExecutorService executor = Executors.newCachedThreadPool();
    executor.execute(hellos);
    executor.execute(goodbyes);
}
</code></pre><blockquote>
<p>注意：在线程池的线程空闲一段时间之后，executor会终止这些线程，然后程序才终止。</p>
</blockquote>
<h4 id="1-2-Future"><a href="#1-2-Future" class="headerlink" title="1.2 Future"></a>1.2 Future</h4><p>虽然Runnable执行任务，但是其没有返回值。如果任务需要计算结果，则使用Callable<v>接口代替Runnable。与Runnable接口的run()方法不同，Callable接口的call()方法可以返回类型为V的值。</v></p>
<pre><code>public interface Callable&lt;V&gt; {
    v call() throws Exception();
}
</code></pre><blockquote>
<p>提示：这里要执行Callable，将其提交到ExecutorService。当提交任务时，会得到一个future，代表计算的对象，将来会用到的计算结果。</p>
</blockquote>
<p><strong>1.2.1 Future 接口的方法</strong><br></p>
<pre><code>//get()方法会被阻塞，直到有可用的结果或者到达超时
1.V get() 
2.V get(long timeout, TimeUnit unit)

//该方法试图取消任务，如果任务还没有运行则不会将任务加入运行计划
3.boolean cancel(boolean mayInterruptIfRunning)
4.boolean isCancelled();
5.boolean isDone();
</code></pre><p>任务有时候可能需要等待多个子任务的完成结果，可以将Callable实例的一个集合传递给一个invokeAll()方法，实现一次提交多个任务。</p>
<pre><code>String word = ...;
String paths = ...;
List&lt;Callable&lt;Long&gt;&gt; tasks = new ArrayList&lt;&gt;();
for(Path p : paths){
    task.add(
        () -&gt; {return number of .. word in p};
        List&lt;Future&lt;Long&gt;&gt; results = executor.invokeAll(tasks);

        //该调用会阻塞，直到所有任务tasks都完成
        long total = 0;
        for(Future&lt;Long&gt; result : results){
            total += result.get();
        }
    )
}
</code></pre><blockquote>
<p>提示：invokeAny()方法和invokeAll()方法很像，但只要提交的所有任务中的任何一个完成了并且没有抛出异常，它就返回。它返回Future值，其它任务被取消。</p>
</blockquote>
<h2 id="2-异步计算"><a href="#2-异步计算" class="headerlink" title="2 异步计算"></a>2 异步计算</h2><h4 id="2-1-可完成的Future"><a href="#2-1-可完成的Future" class="headerlink" title="2.1 可完成的Future"></a>2.1 可完成的Future</h4><p>在拥有Future对象时，就需要调用get()方法获取值，get()方法会被阻塞，直到有可用的值。CompletableFuture类实现Future接口，并且提供获取结果的第二种机制。注册回调函数，一旦结果可用，会立刻处理。</p>
<p>如果想要异步运行任务并获取CompletableFuture时，不要直接将任务提交到ExecutorService,调用CompletableFuture.supplyAsync。</p>
<pre><code>CompletableFuture&lt;String&gt; f = CompletableFuture.supplyAsync(
    () -&gt; {String result; Compute the result; return result;},
    executor
);
</code></pre><blockquote>
<p>提示：这里如果省略executor，任务会在默认的executor上运行。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：在多线程中调用同一个future的complete或者completeExceptionally()方法是安全的。如果future已经完成，这些调用没有影响。</p>
</blockquote>
</blockquote>
<h4 id="2-2-组合可完成的Future"><a href="#2-2-组合可完成的Future" class="headerlink" title="2.2 组合可完成的Future"></a>2.2 组合可完成的Future</h4><p>CompletableFuture类通过提供一种将异步任务组合到一个处理流水线中的机制。</p>
<h4 id="2-3-UI回调中的长时间运行任务"><a href="#2-3-UI回调中的长时间运行任务" class="headerlink" title="2.3 UI回调中的长时间运行任务"></a>2.3 UI回调中的长时间运行任务</h4><p>在程序需要做一些耗时的事情时，不能在UI线程中执行这样的任务，否则UI就会冻结。所以在这种时候可以启动另外一个工作线程。</p>
<pre><code>Button read = new Button(&quot;Read&quot;);
read.setOnAction(event -&gt; {
    Scanner in = new Scanner(url.openStream());
    while(in.hasNextLine()){
        String line = in.nextLine();
        ..
    }
});

//在另外一个线程做 长时间运行的任务在单一的线程中
read.setOnAction(event -&gt; {
    Runnable task = () -&gt; {
        Scanner in = new Scanner(url.openStream());
        while(in.hasNextLine()){
            String line = in.nextLine();
            ...
        }
    }
    executor.execute(task);
})
</code></pre><h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3 线程安全"></a>3 线程安全</h2><h4 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h4><pre><code>private static boolean done = false;

public static void main(String[] args){
    Runnable hellos = () -&gt; {
        for(int i = 1; i &lt;= 1000; i++){
            System.out.println(&quot;hello&quot; + i);
            done = true;
        }
    };

    Runnable goodbye = () -&gt; {
        int i = 1;
        while(!done){
            i++;
        }
        System.out.println(&quot;goodbye&quot; + i);
    };

    Executor executor = Executors.newCachedThreadPool();
    executor.execute(hellos);
    executor.execute(goodbye);
}
</code></pre><blockquote>
<p>提示：这一程序中的done对第二个任务线程是不可见的。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：总结集中方式可以确保对变量的更新是可见的：1.final变量的值在初始化后是可见的。2.static变量的初始值在静态初始化后是可见的。3.对volatie变量的改变是可见的。</p>
</blockquote>
</blockquote>
<pre><code>//所以上面的done变量声明时带上volatile修饰符
private static volatile boolean done;
</code></pre><h4 id="3-2-竞争条件"><a href="#3-2-竞争条件" class="headerlink" title="3.2 竞争条件"></a>3.2 竞争条件</h4><p>多个并发任务更新一个整数共享计数器。这时候就会发生一种因为共享变量变化不一致的问题。这种错误称之为：竞争条件，因为其依赖于哪个线程赢得更新共享变量的竞争。</p>
<blockquote>
<p>提示：竞争条件是修改共享变量时的一个问题。如果指定的复杂序列在不合适的时候被暂停，而其它任务获得对序列的控制，此时序列会处于不一致的状态，这样很多事情都会出错。此时如果我们需要确保操作的整个序列是一起执行的。这样的执行序列是：临界区。可以使用锁来保护临界区，但是锁很难恰当的使用。</p>
</blockquote>
<h4 id="3-3-安全并发策略"><a href="#3-3-安全并发策略" class="headerlink" title="3.3 安全并发策略"></a>3.3 安全并发策略</h4><pre><code>1.限制：在任务中间不共享数据，每个任务都有自己私有计数器，如果后面需要统一的结果再将任务的结果切换到另一任务中执行合并。

2.不变性：共享不可修改的对象是安全的。

3.锁
</code></pre><h4 id="3-4-不可变类"><a href="#3-4-不可变类" class="headerlink" title="3.4 不可变类"></a>3.4 不可变类</h4><p>如果一个类的实例一旦构造完毕，就不能再次改变，那么此类是不可变类。</p>
<h2 id="4-并行算法"><a href="#4-并行算法" class="headerlink" title="4 并行算法"></a>4 并行算法</h2><h4 id="4-1-并行流"><a href="#4-1-并行流" class="headerlink" title="4.1 并行流"></a>4.1 并行流</h4><pre><code>long result = coll.parallelStream().filter(s -&gt; s.startsWith(&quot;A&quot;)).count();
</code></pre><p>parallelStream()方法产生一个并行流。</p>
<h4 id="4-2-并行数组操作"><a href="#4-2-并行数组操作" class="headerlink" title="4.2 并行数组操作"></a>4.2 并行数组操作</h4><p>Arrays类有很多并行化操作。这些操作将数组分解为片，在片上并发工作，最后合并结果。静态Arrays.parallelSetAll()方法以函数的计算值填充数组。</p>
<pre><code>Arrays.parallelSetAll(values, i -&gt; i % 10);

Arrays.parallelSort(words, Comparator.comparing(String::length));
</code></pre><h2 id="5-线程安全的数据结构"><a href="#5-线程安全的数据结构" class="headerlink" title="5 线程安全的数据结构"></a>5 线程安全的数据结构</h2><p>java.util.concurrent包中的集合都是巧妙实现的，因此多个线程可以在不阻塞的情况下实现对数据的访问。</p>
<blockquote>
<p>注意：这些集合产生 弱一致性 的迭代器。</p>
</blockquote>
<h4 id="5-1-ConcurrentHashMap"><a href="#5-1-ConcurrentHashMap" class="headerlink" title="5.1 ConcurrentHashMap"></a>5.1 ConcurrentHashMap</h4><p>ConcurrentHashMap 首先是哈希映射，其操作时线程安全的。不管多少线程同时在map上操作，内部结构都不会损坏。一些线程可能会临时被阻塞，但map可以高效支持大量并发操作以及一定数量的并发写操作。</p>
<h4 id="5-2-阻塞队列"><a href="#5-2-阻塞队列" class="headerlink" title="5.2 阻塞队列"></a>5.2 阻塞队列</h4><p>阻塞队列 是在任务中间协调工作的一个常用工具。生产者任务在队列中插入项，消费者在队列中获取项。队列让我们安全的将数据从一个任务转移到另外一个任务。</p>
<pre><code>java.util.concurrent包提供几个阻塞队列的变体：

    1.LinkedBlockingQueue 基于链表
    2.ArrayBlockingQueue 使用循环数组
</code></pre><h4 id="5-3-其它线程安全的数据结构"><a href="#5-3-其它线程安全的数据结构" class="headerlink" title="5.3 其它线程安全的数据结构"></a>5.3 其它线程安全的数据结构</h4><h2 id="6-原子计数器和累加器"><a href="#6-原子计数器和累加器" class="headerlink" title="6 原子计数器和累加器"></a>6 原子计数器和累加器</h2><p>如果多个线程更新一个共享计数器，那么我们需要保证更新操作时按照线程安全方式进行的。java.util.concurrent.atomic包中有很多类，它们使用 安全并且高效 的机器级指令确保对整数和long和boolean值、对象引用和数组操作的原子性。</p>
<pre><code>public static AtomicLong nextNumber = new AtomicLong();
//某些线程中..
long id = nextNumber.incrementAndGet();
</code></pre><blockquote>
<p>提示：这里的incrementAndGet()方法会自动将AtomicLong的值加1，返回加之后的值。</p>
</blockquote>
<pre><code>public static AtomicLong largest = new AtomicLong();
//某些线程中..
largest.updateAndGet(x -&gt; Math.max(x, observed));
//或者
largest.accumulateAndGet(observed, Math::max);
</code></pre><h2 id="7-锁和条件"><a href="#7-锁和条件" class="headerlink" title="7 锁和条件"></a>7 锁和条件</h2><h4 id="7-1-锁"><a href="#7-1-锁" class="headerlink" title="7.1 锁"></a>7.1 锁</h4><h4 id="7-2-synchronized关键字"><a href="#7-2-synchronized关键字" class="headerlink" title="7.2 synchronized关键字"></a>7.2 synchronized关键字</h4><h4 id="7-3-条件等待"><a href="#7-3-条件等待" class="headerlink" title="7.3 条件等待"></a>7.3 条件等待</h4><p>这里的synchronized方法确保这些操作是原子的。】</p>
<pre><code>public class Queue{
    class Node{
        Object value;
        Node next;
    }

    private Node head;
    private Node tail;

    public synchronized void add(Object newValue){
        Node n = new Node();
        if(head == null){
            head = n;
        }else{
            tail.next = n;
        }
        tail = n;
        tail.value = newValue;
    }

    public synchronized Object remove(){
        if(head == null){
            return null;
        }
        Node n = head;
        head = n.next;
        return n.value;
    }
}
</code></pre><h2 id="8-线程"><a href="#8-线程" class="headerlink" title="8 线程"></a>8 线程</h2><h4 id="8-1-启动线程"><a href="#8-1-启动线程" class="headerlink" title="8.1 启动线程"></a>8.1 启动线程</h4><pre><code>//等待一个线程完成
thread.join(millis);
</code></pre>]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程 - 续</title>
    <url>/undefined/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20-%20%E7%BB%AD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="多线程之共享数据"><a href="#多线程之共享数据" class="headerlink" title="多线程之共享数据"></a>多线程之共享数据</h2><p>在这里主要总结线程共享数据的相关知识，主要包括两方面:一是某个线程内如何共享数据，保证各个线程的数据不交叉。二是多个线程间如何共享数据，保证数据的一致性。</p>
<h4 id="1-线程范围内共享数据"><a href="#1-线程范围内共享数据" class="headerlink" title="1.线程范围内共享数据"></a>1.线程范围内共享数据</h4><p>当我们自己实现的话，是定义一个Map，线程为键，数据为值。表中的每一项即是为每个线程准备的数据，这样在一个线程中数据是一致的。<br><a id="more"></a><br>如：</p>
<pre><code>package com.iot.thread;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

/**
 * Created by brian on 2016/2/4.
 */
public class ThreadScopeShareData {
    //准备一个哈希表，为每个线程准备数据
    private  static Map&lt;Thread,Integer&gt; threadData = new HashMap&lt;&gt;();
    public static void main(String[] args) {
        for(int i=0;i&lt;2;i++){
            new Thread(
                    new Runnable() {
                @Override
                public void run() {
                    int data = new Random().nextInt();
                    threadData.put(Thread.currentThread(),data);
                    System.out.println(Thread.currentThread()+&quot; put data：&quot;+data);
                    new A().get();
                    new B().get();
                }
            }).start();
        }
    }
   static  class A{
        public void get(){
            int data = threadData.get(Thread.currentThread());
            System.out.println(&quot;A from &quot;+Thread.currentThread()+&quot; get data &quot;+data);
        }
    }

    static  class B{
        public void get(){
            int data = threadData.get(Thread.currentThread());
            System.out.println(&quot;B from &quot;+Thread.currentThread()+&quot; get data &quot;+data);
        }
    }
}
</code></pre><p>上述代码偶尔会报异常：</p>
<pre><code>Exception in thread &quot;Thread-0&quot; java.lang.NullPointerException
    at com.iot.thread.ThreadScopeShareData$A.get(ThreadScopeShareData.java:29)
    at com.iot.thread.ThreadScopeShareData$1.run(ThreadScopeShareData.java:21)
    at java.lang.Thread.run(Thread.java:745)
</code></pre><h4 id="2-ThreadLocal类"><a href="#2-ThreadLocal类" class="headerlink" title="2.ThreadLocal类"></a>2.ThreadLocal类</h4><p>API</p>
<pre><code>java.lang:Class ThreadLocal&lt;T&gt;
</code></pre><ul>
<li><p>单变量 使用ThreadLocal类型的对象代替上面的Map即可</p>
</li>
<li><p>多变量 定义一个对象来封装多个变量，然后在ThreadLocal中存储整个对象</p>
</li>
</ul>
<blockquote>
<p>多变量时，最好将ThreadLocal类放在数据类的内部，数据类采用单例模式，这样，新建对象和获取对象都会更方便，同时封装性更强。</p>
</blockquote>
<p>示例代码:</p>
<pre><code>package com.iot.thread;

import java.util.Random;

/**
 * Created by brian on 2016/2/4.
 */
public class ThreadLocalTest {
    private  static ThreadLocal&lt;Integer&gt; threadInger = new ThreadLocal&lt;&gt;();
    public static void main(String[] args) {
        for(int i=0;i&lt;2;i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    int data = new Random().nextInt(100);
                    threadInger.set(data);
                    System.out.println(Thread.currentThread()+&quot; put data：&quot;+data);
                    MyThreadScopeData.getThreadInstance().setName(Thread.currentThread().toString());
                    MyThreadScopeData.getThreadInstance().setAge(data%10);
                    new A().get();
                    new B().get();
                }
            }).start();
        }
    }
    static  class A{
        public void get(){
            int data = threadInger.get();
            System.out.println(&quot;A from &quot;+Thread.currentThread()+&quot; get data &quot;+data);
            MyThreadScopeData myThreadScopeData = MyThreadScopeData.getThreadInstance();
            System.out.println(&quot;A from &quot;+myThreadScopeData);

        }
    }

    static  class B{
        public void get(){
            int data = threadInger.get();
            System.out.println(&quot;B from &quot;+Thread.currentThread()+&quot; get data &quot;+data);
            MyThreadScopeData myThreadScopeData = MyThreadScopeData.getThreadInstance();
            System.out.println(&quot;B from &quot;+myThreadScopeData);
        }
    }
}

/**
 * 将多变量封装起来的数据类
 * 单例模式，内置ThreadLocal类型变量
 */
class MyThreadScopeData{

    private MyThreadScopeData(){}

    private static ThreadLocal&lt;MyThreadScopeData&gt; data = new ThreadLocal&lt;&gt;();

    public static  MyThreadScopeData getThreadInstance(){
        MyThreadScopeData instance = data.get();
        if(instance == null){
            instance = new MyThreadScopeData();
            data.set(instance);
        }
        return instance;
    }



    private String name;
    private int age;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        String reVal = super.toString()+&quot;-{name,age}&quot;+&quot;:{&quot;+getName()+&quot;,&quot;+getAge()+&quot;}&quot;;
        return reVal;
    }
}
</code></pre><h4 id="3-多线程访问共享数据"><a href="#3-多线程访问共享数据" class="headerlink" title="3.多线程访问共享数据"></a>3.多线程访问共享数据</h4><p>这里的几种方式：</p>
<pre><code>1.线程执行代码相同，使用同一Runnable对象，Runnable对象中有共享数据。
2.线程执行代码不同，将共享数据封装在另一对象中（操作数据的方法也在该对象完成），将这个对象逐一传递给各个Runnable对象。[本质：共享数据的对象作为参数传入Runnable对象]。
3.线程执行代码不同，将Runnable对象作为某一个类的内部类，共享数据作为这个外部类的成员变量（操作数据的方法放在外部类）。[本质:不同内部类共享外部类数据]

4.结合上两种方式，将共享数据封装在另一对象中（操作数据的方法也在该对象完成），该对象作为这个外部类的成员变量，将Runnable对象作为内部类。
</code></pre><p>最后一种方式的示例:<br>设计5个线程，其中三个线程每次对j增加1，另外两个线程对j每次减少1</p>
<pre><code>package com.iot.thread;

/**
 * Created by brian on 2016/2/4.
 */
public class MutiThreadShareData {

    private static MutiShareData mutiShareData = new MutiShareData();

    public static void main(String[] args) {

        for(int i=0;i&lt;3;i++){
            new Thread(
                    new Runnable() {
                        @Override
                        public void run() {
                            System.out.println(Thread.currentThread()+&quot;:{j from &quot;+ mutiShareData.getJ()+&quot; + to: &quot;+mutiShareData.increment()+&quot;}&quot;);
                        }
                    }
            ).start();
        }

        for(int i=0;i&lt;2;i++){
            new Thread(
                    new Runnable() {
                        @Override
                        public void run() {
                            System.out.println(Thread.currentThread()+&quot;:{j from &quot;+ mutiShareData.getJ()+&quot; - to: &quot;+mutiShareData.decrement()+&quot;}&quot;);
                        }
                    }
            ).start();
        }
    }

}

/**
 * 将共享数据封装在另一对象中（操作数据的方法也在该对象完成）
 */
class MutiShareData{
    private int j = 0;
    public synchronized  int increment(){
        return  ++j;
    }
    public synchronized int  decrement(){
        return --j;
    }

    public synchronized int getJ() {
        return j;
    }

    public synchronized void setJ(int j) {
        this.j = j;
    }
}
</code></pre><hr>
<h2 id="多线程之线程并发库"><a href="#多线程之线程并发库" class="headerlink" title="多线程之线程并发库"></a>多线程之线程并发库</h2><p>这里主要概述java.util.concurrent包下的相关类和使用方法</p>
<pre><code>Package java.util.concurrent
</code></pre><h4 id="1-原子性操作类"><a href="#1-原子性操作类" class="headerlink" title="1.原子性操作类"></a>1.原子性操作类</h4><p>java.util.concurrent.atomic包下的类:</p>
<pre><code>Package java.util.concurrent.atomic
</code></pre><h4 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h4><p>线程池的作用是用来管理线程，减少内存的消耗。</p>
<pre><code>java.util.concurrent:Class Executors
</code></pre><h5 id="2-1-常用线程池"><a href="#2-1-常用线程池" class="headerlink" title="2.1 常用线程池"></a>2.1 常用线程池</h5><p>几种常用的的生成线程池的方法：</p>
<pre><code>newCachedThreadPool
newFixedThreadPool
newScheduledThreadPool
newSingleThreadExecutor
newSingleThreadScheduledExecutor
</code></pre><blockquote>
<p>例子：newFixedThreadPool</p>
</blockquote>
<pre><code>ExecutorService threadPool = Executors.newFixedThreadPool(3);
for(int i=0;i&lt;10;i++){
    threadPool.execute(new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName());
        }
    });
}
</code></pre><blockquote>
<p>单线程newSingleThreadExecutor可用于重启</p>
</blockquote>
<blockquote>
<blockquote>
<p>用线程池启动定时器</p>
</blockquote>
</blockquote>
<p><strong>1.案例：类似Timer的定时执行</strong><br></p>
<pre><code>Executors.newScheduledThreadPool(3).scheduleAtFixedRate(
            new Runnable() {
                @Override
                public void run() {
                    System.out.println(&quot;ScheduledThreadPool &quot;+Thread.currentThread().getName());
                }
            },3,1, TimeUnit.SECONDS
    );
</code></pre><p><strong>2.案例：创建线程池</strong><br></p>
<pre><code>package cn.edu.xidian.B.Demo.Thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(6);
        Runnable target = () -&gt; {
            for (int i = 0; i &lt; 100; i++){
                System.out.println(Thread.currentThread().getName() + &quot;的i值为：&quot; + i);
            }
        };

        //向线程中提交两个线程
        pool.submit(target);
        pool.submit(target);

        //关闭线程池
        pool.shutdown();
    }
}
</code></pre><h4 id="3-Callable-amp-Future"><a href="#3-Callable-amp-Future" class="headerlink" title="3.Callable&amp;Future"></a>3.Callable&amp;Future</h4><p>ExecutorService在Executor的基础上增加了一些方法，其中有两个核心的方法：</p>
<pre><code>Future&lt;?&gt; submit(Runnable task)
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
</code></pre><blockquote>
<p>注意：这两个方法都是向线程池中提交任务，它们的区别在于Runnable在执行完毕后没有结果，Callable执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的相同点在于都返回一个Future对象。Future对象可以阻塞线程直到运行完毕（获取结果，如果有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。</p>
</blockquote>
<h4 id="6-同步工具"><a href="#6-同步工具" class="headerlink" title="6.同步工具"></a>6.同步工具</h4><pre><code>Semaphore
</code></pre><p>类似占坑</p>
<pre><code>CyclicBarrier
</code></pre><p>阶段性使进度一致</p>
<pre><code>CountDownLatch
</code></pre><p>一人通知多人/多人通知一人</p>
<pre><code>Exchanger
</code></pre><p>线程间数据交换，都到达则自然交换</p>
<hr>
]]></content>
      <categories>
        <category>Java 并发编程</category>
      </categories>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程</title>
    <url>/undefined/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="多线程之传统多线程"><a href="#多线程之传统多线程" class="headerlink" title="多线程之传统多线程"></a>多线程之传统多线程</h2><p>[TOC]</p>
<h4 id="1-传统线程技术"><a href="#1-传统线程技术" class="headerlink" title="1.传统线程技术"></a>1.传统线程技术</h4><pre><code>1.进程：正在运行的程序，负责了这个程序的内存空间分配，代表了内存中的执行区域。

2.线程：在一个进程中负责一个执行路径。3.多线程：在一个进程中多个执行路径同时执行。
</code></pre><blockquote>
<p>总结：进程负责一个程序的内存空间分配，线程负责一个程序的执行路径。进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
</blockquote>
<pre><code>1.所有与进程相关的资源都被记录在PCB中

2.进程是抢占处理机的调度单位，线程属于某个进程，共享其资源

    1.线程和进程的区别：

        1.线程不能看作独立应用，而进程可看作独立应用

        2.进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径

        3.线程没有独立的地址空间，多进程的程序比多线程程序健壮

        4.进程的切换比线程的切换开销大


    2.Java进程和线程的关系

        1.Java对操作系统提供的功能进行封装，包括进程和线程

        2.运行一个程序会产生一个进程，进程包含至少一个线程

        3.每个进程对应一个JVM实例，多个线程共享JVM里的堆

        4.Java采用单线程编程模型，程序会自动创建主线程

        5.主线程可以创建子线程，原则上要后于子线程完成执行
</code></pre><blockquote>
<blockquote>
<p>提示：再次我们了解到，由于cpu的分时机制，使得每个进程都能够循环获得自己的cpu时间片。但因为轮换速度非常快，所以在我们看来所有的程序好像在同时运行一样。</p>
</blockquote>
</blockquote>
<blockquote>
<p>多线程的优势：1.解决一个进程里面可以同时运行多个任务。2.提高资源的利用率，不是提高效率。</p>
<blockquote>
<p>多线程的弊端：1.降低一个进程里面的线程的执行频率。2.对线程进行管理要求额外的CPU开销。线程的使用会给系统带来上下文切换的额外负担。3.公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个线程存放的数据，发生线程安全问题。4.线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。</p>
</blockquote>
</blockquote>
<h5 id="1-线程的优先级"><a href="#1-线程的优先级" class="headerlink" title="1.线程的优先级"></a>1.线程的优先级</h5><pre><code>Java线程的优先级是整数，取值范围是1-10，默认情况下，每个线程都会分配到一个优先级（5）。
</code></pre><h5 id="2-Thread方法"><a href="#2-Thread方法" class="headerlink" title="2.Thread方法"></a>2.Thread方法</h5><pre><code>1.start() 方法 Java虚拟机调用该线程的run()方法

2.run() 方法 

3.setName()方法 改变线程的名称

4.
</code></pre><h4 id="2-传统线程的创建方式"><a href="#2-传统线程的创建方式" class="headerlink" title="2.传统线程的创建方式"></a>2.传统线程的创建方式</h4><h5 id="1-继承Thread类，覆盖run-方法。"><a href="#1-继承Thread类，覆盖run-方法。" class="headerlink" title="1.继承Thread类，覆盖run()方法。"></a>1.继承Thread类，覆盖run()方法。</h5><pre><code>//在此demo中，线程1 2 只是无序的执行，多线程资源争夺没有起到效果
class Demo extends Thread{
    public Demo(String name){
        super(name);
    }

    public void print(){
        for(int i=0;i&lt;10;i++){
            //这里的getName()方法是获取线程的名字
            System.out.println(this.getName()+&quot;:&quot;+i);
        }
    }
    public static void main(String[] args){
        Demo demo1 = new Demo(&quot;Aaron&quot;);//创建线程1
        Demo demo2 = new Demo(&quot;Brian&quot;);//创建线程2
        demo1.print();
        demo2.print();
    }
}

2.把要执行的任务放在run()方法中
//此程序中线程是按照顺序进行的，即先运行了线程1，然后在运行线程2，没有进行线程之间的争夺效果
class Demo extends Thread {
    @Override
    public void run(){
        print();//该程序主要的任务就是运行print()方法，所以在run()方法中调用print方法即可。
    }

    public Demo (String name){
        super(name);
    }

    public void print(){
        for(int i=0;i&lt;10;i++){
            System.out.println(this.getName()+&quot;:&quot;+i);
        }
    }

    public static void main(String[] args){
        Demo demo1 = new Demo(&quot;Aaron&quot;);//创建线程1
        Demo demo2 = new Demo(&quot;Brian&quot;);//创建线程2

        //运行两个线程
        demo1.run();
        demo2.run();
    }
}

3.调用start()方法启动线程
//此demo中实现了线程之间的资源争夺过程
class Demo extends Thread {
    @Override
    public void run(){
        print();//该程序主要的任务就是运行print()方法，所以在run()方法中调用print方法即可。
    }

    public Demo(String name){
        super(name);
    }
    public void print(){
        for(int i = 0; i &lt; 10; i++){
            try{
                this.sleep(1000);//此运行线程睡眠1s
            }catch(InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(this.getName()+&quot;:&quot;+i);
        }
    }
    public static void main(String[] args){
        Demo demo1 = new Demo(&quot;Aaron&quot;);//创建线程1
        Demo demo2 = new Demo(&quot;Brian&quot;);//创建线程2
        demo1.start();
        demo2.start();
    }
}
</code></pre><blockquote>
<p>总结：1.线程的启动使用了父类的start()方法。2.如果线程对象直接调用run()方法，那么Java虚拟机不会将其当做线程来运行，只会当做普通的方法调用。3.线程的启动只能有一次，否则会抛出异常。4.可以直接创建Thread类的对象并启动该线程，但是如果没有重写run()，什么也不执行。5.匿名内部类的线程实现方式。</p>
</blockquote>
<hr>
<h5 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h5><p>实现Runnable接口是实现线程最简单的方式，实现Runnable，一个类只需要执行一个方法调用run()就行。</p>
<pre><code>package cn.edu.xidian.B.Demo.Thread;

public class RunnableDemo implements Runnable {
    private Thread t;
    private String tname;

    public RunnableDemo(String tname) {
        this.tname = tname;
        System.out.println(&quot;创建&quot; + tname);
    }

    @Override
    public void run() {
        System.out.println(&quot;运行&quot; + tname);
        try {
            for (int i = 4; i &gt; 0; i--){
                System.out.println(&quot;线程&quot; + tname + &quot;,&quot; + i);
                Thread.sleep(100);
            }
        } catch (InterruptedException e) {
            System.out.println(&quot;线程&quot; + tname + &quot;暂停&quot; );
        }
        System.out.println(&quot;线程&quot; + tname + &quot;结束&quot;);
    }

    public void start(){
        System.out.println(&quot;开始&quot; + tname);
        if (t == null){
            t = new Thread(this,tname);
            t.start();
        }
    }
}

//测试类
package cn.edu.xidian.B.Demo.Thread;

public class ThreadRunnableTest {
    public static void main(String[] args) {
        RunnableDemo r1 = new RunnableDemo(&quot;线程1&quot;);
        r1.start();

        RunnableDemo r2 = new RunnableDemo(&quot;线程2&quot;);
        r2.start();

    }
}
</code></pre><h5 id="3-Thread和Runnable的关系"><a href="#3-Thread和Runnable的关系" class="headerlink" title="3.Thread和Runnable的关系"></a>3.Thread和Runnable的关系</h5><pre><code>1.Thread是实现了Runnable接口的类，使得run支持多线程

2.因类的单一继承原则，推荐多使用Runnable接口
</code></pre><hr>
<h2 id="J-U-C-其它组件"><a href="#J-U-C-其它组件" class="headerlink" title="J.U.C - 其它组件"></a>J.U.C - 其它组件</h2><h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><p>Java 5 之后，Java提供Callable接口，该接口是Runnable接口的增强，Callable接口提供一个call()方法可以作为线程执行体，但是call()方法比run()方法更加强大。</p>
<p>因此我们可以提供一个Callable对象作为Thread的target，而该线程的线程执行体就是该Callable对象的call()方法。</p>
<p>call()方法并不是直接调用，它是作为线程执行体被调用的。</p>
<p>Java 5 提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，可以作为Thread类的target。</p>
<p>我们知道Callable接口在调用时有返回值，返回值通过Future进行封装。FutureTask实现了RunnableFuture接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<pre><code>package Java.ChapterSeven.FutureTask;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {

        //用于异步获取执行结果或取消执行任务的场景
        //当一个任务需要很久执行时间，可以用futureTask来封装这个任务，主线程完成自己的任务之后再去获取结果
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i &lt; 100; i++){
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });

        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -&gt; {
            System.out.println(&quot;other task is running...&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}

other task is running...
4950
</code></pre><blockquote>
<p>提示：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
</blockquote>
<h5 id="1-创建并启动有返回值的线程步骤："><a href="#1-创建并启动有返回值的线程步骤：" class="headerlink" title="1.创建并启动有返回值的线程步骤："></a>1.创建并启动有返回值的线程步骤：</h5><pre><code>1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。call()方法可以抛出异常。

2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。

3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。

4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。


package cn.edu.xidian.B.Demo.Thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable&lt;Integer&gt; {
    public static void main(String[] args) {

        //1.程序首先创建一个Callable实现类的实例
        CallableThreadTest ctt = new CallableThreadTest();

        //2.然后将该实例包装成一个FutureTask对象
        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(ctt);

        for (int i = 0; i &lt; 100; i++){
            System.out.println(Thread.currentThread().getName() + &quot;的循环变量i的值&quot; + i);
            if (i == 20){
                new Thread(ft,&quot;有返回值的线程&quot;).start();
            }
        }

        try {

            //3.调用FutureTask对象的get()方法返回call()方法的返回值，该方法将导致线程阻塞，直到call()方法结束并返回为止
            System.out.println(&quot;子线程的返回值：&quot; + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i &lt; 100; i++){
            System.out.println(Thread.currentThread().getName() + &quot;&quot; + i);
        }
        return i;
    }
}


1.程序首先创建一个Callable实现类的实例

2.然后将该实例包装成一个FutureTask对象

3.调用FutureTask对象的get()方法返回call()方法的返回值，该方法将导致线程阻塞，直到call()方法结束并返回为止
</code></pre><blockquote>
<p>总结：1.采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。<br><br>2.使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p>
</blockquote>
<hr>
<h4 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2.线程的状态"></a>2.线程的状态</h4><pre><code>1.新建状态 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

2.运行状态

    1.就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

    2.可运行：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取cpu的执行权。

3.无限期等待 

    不会被分配CPU执行时间，需要显式被唤醒

4.限期等待 

    在一定时间之后会由系统自动唤醒

5.阻塞

    等待获取排它锁

    阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。sleep()睡眠。

6.死亡：线程执行完它的任务时。
</code></pre><blockquote>
<p>注意：在启动线程的时候使用start()方法，永远不要调用run()方法，调用start()方法来启动线程，系统会将该run()方法当做线程执行体来处理。如果直接调用线程对象的run()方法，则run()方法就会立即被执行，在run()方法返回之前，其它线程无法并发执行。</p>
</blockquote>
<blockquote>
<p>提示：如果希望调用子线程的start()方法之后，子线程立即执行，程序可以使用 Thread.sleep()方法睡眠一秒，此时CPU不会空闲，它回去执行另一个处于就绪状态的线程。</p>
</blockquote>
<blockquote>
<p>提示：不要试图对一个已经死亡的线程调用start()方法使他重新启动，死亡就是死亡，该线程将不可再次作为线程执行。只能对新建状态的线程调用start()方法，调用两次也是错误的。会引起IllegalThreadStateException异常。</p>
</blockquote>
<p>3.常见线程的方法</p>
<pre><code>1.Thread(String name) 初始化线程的名字
2.getName() 返回线程的名字
3.setName(String name) 设置线程对象名
4.getPriority() 返回当前线程对象的优先级 默认线程的优先级是5
5.setPriority(int newPriority) 设置线程的优先级 虽然设置了线程的优先级，但是具体的实现取决于底层的操作系统的实现（最大的优先级是10 ，最小的1 ，默认是5）。
6.currentThread() 返回CPU正在执行的线程的对象
</code></pre><p>程序：</p>
<pre><code>class ThreadDemo1 extends Thread {
    public ThreadDemo1(){

    }
    public ThreadDemo1( String name ){
       super( name );
    }

    public void run(){
       int i = 0;
       while(i &lt; 30){
          i++;
          System.out.println( this.getName() + &quot; &quot;+ &quot; : i = &quot; + i);
          System.out.println( Thread.currentThread().getName() + &quot; &quot;+ &quot; : i = &quot; + i);
          System.out.println( Thread.currentThread() == this );
          System.out.println( &quot;getId()&quot; + &quot; &quot;+ &quot; : id = &quot; + super.getId() );
          System.out.println( &quot;getPriority()&quot; + &quot; &quot;+ &quot; : Priority = &quot; + super.getPriority() );
       }
    }
}
class Demo3 
{
    public static void main(String[] args) 
    {
        ThreadDemo1 th1 = new ThreadDemo1(&quot;线程1&quot;);
        ThreadDemo1 th2 = new ThreadDemo1(&quot;线程2&quot;);
        // 设置线程名
        th1.setName( &quot;th1&quot; );
        th2.setName( &quot;th2&quot; );
        // 设置线程优先级  1 ~ 10
        th1.setPriority( 10 ); 
        th2.setPriority( 7 ); 
        // 查看SUN定义的线程优先级范围
        System.out.println(&quot;max : &quot; + Thread.MAX_PRIORITY );
        System.out.println(&quot;min : &quot; + Thread.MIN_PRIORITY );
        System.out.println(&quot;nor : &quot; + Thread.NORM_PRIORITY );
        th1.start();
        th2.start();
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre><h5 id="案例：模拟卖票问题，也就是一个线程的资源争夺问题"><a href="#案例：模拟卖票问题，也就是一个线程的资源争夺问题" class="headerlink" title="案例：模拟卖票问题，也就是一个线程的资源争夺问题"></a>案例：模拟卖票问题，也就是一个线程的资源争夺问题</h5><pre><code>class SaleTickets extends Thread {
    int tickets = 100;
    public void run(){
        while(tickets&gt;0){
            System.out.println(&quot;卖到了第&quot;+tickets+&quot;张票&quot;);
            tickets--;
        }
    }
}

class Demo {
    public static void main(String[] args){
        SaleTickets thread1 = new SaleTickets();
        SaleTickets thread2 = new SaleTickets();
        SaleTickets thread3 = new SaleTickets();
        SaleTickets thread4 = new SaleTickets();
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
    }
}
</code></pre><blockquote>
<p>在这个demo中需要注意的是我们启动了四个线程，那么tickets是一个成员变量，在一个线程对象中都维护了属于自己的tickets属性，所以总的存在四份。解决方案：成员变量tickets使用static修饰，使得每一个线程都共享一份属性。</p>
</blockquote>
<pre><code>class SaleTickets extends Thread {
    static int tickets = 100;
    public void run(){
        while(tickets&gt;0){
            System.out.println(&quot;卖到了第&quot;+tickets+&quot;张票&quot;);
            tickets--;
        }
    }
}

class Demo {
    public static void main(String[] args){
        SaleTickets thread1 = new SaleTickets();
        SaleTickets thread2 = new SaleTickets();
        SaleTickets thread3 = new SaleTickets();
        SaleTickets thread4 = new SaleTickets();
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
    }
}

2.实现Runnable接口，Runnable不是线程，是线程运行的代码的宿主。
    1.Runnable,target,run,start之间的关系：
        1.Runnable是一个接口
        2.target是Thread类中类型为Runnable，名为target的属性
        3.run是Thread类实现了Runnable的接口，重写的方法
        4.start是启动线程的方法
        5.在Thread类中，调用关系：start-&gt;start0-&gt;run-&gt;target.run
</code></pre><blockquote>
<p>注意：<code>target</code>属性由<code>private void init(ThreadGroup g, Runnable target, String name,long stackSize,AccessControlContext acc)</code>方法初始化。init方法在Thread类的构造方法里被调用。</p>
</blockquote>
<h5 id="案例：卖票"><a href="#案例：卖票" class="headerlink" title="案例：卖票"></a>案例：卖票</h5><pre><code>    class MyTicket implements Runnable {
    int tickets = 100;
    public void run() {
        while (true) {
            if (tickets &gt; 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;窗口@销售：&quot;
                        + tickets + &quot;号票&quot;);
                tickets--;

            } else {
                System.out.println(&quot;票已卖完。。。&quot;);
                break;
            }
        }
    }
}
public class Demo6 {
    public static void main(String[] args) {
        MyTicket mt = new MyTicket();
        Thread t1 = new Thread(mt);
        Thread t2 = new Thread(mt);
        Thread t3 = new Thread(mt);
        Thread t4 = new Thread(mt);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}

    2.匿名内部类对象的构造方法如何调用父类的非默认构造方法
</code></pre><h4 id="2-传统定时器技术"><a href="#2-传统定时器技术" class="headerlink" title="2.传统定时器技术"></a>2.传统定时器技术</h4><p>如：</p>
<pre><code>static int count = 0;
public static void main(String[] args) {

    class MyTimerTask extends TimerTask{

        @Override
        public void run() {
            System.out.println(Thread.currentThread()+&quot; bomb!&quot;);
            new Timer().schedule(new MyTimerTask(), 2000+1000*(count++%2));
        }
    }
    //3s后开启定时器
    new Timer().schedule(new MyTimerTask(),3000);
}
</code></pre><blockquote>
<p>提示：可以使用quarlz开源工具。</p>
</blockquote>
<h4 id="3-锁对象"><a href="#3-锁对象" class="headerlink" title="3.锁对象"></a>3.锁对象</h4><p>每个Java对象都有一个锁对象，而且只有一把钥匙。<br>1.创建锁对象<br>可以使用this关键字作为锁对象，或者使用所在类的字节码文件对应的Class对象作为锁对象。</p>
<p><strong>互斥：</strong><br><br>关键字：synchronized,检查锁对象。</p>
<pre><code>synchronized(this)
synchronized void function(){}
synchronized(A.class)
</code></pre><hr>
<pre><code>//锁对象的死锁案例
public class DeadLock {
    public static void main(String[] args) {
        new Thread(new Runnable() { // 创建线程, 代表中国人
                    public void run() {
                        synchronized (&quot;刀叉&quot;) { // 中国人拿到了刀叉
                            System.out.println(Thread.currentThread().getName()
                                    + &quot;: 你不给我筷子, 我就不给你刀叉&quot;);
                            try {
                                Thread.sleep(10);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            synchronized (&quot;筷子&quot;) {
                                System.out.println(Thread.currentThread()
                                        .getName() + &quot;: 给你刀叉&quot;);
                            }
                        }
                    }
                }, &quot;中国人&quot;).start();
        new Thread(new Runnable() { // 美国人
                    public void run() {
                        synchronized (&quot;筷子&quot;) { // 美国人拿到了筷子
                            System.out.println(Thread.currentThread().getName()
                                    + &quot;: 你先给我刀叉, 我再给你筷子&quot;);
                            try {
                                Thread.sleep(10);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            synchronized (&quot;刀叉&quot;) {
                                System.out.println(Thread.currentThread()
                                        .getName() + &quot;: 好吧, 把筷子给你.&quot;);
                            }
                        }
                    }
                }, &quot;美国人&quot;).start();
    }
}
</code></pre><blockquote>
<p>总结:死锁表示进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。</p>
</blockquote>
<h4 id="4-同步"><a href="#4-同步" class="headerlink" title="4.同步"></a>4.同步</h4><p>1.要用到共同数据(包括同步锁)或共同算法的若干个方法应该归在同一个类身上，这种设计体现了高聚类和程序的健壮性。2.同步互斥不是在线程上实现，而是在线程访问的资源上实现，线程调用资源。</p>
<p>线程间通信其实就是多个线程在操作同一个资源，但操作动作不同，wait(),notify(),notifyAll()都使用在同步中，因为要对持有监视器（锁）的线程操作，所以要使用在同步中，因为只有同步才具有锁。</p>
<blockquote>
<p>提示：1.wait()与sleep()之间的区别，wait()方法释放资源，释放锁，是Object的方法。而sleep()方法只释放资源，不释放锁，是Thread的方法。2.在定义了notify还要定义notifyAll是因为只用notify容易出现只唤醒本方线程情况，导致程序中的所有线程都在等待。</p>
</blockquote>
<h5 id="4-1-同步方法"><a href="#4-1-同步方法" class="headerlink" title="4.1 同步方法"></a>4.1 同步方法</h5><p><strong>1.同步函数</strong><br><br>同步函数就是用synchronize关键字修饰方法，由于每一个Java对象都有一个内置锁，所以在用synchronize关键字修饰方法时内置锁会保护整个方法，在调用该方法之前，都需要首先获得内置锁，否则会处于阻塞状态。</p>
<pre><code>public synchronized void run(){}
</code></pre><p><strong>2.同步代码块</strong><br><br>表示synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动加上内置锁，从而实现同步。</p>
<pre><code>public void run() {
    while(true){
        //同步代码块
        synchronized (this) {                        　　　　　　　　　
            if(tick&gt;0){
                try {
                    //执行中让线程睡眠10毫秒
                    Thread.sleep(10);                                
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot; &quot; + tick--);
            }
        }
    }
}
</code></pre><blockquote>
<p>注意：因为静态的方法中不能定义this，所以在静态的同步方法中使用的锁是该方法所在类的字节码文件对象。类名.class</p>
</blockquote>
<pre><code>public static mySyn(String name){
    synchronized (Xxx.class) {
        Xxx.name = name;
    }
}
</code></pre><h5 id="4-2-等待唤醒机制"><a href="#4-2-等待唤醒机制" class="headerlink" title="4.2 等待唤醒机制"></a>4.2 等待唤醒机制</h5><p>1.wait：告诉当前线程放弃执行权，并放弃监视器（锁）并进入阻塞状态，直到其他线程持有获得执行权，并持有了相同的监视器（锁）并调用notify为止。<br>2.notify：唤醒持有同一个监视器（锁）中调用wait的第一个线程。例如，餐馆有空位置后，等候就餐最久的顾客最先入座。注意：被唤醒的线程是进入了可运行状态。等待cpu执行权。<br>3.notifyAll：唤醒持有同一监视器中调用wait的所有的线程。</p>
<p>解决生产者与消费者问题：</p>
<pre><code>package cn.itcast.gz.runnable;

public class Demo10 {
    public static void main(String[] args) {
        Person p = new Person();
        Producer pro = new Producer(p);
        Consumer con = new Consumer(p);
        Thread t1 = new Thread(pro, &quot;生产者&quot;);
        Thread t2 = new Thread(con, &quot;消费者&quot;);
        t1.start();
        t2.start();
    }
}

// 使用Person作为数据存储空间
class Person {
    String name;
    String gender;
    boolean flag = false;

    public synchronized void set(String name, String gender) {
        if (flag) {
            try {
                wait();
            } catch (InterruptedException e) {

                e.printStackTrace();
            }
        }
        this.name = name;
        this.gender = gender;
        flag = true;
        notify();
    }

    public synchronized void read() {
        if (!flag) {
            try {
                wait();
            } catch (InterruptedException e) {

                e.printStackTrace();
            }
        }
        System.out.println(&quot;name:&quot; + this.name + &quot;----gender:&quot; + this.gender);
        flag = false;
        notify();
    }

}

// 生产者
class Producer implements Runnable {
    Person p;

    public Producer() {

    }

    public Producer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {
        int i = 0;
        while (true) {

            if (i % 2 == 0) {
                p.set(&quot;jack&quot;, &quot;man&quot;);
            } else {
                p.set(&quot;小丽&quot;, &quot;女&quot;);
            }
            i++;

        }

    }

}

// 消费者
class Consumer implements Runnable {
    Person p;

    public Consumer() {

    }

    public Consumer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {

        while (true) {
            p.read();

        }
    }

}
</code></pre><p>如：子线程循环5次，主线程循环10次，如此交替50次<br>分析：使用一个Business类来包含子线程和主线程要运行的代码，从而，该类的对象成为加锁的对象。同步互斥在该类实现，由线程调用该类的方法，即调用了资源。</p>
<pre><code>public class TraditionalThreadCommunication {
    public static void main(String[] args) {
        Business business = new Business();
        new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        for(int i=1;i&lt;=50;i++){
                            business.sub(i);
                        }
                    }
                }
        ).start();

        for(int i=1;i&lt;=50;i++){
            business.main(i);
        }

    }
}

class Business{
    private boolean bShouldSub = true;

    public synchronized void sub(int i){
        while(!bShouldSub){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        for(int j=1;j&lt;=5;j++){
            System.out.println(&quot;sub thread count &quot;+j+&quot;,&quot;+i+&quot;/50&quot;);
        }
        bShouldSub = false;
        this.notify();
    }
    public synchronized void main(int i){
        while(bShouldSub){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        for(int j=1;j&lt;=10;j++){
            System.out.println(&quot;main thread count &quot;+j+&quot;,&quot;+i+&quot;/50&quot;);
        }
        bShouldSub = true;
        this.notify();
    }
}
</code></pre><blockquote>
<p>提示：判断条件时，while与if的区别在于，while防止伪唤醒。</p>
</blockquote>
<h5 id="4-3-线程的生命周期"><a href="#4-3-线程的生命周期" class="headerlink" title="4.3 线程的生命周期"></a>4.3 线程的生命周期</h5><pre><code>//在多线程运行过程中，只要控制住循环，然后就可以让run()方法结束，线程结束
class StopThread implements Runnable {
    public boolean tag = true;
    @Override
    public void run() {
        int i = 0;

        while (tag) {
            i++;
            System.out.println(Thread.currentThread().getName() + &quot;i:&quot; + i);
        }
    }
}
public class Demo8 {
    public static void main(String[] args) {
        StopThread st = new StopThread();
        Thread th = new Thread(st, &quot;线程1&quot;);
        th.start();
        for (int i = 0; i &lt; 100; i++) {
            if (i == 50) {
                System.out.println(&quot;main i:&quot; + i);
                st.tag = false;
            }
        }
    }
}
</code></pre><h2 id="5-线程间通讯"><a href="#5-线程间通讯" class="headerlink" title="5.线程间通讯"></a>5.线程间通讯</h2><p>线程的通讯指的是多个线程在操作同一个资源，但是操作的动作不同。</p>
<p><strong>1.案例：生产者与消费者问题</strong><br></p>
<blockquote>
<p>提示：如有多个生产者和消费者，需要使用while循环判断标记，然后再使用notifyAll唤醒。否则只用notify容易出现只唤醒本方线程情况，导致程序中的所有线程都在等待。</p>
</blockquote>
<blockquote>
<blockquote>
<p>如：有一个数据存储空间，划分为两个部分：1.存储人的姓名。2.存储性别。然后开启两个线程，一个作为不停的向其中存储姓名与性别(生产者)，另外一个线程作为从数据存储空间中取出数据(消费者)。</p>
</blockquote>
</blockquote>
<p>所以在这个问题中需要考虑多线程的情况，如：1.假如生产者刚向数据存储空间中添加了一个人名，还没有来得及添加性别，cpu就切换到了消费者的线程，消费者就会将这个人的姓名和上一个人的性别进行了输出。2.生产者生产了若干次数据，消费者才开始取数据，或者消费者取出数据后，没有等到生产者放入新的数据，消费者又重复的取出自己已经取过的数据。</p>
<pre><code>//main方法
public class Demo10 {
    public static void main(String[] args) {
        Person p = new Person();
        Producer pro = new Producer(p);
        Consumer con = new Consumer(p);
        Thread t1 = new Thread(pro, &quot;生产者&quot;);
        Thread t2 = new Thread(con, &quot;消费者&quot;);
        t1.start();
        t2.start();
    }
}

// 使用Person作为数据存储空间
class Person {
    String name;
    String gender;
}

// 生产者
class Producer implements Runnable {
    Person p;

    public Producer() {

    }

    public Producer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {
        int i = 0;
        while (true) {
            if (i % 2 == 0) {
                p.name = &quot;jack&quot;;
                p.gender = &quot;man&quot;;
            } else {
                p.name = &quot;小丽&quot;;
                p.gender = &quot;女&quot;;
            }
            i++;
        }
    }
}

// 消费者
class Consumer implements Runnable {
    Person p;

    public Consumer() {

    }

    public Consumer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {

        while (true) {
            System.out.println(&quot;name:&quot; + p.name + &quot;---gnder:&quot; + p.gender);
        }
    }

}
</code></pre><blockquote>
<p>注意：在上面程序输出的过程中出现了线程的安全问题，所以需要使用关键字 synchronized 来解决该问题。</p>
</blockquote>
<pre><code>package cn.itcast.gz.runnable;

public class Demo10 {
    public static void main(String[] args) {
        Person p = new Person();
        Producer pro = new Producer(p);
        Consumer con = new Consumer(p);
        Thread t1 = new Thread(pro, &quot;生产者&quot;);
        Thread t2 = new Thread(con, &quot;消费者&quot;);
        t1.start();
        t2.start();
    }
}

// 使用Person作为数据存储空间
class Person {
    String name;
    String gender;
}

// 生产者
class Producer implements Runnable {
    Person p;

    public Producer() {

    }

    public Producer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {
        int i = 0;
        while (true) {
            synchronized (p) {
                if (i % 2 == 0) {
                    p.name = &quot;jack&quot;;
                    p.gender = &quot;man&quot;;
                } else {
                    p.name = &quot;小丽&quot;;
                    p.gender = &quot;女&quot;;
                }
                i++;
            }

        }

    }

}

// 消费者
class Consumer implements Runnable {
    Person p;

    public Consumer() {

    }

    public Consumer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {

        while (true) {
            synchronized (p) {
                System.out.println(&quot;name:&quot; + p.name + &quot;---gnder:&quot; + p.gender);
            }

        }
    }

}

//解决上面的问题2，生产者生产了若干次数据之后，消费者才开始取数据，或者消费者取出数据之后没有等到消费者//放入新的数据，消费者又重复取出自己已经取过的数据。
//解决：在Person类中添加set和read方法并设置为synchronized的，让生产者和消费者调用者两个方法。
public class Demo10 {
    public static void main(String[] args) {
        Person p = new Person();
        Producer pro = new Producer(p);
        Consumer con = new Consumer(p);
        Thread t1 = new Thread(pro, &quot;生产者&quot;);
        Thread t2 = new Thread(con, &quot;消费者&quot;);
        t1.start();
        t2.start();
    }
}

// 使用Person作为数据存储空间
class Person {
    String name;
    String gender;


    public synchronized void set(String name, String gender) {
        this.name = name;
        this.gender = gender;
    }

    public synchronized void read() {
        System.out.println(&quot;name:&quot; + this.name + &quot;----gender:&quot; + this.gender);
    }

}

// 生产者
class Producer implements Runnable {
    Person p;

    public Producer() {

    }

    public Producer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {
        int i = 0;
        while (true) {

            if (i % 2 == 0) {
                p.set(&quot;jack&quot;, &quot;man&quot;);
            } else {
                p.set(&quot;小丽&quot;, &quot;女&quot;);
            }
            i++;

        }

    }

}

// 消费者
class Consumer implements Runnable {
    Person p;

    public Consumer() {

    }

    public Consumer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {

        while (true) {
            p.read();

        }
    }

}
</code></pre><blockquote>
<p>总结：Java使用Object类的wait，notify，notifyAll这几个方法实现线程间的通信。所以在我们的需求是，生产者生产一次，消费者就消费一次的话，需要使用到线程间的通信。</p>
</blockquote>
<h4 id="传统线程通信"><a href="#传统线程通信" class="headerlink" title="传统线程通信"></a>传统线程通信</h4><h4 id="Lock-amp-Condition"><a href="#Lock-amp-Condition" class="headerlink" title="Lock &amp; Condition"></a>Lock &amp; Condition</h4><p><strong>1.Lock</strong><br><br>Lock功能类似传统多线程技术里的synchronized，实现线程互斥，但更加面向对象。将需要互斥的代码片段放到lock.lock();和lock.unlock();之间。</p>
<blockquote>
<p>案例1：</p>
</blockquote>
<pre><code>class A{
    private Lock lock = new ReentrantLock();

    public void function(){
        lock.lock();
        try{
            //功能代码
        }finally{
            lock.unlock();
        }
    }
}
</code></pre><ul>
<li>读写锁 <code>java.util.concurrent.locks:Class ReentrantReadWriteLock</code></li>
</ul>
<blockquote>
<p>案例2：javaDoc文档读写锁例子,缓存:</p>
</blockquote>
<pre><code>class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
        //在这获得写锁之前必须先释放读锁
       rwl.readLock().unlock();
       rwl.writeLock().lock();
       try {
         // Recheck state because another thread might have
         // acquired write lock and changed state before we did.
         if (!cacheValid) {
           data = ...
           cacheValid = true;
         }
         // Downgrade by acquiring read lock before releasing write lock
         rwl.readLock().lock();
       } finally {
         rwl.writeLock().unlock(); // Unlock write, still hold read
       }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 }
</code></pre><blockquote>
<p>注意：在释放写锁前加读锁那部分代码，注释为// Downgrade by acquiring read lock before releasing write lock。自己挂了写锁，再挂读锁是可以的，这面涉及的技巧以后再研究。</p>
</blockquote>
<hr>
<blockquote>
<blockquote>
<p>提示：volatile表示一个类型修饰符，被设计用来修饰不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到的时候是直接从对应的内存中提取，不会利用缓存。在使用了volatile修饰成员变量后，所有线程在任何时候所看到变量的值是相同的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>注意：volatile不能保证操作的原子性，所以在一般情况下volatile不能代替sychronized。此外，使用volatile会组织编译器对代码的优化，因此会降低程序的执行效率。</p>
</blockquote>
</blockquote>
<hr>
<h4 id="5-Condition"><a href="#5-Condition" class="headerlink" title="5.Condition"></a>5.Condition</h4><p>Condition类似于传统多线程技术中的Object.wait和Object.notify,实现线程间同步。</p>
<p>如果程序不使用synchronized关键字来保证同步，而是直接使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，不能使用 wait() | notify() | notifyAll()方法进行线程通信。</p>
<p>在使用Lock对象来保证同步时，Java提供一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法执行的线程释放Lock对象，Condition对象也可以唤醒其它处于等待的线程。</p>
<p>javaDoc文档例子，可阻塞队列</p>
<pre><code>class BoundedBuffer例子

class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length)
         notFull.await();
       items[putptr] = x;
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();
     } finally {
       lock.unlock();
     }
   }

   public Object take() throws InterruptedException {
     lock.lock();
     try {
       while (count == 0)
         notEmpty.await();
       Object x = items[takeptr];
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally {
       lock.unlock();
     }
   }
 }
</code></pre><blockquote>
<p>提示：使用了两个condition</p>
</blockquote>
<hr>
<h3 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h3><h4 id="6-使用阻塞队列（BlockingQueue）控制线程通信"><a href="#6-使用阻塞队列（BlockingQueue）控制线程通信" class="headerlink" title="6.使用阻塞队列（BlockingQueue）控制线程通信"></a>6.使用阻塞队列（BlockingQueue）控制线程通信</h4><p>在java.util.concurrent.BlockingQueue接口有以下阻塞队列实现：</p>
<pre><code>1.FIFO队列：LinkedBlockingQueue | ArrayBlockingQueue（固定长度）

2.优先级队列：PriorityBlockingQueue
</code></pre><p>该阻塞队列提供了阻塞的 take() | put()方法：如果队列为空 take() 将阻塞，直到队列中有内容。如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<h5 id="阻塞队列实现生产者和消费者的场景"><a href="#阻塞队列实现生产者和消费者的场景" class="headerlink" title="阻塞队列实现生产者和消费者的场景"></a>阻塞队列实现生产者和消费者的场景</h5><pre><code>package Java.ChapterSeven.BlockingQueue;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class ProducerConsumer {

    private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);
    private static class Producer extends Thread {
        @Override
        public void run(){
            try {
                queue.put(&quot;product&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;produce..&quot;);
        }
    }

    private static class Consumer extends Thread {
        @Override
        public void run(){
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;consumer..&quot;);
        }
    }

    public static void main(String[] args) {

        for (int i = 0; i &lt; 2; i++){
            Producer producer = new Producer();
            producer.start();
        }

        for (int i = 0; i &lt; 5; i++){
            Consumer consumer = new Consumer();
            consumer.start();
        }

        for (int i = 0; i &lt; 3; i++){
            Producer producer = new Producer();
            producer.start();
        }
    }
}
</code></pre><hr>
<h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><h4 id="1-join线程"><a href="#1-join线程" class="headerlink" title="1.join线程"></a>1.join线程</h4><p>Thread提供一线程等待另一线程完成再执行本线程的方法，join()方法。当在某一个程序执行流中调用该方法，调用线程将会被阻塞，直到被join()方法加入的join线程执行完为止。</p>
<blockquote>
<p>注意：在某个执行的线程中调用join()方法，调用线程将阻塞，直到被join()方法加入线程执行完。</p>
</blockquote>
<pre><code>package cn.edu.xidian.B.Demo.Thread;

public class ThreadJoinTest extends Thread{
    public ThreadJoinTest(String name) {
        super(name);
    }

    //线程执行体
    @Override
    public void run(){
        for (int i = 0; i &lt; 10; i++){
            System.out.println(&quot;当前线程是：&quot; + this.getName() + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //在主线程上再走一个子线程
        new ThreadJoinTest(&quot;newThread&quot;).start();
        for (int i = 0; i &lt; 100; i++){
            if (i == 20){
                //在这里再次创建子线程
                ThreadJoinTest tj = new ThreadJoinTest(&quot;join线程&quot;);
                tj.start();
                //该方法不会和主线程一起执行，必须等该线程执行完之后，主线程才会继续执行
                tj.join();
            }
            System.out.println(Thread.currentThread().getName() + &quot;&quot; + i);
        }
    }
}
</code></pre><h4 id="2-后台线程"><a href="#2-后台线程" class="headerlink" title="2.后台线程"></a>2.后台线程</h4><p>后台线程特点：如果所有的前台线程死亡，后台线程会自动死亡。然后调用Thread对象的setDaemon(true)方法会将指定的线程定义为后台线程。同时这里定义后台线程与普通线程没有区别。</p>
<pre><code>package cn.edu.xidian.B.Demo.Thread;

public class DaemonThread extends Thread {
    public DaemonThread(String name) {
        super(name);
    }

    @Override
    public void run(){
        for (int i = 0; i &lt; 10; i++){
            System.out.println(&quot;当前线程是：&quot; + this.getName() + i);
        }
    }

    public static void main(String[] args) {
        DaemonThread t = new DaemonThread(&quot;DaemonThread&quot;);
        //设置后台线程，此方法需要在start()方法之前调用
        t.setDaemon(true);
        //启动后台线程
        t.start();
        for (int i = 0; i &lt; 10; i++){
            System.out.println(Thread.currentThread().getName() + &quot;&quot; + i);
        }
        //在主线程执行完之后，后台线程也会自动执行结束
    }
}
</code></pre><h4 id="3-线程让步-yield-方法"><a href="#3-线程让步-yield-方法" class="headerlink" title="3.线程让步 yield()方法"></a>3.线程让步 yield()方法</h4><p>该方法只是Thread类提供的一个静态方法，它可以让当前正在执行的线程暂停，但不会阻塞该线程，只是将该线程转入就绪状态。</p>
<p>实际上，当某个线程调用yield()方法之后，只有优先级与当前线程相同或者优先级比当前线程更高的处于就绪状态的线程才会获得执行机会。</p>
<h4 id="4-线程睡眠-sleep-方法"><a href="#4-线程睡眠-sleep-方法" class="headerlink" title="4.线程睡眠 sleep()方法"></a>4.线程睡眠 sleep()方法</h4><h4 id="5-同步代码块-synchronized-方法"><a href="#5-同步代码块-synchronized-方法" class="headerlink" title="5.同步代码块 synchronized()方法"></a>5.同步代码块 synchronized()方法</h4><hr>
<h2 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h2><h4 id="1-ThreadLocal类"><a href="#1-ThreadLocal类" class="headerlink" title="1.ThreadLocal类"></a>1.ThreadLocal类</h4><pre><code>1.T get() 方法
2.void remove() 方法
3.void set(T value) 方法
</code></pre><hr>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h3><p>如果一个线程的run()方法执行一个无限循环，并且没有执行sleep()等将会抛出 InterruptedException异常，在调用 interrupt() 方法就无限使得线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<h3 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>这里使用lambda创建线程，相当于创建一个匿名内部线程：</p>
<pre><code>package Java.ChapterSeven.Executor;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ExecutorSecondOne {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
//        executorService.execute(() -&gt; {
//            try {
//                Thread.sleep(2000);
//                System.out.println(&quot;thread run&quot;);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//        });
//        executorService.shutdownNow();


        Future&lt;?&gt; future = executorService.submit(() -&gt; {
            try {
                Thread.sleep(2000);
                System.out.println(&quot;thread run&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        future.cancel(true);

        System.out.println(&quot;main run&quot;);
    }
}
</code></pre><blockquote>
<p>提示：通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。因为在第一步的时候，在子线程内部调用了sleep()方法使得该线程处于限期等待状态。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在第二步的过程中通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
</blockquote>
</blockquote>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>在Java中提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h3 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h3><p>使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<pre><code>package Java.ChapterSeven.SynchronizedDemo;

public class SynchronizedDemo {

    public void funOne(){
        synchronized (this){
            for (int i = 0; i &lt; 10; i++){
                System.out.println(i + &quot; &quot;);
            }
        }
    }
}

package Java.ChapterSeven.SynchronizedDemo;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Run {
    public static void main(String[] args) {
        SynchronizedDemo sn = new SynchronizedDemo();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&gt; sn.funOne());
        executorService.execute(() -&gt; sn.funOne());
    }
}
</code></pre><p>两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<pre><code>package Java.ChapterSeven.SynchronizedDemo;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Run {
    public static void main(String[] args) {
        SynchronizedDemo snOne = new SynchronizedDemo();
        SynchronizedDemo snTwo = new SynchronizedDemo();

        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&gt; snOne.funOne());
        executorService.execute(() -&gt; snTwo.funOne());
    }
}
</code></pre><h3 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2.同步方法"></a>2.同步方法</h3><h3 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3.同步一个类"></a>3.同步一个类</h3><p>作用与整个类，两个线程调用同一个类的不同对象的同步语句，也会进行同步。</p>
<pre><code>package Java.ChapterSeven.SynchronizedDemo;

public class SynchronizedDemoTwo {

    public void funTwo(){
        //类同步
        synchronized (SynchronizedDemoTwo.class){
            for (int i = 0; i &lt; 10; i++){
                System.out.println(i + &quot; &quot;);
            }
        }
    }
}

package Java.ChapterSeven.SynchronizedDemo;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Run {
    public static void main(String[] args) {
        SynchronizedDemoTwo snOne = new SynchronizedDemoTwo();
        SynchronizedDemoTwo snTwo = new SynchronizedDemoTwo();

        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&gt; snOne.funTwo());
        executorService.execute(() -&gt; snTwo.funTwo());
    }
}
</code></pre><h3 id="4-同步静态方法"><a href="#4-同步静态方法" class="headerlink" title="4.同步静态方法"></a>4.同步静态方法</h3><p>作用于整个类。</p>
<hr>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<pre><code>package Java.ChapterSeven.ReentrantLock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {

    private Lock lock = new ReentrantLock();
    public void funOne(){
        //实现同步
        lock.lock();
        try {
            for (int i = 0; i &lt; 10; i++){
                System.out.println(i + &quot; &quot;);
            }
        }finally {
            lock.unlock();
        }
    }
}

package Java.ChapterSeven.ReentrantLock;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Run {
    public static void main(String[] args) {
        ReentrantLockDemo rt = new ReentrantLockDemo();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&gt; rt.funOne());
        executorService.execute(() -&gt; rt.funOne());
    }
}
</code></pre><h3 id="synchronized-ReentrantLock-比较"><a href="#synchronized-ReentrantLock-比较" class="headerlink" title="synchronized | ReentrantLock 比较"></a>synchronized | ReentrantLock 比较</h3><pre><code>1.synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

2.新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

3.当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。

4.公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

5.一个 ReentrantLock 可以同时绑定多个 Condition 对象。
</code></pre><hr>
<h2 id="J-U-C-AQS"><a href="#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h2><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h3><p>其用来控制一个线程等待多个线程。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<pre><code>package Java.ChapterSeven.CountdownLatch;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CountdownLatchDemo {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countdownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++){
            executorService.execute(() -&gt; {
                System.out.print(&quot;run ..&quot;);
                countdownLatch.countDown();
            });
        }
        countdownLatch.await();
        System.out.println(&quot;end&quot;);
        executorService.shutdown();
    }
}
</code></pre><h3 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2.CyclicBarrier"></a>2.CyclicBarrier</h3><p>控制多个线程互相等待，只有多个线程都到达时，这些线程才会继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<blockquote>
<p>提示：CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
</blockquote>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<pre><code>public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}


package Java.ChapterSeven.CyclicBarrier;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++){
            executorService.execute(() -&gt; {
                System.out.println(&quot;before..&quot;);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;after..&quot;);
            });
        }
        executorService.shutdown();
    }
}
</code></pre><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3.Semaphore"></a>3.Semaphore</h3><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>这里程序模拟对某个服务的并发请求，每次只能有3个客户端同时访问，请求总数是10。</p>
<pre><code>package Java.ChapterSeven.Semaphore;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalRequestCount; i++){
            executorService.execute(() -&gt; {
                try {
                    semaphore.acquire();
                    System.out.println(semaphore.availablePermits() + &quot; &quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
</code></pre><p>未完…</p>
]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP入门</title>
    <url>/undefined/HTTP/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="HTTP入门"><a href="#HTTP入门" class="headerlink" title="HTTP入门"></a>HTTP入门</h1><p>对HTTP协议早有了解，最近在看javaweb，视频中讲到了这部分，就把视频的内容整理归纳下。</p>
<h2 id="请求-Request"><a href="#请求-Request" class="headerlink" title="请求(Request)"></a>请求(Request)</h2><p>一个完整的HTTP请求包括：一个请求行、若干请求头、以及实体内容</p>
<h3 id="请求头字段"><a href="#请求头字段" class="headerlink" title="请求头字段"></a>请求头字段</h3><ul>
<li>Accept:用于告诉服务器，客户机支持的数据类型</li>
<li>Accept-Charset:用于告诉服务器，客户机采用的编码</li>
<li>Accept-Encoding:用于告诉服务器，客户机支持数据压缩格式</li>
<li>Accept-Language:客户机的语言环境</li>
<li>Host:客户机通过这个头告诉服务器，想访问的主机名</li>
<li>If-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间</li>
<li>Refer:客户机通过这个头告诉服务器，它是从哪个资源访问服务器的(防盗链)</li>
<li>User-Agent:客户机通过这个头告诉服务器，客户机的软件环境</li>
<li>Cookie:客户机通过这个头向服务器带数据</li>
<li>Connection:这个请求完了，是保持连接还是关闭</li>
<li>Range:断点下载<ul>
<li><code>bytes=n1-n2</code>,传输范围n1到n2字节</li>
<li><code>bytes=n-</code>，传输web资源中第n个字节以后的所有内容</li>
<li><code>bytes=n</code>,传输最后n个字节</li>
</ul>
</li>
</ul>
<h2 id="响应-Response"><a href="#响应-Response" class="headerlink" title="响应(Response)"></a>响应(Response)</h2><p>一个HTTP响应代表服务器向客户端回送的数据，包括：一个状态行、若干消息头、以及实体内容</p>
<h3 id="响应状态行"><a href="#响应状态行" class="headerlink" title="响应状态行"></a>响应状态行</h3><p>详情可参考</p>
<blockquote>
<p><a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="noopener">HTTP 状态消息</a></p>
</blockquote>
<h3 id="响应头字段"><a href="#响应头字段" class="headerlink" title="响应头字段"></a>响应头字段</h3><ul>
<li>Location:这个头配合302状态码使用，用于告诉客户机找谁(location和302实现请求重定向)</li>
<li>Server:服务器通过这个头，告诉浏览器服务器的类型</li>
<li>Content-Encoding:服务器通过这个头，数据的压缩格式<br>(相关java知识:<code>GZIPOutputStream</code>,包装流/底层流)</li>
<li>Content-Length:服务器通过这个头，告诉浏览器回送数据的长度</li>
<li>Content-Type:服务器通过这个头，告诉浏览器回送数据的类型</li>
<li>Last-Modified:服务器通过这个头，告诉浏览器当前资源的缓存时间</li>
<li>Refresh:服务器通过这个头，告诉浏览器隔多长时间刷新一次</li>
<li>Content-Disposition:服务器通过这个头，告诉浏览器以下载方式打开</li>
<li>Transfer-Encoding:服务器通过这个头，告诉浏览器数据的传送格式</li>
<li>Etag:缓存相关的头部，用于实时性要求高的系统</li>
<li>Expires:服务器通过这个头，告诉浏览器把回送的资源缓存多长时间，-1或0则不缓存</li>
<li>Cache-Control和Pragma:no-cache,服务器通过这两个头，也是控制浏览器不要缓存数据</li>
<li>Connection:断开连接/保持连接</li>
<li>Date:当前时间</li>
<li>Accept-Ranges:用来说明web服务器是否支持range。支持返回bytes;不支持返回none</li>
<li>Content-Range:制定了返回web资源的字节范围，格式：<code>n1-n2/n_total</code></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>EXCEL UTIL</title>
    <url>/undefined/ExcelUtil/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java用来处理Excel的第三方开源项目主要是POI与JXL，POI功能强大，但是比较消耗资源，所以对于大数据量的导入导出性能不是很友好。JXL功能简单，但是性能优秀。</p>
<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>Java项目中，导出数据到Excel表示将list转换为Excel(List2Excel)。导入表示将Excel转换为List(Excel2List)。但是在导出和导入的过程中可能会发生一些异常(如：数据源为空、有重复行等)。</p>
<hr>
<h2 id="Java-Excel-import-export"><a href="#Java-Excel-import-export" class="headerlink" title="Java - Excel (import/export)"></a>Java - Excel (import/export)</h2><p>在Java中的常用的两种技术：Jakarta POI和Java Excel 实现Excel的导入导出。</p>
<h4 id="1-Jakarta-POI-Excel"><a href="#1-Jakarta-POI-Excel" class="headerlink" title="1.Jakarta POI - Excel"></a>1.Jakarta POI - Excel</h4><p>Jakarta POI 是一套用于访问微软式文档的Java API。Jakarta POI有很多组件组成，其中有用于操作Excel格式文件的HSSF和用于操作Word的HWPF，在各种组件中目前只有用于操作Excel的HSSF相对成熟。</p>
<h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2.环境变量配置"></a>2.环境变量配置</h4><p><strong>1.Jakarta POI HSSF API组件</strong><br><br>HSSF（用于操作Excel的组件）提供给用户使用的对象在rg.apache.poi.hssf.usermodel包中,主要部分包括Excel对象，样式和格式，还有辅助操作。</p>
<blockquote>
<p>组件：</p>
</blockquote>
<pre><code>HSSFWorkbook:excel的文档对象
HSSFSheet:excel的表单
HSSFRow:excel的行
HSSFCell:excel的格子单元
HSSFFont:excel字体
HSSFDataFormat:日期格式
HSSFHeader:sheet头
HSSFFooter:sheet尾（只有打印的时候才能看到效果）
</code></pre><blockquote>
<p>样式：</p>
</blockquote>
<pre><code>HSSFCellStyle:cell样式
</code></pre><blockquote>
<p>辅助操作包括：</p>
</blockquote>
<pre><code>HSSFDateUtil:日期
HSSFPrintSetup:打印
HSSFErrorConstants:错误信息表
</code></pre><blockquote>
<blockquote>
<p>步骤：首先我们应该理解一个Excel的文件形式，一个Excel文件对应于一个workbook(HSSFWorkbook)。然后一个workbook可以有多个sheet(HSSFSheet)组成，一个sheet是由多个row（HSSFRow）组成，一个row是由多个cell（HSSFCell）组成。下面是一个基本的操作步骤：</p>
</blockquote>
</blockquote>
<pre><code>1.用HSSFWorkbook打开或者创建“Excel文件对象”
2.用HSSFWorkbook对象返回或者创建Sheet对象
3.用Sheet对象返回行对象，用行对象得到Cell对象
4.对Cell对象读写。
</code></pre><p><strong>案例1：一个动态生成Excel文件的例子</strong><br></p>
<pre><code>//创建HSSFWorkbook对象
HSSFWorkbook wb = new HSSFWorkbook();

//创建HSSFSheet对象
HSSFSheet sheet = wb.createSheet(&quot;sheet0&quot;);

//创建HSSFRow对象
HSSFRow row = sheet.createRow(0);

//创建HSSFCell对象
HSSFCell cell=row.createCell(0);

//设置单元格的值
cell.setCellValue(&quot;单元格中的中文&quot;);

//输出Excel文件
FileOutputStream output=new FileOutputStream(&quot;d:\\workbook.xls&quot;);
wkb.write(output);
output.flush();
</code></pre><blockquote>
<p>注意：HSSF读取文件还是使用这几个对象，只是将相应的createXXX方法变成了getXXX方法。</p>
</blockquote>
<p><strong>案例2：导出Excel文件的实例</strong><br></p>
<pre><code>//创建HSSFWorkbook对象(excel的文档对象)
HSSFWorkbook wb = new HSSFWorkbook();

//建立新的sheet对象（excel的表单）
HSSFSheet sheet=wb.createSheet(&quot;成绩表&quot;);

//在sheet里创建第一行，参数为行索引(excel的行)，可以是0～65535之间的任何一个
HSSFRow row1=sheet.createRow(0);

//创建单元格（excel的单元格，参数为列索引，可以是0～255之间的任何一个
HSSFCell cell=row1.createCell(0);

//设置单元格内容
cell.setCellValue(&quot;学员考试成绩一览表&quot;);

//合并单元格CellRangeAddress构造参数依次表示起始行，截至行，起始列， 截至列
sheet.addMergedRegion(new CellRangeAddress(0,0,0,3));

//在sheet里创建第二行
HSSFRow row2=sheet.createRow(1);

//创建单元格并设置单元格内容
row2.createCell(0).setCellValue(&quot;姓名&quot;);
row2.createCell(1).setCellValue(&quot;班级&quot;);    
row2.createCell(2).setCellValue(&quot;笔试成绩&quot;);
row2.createCell(3).setCellValue(&quot;机试成绩&quot;); 

//在sheet里创建第三行
HSSFRow row3=sheet.createRow(2);
row3.createCell(0).setCellValue(&quot;李明&quot;);
row3.createCell(1).setCellValue(&quot;As178&quot;);
row3.createCell(2).setCellValue(87);    
row3.createCell(3).setCellValue(78);    
//.....省略部分代码

//输出Excel文件
OutputStream output=response.getOutputStream();
response.reset();
response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=details.xls&quot;);
response.setContentType(&quot;application/msexcel&quot;);        
wkb.write(output);
output.close();
retrun null;
</code></pre><p><strong>3.样式设置</strong><br><br>在实际应用中导出的Excel文件往往需要阅读和打印的，这就需要对输出的Excel文档进行排版和样式的设置，主要操作有合并单元格、设置单元格样式、设置字体样式等。</p>
<p><strong>3.1 单元格合并</strong><br><br>使用HSSFSheet的addMergedRegion()方法</p>
<pre><code>public int addMergedRegion(CellRangeAddress region)
</code></pre><p>参数CellRangeAddress 表示合并的区域，构造方法如下：</p>
<pre><code>//构造参数依次表示起始行，截至行，起始列， 截至列
CellRangeAddress(int firstRow, int lastRow, int firstCol, int lastCol)
</code></pre><p><strong>3.2 设置单元格的行高、列宽</strong><br></p>
<pre><code>HSSFSheet sheet=wb.createSheet();

//设置缺省列高
sheet.setDefaultRowHeightInPoints(10);
//设置缺省列宽
sheet.setDefaultColumnWidth(20);

//设置指定列的列宽，256 * 50这种写法是因为width参数单位是单个字符的256分之一
sheet.setColumnWidth(cell.getColumnIndex(), 256 * 50);
</code></pre><p><strong>3.3 单元格样式</strong><br><br>1.创建HSSFCellStyle</p>
<pre><code>HSSFCellStyle cellStyle=wkb.createCellStyle()
</code></pre><p>2.设置样式</p>
<pre><code>//设置单元格的横向和纵向对齐方式，具体参数就不列了，参考HSSFCellStyle

cellStyle.setAlignment(HSSFCellStyle.ALIGN_JUSTIFY);

cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);

/* 设置单元格的填充方式，以及前景颜色和背景颜色
 注意：
 1.如果需要前景颜色或背景颜色，一定要指定填充方式，两者顺序无所谓；
 2.如果同时存在前景颜色和背景颜色，前景颜色的设置要写在前面；
 3.前景颜色不是字体颜色。
*/

//设置填充方式(填充图案)
cellStyle.setFillPattern(HSSFCellStyle.DIAMONDS);

//设置前景色
cellStyle.setFillForegroundColor(HSSFColor.RED.index);

//设置背景颜色
cellStyle.setFillBackgroundColor(HSSFColor.LIGHT_YELLOW.index);

// 设置单元格底部的边框及其样式和颜色
// 这里仅设置了底边边框，左边框、右边框和顶边框同理可设
cellStyle.setBorderBottom(HSSFCellStyle.BORDER_SLANTED_DASH_DOT);
cellStyle.setBottomBorderColor(HSSFColor.DARK_RED.index);

//设置日期型数据的显示样式
cellStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat(&quot;m/d/yy h:mm&quot;));
</code></pre><p>3.将样式应用于单元格</p>
<pre><code>cell.setCellStyle(cellStyle);
//将样式应用到行，但有些样式只对单元格起作用
row.setRowStyle(cellStyle);
</code></pre><p><strong>3.4 设置字体样式</strong><br><br>1.创建HSSFFont对象（调用HSSFWorkbook 的createFont方法）</p>
<pre><code>HSSFWorkbook wb=new HSSFWorkbook();
HSSFFont  fontStyle=wb.createFont();
HSSFWorkbook wb=new HSSFWorkbook ();
</code></pre><p>2.设置字体各种样式</p>
<pre><code>//设置字体样式
fontStyle.setFontName(&quot;宋体&quot;);  

//设置字体高度
fontStyle.setFontHeightInPoints((short)20);  

//设置字体颜色
font.setColor(HSSFColor.BLUE.index);

//设置粗体
fontStyle.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);

//设置斜体
font.setItalic(true);

//设置下划线
font.setUnderline(HSSFFont.U_SINGLE);
</code></pre><h4 id="3-将已经存在Excel导入的应用实例"><a href="#3-将已经存在Excel导入的应用实例" class="headerlink" title="3.将已经存在Excel导入的应用实例"></a>3.将已经存在Excel导入的应用实例</h4><p>实现将已存在的Excel文件中的数据导入到系统中的基本步骤同导出十分的类似，关键在于要了解要导入Excel文件的结构，比如数据有哪些列、读取数据起始位置（有效数据从第几行几列开始）等。在实际项目中由于这些数据（Excel文件）往往来自于日常办公人员或其他系统平台产生的业务数据，因此这些Excel文件的数据格式要有统一的要求，并提供访问接口（指访问途径），这样在所需数据的系统中就可通过提供这个访问接口调用方法，从而获得数据。解决方案采用Web Service是不错的选择。</p>
<pre><code>public List&lt;ScoreInfo&gt; loadScoreInfo(String xlsPath) throws IOException{
    List temp = new ArrayList();
    FileInputStream fileIn = new FileInputStream(xlsPath);
    //根据指定的文件输入流导入Excel从而产生Workbook对象
    Workbook wb0 = new HSSFWorkbook(fileIn);
    //获取Excel文档中的第一个表单
    Sheet sht0 = wb0.getSheetAt(0);
    //对Sheet中的每一行进行迭代
    for (Row r : sht0) {
        //如果当前行的行号（从0开始）未达到2（第三行）则从新循环
        If(r.getRowNum()&lt;1){
            continue;
        }
        //创建实体类
        ScoreInfo info=new ScoreInfo();
        //取出当前行第1个单元格数据，并封装在info实体stuName属性上
        info.setStuName(r.getCell(0).getStringCellValue());
        info.setClassName(r.getCell(1).getStringCellValue());
        info.setRscore(r.getCell(2).getNumericCellValue());
        info.setLscore(r.getCell(3).getNumericCellValue());
        temp.add(info);
    }
    fileIn.close();    
    return temp;    
}
</code></pre><hr>
<h2 id="4-使用Java-Excel操作Excel文件"><a href="#4-使用Java-Excel操作Excel文件" class="headerlink" title="4.使用Java Excel操作Excel文件"></a>4.使用Java Excel操作Excel文件</h2><p>Java Excel是一款开源的项目，通过它Java开发人员可以读取Excel文件的内容、创建新的Excel文件、更新已经存在的Excel文件。jxl小巧易用，逐渐取代POI-excel的地位。</p>
<h4 id="4-1-环境配置"><a href="#4-1-环境配置" class="headerlink" title="4.1 环境配置"></a>4.1 环境配置</h4><p>在使用这些功能的时候要注意的是在项目工程中引入这些依赖文件。</p>
<h4 id="4-2-使用Java-Excel-API-导出Excel文件"><a href="#4-2-使用Java-Excel-API-导出Excel文件" class="headerlink" title="4.2 使用Java Excel API 导出Excel文件"></a>4.2 使用Java Excel API 导出Excel文件</h4><pre><code>//获得输出流，该输出流的输出介质是客户端浏览器
OutputStream output=response.getOutputStream();
response.reset();
response.setHeader(&quot;Content-disposition&quot;,&quot;attachment;           filename=temp.xls&quot;);
response.setContentType(&quot;application/msexcel&quot;);

//创建可写入的Excel工作薄，且内容将写入到输出流，并通过输出流输出给客户端浏览
WritableWorkbook wk=Workbook.createWorkbook(output);

//创建可写入的Excel工作表
WritableSheet sheet=wk.createSheet(&quot;成绩表&quot;, 0);

//把单元格（column, row）到单元格（column1, row1）进行合并。
//mergeCells(column, row, column1, row1);
sheet.mergeCells(0,0, 4,0);//单元格合并方法

//创建WritableFont 字体对象，参数依次表示黑体、字号12、粗体、非斜体、不带下划线、亮蓝色
WritableFont titleFont=new WritableFont(WritableFont.createFont(&quot;黑体&quot;),12,WritableFont.BOLD,false,UnderlineStyle.NO_UNDERLINE,Colour.LIGHT_BLUE);

//创建WritableCellFormat对象，将该对象应用于单元格从而设置单元格的样式
WritableCellFormat titleFormat=new WritableCellFormat();

//设置字体格式
titleFormat.setFont(titleFont);

//设置文本水平居中对齐
titleFormat.setAlignment(Alignment.CENTRE);

//设置文本垂直居中对齐
titleFormat.setVerticalAlignment(VerticalAlignment.CENTRE);

//设置背景颜色
titleFormat.setBackground(Colour.GRAY_25);

//设置自动换行
titleFormat.setWrap(true);

//添加Label对象，参数依次表示在第一列，第一行，内容，使用的格式
Label lab_00=new Label(0,0,&quot;学员考试成绩一览表&quot;,titleFormat);

//将定义好的Label对象添加到工作表上，这样工作表的第一列第一行的内容为‘学员考试成绩一览表’并应用了titleFormat定义的样式
sheet.addCell(lab_00);

WritableCellFormat cloumnTitleFormat=new WritableCellFormat();
cloumnTitleFormat.setFont(new WritableFont(WritableFont.createFont(&quot;宋体&quot;),10,WritableFont.BOLD,false));
cloumnTitleFormat.setAlignment(Alignment.CENTRE);
Label lab_01=new Label(0,1,&quot;姓名&quot;,cloumnTitleFormat);
Label lab_11=new Label(1,1,&quot;班级&quot;,cloumnTitleFormat);
Label lab_21=new Label(2,1,&quot;笔试成绩&quot;,cloumnTitleFormat);
Label lab_31=new Label(3,1,&quot;上机成绩&quot;,cloumnTitleFormat);
Label lab_41=new Label(4,1,&quot;考试日期&quot;,cloumnTitleFormat);

sheet.addCell(lab_01);
sheet.addCell(lab_11);
sheet.addCell(lab_21);
sheet.addCell(lab_31);
sheet.addCell(lab_41);
sheet.addCell(new Label(0,2,&quot;李明&quot;));
sheet.addCell(new Label(1,2,&quot;As178&quot;));

//定义数字格式
NumberFormat nf=new NumberFormat(&quot;0.00&quot;);
WritableCellFormat wcf=new WritableCellFormat(nf);

//类似于Label对象，区别Label表示文本数据，Number表示数值型数据
Number numlab_22=new Number(2,2,78,wcf);
sheet.addCell(numlab_22);
sheet.addCell(newNumber(3,2,87,new WritableCellFormat(new NumberFormat(&quot;#.##&quot;) )));

//定义日期格式
DateFormat df=new DateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);

//创建WritableCellFormat对象
WritableCellFormat datewcf=new WritableCellFormat(df);

//类似于Label对象，区别Label表示文本数据，DateTime表示日期型数据
DateTime dtLab_42=new DateTime(4,2,new Date(),datewcf);
sheet.addCell(dtLab_42);   

//将定义的工作表输出到之前指定的介质中（这里是客户端浏览器）
wk.write();

//操作完成时，关闭对象，释放占用的内存空间   
wk.close();
加下划线这部分代码是B/S模式中采用的输出方式，而不是输出到本地指定的磁盘目录。该代码表示将temp.xls的Excel文件通过应答实体（response）输出给请求的客户端浏览器，下载到客户端本地（保存或直接打开）。若要直接输出到磁盘文件可采用下列代码替换加下划线这部分代码
File file=new File(&quot;D://temp.xls&quot;);
WritableWorkbook wwb = Workbook.createWorkbook(file);
</code></pre><h2 id="3-高级操作"><a href="#3-高级操作" class="headerlink" title="3.高级操作"></a>3.高级操作</h2><h4 id="3-1-数据格式化"><a href="#3-1-数据格式化" class="headerlink" title="3.1 数据格式化"></a>3.1 数据格式化</h4><p>数据的格式化涉及到的是字体、粗细、字号等元素，这些功能主要由 WritableFont和WritableCellFormat类来负责。</p>
<h4 id="3-2-单元格操作"><a href="#3-2-单元格操作" class="headerlink" title="3.2 单元格操作"></a>3.2 单元格操作</h4><p>Excel中很重要的一部分是对单元格的操作，比如行高、列宽、单元格合并等，所幸jExcelAPI提供了这些支持。</p>
<p><strong>1.合并单元格</strong><br></p>
<pre><code>WritableSheet.mergeCells(int m,int n,int p,int q);

//作用是从(m,n)到(p,q)的单元格全部合并，比如：
WritableSheet sheet=book.createSheet(“第一页”,0);

//合并第一列第一行到第六列第一行的所有单元格
sheet.mergeCells(0,0,5,0);

//合并既可以是横向的，也可以是纵向的。合并后的单元格不能再次进行合并，否则会触发异常。
</code></pre><p><strong>2.行高和列宽</strong><br></p>
<pre><code>writableSheet.setRowView(int i,int height);

//作用是指定第i+1行的高度，比如：

// 将第一行的高度设为200

sheet.setRowView(0,200);

WritableSheet.setColumnView(int i,int width);

//作用是指定第i+1列的宽度，比如：

//将第一列的宽度设为30

sheet.setColumnView(0,30);
</code></pre><h2 id="4-从Excel中读取数据表"><a href="#4-从Excel中读取数据表" class="headerlink" title="4.从Excel中读取数据表"></a>4.从Excel中读取数据表</h2><pre><code>public List&lt;ScoreInfo&gt; loadScoreInfo(String xlsPath) throws IOException, BiffException{

    //导入已存在的Excel文件，获得只读的工作薄对象
    FileInputStream fis=new FileInputStream(xlsPath);
    Workbook wk=Workbook.getWorkbook(fis);

    //获取第一张Sheet表 
    Sheet sheet=wk.getSheet(0);

    //获取总行数
    int rowNum=sheet.getRows();

    //从数据行开始迭代每一行
    for(int i=2;i&lt;rowNum;i++){
        ScoreInfo info=new ScoreInfo();        
        //getCell(column,row);//表示取得指定列指定行的单元格（Cell）
        //getContents();//获取单元格的内容，返回字符串数据。适用于字符型数据的单元格
        //使用实体类封装单元格数据
        info.setStuName(sheet.getCell(0, i).getContents());
        info.setClassName(sheet.getCell(1, i).getContents());

        //判断单元格的类型，单元格主要类型LABEL、NUMBER、DATE
        if(sheet.getCell(2,i).getType==CellType.NUMBER){
            //转化为数值型单元格
            NumberCell numCell=(NumberCell)sheet.getCell(2,i);
            //NumberCell的getValue()方法取得单元格的数值型数据
            info.setRscore(numCell.getValue());
        }
        if(sheet.getCell(3,i).getType == CellType.NUMBER){
            NumberCell numCell=(NumberCell)sheet.getCell(3,i);
            info.setRscore(numCell.getValue);
        }

        if(sheet.getCell(4,i).getType == CellType.DATE){
            DateCell dateCell=(DateCell)sheet.getCell(4,i);
            //DateCell的getDate()方法取得单元格的日期型数据
            info.setDate(dateCell.getDate());
        }
    }
    fis.close();
    wk.close();
}
</code></pre><h2 id="5-更新已存在的Excel文件"><a href="#5-更新已存在的Excel文件" class="headerlink" title="5.更新已存在的Excel文件"></a>5.更新已存在的Excel文件</h2><p>将已经产生的Excel表中的第一条记录修改掉。</p>
<pre><code>File file=new File(&quot;d://temp.xls&quot;);
//导入已存在的Excel文件，获得只读的工作薄对象
Workbook wk=Workbook.getWorkbook(file);

//根据只读的工作薄对象（wk）创建可写入的Excel工作薄对象 
WritableWorkbook wwb=Workbook.createWorkbook(file, wk);

//读取第一张工作表 
WritableSheet sheet=wwb.getSheet(0);

///获得要编辑的单元格对象 
WritableCell cell=sheet.getWritableCell(1, 2);

//判断单元格的类型, 做出相应的转化 
if(cell.getType()==CellType.LABEL){
    Label lable=(Label)cell;
    //修改单元格的内容
    lable.setString(&quot;As179&quot;);
    }
wwb.write(); 
wwb.close(); 
wk.close();
</code></pre><blockquote>
<p>注意：对于已经存在的Excel文件实际上就是获取已有工作簿对象(只读)，然后将获取的只读的工作簿对象转化为可写入的Excel工作簿对象(WritableWorkbook)，其它部分就是通过写入WritableWorkbook对象和可写入WritableCell对象进行编辑。</p>
</blockquote>
<hr>
<h2 id="6-案例"><a href="#6-案例" class="headerlink" title="6.案例"></a>6.案例</h2><h4 id="6-1-工具类ExcelUtil"><a href="#6-1-工具类ExcelUtil" class="headerlink" title="6.1 工具类ExcelUtil"></a>6.1 工具类ExcelUtil</h4><pre><code>package edu.xidian.lab.util;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.log4j.Logger;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.slf4j.LoggerFactory;
//import org.apache.poi.xssf.streaming.SXSSFSheet;
//import org.apache.poi.xssf.streaming.SXSSFWorkbook;

/**
 * 1.创建实例时初始化表头信息和创建sheet
 * 2.向Excel中填充数据的方式有两种，createTableRow方法和createTableRows方法
 * 3.createTableRow(List,int)方法就是多次调用此方法，list中数据，int是行号。list中数据依次作为第i行的列数据。
 * 4.createTableRows(List&lt;Map&gt;,String[])这个方法应该是非常常用的一种方式。我们从数据库查询到的数据大多数映射为Map放入list中，因此上面的方法就比较常用。
 * 4.1 List&lt;Map&gt;参数表示所有的数据，一个Map表示一行，String[]是Map中的key，表示数组的第一个元素对应的key作为第一列，第二个元素作为第二列。
 * @author Administrator
 *
 */
public class ExcelExporter {
    public static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ExcelExporter.class);

    private String[] headerNames;
    private Workbook workBook;
    private Sheet sheet;
    public ExcelExporter(String[] headerNames, String sheetName, String excelVersion) {
        this.headerNames = headerNames;
        //创建工作簿
//        if(&quot;07&quot;.equals(excelVersion)){
//            workBook = new XSSFWorkbook();//处理07版本excel
//            workBook = new SXSSFWorkbook();//处理07版本，适用于大数据量，导出之后数据不会占用内存
//        }else{
            workBook = new HSSFWorkbook();
//        }
        //创建一个工作表sheet
        sheet = workBook.createSheet(sheetName);    
        initHeader();
    }

    //初始化表头
    private void initHeader(){
        //创建第一行
        Row row = sheet.createRow(0);
        Cell cell = null;
        //创建表头
        for(int i = 0; i &lt; headerNames.length; i++){
            cell = row.createCell(i);
            cell.setCellValue(headerNames[i]);
            setCellStyle(cell);
        }
    }

    //设置单元格样式
    public void setCellStyle(Cell cell){
        //设置样式
        CellStyle cellStyle = workBook.createCellStyle();
        //设置字体居中
        cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
        //设置字体
        Font font = workBook.createFont();
        font.setFontName(&quot;宋体&quot;);
        //字体加粗
        font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
        font.setFontHeightInPoints((short) 13);
        cellStyle.setFont(font);
        cell.setCellStyle(cellStyle);
    }

    //创建行内容
    public void createTableRow(List&lt;String&gt; dataset, int rowIndex){
        //创建第i行
        Row row = sheet.createRow(rowIndex);
        Cell cell = null;
        //写入数据
        for(int index = 0, length = dataset.size(); index &lt; length; index++){
            //参数代表第几列
            cell = row.createCell(index);
            cell.setCellType(HSSFCell.CELL_TYPE_STRING);
            cell.setCellValue(dataset.get(index));
        }
    }

    public void createTableRows(List&lt;Map&lt;String,Object&gt;&gt; dataset, String[] keys){
        for(int i = 0, length_one = dataset.size(); i &lt; length_one; i++){
            if(ArrayUtils.isEmpty(keys)){
                keys = headerNames;
            }

            //创建行（从第二行开始）
            Map&lt;String,Object&gt; datasets = dataset.get(i);
            Row row = sheet.createRow(i+1);
            Cell cell = null;
            for(int j = 0, length_two = keys.length; j &lt; length_two; j++){
                //单元格获取map中的key
                String key = keys[j];
                String value = MapUtils.getString(datasets, key, &quot;&quot;);

                cell = row.createCell(j);
                cell.setCellType(HSSFCell.CELL_TYPE_STRING);
                cell.setCellValue(value);
            }
        }
    }

    //根据表头自动调整列宽
    public void autoAllSizeColum(){
//        if (sheet instanceof SXSSFSheet) {// 如果是SXSSFSheet，需要调用trackAllColumnsForAutoSizing方法一次
//            SXSSFSheet tmpSheet = (SXSSFSheet) sheet;
//            tmpSheet.trackAllColumnsForAutoSizing();
//        }
        for(int i = 0, length = headerNames.length; i &lt; length; i++){
            sheet.autoSizeColumn(i);
        }
    }

    //将数据写出到excel中
    public void exportExcel(FileOutputStream fileOutputStream){
        //导出之前先设置自动列宽
        this.autoAllSizeColum();
        try{
            workBook.write(fileOutputStream);
        }catch(IOException e){
            LOGGER.error(&quot;exportExcel error: &quot;, e);
        }finally{
            IOUtils.closeQuietly(fileOutputStream);
        }
    }

}
</code></pre><h4 id="6-2-测试文件"><a href="#6-2-测试文件" class="headerlink" title="6.2 测试文件"></a>6.2 测试文件</h4><pre><code>package edu.xidian.lab.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.List;

public class ExcelTest {
    ExcelExporter hssfWorkExcel = new ExcelExporter(new String[] {&quot;姓名&quot;,&quot;年龄&quot;},&quot;人员基本信息&quot;,&quot;03&quot;);
    for(int i = 0; i &lt; 10; i++){
        List&lt;String&gt; dataset = new ArrayList&lt;&gt;();
        dataset.add(&quot;BangjinHu&quot;);
        dataset.add(&quot;&quot;+(i+20));
        hssfWorkExcel.createTableRow(dataset, i+1);
    }
    try{
        hssfWorkExcel.exportExcel(new FileOutputStream(new File(&quot;e:/test.xls&quot;)));
    }catch(FileNotFoundException e){
        e.printStackTrace();
        }
    }
}
</code></pre>]]></content>
      <categories>
        <category>util</category>
      </categories>
      <tags>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 抽象类 接口 内部类 异常处理</title>
    <url>/undefined/Java%208%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%20%E5%86%85%E9%83%A8%E7%B1%BB%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-8-抽象类-接口-内部类-异常处理"><a href="#Java-8-抽象类-接口-内部类-异常处理" class="headerlink" title="Java 8 抽象类 接口 内部类 异常处理"></a>Java 8 抽象类 接口 内部类 异常处理</h2><p>[TOC]</p>
<h3 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h3><ol>
<li>声明异常</li>
</ol>
<blockquote>
<p>注意：如果方法没有在父类中声明异常，那么就不能在子类中对其进行覆盖来声明异常。</p>
</blockquote>
<ol start="2">
<li>抛出异常</li>
</ol>
<blockquote>
<p>注意：通常JAVA API 中的每个异常类至少有两个构造方法：1.无参构造方法。</p>
</blockquote>
<ol start="3">
<li>一个带可描述此异常的String参数的构造方法。(该参数称为异常消息，可以使用getMessage()获取)</li>
</ol>
<blockquote>
<p>注意：声明异常的关键字：throws 抛出异常的关键字：throw。</p>
</blockquote>
<ol start="4">
<li><p>捕获异常</p>
<p> 注意：</p>
<pre><code>1.从一个通用父类可以派生出各种异常类，如果一个catch块可以捕获一个父类的异常对象，那么它就能够父类的所有子类的异常对象。

2.在catch块中异常被指定的顺序非常重要，如果父类的catch块出现在子类的catch块之前，就会导致编译错误。

3.Java强迫程序员必须处理必检异常，如果方法中声明了一个必须检验的异常(error或runtimeException)，就必须在try-catch块中调用它，或者在调用方法中声明要抛出异常。

4.使用异常的时机

    注意：异常处理过程中通常需要更多的时间和资源。

    1.异常出现在方法中，如果想让该方法的调用者处理异常，应该创建一个异常对象并将其抛出。如果能在发生异常的方法中处理异常，那么就不需要抛出异常或使用异常。
</code></pre></li>
</ol>
<blockquote>
<p>注意：不要将异常处理用作简单的逻辑测试。而在哪种情况下使用异常需要我们自己判断。</p>
</blockquote>
<ol start="5">
<li>重新抛出异常</li>
</ol>
<p>前提：如果异常处理器没有处理某个异常，或者处理器只是希望其调用者注意该异常，Java就允许处理器重新抛出异常。在try-catch块中最后使用throw关键字。这样就方便其他的调用者获得处理抛出异常的机会。</p>
<ol start="6">
<li>链式异常</li>
</ol>
<ol start="7">
<li>自定义异常</li>
</ol>
<blockquote>
<p>注意：因为Java提供了很多的异常类，所以在不是特殊的情况下尽量避免使用自定义异常类。</p>
</blockquote>
<blockquote>
<blockquote>
<p>通过派生Exception类或其子类(如:IOException)来创建自定义异常类。</p>
</blockquote>
</blockquote>
<h4 id="1-异常类Throwable"><a href="#1-异常类Throwable" class="headerlink" title="1. 异常类Throwable"></a>1. 异常类Throwable</h4><p>该异常类中对应的相应的方法，toString()方法表示输出该异常类名+错误信息。getMessage()方法输出异常信息，需要通过构造方法传入异常信息(返回创建throwable的异常信息)。printStackTrace()方法打印异常的栈信息。</p>
<blockquote>
<blockquote>
<p>throws/throw抛出处理的细节：1.如果一个方法的内部抛出一个编译时异常对象，那么必须在方法上声明抛出。</p>
</blockquote>
</blockquote>
<pre><code>public static void div(int a,int b) throws Exception{
    //函数方法执行体
}
</code></pre><p>2.如果调用了一个声明抛出异常的方法，那么调用者必须处理该抛出的异常。3.如果一个方法内部抛出了一个异常对象，那么throw语句后面的程序就不会再执行。4.在一种情况下只能抛出一种异常对象。</p>
<blockquote>
<p>throw关键字用于在方法体内部抛出异常对象，throws关键字用于在方法声明上声明抛出异常类型。一个try块后面可以跟多个catch块，也就是一个try块可以捕获多种异常类型，但是捕获的异常类型必须从小到大进行捕获(不然在执行大的异常对象之后，小的异常不会被执行)。</p>
</blockquote>
<blockquote>
<blockquote>
<p>运行时异常(RuntimeException/RuntimeException子类)：如果一个方法内部抛出一个运行时异常，那么方法上可以声明也可以不声明，调用者可以处理也可以不处理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>编译时异常(非运行时异常、受捡异常)：如果一个方法内部抛出了一个编译时异常对象，那么方法上就必须要声明，而且调用者也必须要处理。</p>
</blockquote>
</blockquote>
<p>运行时异常都是程序员良好的编程习惯去避免的，所以Java编译器就没有严格要求处理运行时异常。</p>
<pre><code>总结：
    1.异常处理能够使得一个方法给它的调用者抛出一个异常。
    2.异常发生在一个方法的执行过程中，RuntimeException/Error都是免检异常，其他所有的异常都是必须检验的异常。
    3.当声明一个方法时，如果这个方法抛出一个必须检验的异常，则必须声明为必须检验异常，告诉编译器可能会出现什么错误。
    4.声明异常的关键字：throws，抛出异常的关键字：throw

    5.异常处理是将处理代码从正常的程序中分离出来，这样的话，程序更容易处理和理解。
    6.我们不应该使用异常处理代替简单的测试，应该尽可能的测试简单异常，将异常处理保留为处理那些无法使用if语句处理的异常。
</code></pre><h4 id="2-常见的Error以及Exception"><a href="#2-常见的Error以及Exception" class="headerlink" title="2. 常见的Error以及Exception"></a>2. 常见的Error以及Exception</h4><pre><code>1.RuntimeException

    1.NullPointerException 空指针引用异常

    2.ClassCastException 类型强转异常

    3.IllegalArgumentException 传递非法参数异常

    4.IndexOutOfBoundsException 下标越界异常

    5.NumberFormatException 数字格式异常

2.非RuntimeException

    1.ClassNotFoundException 找不到指定class异常

    2.IOException IO操作异常

3.Error

    1.NoClassDefFoundError 找不到class定义异常

        1.类依赖的class或者jar不存在

        2.类文件存在，但存在不同的域中

        3.大小写问题，javac编译的时候是无视大小写的，可能编译出来的class文件与想要的不一样

    2.StackOverflowError 深递归导致栈被耗尽抛出的异常

    3.OutOfMemoryError 内存溢出异常
</code></pre><h4 id="3-Java异常处理机制"><a href="#3-Java异常处理机制" class="headerlink" title="3.Java异常处理机制"></a>3.Java异常处理机制</h4><pre><code>1.抛出异常：创建异常对象，交由运行时系统处理

2.捕获异常：寻找合适的异常处理器处理异常，否则终止运行
</code></pre><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>断言是防御性编程中一种常见用法。Java中断言用于调试目的以检验内部假设，不是一种强制合约。</p>
<h5 id="1-使用断言"><a href="#1-使用断言" class="headerlink" title="1.使用断言"></a>1.使用断言</h5><pre><code>assert 条件

    assert &lt;boolean表达式&gt;
        如果&lt;boolean表达式&gt;为true，则程序继续执行。
        如果为false，则程序抛出AssertionError，并终止执行。

assert 条件 : 表达式

    assert &lt;boolean表达式&gt; : &lt;错误信息表达式&gt;
        如果&lt;boolean表达式&gt;为true，则程序继续执行。
        如果为false，则程序抛出java.lang.AssertionError，并输入&lt;错误信息表达式&gt;。
</code></pre><p>assert 语句会计算条件表达式的值，如果是false，则会抛出一个AssertionError异常。</p>
<h5 id="2-启用和禁用断言"><a href="#2-启用和禁用断言" class="headerlink" title="2.启用和禁用断言"></a>2.启用和禁用断言</h5><p>在默认情况下，断言是被禁用的。在运行程序时加上命令 -ea | -enableassertion 启用断言。</p>
<hr>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><blockquote>
<p>注意：抽象类和常规类很像，但是不能使用new关键字创建其实例。抽象方法只有定义没有实现，它的实现由子类提供，一个包含抽象方法的类必须声明为抽象类。</p>
</blockquote>
<p>抽象类的构造方法定义为protected，其只能被子类使用。</p>
<pre><code>注意：

    1.抽象方法不能定义在非抽象类中，如果抽象父类的子类不能实现所有的抽象方法，那么子类必须定义为抽象，同时注意抽象方法是 非静态 的。

    2.抽象类不能使用new关键字来初始化，但可以定义其构造方法，这个构造方法在它的子类的构造方法中可以被调用。

    3.包含抽象对象的类必须是抽象的，但可以定义一个不包含抽象方法的抽象类。此时不能使用new操作符创建该类的实例。

    4.如果一个类是具体的，但是其子类可以是抽象的。
</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote>
<p>注意：由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以Java允许忽略这些修饰符。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：接口中定义的常量可以使用语法：接口名.常量名(如：T.k)来访问。</p>
</blockquote>
</blockquote>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态表示对象的多种状态，多态可以作为形参接受范围更广的对象，避免函数重载或过度使用。同时多态可以作为返回值类型。抽象类和接口都可以作为多态中的父类引用类型。</p>
<blockquote>
<blockquote>
<p>提示：1.当父类和子类具有相同的非静态成员变量，那么在多态下访问的是父类的成员变量。2.当父类和子类具有相同的静态成员变量，那么在多态下访问的是父类的静态成员变量。所以父类和子类有相同的成员变量，多态下访问的是父类的成员变量。3.当父类和子类具有相同的非静态方法（就是子类重写父类方法），多态下访问的是子类的成员方法。4.当父类和子类具有相同的静态方法（就是子类重写父类静态方法），多态下访问的是父类的静态方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>总结：多态情况下，子父类存在同名的成员时，访问的都是父类的成员，只有在同名非静态函数时才是访问子类的。多态情况下，不能访问子类特有的成员。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：使用多态的前提是类与类之间存在有关系，如：继承或实现关系。</p>
</blockquote>
<pre><code>总结：

    1.抽象类和常规类一样，都有数据和方法，但是不能使用new操作符创建抽象类的实例。
    2.非抽象类中不能包含抽象方法。如果抽象类的子类没有实现所有被继承的父类抽象方法，就必须将子类也定义为抽象类。
    3.包含抽象方法的类必须是抽象类，但抽象类可以不包含抽象方法。

    4.接口中只包含常量和抽象方法，接口与抽象类很类似，但是抽象类除了包含常量和抽象方法之外，还包含变量和具体方法。

    5.接口java.lang.Comparable定义了compareTo()方法，Java类库中许多类都实现了Comparable。

    6.
</code></pre><hr>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol>
<li><p>内部类可以直接访问外部类的成员属性。</p>
</li>
<li><p>外部类需要访问内部类的成员属性时需要创建内部类的对象：</p>
<ol>
<li><p>在外部类的成员函数中创建内部类的对象，通过内部类的对象直接访问内部类的成员变量。</p>
</li>
<li><p>在其他类中创建内部类的对象 创建的格式：外部类.内部类 变量名=new 外部类();</p>
</li>
</ol>
</li>
</ol>
<p><strong>1.内部类的共性</strong><br></p>
<pre><code>(1)内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。

(2)内部类不能用普通的方式访问。

(3)内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量 。

(4)外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问
</code></pre><blockquote>
<p>注意：如果是静态内部类，其在其他类的创建对象的方式：外部类.内部类 变量名=new 外部类.内部类();</p>
</blockquote>
<p><strong>2.静态内部类的作用</strong><br></p>
<pre><code>1.只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类。

2.由于Java规定静态内部类不能用使用外在类的非静态属性和方法，所以只是为了方便管理类结构而定义。于是我们在创建静态内部类的时候，不需要外部类对象的引用。
</code></pre><p><strong>3.非静态内部类的作用</strong><br></p>
<pre><code>1.内部类继承自某个类或实现某个接口，内部类的代码操作创建其他外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。

2.使用内部类最吸引人的原因是:每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响。
</code></pre><p><strong>4.普通内部类与静态内部类的区别</strong><br></p>
<pre><code>1.普通内部类不能声明static的方法和变量

2.静态内部类不依赖外部类

3.静态内部类不持有外部类的引用
</code></pre><blockquote>
<p>总结：普通内部类不能使用静态变量是因为成员内部类是类实例的一部分，不是类的一部分。如果想在内部类内声明静态字段，就需要声明该内部类是静态的。</p>
</blockquote>
<blockquote>
<blockquote>
<p>成员内部类要注意的事项：</p>
</blockquote>
</blockquote>
<ol>
<li><p>成员内部类可以直接访问外部类成员。</p>
</li>
<li><p>如果成员内部类与外部类存在同名的成员，在内部类中默认是访问内部类的成员，成员通过”外部类.this.成员”指定访问外部类的成员。</p>
</li>
<li><p>如果成员内部类出现了静态的成员，那么该成员内部类也必须使用static修饰。</p>
</li>
<li><p>如果成员内部类是私有的，那么创建内部类的对象就只能在外部类提供方法创建。</p>
</li>
</ol>
<p>使用内部类的时间：当我们分析事物时，发现事物的内部还有具体的事物，这时就应该定义内部类。优势：成员内部类作为外部类的成员，可以访问外部类的任意成员。成员内部类访问细节：</p>
<pre><code>1.私有的成员内部类不能在其他类中直接创建内部类对象来访问。

2.如果内部类中包含静态成员，那么Java规定内部类必须声明为静态的访问静态类的形式，Out.Inner in=new Outer.Inner();
</code></pre><blockquote>
<p>总结：成员内部类(成员)属性、成员方法的特点：</p>
</blockquote>
<pre><code>1.私有的成员内部类，不能在其它类中直接创建内部类对象来访问

2.静态的成员内部类，如果内部类中包含有静态成员，那么Java规定内部类必须声明为静态的访问静态类的形式。
</code></pre><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义：包含在外部类的函数中定义的内部类称之为局部内部类</p>
<p>访问：在包含局部内部类的方法中直接创建局部内部类的对象调用局部内部类的成员(即直接在该内部类存在的方法中创建对象，对其成员进行访问)。</p>
<p>局部内部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</p>
<p>局部类的优势，对外界可以完全隐藏起来。</p>
<blockquote>
<blockquote>
<p>注意：局部内部类只能访问所在函数的final属性</p>
</blockquote>
</blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>该类是没有名称的内部类。类似于Java 8新特性中。</p>
<pre><code>new SuperType(construction parameters){
    inner class methods and data
}
</code></pre><blockquote>
<p>提示：匿名内部类不能有构造函数。匿名类没有类名。</p>
</blockquote>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>在有时候，使用静态内部类的目的在于将一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。所以我们可以将该类声明为static，以便取消产生的引用。</p>
<blockquote>
<p>提示：只有内部类可以被声明为static。静态内部类除了没有对生成它的外围对象的引用特权外，与其它内部类一样。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 新特性</title>
    <url>/undefined/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
---
title: Redis - Java集成 
tags:
  - Redis 
categories: 
  - Redis 
copyright: true
showdonate: true
date: 2019-10-15 09:22:26
comments: true
password: 
---
<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h2><p>[TOC]</p>
<h4 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h4><p>Lambda表达式允许将函数作为一个方法的参数(函数作为参数传递进方法中)，使用Lambda表达式可以使程序变得紧凑。<br><a id="more"></a></p>
<pre><code>// 1. 不需要参数,返回值为 5  
() -&gt; 5  

// 2. 接收一个参数(数字类型),返回其2倍的值  
x -&gt; 2 * x  

// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -&gt; x – y  

// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -&gt; x + y  

// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -&gt; System.out.print(s)

package cn.edu.xidian.B.Demo.Java8;

public class Java8Test {
    public static void main(String[] args) {
        Java8Test java8Test = new Java8Test();
        MathOperation addtion = (int a, int b) -&gt; a + b;

        MathOperation substraction = (a, b) -&gt; a - b;

        MathOperation multiplication = (int a, int b) -&gt; {return a*b;};

        MathOperation division = (int a, int b) -&gt; a/b;

        System.out.println(&quot;8+5=&quot; + java8Test.oprate(8,5, addtion));
        System.out.println(&quot;8-5=&quot; + java8Test.oprate(8,5, substraction));
        System.out.println(&quot;8*5=&quot; + java8Test.oprate(8,5, multiplication));
        System.out.println(&quot;8/5=&quot; + java8Test.oprate(8,5, division));

        GreetingService greetingService = message -&gt; System.out.println(&quot;hello&quot; + message);

        GreetingService greetingService1 = message -&gt; System.out.println(&quot;hello&quot; + message);

        greetingService.sayMessage(&quot;world&quot;);
        greetingService1.sayMessage(&quot;google&quot;);

    }

    interface MathOperation{
        int operation(int a, int b);
    }

    interface GreetingService{
        void sayMessage(String message);
    }

    private int oprate(int a, int b, MathOperation mathOperation){
        return mathOperation.operation(a, b);
    }
}
</code></pre><blockquote>
<p>注意：1.Lambda 表达式主要用来定义行内执行的方法类型接口。2.Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</p>
</blockquote>
<h4 id="2-变量作用域"><a href="#2-变量作用域" class="headerlink" title="2. 变量作用域"></a>2. 变量作用域</h4><p>lambda表达式只能引用标记final的外层局部变量，所以lambda内部修改定义在域外的局部变量。</p>
<h4 id="3-Lambda表达式实现Runnable接口"><a href="#3-Lambda表达式实现Runnable接口" class="headerlink" title="3.Lambda表达式实现Runnable接口"></a>3.Lambda表达式实现Runnable接口</h4><p><strong>1.使用匿名内部类</strong><br></p>
<pre><code>// 1.1使用匿名内部类  
new Thread(new Runnable() {  
    @Override  
    public void run() {  
        System.out.println(&quot;Hello world !&quot;);  
    }  
}).start();  

// 1.2使用 lambda expression  
new Thread(() -&gt; System.out.println(&quot;Hello world !&quot;)).start();  

// 2.1使用匿名内部类  
Runnable race1 = new Runnable() {  
    @Override  
    public void run() {  
        System.out.println(&quot;Hello world !&quot;);  
    }  
};  

// 2.2使用 lambda expression  
Runnable race2 = () -&gt; System.out.println(&quot;Hello world !&quot;);  

// 直接调用 run 方法(没开新线程哦!)  
race1.run();  
race2.run();  
</code></pre><h4 id="4-方法的引用"><a href="#4-方法的引用" class="headerlink" title="4.方法的引用"></a>4.方法的引用</h4><blockquote>
<p>提示：在Java8中方法的引用使用 :: 形式，比如在类Car中引用方法run()方法，直接使用形式 Car :: run 的形式。</p>
</blockquote>
<h4 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5.函数式接口"></a>5.函数式接口</h4><p>Java 8为函数式接口引入了一个新注解@FunctionalInterface，主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。</p>
<blockquote>
<p>提醒：加不加 @FunctionalInterface 对于接口是不是函数式接口没有影响，该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法。</p>
</blockquote>
<h5 id="1-函数式接口里允许定义默认方法"><a href="#1-函数式接口里允许定义默认方法" class="headerlink" title="1.函数式接口里允许定义默认方法"></a>1.函数式接口里允许定义默认方法</h5><p>函数式接口里是可以包含默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的。</p>
<h5 id="2-函数式接口里允许定义静态方法"><a href="#2-函数式接口里允许定义静态方法" class="headerlink" title="2.函数式接口里允许定义静态方法"></a>2.函数式接口里允许定义静态方法</h5><pre><code>default void test();
</code></pre><h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><pre><code>1. 如果一个接口只要一个抽象方法，那么该接口就是一个函数式接口

2. 如果我们在某一个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口。

3. 如果某一个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那编译器会对该接口定义为函数式接口。

4. If an interface declares an abstract method overriding one of the public methods of {@code java.lang.Object}, that also does em&gt;not&lt;/em&gt; count toward the interface&apos;s abstract method count since any implementation of the interface will have an implementation from {@code java.lang.Object} or elsewhere.

5. 在将函数作为一等公民的语言中，Lambda表达式的类型是函数，但是在Java中，Lambda表达式是对象，它们必须依附于一类特别的对象类型——函数式接口。

6. 高阶函数，如果一个函数的参数是为一个函数，那么该函数就称为高阶函数。

7. 流是存在短路运算的，只要其中一个操作满足条件，后面的操作就将不会再去执行。
</code></pre><h5 id="4-Function-接口"><a href="#4-Function-接口" class="headerlink" title="4. Function 接口"></a>4. Function 接口</h5><p>表示接收一个参数，并返回一个结果函数式接口。</p>
<pre><code>Function&lt;T, R&gt; T 表示输入参数类型 R 表示结果类型

/**
 * Applies this function to the given argument.
 *
 * @param t the function argument
 * @return the function result
 */
R apply(T t);

default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {
    Objects.requireNonNull(before);
    return (V v) -&gt; apply(before.apply(v));
}

default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
    Objects.requireNonNull(after);
    return (T t) -&gt; after.apply(apply(t));
}

/**
 * Returns a function that always returns its input argument.
 *
 * @param &lt;T&gt; the type of the input and output objects to the function
 * @return a function that always returns its input argument
 */
static &lt;T&gt; Function&lt;T, T&gt; identity() {
    return t -&gt; t;
}
</code></pre><h5 id="5-BiFunction-接口"><a href="#5-BiFunction-接口" class="headerlink" title="5. BiFunction 接口"></a>5. BiFunction 接口</h5><p>BiFunction&lt;T,U,R&gt;描述了 参数类型为T和U，而返回类型为R的函数。</p>
<pre><code>/**
 * Returns a composed function that first applies this function to
 * its input, and then applies the {@code after} function to the result.
 * If evaluation of either function throws an exception, it is relayed to
 * the caller of the composed function.
 *
 * @param &lt;V&gt; the type of output of the {@code after} function, and of the
 *           composed function
 * @param after the function to apply after this function is applied
 * @return a composed function that first applies this function and then
 * applies the {@code after} function
 * @throws NullPointerException if after is null
 */
default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
    Objects.requireNonNull(after);
    return (T t, U u) -&gt; after.apply(apply(t, u));
}

/**
 * Applies this function to the given arguments.
 *
 * @param t the first function argument
 * @param u the second function argument
 * @return the function result
 */
R apply(T t, U u);
</code></pre><blockquote>
<p>总结：在之前我们定义函数功能的时候，我们在定义的时候已经固定好实现逻辑，然后现在的函数式编程只是定义了一个通用的方法，然后用户在具体使用的时候定义它的实现逻辑。</p>
</blockquote>
<h5 id="6-Predicate接口"><a href="#6-Predicate接口" class="headerlink" title="6. Predicate接口"></a>6. Predicate接口</h5><pre><code>/**
 * Evaluates this predicate on the given argument.
 *
 * @param t the input argument
 * @return {@code true} if the input argument matches the predicate,
 * otherwise {@code false}
 */
boolean test(T t);

//逻辑与操作
default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {
    Objects.requireNonNull(other);
    return (t) -&gt; test(t) &amp;&amp; other.test(t);
}

//逻辑非操作
default Predicate&lt;T&gt; negate() {
    return (t) -&gt; !test(t);
}

//逻辑或操作
default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {
    Objects.requireNonNull(other);
    return (t) -&gt; test(t) || other.test(t);
}

...
</code></pre><p>在源码中查看具体的方法。</p>
<h5 id="7-Supplier-接口"><a href="#7-Supplier-接口" class="headerlink" title="7. Supplier 接口"></a>7. Supplier 接口</h5><p>不接受参数，且返回结果。</p>
<pre><code>/**
 * Gets a result.
 *
 * @return a result
 */
T get();
</code></pre><h5 id="8-Consumer接口"><a href="#8-Consumer接口" class="headerlink" title="8. Consumer接口"></a>8. Consumer接口</h5><p>表示接收一个单一的输入参数，不返回结果。</p>
<pre><code>/**
 * Performs this operation on the given argument.
 *
 * @param t the input argument
 */
void accept(T t);

* @param after the operation to perform after this operation
 * @return a composed {@code Consumer} that performs in sequence this
 * operation followed by the {@code after} operation
 * @throws NullPointerException if {@code after} is null
 */
default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {
    Objects.requireNonNull(after);
    return (T t) -&gt; { accept(t); after.accept(t); };
}


//example
List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
list.forEach(new Consumer&lt;Integer&gt;() {
    @Override
    public void accept(Integer integer) {
        System.out.println(integer);
    }
});
</code></pre><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>Optional<t> 对象是一个T类型对象或者空对象的封装。Optional<t>类型是要么指向对象要么为null的T类型引用的安全替代者。</t></t></p>
<p><strong>8.7.1 使用Optional类型值</strong><br><br>有效使用Optional的关键在于：使用一个要么如果值不存在，产生另外一个替代者。要么如果值存在，使用该值的方法。即不会报空指针异常。</p>
<pre><code>第一种策略：当没有可匹配项时，我们可能会希望使用一个默认值，可能是一个空字符串。

    //封装的字符串，如果没有的话则为空字符串
    String result = optionalString.orElse(&quot;&quot;);

    //只有在被需要时才会被调用
    String result = optionalString.orElseGet(() -&gt; System.getProperty(&quot;myapp.default&quot;));

    //提供一个可以产生异常对象的方法
    String result = optionalString.orElseThrow(IllegalStateException::new);
</code></pre><p><strong>8.7.2 如何不使用Optional类型值</strong><br></p>
<p><strong>8.7.3 创建Optional类型值</strong><br><br>如果我们需要创建Optional对象的方法，有一些静态方法选择。Optional.of(result)和Optional.empty()。</p>
<pre><code>public static Optional&lt;Double&gt; inverse(Double x){
    return x == 0 ? Optional.empty() : Optional.of(1 / x);
}
</code></pre><p><strong>8.7.4 使用flatMap来组合可选值函数</strong><br></p>
<p><strong>8.7.5 将Optional转变成流</strong><br></p>
<pre><code>/**
     * If a value is present, apply the provided mapping function to it,
     * and if the result is non-null, return an {@code Optional} describing the
     * result.  Otherwise return an empty {@code Optional}.
     *
     * @apiNote This method supports post-processing on optional values, without
     * the need to explicitly check for a return status.  For example, the
     * following code traverses a stream of file names, selects one that has
     * not yet been processed, and then opens that file, returning an
     * {@code Optional&lt;FileInputStream&gt;}:
     *
     * &lt;pre&gt;{@code
     *     Optional&lt;FileInputStream&gt; fis =
     *         names.stream().filter(name -&gt; !isProcessedYet(name))
     *                       .findFirst()
     *                       .map(name -&gt; new FileInputStream(name));
     * }&lt;/pre&gt;
     *
     * Here, {@code findFirst} returns an {@code Optional&lt;String&gt;}, and then
     * {@code map} returns an {@code Optional&lt;FileInputStream&gt;} for the desired
     * file if one exists.
     *
     * @param &lt;U&gt; The type of the result of the mapping function
     * @param mapper a mapping function to apply to the value, if present
     * @return an {@code Optional} describing the result of applying a mapping
     * function to the value of this {@code Optional}, if a value is present,
     * otherwise an empty {@code Optional}
     * @throws NullPointerException if the mapping function is null
     */
    public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
        Objects.requireNonNull(mapper);
        if (!isPresent())
            return empty();
        else {
            return Optional.ofNullable(mapper.apply(value));
        }
    }
</code></pre><h4 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h4><p>Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器，jdk1.8中的集合框架中的数据结构都默认实现了spliterator，后面我们也会结合ArrayList中的spliterator()一起解析。</p>
<pre><code>//单个对元素执行给定的动作，如果有剩下元素未处理返回true，否则返回false
boolean tryAdvance(Consumer&lt;? super T&gt; action);

//对每个剩余元素执行给定的动作，依次处理，直到所有元素已被处理或被异常终止。默认方法调用tryAdvance方法
default void forEachRemaining(Consumer&lt;? super T&gt; action) {
   do { } while (tryAdvance(action));
}

//对任务分割，返回一个新的Spliterator迭代器
Spliterator&lt;T&gt; trySplit();

//用于估算还剩下多少个元素需要遍历
long estimateSize();

//当迭代器拥有SIZED特征时，返回剩余元素个数；否则返回-1
default long getExactSizeIfKnown() {
   return (characteristics() &amp; SIZED) == 0 ? -1L : estimateSize();
}

 //返回当前对象有哪些特征值
int characteristics();

//是否具有当前特征值
default boolean hasCharacteristics(int characteristics) {
   return (characteristics() &amp; characteristics) == characteristics;
}
//如果Spliterator的list是通过Comparator排序的，则返回Comparator
//如果Spliterator的list是自然排序的 ，则返回null
//其他情况下抛错
default Comparator&lt;? super T&gt; getComparator() {
    throw new IllegalStateException();
}
</code></pre><blockquote>
<p>提示：特征值其实就是为表示该Spliterator有哪些特性，用于可以更好控制和优化Spliterator的使用。</p>
</blockquote>
<h4 id="6-Java8-默认方法"><a href="#6-Java8-默认方法" class="headerlink" title="6.Java8 默认方法"></a>6.Java8 默认方法</h4><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<p>默认方法很大程度上解决向后兼容的问题。避免其破坏类。</p>
<h4 id="7-Java-8-Stream"><a href="#7-Java-8-Stream" class="headerlink" title="7.Java 8 Stream"></a>7.Java 8 Stream</h4><p>此抽象可以让编程人员以一种声明的方式处理数据。这种风格将要处理的元素集合看作是一种流，流在管道中传输，并且可以在管道的结点上进行处理。</p>
<h5 id="1-Stream流"><a href="#1-Stream流" class="headerlink" title="1.Stream流"></a>1.Stream流</h5><p>Stream流是数据渠道，用于操作数据源(集合、数组)所生成的元素序列，其可以多个操作链接起来运行，内部迭代。</p>
<p>流的组成：</p>
<pre><code>1. 源

2. 零个或多个中间操作

3. 终止操作
</code></pre><blockquote>
<p>注意：stream流不会改变原有的对象，会返回一个新的stream。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：Stream操作还有两个基础特征。1.Pipelining：中间操作都会返回流对象本身。2.内部迭代：通过访问者模式(Visitor)实现。</p>
</blockquote>
</blockquote>
<p>流操作的分类：</p>
<pre><code>1. 惰性求值

2. 及早求值
</code></pre><blockquote>
<p>提示：只有在遇到上面的操作之后，中间操作才会执行。如果没有及早求值或终止操作，中间操作不会执行。</p>
</blockquote>
<h5 id="2-创建Stream"><a href="#2-创建Stream" class="headerlink" title="2.创建Stream"></a>2.创建Stream</h5><pre><code>流的典型工作流程：

    1.创建Stream
    2.指定将初始流转换成其它流的中间操作，可能需要多步操作
    3.应用终止操作产生结果
</code></pre><p>使用Collection接口的Stream()方法可以将任何集合转换为Stream。如果是数组的话可以使用静态方法 Stream.of将它转化为Stream。</p>
<pre><code>Stream&lt;String&gt; words = Stream.of(contents.split(&quot;\\PL+&quot;);
</code></pre><h4 id="8-filter-map-flatMap-方法"><a href="#8-filter-map-flatMap-方法" class="headerlink" title="8. filter | map | flatMap 方法"></a>8. filter | map | flatMap 方法</h4><p>流的转换产生一个新流，该流的元素来源于其它流。filter转换生成一个匹配一定条件的新流。</p>
<pre><code>List&lt;String&gt; words = ...;
Stream&lt;String&gt; longWords = words.stream().filter(w -&gt; w.length() &gt; 12);
</code></pre><blockquote>
<p>filter的参数是一个Predicate<t>对象，即从T到boolean的函数。</t></p>
</blockquote>
<p>考虑将一个流中的值进行某种形式的转换，可以考虑使用map()方法，并且传递给它一个执行转换的函数。</p>
<pre><code>Stream&lt;String&gt; lowercaseWords = words.stream().map(String::toLowerCase);
Stream&lt;String&gt; firstLetters = words.stream().map(s -&gt; s.substring(0, 1));
</code></pre><p>使用flatMap()方法将字符串转换成只包含字符串的流。</p>
<pre><code>List&lt;String&gt; words = ...;
Stream&lt;String&gt; flatResult = words.stream().flatMap(w -&gt; codePoints(w));
</code></pre><h5 id="2-流与集合之间的比较"><a href="#2-流与集合之间的比较" class="headerlink" title="2.流与集合之间的比较"></a>2.流与集合之间的比较</h5><pre><code>1.在集合中，其会包含当前数据结构中所有的值，可以随时对其操作，在集合里面的元素值已经提前计算好。而流则是按需就散，按照当前使用的需要计算数据。
创建stream的过程就是将一个数据源(集合或者数组等)转换为一个流。这里有三种方式创建stream流。

2.迭代的差异，集合进行外部迭代，一遍遍的的去进行迭代操作。而流由流水线直接进行内部迭代。


//1 通过Collection系列提供的stream()（串行） 或parallelStream()（并行）获取
List&lt;String&gt; list = new ArrayList&lt;&gt;();
Stream&lt;String&gt; stream1 = list.stream();//串行流
Stream&lt;String&gt; stream2 = list.parallelStream();//并行流

//2 通过Arrays中的静态方法stream() 获取数据流
User[] u = new User[2];
Stream&lt;User&gt; stream3 = Arrays.stream(u);

//3 通过Stream类中的静态方法of()
Stream&lt;String&gt; stream4 = Stream.of(&quot;11&quot;,&quot;2&quot;);
</code></pre><h5 id="3-中间操作"><a href="#3-中间操作" class="headerlink" title="3.中间操作"></a>3.中间操作</h5><pre><code>&lt;!--这里表示对数据源进行一系列的操作处理，链接起来作为一条流水线处理各种操作。--&gt;
</code></pre><h5 id="4-方法"><a href="#4-方法" class="headerlink" title="4.方法"></a>4.方法</h5><pre><code>1.filter(predicate)-接收lambda，从流中排除某些元素。
2.limit(n)-截断流，使其元素不超过给定数量。
3.skip(n)-跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补。
4.distinct-筛选，通过流所生成元素的hashcode()和equals()去重复元素。
5.forEach 迭代流中的每个数据
6.map 映射每个元素对应的结果，类似类型转换
8.flatMap() 将流中的每一个元素映射为一个流，再把每一个流连接成为一个新流

7.collect 作为终端操作，接收的是一个Collector接口参数，能对数据进行一些搜集归总操作。
    7.1 toList
    7.2 toSet
    7.3 toCollection
    7.4 toMap

9.reduce 用于组合流中的元素 如：求和|求积|求最大值等

    //计算年龄总和
    int sum = list.stream().map(Person::getAge).reduce(0, (a,b) -&gt; a + b);

    //或者是这样
    int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum);

//例
//打印年龄大于18的前4位用户，并且跳过第1个用户
public void test1(){
    list.stream().filter((x)-&gt;x.getAge()&gt;18).distinct().limit(4)
    .skip(1).forEach(System.out::println);
 }
</code></pre><h4 id="8-6-简单归约"><a href="#8-6-简单归约" class="headerlink" title="8.6 简单归约"></a>8.6 简单归约</h4><p>归约就是如何从流数据中获得答案，归约是终止操作。如简单的归约函数：count() | max() | min() 方法，这些方法都会返回一个Optional<t>类型的值。</t></p>
<pre><code>Optional&lt;String&gt; largest = words.max(String::compareToIngnoreCase);
System.out.println(&quot;largest:&quot; + largest.orElse(&quot;&quot;));
</code></pre><h4 id="方法引用（method-reference）"><a href="#方法引用（method-reference）" class="headerlink" title="方法引用（method reference）"></a>方法引用（method reference）</h4><p>方法引用实际上是个lambda表达式的一种语法糖。</p>
<p>我们可以将方法引用看做是一个函数指针，function pointer。</p>
<p>方法引用分为四类：</p>
<pre><code>1. 类名::静态方法名，方法引用与方法的静态引用（方法调用）没有任何关系。

2. 引用名（对象名）::实例方法名

3. 类名::实例方法名，这里的调用者是第一个参数，后续的所有参数都是作为参数传入进去的。

4. 构造方法引用：类名::new
</code></pre><blockquote>
<p>提示：实现类的优先级比接口的优先级要高一些。</p>
</blockquote>
<p>在有现成的方法的时候，可以使用方法引用来代替lambda表达式。</p>
<blockquote>
<blockquote>
<p>流不能重复使用。</p>
</blockquote>
</blockquote>
<h4 id="9-映射"><a href="#9-映射" class="headerlink" title="9.映射"></a>9.映射</h4><pre><code>1.map 接收lambda，并将元素转换成其它形式或提取信息，会将元素映射成新的元素。

2.flatMap 接收函数作为参数，并将流中的每个值转换成流，将流链接成另外一个流。
</code></pre><h4 id="10-构建流"><a href="#10-构建流" class="headerlink" title="10.构建流"></a>10.构建流</h4><pre><code>1.Stream.of(&quot;Aaron&quot;,&quot;Brian&quot;,&quot;Carol&quot;); //这里构建一个字符串流
2.Stream.empty();//这里生成空流
</code></pre><h4 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h4><pre><code>1.counting 用于计算总和

    long l = list.stream().collect(counting());

    //或者这样

    long l = list.stream().count();

2.summingInt | summingLong | summingDouble

    int sum = list.stream().collect(summingInt(Person::getAge));//计算年龄总和

    //或者是这样
    int sum = list.stream().mapToInt(Person::getAge).sum();

    //或者这样
    int sum = list.stream().map(Person::getAge).reduce(Interger::sum).get();
</code></pre><blockquote>
<p>提示：函数式编程通常提供多种方式完成同一操作。</p>
</blockquote>
<pre><code>3.averagingInt | averagingLong | averagingDouble

    Double average = list.stream().collect(averagingInt(Person::getAge));

    //或者是这样
    OptionalDouble average = list.stream().mapToInt(Person::getAge).average();

4.joining 连接字符串

    此方法是对流里面的字符串进行连接 底层实现是使用用于字符串连接的StringBuilder

    String s = list.stream().map(Person::getName).collect(joining());

    String s = list.stream().map(Person::getName).collect(joining(&quot;,&quot;));//这里是在获得名字中间用,区分开

5.取最值 maxBy() | minBy() 

    此方法需要Comparator接口作为参数

        Optional&lt;Person&gt; optional = list.stream().collect(maxBy(comparing(Person::getAge)));

        //或者是这样
        Optional&lt;Person&gt; optional = list.stream().max(comparing(Person::getAge));

6.summarizingInt | summarizingLong | summarizingDouble

    这三种方法比较特殊，比如 summarizingInt 会返回 IntSummaryStatistics 类型

        //IntSummaryStatistics 包含了计算出来的平均值，总数，总和，最值，可以通过下面这些方法获得相应的数据
        IntSummaryStatistics l = list.stream().collect(summarizingInt(Person::getAge));
</code></pre><h4 id="数据的分区与分组"><a href="#数据的分区与分组" class="headerlink" title="数据的分区与分组"></a>数据的分区与分组</h4><pre><code>Student student1 = new Student(&quot;zhangsan&quot;, 86, 18);
Student student2 = new Student(&quot;lisi&quot;, 89, 20);
Student student3 = new Student(&quot;wangwu&quot;, 93, 23);
Student student4 = new Student(&quot;lisi&quot;, 79, 24);

List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);

//group
Map&lt;String, List&lt;Student&gt;&gt; map = students.stream().collect(Collectors.groupingBy(Student::getName));
System.out.println(map);

System.out.println(&quot;--------------------------------&quot;);

Map&lt;Integer, List&lt;Student&gt;&gt; map2 = students.stream().collect(Collectors.groupingBy(Student::getScore));
System.out.println(map2);

System.out.println(&quot;--------------------------------&quot;);

Map&lt;String, Long&gt; map3 = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting()));
System.out.println(map3);

System.out.println(&quot;--------------------------------&quot;);

Map&lt;String, Double&gt; map4 = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore)));
System.out.println(map4);

System.out.println(&quot;--------------------------------&quot;);

//partion
Map&lt;Boolean, List&lt;Student&gt;&gt; map5 = students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= 90));
System.out.println(map5);
</code></pre><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>我们通过list.stream()将List类型转换为流类型，还可以通过list.parallelStream()转换成并行流。所以通常可以通过使用parallelStream代替Stream()方法。</p>
<blockquote>
<p>注意：并行流是将内容分成多个数据块，使用不同的线程分别处理每个数据块的Luis。</p>
</blockquote>
<hr>
<h3 id="底层（bottom）"><a href="#底层（bottom）" class="headerlink" title="底层（bottom）"></a>底层（bottom）</h3><h4 id="分组与分区"><a href="#分组与分区" class="headerlink" title="分组与分区"></a>分组与分区</h4><p>分区是分组的一种特例，分区的话就只有false和true两种类型。</p>
<h4 id="Collector-收集器"><a href="#Collector-收集器" class="headerlink" title="Collector 收集器"></a>Collector 收集器</h4><ol>
<li><p>Collector作为collect()方法的参数。</p>
</li>
<li><p>Collector是一个接口，它是一个可变的汇聚操作，将输入元素累积到一个可变的结果容器中。</p>
</li>
<li><p>它会在所有元素都处理完毕之后，将累积的结果转换成一个最终的表示（这是一个可选操作）。它支持串行和并行两种操作。</p>
</li>
<li><p>Collectors本身提供了关于Collector的常见汇聚实现，Collectors本身实际上是一个工厂。</p>
</li>
<li><p>为了确保串行与并行操作结果的等价性，Collector函数需要满足两个条件：identity(同一性)与associativity(结合性)。</p>
</li>
<li><p>a == combiner.apply(a, supplier.get());</p>
<p> (List<string> list1, List<string> list2) -&gt; {list1.addAll(list2); return list1}</string></string></p>
</li>
<li><p>函数式编程最大的特点：表示做什么，而不是如何做。</p>
</li>
</ol>
<blockquote>
<p>combiner()函数，假设有四个线程同时去执行，就会生成四个不同的结果，combiner函数就是将四个不同的结果合并成一个结果。该函数是在多线程并行环境下起作用的。</p>
</blockquote>
<h4 id="自定义-Collector"><a href="#自定义-Collector" class="headerlink" title="自定义 Collector"></a>自定义 Collector</h4><h4 id="Collectors-底层"><a href="#Collectors-底层" class="headerlink" title="Collectors 底层"></a>Collectors 底层</h4><p>对于Collectors静态工厂类来说，其实现一共分为两种情况：</p>
<pre><code>1. 通过CollectorImpl来实现。

2. 通过reducing方法来实现，reducing方法本身又是通过CollectorImpl来实现。
</code></pre><h3 id="Comparator-比较器"><a href="#Comparator-比较器" class="headerlink" title="Comparator 比较器"></a>Comparator 比较器</h3><blockquote>
<p>如果存在特化的方法和通用的方法，那么一定调用特化的方法，这样的效率要高一些。</p>
</blockquote>
<p>#### </p>
]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/undefined/Java%20%E4%BA%8C%E8%BF%9B%E5%88%B6IO/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>Java中处理输入输出，File对象封装文件或路径属性，不包含从/向文件读/写数据的方法。为了进行I/O操作，需要使用正确的Java I/O类创建对象。</p>
<h4 id="1-File-类"><a href="#1-File-类" class="headerlink" title="1.File 类"></a>1.File 类</h4><pre><code>//检查指定路径下是否存在指定目录或者文件
File file = new File(&quot;c:\\a.txt&quot;);//在c:目录下创建一个file文件
System.out.println(file.exists());//指定文件是否存在

//File对象是否是目录
System.out.println(file.isDirectory());

//对象是否是文件
System.out.println(file.isFile());
</code></pre><blockquote>
<p>注意：构建一个File实例不会在机器上创建一个文件，不管文件是否存在都可以创建任意文件名的File实例，调用File实例的exists()方法判断文件或目录是否存在。</p>
</blockquote>
<pre><code>//创建一个File类实例
new File(String pathname);
//通过制定路径创建一个新的File实例
new File(String parent,String child);
</code></pre><blockquote>
<p>总结：I/O类可以分为文本I/O和二进制I/O，文本I/O将数据解释成字符序列，二进制I/O将数据解释成原始的二进制数值。Java自动完成对文本I/O的编码和解码。</p>
</blockquote>
<pre><code>File 类中常用的方法：
    1.createNewFile()：在指定的位置创建一个文件，成功返回true，如果已经存在就不创建并返回false。
    2.mkdir()：在指定位置创建目录，这只会创建最后一级目录，如果上级目录不存在就抛出异常。
    3.mkdirs()：在指定位置创建目录，这会创建路径中所有不存在的目录。

    exists() 文件或文件夹是否存在。
    isFile() 是否是一个文件，如果不存在，则始终为false。
    isDirectory() 是否是一个目录，如果不存在，则始终为false。
    isHidden() 是否是一个隐藏的文件或是否是隐藏的目录。
    isAbsolute() 测试此抽象路径名是否为绝对路径名。

    getName() 获取文件或文件夹的名称，不包含上级路径。
    getPath() 返回绝对路径，可以是相对路径，但是目录要指定
    getAbsolutePath() 获取文件的绝对路径，与文件是否存在没关系
    length() 获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。
    getParent() 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。
    lastModified() 获取最后一次被修改的时间。

    文件夹相关：
        staic File[] listRoots() 列出所有的根目录（Window中就是所有系统的盘符）
        list() 返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。
        list(FilenameFilter filter)    返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。
        listFiles() 返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。
        listFiles(FilenameFilter filter) 返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。
</code></pre><p>案例：</p>
<pre><code>//列出指定目录下所有包含的子文件与子目录
public static void listAllFileAndDirs(String path){
    //1.创建File对象，表示这个目录
    File dir = new File(path);
    //2.通过list方法得到所包含的所有目录与子文件的名称
    String[] names = dir.list();
    //3.显示这些名称
    for(int i = 0; i &lt; names.length; i++){
        System.out.println(names[i]);
    }
}

//在上面案例的基础上判断哪些是文件，哪些是文件夹
public static void listAllFilesAndDirs2(String path){
    //1.创建File对象，表示这个目录
    File dir = new File(path);
    //2.通过listFiles()方法得到所包含的所有子目录与子文件名称
    File[] names = dir.listFiles();
    //3.分别显示文件夹名与文件名
    for(int i = 0; i &lt; names.length; i++){
        File file = names[i];
        if(file.isFile()){
            System.out.println(&quot;文件：&quot;);
            System.out.println(&quot;\t&quot;+file.getName());
        }else if(file.isDirectory()){
            System.out.println(&quot;文件夹：&quot;);
            System.out.println(&quot;\t&quot;+file.getName());
        }
    }
}

//或者通过集合的形式实现，列出所有的文件以及文件夹
public static void listAllFilesAndDirs(String path) {
    //1.创建File对象表示这个目录
    File dir = new File(path);

    //2.通过listFiles方法得到所包含的所有子目录与子文件名称
    File[] names = dir.listFiles();

    //3.得到所有的文件名集合，与所有的文件夹名集合
    List&lt;File&gt; filesList = new ArrayList&lt;File&gt;();
    List&lt;File&gt; dirsList = new ArrayList&lt;File&gt;();
    for (int i = 0; i &lt; names.length; i++) {
        File file = names[i];
        //不管是用什么方式都需要用File相关的方法判断其是否是文件或者文件夹
        if (file.isFile()) {
            filesList.add(file);
        } else if (file.isDirectory()) {
            dirsList.add(file);
        }
    }

    //4.分别显示文件名与文件夹名
    System.out.println(&quot;子文件：&quot;);
    for (int i = 0; i &lt; filesList.size(); i++) {
        System.out.println(&quot;\t&quot; + filesList.get(i).getName());
    }
    System.out.println(&quot;子目录：&quot;);
    for (int i = 0; i &lt; dirsList.size(); i++) {
        System.out.println(&quot;\t&quot; + dirsList.get(i).getName());
    }
}

//列出指定目录下所有扩展名为.java的文件
public class FileTest2 {
    public static void main(String[] args) {
        String path = &quot;c:&quot; + File.separatorChar + &quot;test&quot;;
        File file = new File(path);
        listtAllFiles(file, &quot;java&quot;);
    }

    public static void listtAllFiles(File dir, String extension) {
        // 1.获取所有的子文件和子文件夹
        File[] files = dir.listFiles();

        // 2.从中找出符合条件的文件并显示出来
        for (int i = 0; i &lt; files.length; i++) {
            File file = files[i];
            // 3.需要以指定文件后缀结尾才算符合条件
            if (file.getName().endsWith(extension)) {
                System.out.println(file.getName());
            }
        }
    }
}

//给FilenameFilter接口写一个工具类，可以传递指定的过滤规则，从指定目录中找出指定扩展名的文件，并列出来
public class FileTest2 {
    public static void main(String[] args) {
        String path = &quot;c:&quot; + File.separatorChar + &quot;test&quot;;
        File file = new File(path);
        listtAllFiles2(file, &quot;txt&quot;);
    }

    public static void listtAllFiles2(File dir, String name) {
        // 1.获取所有的子文件和子文件夹
        String[] files = dir.list(new DirFilter(&quot;txt&quot;));

        // 2.显示名称
        for (int i = 0; i &lt; files.length; i++) {
            System.out.println(files[i]);
        }
    }
}

class DirFilter implements FilenameFilter {
    private String extension;

    public DirFilter() {

    }

    public DirFilter(String extension) {
        this.extension = extension;
    }

    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(extension);
    }
}
</code></pre><hr>
<h4 id="2-IO流技术"><a href="#2-IO流技术" class="headerlink" title="2.IO流技术"></a>2.IO流技术</h4><p>通过Java程序读取文件中的内容以及将程序中的数据保存早硬盘的文件中去都需要用到IO流技术。</p>
<p>案例：</p>
<pre><code>//使用IO流技术读写文件
public class IOTest{
    public static void mian(String[] args) throws FileNotFoundException,IOException {
        writeFileTest();
        readFileTest();
    }
    private static void writeFileTest() throws FileNotFoundException,IOException {
        //1.创建文件对象
        File file = new File(&quot;c:\\a.txt&quot;);
        //2.创建文件输出流
        FileOutputStream fos = new FileOutputStream(file);
        fos.write(&apos;g&apos;);
        fos.write(&apos;z&apos;);
        fos.write(&apos;i&apos;);
        fos.write(&apos;t&apos;);
        fos.write(&apos;c&apos;);
        fos.write(&apos;a&apos;);
        fos.write(&apos;s&apos;);
        fos.write(&apos;t&apos;);
        fos.close();

    }
    private static void readFileTest() throws FileNotFoundException,IOException {
    // 1.创建文件对象
    File file = new File(&quot;c:\\a.txt&quot;);
    // 2.创建文件输入流
    FileInputStream fis = new FileInputStream(file);
    // 3.有对多长，就读多少字节。
    for (int i = 0; i &lt; file.length(); i++) {
        System.out.print((char) fis.read());
    }
    //完成读写操作之后，应该通过调用close()方法来关闭它，释放有限的系统资源
    fis.close();
}
}
</code></pre><blockquote>
<p>注意：读取硬盘上的文件应该使用输入流(InputStream)，但是InputStream是抽象类，具体使用时使用具体实现类来创建对象(FileInputStream)。</p>
</blockquote>
<pre><code>//输入流读取方式1：read()方法
//根据read()方法返回值的特性，如果读到文件的末尾返回-1，如果不为-1继续往下读
private static void showContent(String path) throws IOException {
    FileInputStream fis = new FileInputStream(path);
    int len = fis.read();
    while(len != -1){
        System.out.println((char)len);
        len = fis.read();
    }
    //使用完之后关闭流
    fis.close();
}

...
</code></pre><blockquote>
<p>注意：Java文件向指定文件中写入数据，使用字节流对象OutputStream。该类是抽象类，使用具体实现类FileOutputStream创建其流对象。</p>
</blockquote>
<pre><code>//输出流写出方式1：write(int b)方法
import java.io.FileOutputStream;
import java.io.IOException;

public class IOTest2 {
    public static void main(String[] args){
        String path = &quot;c:\\a.txt&quot;;
        writeTxtFile(path);
    }
    private static void writeTxtFile(String path) throws IOException {
        //1.打开文件输出流，流的目的地是指定的文件
        FileOutputStream fos = new FileOutputStream(path);
        //2.通过流向文件写数据
        fos.write(&apos;j&apos;);
        fos.write(&apos;a&apos;);
        fos.write(&apos;v&apos;);
        fos.write(&apos;a&apos;);
        //3.用完流后关闭流
        fos.close();
    }
}
</code></pre><blockquote>
<p>提示：如果在对应的path路径下不存在相应的文件时，其会自动创建一个，但不是创建多级目录。</p>
</blockquote>
<pre><code>//输出流写出方式2：write(byte[] b) 使用缓冲，提高效率
public class IoTest2 {
    public static void main(String[] args) throws IOException {
        String path = &quot;c:\\a.txt&quot;;
        writeTxtFile(path);
    }
    private static void writeTxtFile(String path) throws IOException {
        //1.打开文件输出流，流的目的地是指定的文件
        FileOutputStream fos = new FileOutputStream(path);

        //2.通过流向文件写数据
        byte[] byt = &quot;java&quot;.getBytes();
        fos.write(byt);

        //3.用完流后关闭流
        fos.close();
    }
}

//字节输入/输出流综合使用
public class IoTest3 {
    public static void main(String[] args) throws IOException {
        String path = &quot;c:\\b.txt&quot;;
        String content = &quot;hello java&quot;;

        writeFile(path, content);

        readFile(path);
    }

    public static void writeFile(String path, String content)
            throws IOException {
        // 打开文件输出流
        FileOutputStream fos = new FileOutputStream(path);
        byte[] buffer = content.getBytes();
        // 向文件中写入内容
        fos.write(buffer);
        // 关闭流
        fos.close();

    }

    public static void readFile(String path) throws IOException {
        FileInputStream fis = new FileInputStream(path);
        byte[] byt = new byte[1024];
        int len = 0;
        while ((len = fis.read(byt)) != -1) {
            System.out.println(new String(byt, 0, len));
        }
        // 关闭流
        fos.close();

    }
}

//文件的拷贝 方式1
public class IoTest3 {
    public static void main(String[] args) throws IOException {
        String srcPath = &quot;c:\\a.txt&quot;;
        String destPath = &quot;d:\\a.txt&quot;;
        copyFile(srcPath, destPath);
    }
    public static void copyFile(String srcPath, String destPath)
            throws IOException {

        // 打开输入流，输出流
        FileInputStream fis = new FileInputStream(srcPath);
        FileOutputStream fos = new FileOutputStream(destPath);

        // 读取和写入信息
        int len = 0;
        while ((len = fis.read()) != -1) {
            fos.write(len);
        }

        // 关闭流
        fis.close();
        fos.close();
    }
}

//图片/视频/音频的拷贝
public class IoTest3 {
    public static void main(String[] args) throws IOException {

        String srcPath = &quot;c:\\秋.jpg&quot;;
        String destPath = &quot;d:\\秋.jpg&quot;;
        copyFile(srcPath, destPath);
    }
    public static void copyFile(String srcPath, String destPath)
            throws IOException {
        // 打开输入流，输出流
        FileInputStream fis = new FileInputStream(srcPath);
        FileOutputStream fos = new FileOutputStream(destPath);

        // 读取和写入信息
        int len = 0;
        while ((len = fis.read()) != -1) {
            fos.write(len);
        }

        // 关闭流
        fis.close();
        fos.close();
    }
}

//字节流拷问文件 方式2
//使用字节数组作为缓冲区
public static void copyFile2(String srcPath, String destPath)
        throws IOException {
    // 打开输入流，输出流
    FileInputStream fis = new FileInputStream(srcPath);
    FileOutputStream fos = new FileOutputStream(destPath);

    // 读取和写入信息
    int len = 0;

    // 使用字节数组，当做缓冲区
    byte[] byt = new byte[1024];
    while ((len = fis.read(byt)) != -1) {
        fos.write(byt);
    }

    // 关闭流
    fis.close();
    fos.close();
}
</code></pre><hr>
<p><strong>字节流的异常处理</strong><br></p>
<p>案例：</p>
<pre><code>public class IoTest4 {
    public static void main(String[] args) throws IOException,InterruptedException {
        String path = &quot;c:\\b.txt&quot;;
        readFile(path);
    }

    private static void readFile(String path) throws IOException,InterruptedException {
        FileInputStream fis = new FileInputStream(path);
        byte[] byt = new byte[1024];
        int len = fis.read(byt);
        System.out.println(new String(byt, 0, len));
        // 让程序睡眠，无法执行到close方法。
        Thread.sleep(1000 * 10);
        fis.close();
    }
}
</code></pre><blockquote>
<p>提示：在上面的案例中如果进程Thread没有睡醒便不能执行关闭操作，所以这样的异常一般使用try…catch块来处理。</p>
</blockquote>
<h4 id="3-字节缓冲流"><a href="#3-字节缓冲流" class="headerlink" title="3.字节缓冲流"></a>3.字节缓冲流</h4><p>提供专门的字节缓冲流来提高效率，BufferedInputStream和BufferedOutputStream。虽然使用缓冲流来提升效率时，对于小文件看不到性能的提升，但是对于稍微大一些的文件就可以看到实质性的性能的提升。</p>
<pre><code>public class IOTest{
    public static void main(String[] args){
        String srcPath = &quot;c:\\a.mp3&quot;;
        String destPath = &quot;d:\\copy.mp3&quot;;
        copyFile(srcPath,destPath);
    }
    public static void copyFile(String srcPath,String destPath) throws IOException {
        //1.打开输入输出流
        FileInputStream fis = new FileInputStream(srcPath);
        FileOutputStream fos = new FileOutputStream(destPath);
        //2.使用缓冲流
        BufferedInputStream bis = new BufferedInputStream(fis);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        //3.读取和写入信息
        int len = 0;
        while((len = bis.read()) != -1){
            bos.write(len);
        }
        //关闭流
        bis.close();
        bos.close();
    }
}
</code></pre><h4 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h4><p>字符流=字节流+ 编码表，字符流的抽象基类：Reader/Writer 这些类派生出来的子类名称以其父类名作为子类名的后缀。如：FileReader/FileWriter</p>
<p><strong>1.Reader</strong><br><br>使用Reader读取文本，可以使用InputStreamReader适配器从任何一种输入流获取一个Reader。</p>
<pre><code>public class IoTest1_Reader {
    public static void main(String[] args) throws Exception {
        String path = &quot;c:/a.txt&quot;;
        // readFileByInputStream(path);
        readFileByReader(path);
    }

    //使用字节流读取文件内容
    public static void readFileByInputStream(String path) throws Exception {
        InputStream in = new FileInputStream(path);

        int len = 0;
        while ((len = in.read()) != -1) {
            System.out.print((char) len);
        }
        in.close();
    }

    //使用字符流读取文件内容
    public static void readFileByReader(String path) throws Exception {
        Reader reader = new FileReader(path);
        int len = 0;
        while ((len = reader.read()) != -1) {
            System.out.print((char) len);
        }
        reader.close();
    }
}
</code></pre><p><strong>2.Writer</strong><br></p>
<pre><code>1.write(ch): 将一个字符写入到流中。&lt;br&gt;
2.write(char[]): 将一个字符数组写入到流中。&lt;br&gt;
3.write(String): 将一个字符串写入到流中。&lt;br&gt;
4.flush():刷新流，将流中的数据刷新到目的地中，流还存在。&lt;br&gt;
5.close():关闭资源，在关闭前会先调用flush()，刷新流中的数据去目的地。然流关闭。
</code></pre><hr>
<pre><code>//将文本数据存储到一个文件中
public class IoTest2_Writer {
    public static void main(String[] args) throws Exception {
        String path = &quot;c:/ab.txt&quot;;
        writeToFile(path);
    }

    //写指定数据到指定文件中
    public static void writeToFile(String path) throws Exception {
        Writer writer = new FileWriter(path);
        writer.write(&apos;中&apos;);
        writer.write(&quot;世界&quot;.toCharArray());
        writer.write(&quot;中国&quot;);
        writer.close();
    }
}
</code></pre><blockquote>
<p>注意：程序执行完打开文件，发现没有内容写入。原来需要使用flush方法，刷新该流的缓冲。现在只需要调用close()方法即可，因为close()方法调用了flush()方法。</p>
</blockquote>
<pre><code>//字符流拷贝文件 方式1 这而是读一个字符，然后再写一个字符，效率不高
public static void main(String[] args) throws Exception {
    String path1 = &quot;c:/a.txt&quot;;
    String path2 = &quot;c:/b.txt&quot;;

    copyFile(path1, path2);
}

//使用字符流拷贝文件
public static void copyFile(String path1, String path2) throws Exception {
    Reader reader = new FileReader(path1);
    Writer writer = new FileWriter(path2);

    int ch = -1;
    while ((ch = reader.read()) != -1) {
        writer.write(ch);
    }
    //关闭字符流
    reader.close();
    writer.close();
}

//字符流拷贝文件 方式2
public static void main(String[] args){
    String path1 = &quot;c:\\a.txt&quot;;
    String path2 = &quot;c:\\b.txt&quot;;
    copyFile(path1,path2);
}

//拷贝文件
public static void copyFile3(String path1,String path2){
    Reader reader = new FileReader(path1);
    Writer writer = new FileWriter(path2);

    int ch = -1;
    char [] arr = new char[1024];
    while((ch = reader.read(arr)) != -1){
        writer.write(arr,0,ch);
    }
    reader.close();
    writer.close();
}
</code></pre><blockquote>
<p>提示：字符流不可以拷贝视频以及音频等文件，是因为计算机中所有的信息都是以二进制形式进行存储的，在读取文件的时候，字符流自动对这些二进制按照码表进行编码处理，但图片本身就是二进制文件，不需要编码。字符流只能拷贝以字符为单位的文本文件（以ASCII码为例是127个，并不是所有的二进制都可以找到对应的ASCII，有些对不上的，就会丢失信息。）</p>
</blockquote>
<p><strong>3.字符流的异常处理</strong><br></p>
<pre><code>public static void main(String[] args) throws Exception {
    //首先创建两个File路径文件
    String path1 = &quot;c:/a.txt&quot;;
    String path2 = &quot;c:/b.txt&quot;;
    //调用拷贝文件函数
    copyFile2(path1, path2);
}

    //使用字符流拷贝文件，有完善的异常处理
    public static void copyFile2(String path1, String path2) {
        Reader reader = null;
        Writer writer = null;
        try {
            // 打开流
            reader = new FileReader(path1);//Java文件读取对应路径下的文件
            writer = new FileWriter(path2);//Java文件中写入到对应的路径文件中

            // 进行拷贝
            int ch = -1;
            while ((ch = reader.read()) != -1) {
                writer.write(ch);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            // 关闭流，注意一定要能执行到close()方法，所以都要放到finally代码块中
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                try {
                    if (writer != null) {
                        writer.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
</code></pre><p><strong>4.字符流的缓冲区</strong><br></p>
<pre><code>public class IOTest_BufferedReader {
    public static void main(String[] args) throws IOException {
        readFile(&quot;c:\\a.txt&quot;);
    }

    private static void readFile(String path) throws IOException {
        Reader reader = new FileReader(path);
        BufferedReader br = new BufferedReader(read);
        String line = null;
        while((line = br.readLine()) != null){
            System.out.println(line);
        }
    }
}
</code></pre><blockquote>
<p>注意：在使用缓冲区对象时，我们应该明确缓冲的存在只是为了增强流的功能而存在，所以在建立缓冲区对象时，要先有流对象的存在。缓冲区的出现提高了对流的操作效率。其实就是将数组进行封装。</p>
</blockquote>
<pre><code>//使用字符流缓冲区拷贝文本文件
public class Demo {
    public static void main(String[] args) throws IOException {
        //1.关联源文件
        File srcFile = new File(&quot;c:\\a.txt&quot;);
        //2.关联目标文件
        File destFile = new File(&quot;d:\\b.txt&quot;);
        //3.实现拷贝
        copyFile(srcFile,destFile);
    }
    private static void copyFile(File srcFile,File destFile) throws IOException {
        //1.创建字符输入流
        FileReader fr = new FileReader(srcFile);
        //2.创建字符输出流
        FileWriter fw = new FileWriter(destFile);

        //3.字符输入流的缓冲流
        BufferedReader br = new BufferedReader(fr);
        //4.字符输出流的缓冲流
        BufferedWriter bw = new BufferedWriter(fw);

        String line = null;
        //一次读取一行
        while((line = br.readLine()) != null) {
            //一次读一行
            bw.write(line);
            //刷新缓冲
            bw.flush();
            //进行换行，由于readLine()方法默认没有换行，需要手动换行
            bw.newLine();
        }
        //关闭流
        br.close();
        bw.close();
    }
}
</code></pre><hr>
<h4 id="4-装饰者模式"><a href="#4-装饰者模式" class="headerlink" title="4.装饰者模式"></a>4.装饰者模式</h4><p>案例1：在读取的文件的每一行添加行号</p>
<pre><code>public class IoTest7_BufferedReader {
    public static void main(String[] args) throws IOException {
        readFile(&quot;c:\\a.txt&quot;);
    }

    private static void readFile(String path) throws IOException {
        Reader read = new FileReader(path);

        BufferedReader br = new BufferedReader(read);
        int count = 0;
        String line = null;
        while ((line = br.readLine()) != null) {
            count++;
            System.out.println(count+&quot;:&quot;+line);        
        }

    }
}
</code></pre><p>案例2：每次使用BufferedReader输出时都需要显示行号</p>
<pre><code>public class IoTest_BufferedReader {
    public static void main(String[] args) throws IOException {
        readFile(&quot;c:\\a.txt&quot;);
    }
    private static void readFile(String path) throws IOException {
        Reader read = new FileReader(path);
        BufferedReader br = new MyBufferedReader(read);
        String line = null;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    }
}
class MyBufferedReader extends BufferedReader {
    public MyBufferedReader(Reader read) {
        super(read);
    }
    int count;
    @Override
    public String readLine() throws IOException {
        String line = super.readLine();
        if (line != null) {
            count++;
            return count + &quot;:&quot; + line;
        } else {
            return null;
        }
    }
}
</code></pre><p>案例3：在输出的一行前加上引号，可以再定义一个BufferedReader的子类，继承BufferedReader增强功能。</p>
<pre><code>public class IOTest_BufferedReader {
    public static void main(String[] args) throws IOException {
        readFile(&quot;c:\\a.txt&quot;);
    }
    private static void readFile(String path) throws IOException {
        Reader reader = new FileReader(path);
        BufferedReader br = new MyQutoBufferedReader(read);
        int count = 0;
        String line = null;
        while((line = br.readLine()) != null) {
            System.out.println(line);
            count++;
        }
    }
}

//quotation 引号
class MyQutoBufferedReader extends BufferedReader {
    public MyQutoBufferedReader(Reader reader){
        super(reader);
    }
    public String readLine() throws IOException {
        String line = super.readLine();
        if(line != null){
            return &quot;\&quot;+line+&quot;\&quot;;
        }else{
            return null;
        }
    }
}
</code></pre><p>案例4：既要显示行号，也要显示引号</p>
<pre><code>public class IoTest_BufferedReader {
    public static void main(String[] args) throws IOException {
        readFile(&quot;c:\\a.txt&quot;);
    }
    private static void readFile(String path) throws IOException {
        Reader read = new FileReader(path);
        BufferedReader bufferedReader = new BufferedReader(read);
        BufferedReader br = new MyQutoBufferedReader2(bufferedReader);
        br = new MyLineBufferedReader2(br);
        String line = null;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    }
}
// quotation 引号
class MyQutoBufferedReader2 extends BufferedReader {
    private BufferedReader bufferedReader;
    public MyQutoBufferedReader2(BufferedReader bufferedReader) {
        super(bufferedReader);
        this.bufferedReader = bufferedReader;
    }
    public String readLine() throws IOException {
        String line = super.readLine();
        if (line != null) {
            return &quot;\&quot;&quot; + line + &quot;\&quot;&quot;;
        } else {
            return null;
        }
    }
}
class MyLineBufferedReader2 extends BufferedReader {
    private BufferedReader bufferedReader;
    public MyLineBufferedReader2(BufferedReader bufferedReader) {
        super(bufferedReader);
        this.bufferedReader = bufferedReader;
    }
    int count;
    @Override
    public String readLine() throws IOException {
        String line = super.readLine();
        if (line != null) {
            count++;
            return count + &quot;:&quot; + line;
        } else {
            return null;
        }
    }
}
</code></pre><blockquote>
<p>装饰者模式：1.使用分层对象来动态透明的向单个对象中添加功能。2.装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。3.某些对象是可装饰的，可以通过将其它类包装在这个可装饰对象的周围，来将功能分层。4.装饰器必须具有和它装饰的对象相同的接口。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>西电体检信息管理系统 - 接口文档</title>
    <url>/undefined/%E8%A5%BF%E7%94%B5%E4%BD%93%E6%A3%80%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%20-%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="西电体检信息管理系统-接口文档"><a href="#西电体检信息管理系统-接口文档" class="headerlink" title="西电体检信息管理系统  - 接口文档"></a>西电体检信息管理系统  - 接口文档</h2><p>[TOC]</p>
<h4 id="1-接口功能"><a href="#1-接口功能" class="headerlink" title="1.接口功能"></a>1.接口功能</h4><blockquote>
<p>此接口实现的是用户根据用户名、学号、身份证号查询用户的体检信息，如果用户输入的信息在体检信息库里面不存在，返回false。否则返回用户的具体体检信息。</p>
</blockquote>
<h4 id="2-接口链接-URL"><a href="#2-接口链接-URL" class="headerlink" title="2.接口链接(URL)"></a>2.接口链接(URL)</h4><blockquote>
<p><a href="http://bodycheckinfo/demand/result/" target="_blank" rel="noopener">http://bodycheckinfo/demand/result/</a></p>
</blockquote>
<h4 id="3-支持格式"><a href="#3-支持格式" class="headerlink" title="3.支持格式"></a>3.支持格式</h4><blockquote>
<p>JSON</p>
</blockquote>
<h4 id="4-HTTP请求方式"><a href="#4-HTTP请求方式" class="headerlink" title="4.HTTP请求方式"></a>4.HTTP请求方式</h4><blockquote>
<p>POST<br><a id="more"></a></p>
</blockquote>
<h4 id="5-请求参数"><a href="#5-请求参数" class="headerlink" title="5.请求参数"></a>5.请求参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>是否必选</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>idNum</td>
<td>true</td>
<td>String</td>
<td>用户身份证号</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>true</td>
<td>String</td>
<td>用户姓名</td>
<td></td>
</tr>
<tr>
<td>studentNum</td>
<td>true</td>
<td>String</td>
<td>用户学号</td>
<td></td>
</tr>
<tr>
<td>attachedWord</td>
<td>false</td>
<td>String</td>
<td>自动生成的秘钥</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="6-返回参数"><a href="#6-返回参数" class="headerlink" title="6.返回参数"></a>6.返回参数</h4><p>对当前接口返回参数的说明，即{“ret”:返回状态码,”data”:”返回的业务数据”,”msg”:”错误提示”}中的data部分进行说明。<br>在本地输入链接：<code>http://localhost:8000/bodycheckinfo/d/record?attachedWord=ec8(!37@fd865{s(f$-*2ADV.&amp;studentNum=18021211086</code>得到如下JSON数据结果返回。</p>
<pre><code>{
    &quot;ret&quot;: 200,
    &quot;data&quot;:{
    &quot;bodyCheck&quot;:&quot;正常&quot;,
    &quot;checkTime&quot;:1535558400000,
    &quot;hemorrhagic1&quot;:&quot;未注射&quot;,
    &quot;hemorrhagic2&quot;:&quot;未注射&quot;,
    &quot;hemorrhagic3&quot;:&quot;未注射&quot;,
    &quot;hepatitisA1&quot;:&quot;未注射&quot;,
    &quot;hepatitisA2&quot;:&quot;未注射&quot;,
    &quot;hepatitisB1&quot;:&quot;未注射&quot;,
    &quot;hepatitisB2&quot;:&quot;未注射&quot;,
    &quot;hepatitisB3&quot;:&quot;未注射&quot;,
    &quot;hepatitisBCheck&quot;:&quot;未检查&quot;,
    &quot;idNum&quot;:&quot;522224199410221612&quot;,
    &quot;kidney&quot;:&quot;未检查&quot;,
    &quot;listSubmit&quot;:0,
    &quot;listSubmitStr&quot;:&quot;未提交&quot;,
    &quot;liverFunction&quot;:&quot;正常&quot;,
    &quot;measles&quot;:&quot;未注射&quot;,
    &quot;name&quot;:&quot;张大大&quot;,
    &quot;ppdCheck&quot;:&quot;正常&quot;,
    &quot;sex&quot;:&quot;男&quot;,
    &quot;studentId&quot;:21018,
    &quot;studentNum&quot;:&quot;15289561248256&quot;
    },
    &quot;msg&quot;: &quot;&quot;
}
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bodyCheck</td>
<td>String</td>
<td>体检结果</td>
</tr>
<tr>
<td>checkTime</td>
<td>String</td>
<td>体检时间(时间戳)</td>
</tr>
<tr>
<td>hemorrhagic1</td>
<td>String</td>
<td>出血热第一针</td>
</tr>
<tr>
<td>hepatitisA1</td>
<td>String</td>
<td>甲肝疫苗第一针</td>
</tr>
<tr>
<td>hepatitisB1</td>
<td>String</td>
<td>乙肝疫苗第一针</td>
</tr>
<tr>
<td>hepatitisBCheck</td>
<td>String</td>
<td>乙肝</td>
</tr>
<tr>
<td>idNum</td>
<td>String</td>
<td>身份证号</td>
</tr>
<tr>
<td>kidney</td>
<td>String</td>
<td>肾功能检查</td>
</tr>
<tr>
<td>listSubmit</td>
<td>Integer</td>
<td>体检表是否提交</td>
</tr>
<tr>
<td>liverFunction</td>
<td>String</td>
<td>肝功能检查</td>
</tr>
<tr>
<td>measles</td>
<td>String</td>
<td>荨麻疹</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>姓名</td>
</tr>
<tr>
<td>ppdCheck</td>
<td>String</td>
<td>ppd检查</td>
</tr>
<tr>
<td>sex</td>
<td>String</td>
<td>性别</td>
</tr>
<tr>
<td>studentId</td>
<td>String</td>
<td>学生id</td>
</tr>
<tr>
<td>studentNum</td>
<td>String</td>
<td>学号</td>
</tr>
</tbody>
</table>
<h4 id="7-接口实例"><a href="#7-接口实例" class="headerlink" title="7.接口实例"></a>7.接口实例</h4><p>在浏览器输入链接：<code>http://localhost:8000/bodycheckinfo/d/record?attachedWord=ec8(!37@fd865{s(f$-*2ADV.&amp;studentNum=18021211086&amp;name=%E8%83%A1%E9%82%A6%E9%87%91</code>得到返回值。</p>
<pre><code>{
    &quot;data&quot;:{
                &quot;bodyCheck&quot;:&quot;正常&quot;,
                &quot;checkTime&quot;:1535558400000,
                &quot;hemorrhagic1&quot;:&quot;未注射&quot;,
                &quot;hemorrhagic2&quot;:&quot;未注射&quot;,
                &quot;hemorrhagic3&quot;:&quot;未注射&quot;,
                &quot;hepatitisA1&quot;:&quot;未注射&quot;,
                &quot;hepatitisA2&quot;:&quot;未注射&quot;,
                &quot;hepatitisB1&quot;:&quot;未注射&quot;,
                &quot;hepatitisB2&quot;:&quot;未注射&quot;,
                &quot;hepatitisB3&quot;:&quot;未注射&quot;,
                &quot;hepatitisBCheck&quot;:&quot;未检查&quot;,
                &quot;idNum&quot;:&quot;78256985465877425422454&quot;,
                &quot;kidney&quot;:&quot;未检查&quot;,
                &quot;listSubmit&quot;:0,
                &quot;listSubmitStr&quot;:&quot;未提交&quot;,
                &quot;liverFunction&quot;:&quot;正常&quot;,
                &quot;measles&quot;:&quot;未注射&quot;,
                &quot;name&quot;:&quot;张大大&quot;,
                &quot;ppdCheck&quot;:&quot;正常&quot;,
                &quot;sex&quot;:&quot;男&quot;,
                &quot;studentId&quot;:21018,
                &quot;studentNum&quot;:&quot;1234567891025&quot;
            },
        &quot;info&quot;:&quot;success&quot;
}
</code></pre>]]></content>
      <categories>
        <category>西电体检信息管理系统</category>
      </categories>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 浏览器开发者程序</title>
    <url>/undefined/Chrome%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%A1%E6%9F%A5%E5%85%83%E7%B4%A0(F12)%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Chrome开发者工具功能模块"><a href="#Chrome开发者工具功能模块" class="headerlink" title="Chrome开发者工具功能模块"></a>Chrome开发者工具功能模块</h2><h4 id="1-Elements"><a href="#1-Elements" class="headerlink" title="1.Elements"></a>1.Elements</h4><p>主要用来查看前端界面的html的Dom结构，和修改css的样式。查看或修改HTML元素的属性、CSS属性、监听事件、断点等。</p>
<h4 id="2-console"><a href="#2-console" class="headerlink" title="2.console"></a>2.console</h4><p>这个除了查看错误信息、打印调试信息(console.log())、写一些测试脚本以外，还可以当作Javascript API查看用。用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。例如我想查看console都有哪些方法和属性，我可以直接在Console中输入”console”并执行。<br><a id="more"></a></p>
<h4 id="3-Sources"><a href="#3-Sources" class="headerlink" title="3.Sources"></a>3.Sources</h4><p>该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。</p>
<h4 id="4-Network"><a href="#4-Network" class="headerlink" title="4.Network"></a>4.Network</h4><p>网络页面主要用于查看header等与网络连接相关的信息。</p>
<h4 id="5-技巧总结"><a href="#5-技巧总结" class="headerlink" title="5.技巧总结"></a>5.技巧总结</h4><pre><code>1.直接修改页面元素
  在elements面板双击进行修改，或者右击edit html进行修改。

2.颜色取色器
  在elements面板中的Styles窗口中有一个color小方块(如果没有可以自己加上color:red等)，然后会弹出颜色拾取器，我们可以在上面颜色画板中选择一个颜色，或者选择笔拾取一个颜色。

3.快速查找并定位文件
  Ctrl+p

4.编辑源码
  1.Console 下面输入框输入，回车直接执行，多行代码在别的编辑器编辑好之后复制进来执行。
  2.Sources 下面，点击左上角第二行Sources旁边的“&gt;&gt;”打开Snippets，点击“+ New Snippet”新建一个文件编辑脚本，写完右键“Save”保存，再右键点击这个文件“Run”运行。

  注意：如果是要覆盖页面JS程序，如果是函数，则是直接以相同的函数名重写方法即可。如果是要覆盖页面JS代码的按钮事件，则需要重新注册该事件，否则相同的多个事件会全部响应。

5.只分析异步请求资源
  Network 下面点击XHR，这样就只会显示XHR异步请求资源，以便于快速分析请求Header和Response。

6.在源码中快速调到指定行
  在Sources标签中打开一个文件之后，按Ctrl + G然后输入行号，chrome控制台就会跳转到你输入的行号所在的行。

7.使用多个插入符进行选择
  当编辑一个文件的时候，你可以按住Ctrl在你要编辑的地方点击鼠标，可以设置多个插入符，这样可以一次在多个地方编辑。
</code></pre>]]></content>
      <categories>
        <category>开发者工具</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-学习笔记</title>
    <url>/undefined/Java-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Java开发前奏"><a href="#Java开发前奏" class="headerlink" title="Java开发前奏"></a>Java开发前奏</h2><h3 id="1-计算机基础"><a href="#1-计算机基础" class="headerlink" title="1.计算机基础"></a>1.计算机基础<br></h3><h4 id="1-1-计算机"><a href="#1-1-计算机" class="headerlink" title="1.1.计算机"></a>1.1.计算机</h4><p>电子计算机，俗称电脑，是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。</p>
<h3 id="1-2-硬件和软件"><a href="#1-2-硬件和软件" class="headerlink" title="1.2.硬件和软件"></a>1.2.硬件和软件</h3><h4 id="1-2-1-硬件"><a href="#1-2-1-硬件" class="headerlink" title="1.2.1.硬件"></a>1.2.1.硬件</h4><pre><code>1.CPU是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成。作为整个系统的核心，CPU 也是整个系统最高的执行单元，因此CPU已成为决定电脑性能的核心部件，很多用户都以它为标准来判断电脑的档次。CPU的主频,即CPU内核工作的时钟频率（CPU Clock Speed）。该时钟速度越快，时间段内执行的指令就越多， 目前酷睿是2G-3G（1G是10000Mhz）例如，2MHz（200万次/秒），3GHz（三十亿次/秒）。
</code></pre><a id="more"></a>
<pre><code>2.内存是数据与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。

3.    存储设备：内存不能长久保存数据（非ROM），断电时信息就丢失，程序和数据都会被保存在存储设备中（例如硬盘），当程序和数据需要使用时，再加载进内存，注意：内存读取和写入的速度要比存储设备快的多。

    存储设备主要有：磁盘驱动器，光盘驱动器（cd dvd）USB闪存（U盘）。
</code></pre><h4 id="1-2-2-软件"><a href="#1-2-2-软件" class="headerlink" title="1.2.2.软件"></a>1.2.2.软件</h4><pre><code>软件的概述：按照一定顺序组织的计算机数据与指令的集合。
软件 = 数据+指令+文档

1.系统软件
    例如：Widows xp  Linux Unix 

2.应用软件
    例如：QQ、WPS、Photoshop、、微软的Office
软件开发：制作软件。
软件的本质 ：提高人与计算机交流效率，方便人与机器交互。
</code></pre><h3 id="1-3-人机交互的方式："><a href="#1-3-人机交互的方式：" class="headerlink" title="1.3.人机交互的方式："></a>1.3.人机交互的方式：</h3><pre><code>1.图形化界面：简单直观，容易操作，用户的体验好。
2.dos命令交互方式：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令,而且只能完成一些比较单一的功能。
    控制台打开的步骤：开始--所有程序---附件--命令行提示符
    或者开始-输入cmd即可。
</code></pre><h3 id="1-4-常见的dos命令"><a href="#1-4-常见的dos命令" class="headerlink" title="1.4.常见的dos命令"></a>1.4.常见的dos命令</h3><pre><code>盘符：进入指定的盘符下。
dir: 列出当前目录下的文件以及文件夹
md : 创建目录 
rd : 删除目录    注意：rd不能删除非空的文件夹，而且只能用于删除文件夹。
cd : 进入指定目录
cd.. : 退回到上一级目录
cd \ : 退回到根目录
echo &quot;hello java&quot;&gt;a.txt  写入文本到指定文件  
type a.txt 显示文件内容命令
del : 删除文件    注意：不能删除文件夹，只能删除文件。
exit : 推出dos命令行
cls  : 通知计算机将当前的命令清空
*:  是通配符。
方向键上下是找回上次你写过的命令。
</code></pre><h3 id="1-5-Java虚拟机（JVM）"><a href="#1-5-Java虚拟机（JVM）" class="headerlink" title="1.5 Java虚拟机（JVM）"></a>1.5 Java虚拟机（JVM）</h3><pre><code>Java Virtual Machine 一个软件模拟的计算机。Java源程序想象成我们的C源程序，Java源程序编译后生成的字节码（.class）就相当于C源程序编译后的二进制可执行文件。JVM虚拟机相当于计算机系统（操作系统+硬件环境），Java解释器相当于CPU。

.exe文件直接在windows操作系统下运行，在CPU上运行的是机器码（.exe文件）
.class字节码文件是运行在JVM虚拟机下的，在Java解释器上运行的是Java字节码。
Java解释器相当于运行Java字节码的“CPU”，但该“CPU”不是通过硬件实现的，而是用软件实现的。Java解释器实际上就是特定的平台下的一个应用程序。只要实现了特定平台下的解释器程序，Java字节码就能通过解释器程序在该平台下运行，这是Java跨平台的根本。当前，并不是在所有的平台 下都有相应Java解释器程序，这也是Java并不能在所有的平台下都能运行的原因，它只能在已实现了Java解释器程序的平台下运行。
</code></pre><hr>
<h2 id="Java-变量与关键字"><a href="#Java-变量与关键字" class="headerlink" title="Java 变量与关键字"></a>Java 变量与关键字</h2><pre><code>文档注释：
    1.需要使用sum给我们提供的javadoc工具生成一个html的说明文档。
    2.只能抽取public的属性或者方法内容。
    格式：javadoc –d 指定存储文档的路径 -version –author（可选） 目标文件

    @author 作者
    @version 版本
    @param 方法的参数
    @return 返回值
</code></pre><hr>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><hr>
<h2 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h2><pre><code>1.数组

注意：给数组分配空间时，必须指定数组能够存储的元素个数来确定数组大小。创建数组之后不能修改数组的大小，我们可以使用length属性获取数组的大小。

数组常见的异常：1.数组角标越界异常。2.空指针异常。

数组的内存分析：
    栈内存特点：存储的局部变量。处理方式：变量使用完离开自己的空间就马上释放。
    堆内存特点：存储的数组和对象，凡是new关键字创建的实体都是保存在堆内存里面的。1.每一个对象都有一个内存首地址。2.对象都有默认的初始值。

2.二维数组

    前提：
        toString()方法：将数组的元素以字符串的形式返回
        sort()方法：将数组按照升序排序
        binarySearch()：在指定数组中查找指定元素，返回元素的索引。如果没有找到，返回(-插入点-1) 注意：使用查找功能的时候，数组一定要先排序。
</code></pre><hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>1.匿名对象：表示没有名字的实体，即该实体没有对应的变量名进行引用。</p>
<pre><code>用途：对象对方法进行一次调用的时候，可以使用匿名对象对代码进行简化。同时匿名对象可以对实际参数进行传递。

使用：当只使用一次的时候可以使用匿名对象，执行完毕之后，对象就变成了垃圾。执行方法时，可以将匿名对象作为实际参数传递进去。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.匿名对象设置的属性永远无法获取，因为没有引用变量指向那个对象。
2.任何两个匿名对象使用==比较，永远返回false。
3.匿名对象主要用于实参。
</code></pre><p>2.构造方法</p>
<pre><code>作用：对对象进行初始化。
</code></pre><p>3.this关键字</p>
<pre><code>this关键字表示对对象的引用，表示this在指向一个对象时，所指向的对象就是调用该函数的对象引用。
this关键字表示所在函数所属对象的引用。
</code></pre><h2 id="字符串和文本I-O"><a href="#字符串和文本I-O" class="headerlink" title="字符串和文本I/O"></a>字符串和文本I/O</h2><pre><code>1.字符串的比较
    警告：如果使用像&gt; &gt;= &lt; &lt;=这样的比较运算符比较两个字符串，就会发生语法错误。替代的方法是：s1.compareTo(s2)来进行比较。

    注意：如果两个字符串相等，equals方法返回true；如果它们不等，方法返回false。compareTo()方法会根据一个字符串是否等于、大于或小于另一个字符串而返回0、正整数或负整数。

    警告：length()方法是String的一个方法，但它是数组对象的一个属性，所以要获取字符串s中的字符个数，必须使用 s.length() 而要获取数组a中的元素个数，必须使用s.length

2.文件类File
    File类特意提供了一种抽象，这种抽象表示以不依赖机器的方式处理很多文件和路径名依赖机器的复杂问题。

    注意：在windows中目录的分隔符是(\)，但是在Java中，反斜杠是一个特殊的字符，需要转义写成(\\)。

    注意：构建一个File实例并不会在机器上创建一个文件。不管文件是否存在，都可以创建任意文件名的File实例。我们可以调用File实例上的exists()方法判断文件是否存在。

3.文件的输入输出

    File对象封装了文件或路径的属性，但是这一File对象不包括创建文件以及向/从文件读/写数据的方法。为了完成I/O操作，我们需要使用恰当的Java I/O类创建对象。

        1.PrintWriter 写数据
            该类可以用来创建一个文件，并向文本文件中写入数据。
            注意：如果文件不存在，那么会调用PrintWriter的构造方法创建一个新的文件。如果文件已经存在，那么文件当前内容会被抛弃。

        2.使用Scanner读取数据
            java.util.Scanner类用来从控制台读取字符串和基本类型数值。为了能够从键盘读取，需要为System.in创建一个Scanner。
            注意：new Scanner(String) 为给定的字符串创建一个Scanner。为创建Scanner从文件中读取数据，需要使用构造方法 new File(filename) 利用 java.io.File 类创建File类的一个实例。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.字符串是封装在String类中的对象，要创建一个字符串，可以使用11种构造方法之一，也可以使用字符串直接量进行简洁初始化。
2.String 对象是不可变的，它的内容不能改变。
3.可以调用字符串的length()方法获取它的长度，使用charAt(index)方法从字符串中提取特定下标位置的字符，使用indexOf()方法和lastIndexOf()方法找出一个字符串中的某个字符或者某个子串。

4.substring()方法从字符串中提取子串

5.
</code></pre><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><pre><code>注意：使用语法 new int[5][]创建数组时，必须指定第一个下标。语法：new int[][]是错误的。
</code></pre><h2 id="异常处理-更多知识"><a href="#异常处理-更多知识" class="headerlink" title="异常处理 更多知识"></a>异常处理 更多知识</h2><pre><code>1.声明异常：
    注意：如果方法没有在父类中声明异常，那么就不能在子类中对其进行覆盖来声明异常。

2.抛出异常：
    注意：通常JAVA API 中的每个异常类至少有两个构造方法：1.无参构造方法。 2.一个带可描述此异常的String参数的构造方法。(该参数称为异常消息，可以使用getMessage()获取)

    注意：声明异常的关键字：throws 抛出异常的关键字：throw。

3.捕获异常

    注意：
        1.从一个通用父类可以派生出各种异常类，如果一个catch块可以捕获一个父类的异常对象，那么它就能够父类的所有子类的异常对象。

        2.在catch块中异常被指定的顺序非常重要，如果父类的catch块出现在子类的catch块之前，就会导致编译错误。

        3.Java强迫程序员必须处理必检异常，如果方法中声明了一个必须检验的异常(error或runtimeException)，就必须在try-catch块中调用它，或者在调用方法中声明要抛出异常。

4.使用异常的时机

    注意：异常处理过程中通常需要更多的时间和资源。

    1.异常出现在方法中，如果想让该方法的调用者处理异常，应该创建一个异常对象并将其抛出。如果能在发生异常的方法中处理异常，那么就不需要抛出异常或使用异常。

    注意：不要将异常处理用作简单的逻辑测试。而在哪种情况下使用异常需要我们自己判断。

5.重新抛出异常

    前提：如果异常处理器没有处理某个异常，或者处理器只是希望其调用者注意该异常，Java就允许处理器重新抛出异常。在try-catch块中最后使用throw关键字。这样就方便其他的调用者获得处理抛出异常的机会。

6.链式异常


7.自定义异常

    注意：因为Java提供了很多的异常类，所以在不是特殊的情况下尽量避免使用自定义异常类。

    通过派生Exception类或其子类(如:IOException)来创建自定义异常类。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.异常处理能够使得一个方法给它的调用者抛出一个异常。
2.异常发生在一个方法的执行过程中，RuntimeException/Error都是免检异常，其他所有的异常都是必须检验的异常。
3.当声明一个方法时，如果这个方法抛出一个必须检验的异常，则必须声明为必须检验异常，告诉编译器可能会出现什么错误。
4.声明异常的关键字：throws，抛出异常的关键字：throw

5.异常处理是将处理代码从正常的程序中分离出来，这样的话，程序更容易处理和理解。
6.我们不应该使用异常处理代替简单的测试，应该尽可能的测试简单异常，将异常处理保留为处理那些无法使用if语句处理的异常。
</code></pre><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><pre><code>1.抽象类

注意：抽象类和常规类很像，但是不能使用new关键字创建其实例。抽象方法只有定义没有实现，它的实现由子类提供，一个包含抽象方法的类必须声明为抽象类。

    抽象类的构造方法定义为protected，其只能被子类使用。

    注意：

        1.抽象方法不能定义在非抽象类中，如果抽象父类的子类不能实现所有的抽象方法，那么子类必须定义为抽象，同时注意抽象方法是 非静态 的。

        2.抽象类不能使用new关键字来初始化，但可以定义其构造方法，这个构造方法在它的子类的构造方法中可以被调用。

        3.包含抽象对象的类必须是抽象的，但可以定义一个不包含抽象方法的抽象类。此时不能使用new操作符创建该类的实例。

        4.如果一个类是具体的，但是其子类可以是抽象的。

2.接口

    注意：由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以Java允许忽略这些修饰符。

    提示：接口中定义的常量可以使用语法：接口名.常量名(如：T.k)来访问。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.抽象类和常规类一样，都有数据和方法，但是不能使用new操作符创建抽象类的实例。
2.非抽象类中不能包含抽象方法。如果抽象类的子类没有实现所有被继承的父类抽象方法，就必须将子类也定义为抽象类。
3.包含抽象方法的类必须是抽象类，但抽象类可以不包含抽象方法。

4.接口中只包含常量和抽象方法，接口与抽象类很类似，但是抽象类除了包含常量和抽象方法之外，还包含变量和具体方法。

5.接口java.lang.Comparable定义了compareTo()方法，Java类库中许多类都实现了Comparable。

6.
</code></pre><h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><pre><code>Java中处理输入输出，File对象封装文件或路径属性，不包含从/向文件读/写数据的方法。为了进行I/O操作，需要使用正确的Java I/O类创建对象。
</code></pre><blockquote>
<p>总结：I/O类可以分为文本I/O和二进制I/O，文本I/O将数据解释成字符序列，二进制I/O将数据解释成原始的二进制数值。Java自动完成对文本I/O的编码和解码。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript-学习笔记</title>
    <url>/undefined/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-js简介"><a href="#1-js简介" class="headerlink" title="1.js简介"></a>1.js简介</h2><pre><code>1、js是什么
2、js作用
3、组成
4、引入方式
</code></pre><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h2><pre><code>1、变量
2、原始数据类型
3、引入数据类型
4、运算符
5、逻辑语句
</code></pre><h2 id="3-内建对象"><a href="#3-内建对象" class="headerlink" title="3.内建对象"></a>3.内建对象</h2><pre><code>(1)Number
    创建方式：
        var myNum=new Number(value);
        var myNum=Number(value);
    属性和方法：
        toString():转成字符串
        valueOf()：返回一个 Number 对象的基本数字值
</code></pre><a id="more"></a>
<pre><code>(2)Boolean
    创建方式：
        var bool = new Boolean(value);    
        var bool = Boolean(value);
    属性和方法：
        toString():转成字符串
        valueOf()：返回一个 Boolean 对象的基本值(boolean)

(3)String
    创建方式：
        var str = new String(s);
        var str = String(s);
    属性和方法：
        length:字符串的长度
        charAt():返回索引字符
        charCodeAt:返回索引字符unicode
        indexOf():返回字符的索引
        lastIndexOf();逆向返回字符的索引
        split();将字符串按照特殊字符切割成数组
        substr():从起始索引号提取字符串中指定数目的字符
        substring():提取字符串中两个指定的索引号之间的字符
        toUpperCase();转大写
    示例：

(4)Array
    创建方式：
        var arr = new Array();//空数组
        var arr = new Array(size);//创建一个指定长度的数据
        var arr = new Array(element0, element1, ..., elementn);//创建数组直接实例化元素
        var arr = [];//空数组
        var arr = [1,2,5,&quot;java&quot;];//创建数组直接实例化元素
    属性和方法：
        length:数组长度
        join()：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔一个
        pop():删除并返回最后元素
        push()：向数组的末尾添加一个或更多元素，并返回新的长度
        reverse();反转数组
        sort();排序

(5)Date
    创建方式：    
        var myDate = new Date();
        var myDate = new Date(毫秒值);//代表从1970-1-1到现在的一个毫秒值
    属性和方法
        getFullYear():年
        getMonth():月 0-11
        getDate():日 1-31
        getDay()：星期 0-6
        getTime():返回1970年1月1日午夜到指定日期（字符串）的毫秒数
        toLocalString();获得本地时间格式的字符串

(6)Math
    创建方式：    
        Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，
        不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。
    属性和方法
        PI：圆周率
        abs():绝对值
        ceil():对数进行上舍入
        floor():对数进行下舍入
        pow(x,y)：返回 x 的 y 次幂
        random():0-1之间的随机数
        round():四舍五入

(7)RegExp
    创建方式：    
        var reg = new RegExp(pattern);
        var reg = /^正则规则$/;
    规则的写法：
        [0-9] 
        [A-Z]
        [a-z]
        [A-z]
        \d 代表数据
        \D    非数字
        \w    查找单词字符
        \W    查找非单词字符
        \s    查找空白字符
        \S    查找非空白字符
        n+    出现至少一次
        n*    出现0次或多次
        n?    出现0次或1次
        {5} 出现5
        {2,8} 2到8次
    方法：    
        test(str):检索字符串中指定的值。返回 true 或 false
    需求：
        校验邮箱：
        var email = haohao_827@163.com
        var reg = /^[A-z]+[A-z0-9_-]*\@[A-z0-9]+\.[A-z]+$/;
        reg.test(email);
</code></pre><h2 id="4-js的函数"><a href="#4-js的函数" class="headerlink" title="4.js的函数"></a>4.js的函数</h2><pre><code>1、js函数定义的方式
    (1)普通方式
        语法：function 函数名(参数列表){函数体}
        示例：
            function method(){
                alert(&quot;xxx&quot;);
            }
            method();
    (2)匿名函数
        语法：function(参数列表){函数体}
        示例：
            var method = function(){
                alert(&quot;yyy&quot;);
            };
            method();
    (3)对象函数
        语法：new Function(参数1,参数2,...,函数体);
        注意：参数名称必须使用字符串形式、最后一个默认是函数体且函数体需要字符串形式
        示例：
            var fn = new Function(&quot;a&quot;,&quot;b&quot;,&quot;alert(a+b)&quot;);
            fn(2,5);
2、函数的参数
    (1)形参没有var去修饰
    (2)形参和实参个数不一定相等
    (3)arguments对象 是个数组 会将传递的实参进行封装
    function fn(a,b,c){
        //var sum = a+b+c;
        //alert(sum);
        //arguments是个数组 会将传递的实参进行封装
        for(var i=0;i&lt;arguments.length;i++){
            alert(arguments[i]);
        }
    }
    fn(1,2,4,8);

3、返回值
    (1)在定义函数的时候不必表明是否具有返回值
    (2)返回值仅仅通过return关键字就可以了 return后的代码不执行
    function fn(a,b){
        return a+b;
        //alert(&quot;xxxx&quot;);
    }
    alert(fn(2,3));

4、js的全局函数
    (1)编码和解码
        encodeURI()   decodeURI()
        encodeURIComponet()      decodeURIComponent()
        escape()    unescape()
        三者区别：
            进行编码的符号范围不同吧，实际开发中常使用第一种
    (2)强制转换
        Number()
        String()
        Boolean()
    (3)转成数字
        parseInt()
        parseFloat()
    (4)eval()方法    
        将字符串当作脚本进行解析运行
        //var str = &quot;var a=2;var b=3;alert(a+b)&quot;;
        //eval(str);
        function print(str){
            eval(str);
        }
        print(&quot;自定义逻辑&quot;);
</code></pre><h2 id="5-js的事件"><a href="#5-js的事件" class="headerlink" title="5.js的事件"></a>5.js的事件</h2><pre><code>事件
事件源
响应行为
1、js的常用事件
    onclick:点击事件
    onchange:域内容被改变的事件
        需求：实现二级联动
        &lt;select id=&quot;city&quot;&gt;
            &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;
            &lt;option value=&quot;tj&quot;&gt;天津&lt;/option&gt;
            &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;
        &lt;/select&gt;
        &lt;select id=&quot;area&quot;&gt;
            &lt;option&gt;海淀&lt;/option&gt;
            &lt;option&gt;朝阳&lt;/option&gt;
            &lt;option&gt;东城&lt;/option&gt;
        &lt;/select&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var select = document.getElementById(&quot;city&quot;);
            select.onchange = function(){
                var optionVal = select.value;
                switch(optionVal){
                    case &apos;bj&apos;:
                        var area = document.getElementById(&quot;area&quot;);
                        area.innerHTML = &quot;&lt;option&gt;海淀&lt;/option&gt;&lt;option&gt;朝阳&lt;/option&gt;&lt;option&gt;东城&lt;/option&gt;&quot;;
                        break;
                    case &apos;tj&apos;:
                        var area = document.getElementById(&quot;area&quot;);
                        area.innerHTML = &quot;&lt;option&gt;南开&lt;/option&gt;&lt;option&gt;西青&lt;/option&gt;&lt;option&gt;河西&lt;/option&gt;&quot;;
                        break;
                    case &apos;sh&apos;:
                        var area = document.getElementById(&quot;area&quot;);
                        area.innerHTML = &quot;&lt;option&gt;浦东&lt;/option&gt;&lt;option&gt;杨浦&lt;/option&gt;&quot;;
                        break;
                    default:
                        alert(&quot;error&quot;);
                }
            };                

        &lt;/script&gt;
    onfoucus:获得焦点的事件
    onblur:失去焦点的事件
        需求：    当输入框获得焦点的时候，提示输入的内容格式
                当输入框失去焦点的时候，提示输入有误
        &lt;label for=&quot;txt&quot;&gt;name&lt;/label&gt;
        &lt;input id=&quot;txt&quot; type=&quot;text&quot; /&gt;&lt;span id=&quot;action&quot;&gt;&lt;/span&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var txt = document.getElementById(&quot;txt&quot;);
            txt.onfocus = function(){
                //友好提示
                var span = document.getElementById(&quot;action&quot;);
                span.innerHTML = &quot;用户名格式最小8位&quot;;
                span.style.color = &quot;green&quot;;
            };
            txt.onblur = function(){
                //错误提示
                var span = document.getElementById(&quot;action&quot;);
                span.innerHTML = &quot;对不起 格式不正确&quot;;
                span.style.color = &quot;red&quot;;
            };
        &lt;/script&gt;

    onmouseover:鼠标悬浮的事件
    onmouseout:鼠标离开的事件
        需求：div元素 鼠标移入变为绿色 移出恢复原色
        #d1{background-color: red;width:200px;height: 200px;}
        &lt;div id=&quot;d1&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var div = document.getElementById(&quot;d1&quot;);
            div.onmouseover = function(){
                this.style.backgroundColor = &quot;green&quot;;
            };
            div.onmouseout = function(){
                this.style.backgroundColor = &quot;red&quot;;
            };
        &lt;/script&gt;


    onload:加载完毕的事件
        等到页面加载完毕在执行onload事件所指向的函数
        &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            window.onload = function(){
                var span = document.getElementById(&quot;span&quot;);
                alert(span);
                span.innerHTML = &quot;hello js&quot;;
            };
        &lt;/script&gt;

2、事件的绑定方式
    (1)将事件和响应行为都内嵌到html标签中
        &lt;input type=&quot;button&quot; value=&quot;button&quot;  onclick=&quot;alert(&apos;xxx&apos;)&quot;/&gt;
    (2)将事件内嵌到html中而响应行为用函数进行封装
        &lt;input type=&quot;button&quot; value=&quot;button&quot; onclick=&quot;fn()&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function fn(){
                alert(&quot;yyy&quot;);
            }
        &lt;/script&gt;
    (3)将事件和响应行为 与html标签完全分离
        &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot;/&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var btn = document.getElementById(&quot;btn&quot;);
            btn.onclick = function(){
                alert(&quot;zzz&quot;);
            };
        &lt;/script&gt;

    ****this关键字
        this经过事件的函数进行传递的是html标签对象
        &lt;input id=&quot;btn&quot; name=&quot;mybtn&quot; type=&quot;button&quot; value=&quot;button123&quot; onclick=&quot;fn(this)&quot;/&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function fn(obj){
                alert(obj.name);
            }
        &lt;/script&gt;

3、阻止事件的默认行为
    IE：window.event.returnValue = false;
    W3c: 传递过来的事件对象.preventDefault();
    //ie：window.event.returnValue = false;
    //W3c：传递过来的事件对象.preventDefault();
    //W3c标准
    if(e&amp;&amp;e.preventDefault){
        alert(&quot;w3c&quot;);
        e.preventDefault();
    //IE标签
    }else{
        alert(&quot;ie&quot;);
        window.event.returnValue = false;
    }


    //通过事件返回false也可以阻止事件的默认行为
    &lt;a href=&quot;demo11.html&quot; onclick=&quot;return false&quot;&gt;点击我吧&lt;/a&gt;

4、阻止事件的传播
    IE：window.event.cancelBubble = true;
    W3c: 传递过来的事件对象.stopPropagation();
    if(e&amp;&amp;e.stopPropagation){
        alert(&quot;w3c&quot;);
        e.stopPropagation();
    //IE标签
    }else{
        alert(&quot;ie&quot;);
        window.event.cancelBubble = true;
    }    
</code></pre><h2 id="6-js的bom"><a href="#6-js的bom" class="headerlink" title="6.js的bom"></a>6.js的bom</h2><pre><code>(1)window对象
    弹框的方法：
        提示框：alert(&quot;提示信息&quot;);
        确认框：confirm(&quot;确认信息&quot;);
            有返回值：如果点击确认返回true  如果点击取消 返回false
            var res = confirm(&quot;您确认要删除吗？&quot;);
            alert(res);
        输入框：prompt(&quot;提示信息&quot;);
            有返回值：如果点击确认返回输入框的文本 点击取消返回null
            var res =  prompt(&quot;请输入密码？&quot;);
            alert(res);
    open方法：
        window.open(&quot;url地址&quot;);            
        open(&quot;../jsCore/demo10.html&quot;);

    定时器：
        setTimeout(函数,毫秒值);
            setTimeout(
                function(){
                    alert(&quot;xx&quot;);
                },
                3000
            );
        clearTimeout(定时器的名称);
            var timer;
            var fn = function(){
                alert(&quot;x&quot;);
                timer = setTimeout(fn,2000);
            };
            var closer = function(){
                clearTimeout(timer);
            };
            fn();
        setInterval(函数,毫秒值);
        clearInterval(定时器的名称)
            var timer = setInterval(
            function(){
                alert(&quot;nihao&quot;);
            },
            2000
        );
        var closer = function(){
            clearInterval(timer);
        };

    需求：注册后5秒钟跳转首页
    恭喜您注册成功，&lt;span id=&quot;second&quot; style=&quot;color: red;&quot;&gt;5&lt;/span&gt;秒后跳转到首页，如果不跳转请&lt;a href=&quot;../jsCore/demo10.html&quot;&gt;点击这里&lt;/a&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var time = 5;
        var timer;
        timer = setInterval(
            function(){
                var second = document.getElementById(&quot;second&quot;);
                if(time&gt;=1){
                    second.innerHTML = time;
                    time--;
                }else{
                    clearInterval(timer);
                    location.href=&quot;../jsCore/demo10.html&quot;;
                }
            },
            1000
        );
    &lt;/script&gt;

(2)location    
    location.href=&quot;url地址&quot;;
(3)history
    back();
    forward();
    go();
    &lt;a href=&quot;demo7.html&quot;&gt;后一页&lt;/a&gt;
    &lt;input type=&quot;button&quot; value=&quot;上一页&quot; onclick=&quot;history.back()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;下一页&quot; onclick=&quot;history.forward()&quot;&gt;

    &lt;input type=&quot;button&quot; value=&quot;上一页&quot; onclick=&quot;history.go(-1)&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;下一页&quot; onclick=&quot;history.go(1)&quot;&gt;
</code></pre><h2 id="7-js的dom"><a href="#7-js的dom" class="headerlink" title="7.js的dom"></a>7.js的dom</h2><pre><code>1、理解一下文档对象模型
    html文件加载到内存之后会形成一颗dom树，根据这些节点对象可以进行脚本代码的动态修改
    在dom树当中 一切皆为节点对象
2、dom方法和属性
    笔记见代码
</code></pre><blockquote>
<p>附录：</p>
</blockquote>
<pre><code>JSDom常用方法：
    1.getElementById()：document对象中获取通过Id值得到的元素值
    2.getElementsByIdName()：document对象中通过元素的name属性获取所有元素的引用
    3.getElementsByTagName()：document对象中获取所有的input元素，返回值是数组    
    4.hasChildNodes()：document对象中返回元素是否还有子节点方法
    5.
</code></pre><h2 id="8-JavaScript-JSON"><a href="#8-JavaScript-JSON" class="headerlink" title="8.JavaScript JSON"></a>8.JavaScript JSON</h2><pre><code>JSON用于存储和传输数据的格式，通常用于服务端向网页传输数据。

注意：JSON使用JavaScript语法，但是JSON格式仅仅只是一个文本，文本可以被任何编程语言读取以及作为数据格式传递。
</code></pre><h2 id="9-扩展"><a href="#9-扩展" class="headerlink" title="9.扩展"></a>9.扩展</h2><pre><code>1.JavaScript forEach()方法
  forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。
  注意：forEach()对于空数组是不会执行回调函数的。
</code></pre>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/undefined/Linux/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="linux-操作系统-笔记"><a href="#linux-操作系统-笔记" class="headerlink" title="linux 操作系统 - 笔记"></a>linux 操作系统 - 笔记</h1><h4 id="1-Linux-操作系统概述"><a href="#1-Linux-操作系统概述" class="headerlink" title="1.Linux 操作系统概述"></a>1.Linux 操作系统概述</h4><pre><code>1.常见操作系统
   - 服务端操作系统 ： linux、unix、windows server 
   - 单机操作系统 ： windows（dos 、ucdos、win95、win98、win2000、xp、vista、win7、win8）
                     MAC 、linux（ubuntu）
   - 移动操作系统 Android、IOS 、Windows phone
</code></pre><a id="more"></a>
<pre><code>2.linux操作系统介绍
  - 为什么要学习linux操作系统 
    1. 大部分服务端都采用linux ，JEE部署到服务器中
    2. 一些企业和学校采用linux研发和教学 

    3. 很多嵌入式开发 用linux  
    4. 云计算、大数据 是集群网  linux : centos 

      - 特点   
        1. 开放、开源、多用户的网络操作系统

        2. 基于unix（unix--&gt;minix--&gt;linux(linus :林纳斯 芬兰 )），可以定制内核

        3. 假如了GNU组织（自由软件组织 ，copyLeft） ，通过GPL（通用公共许可） 许可对外发布  
            - linux组成
                1. linux内核（linus 团队管理）
                2. shell ：用户与内核交互的接口
                3. 文件系统 ： ext3、ext4 等  windows 有 fat32  、ntfs 
                4. 第三方应用软件 

            - linux操作系统版本   
                1. 内核版本 (linus 团队管理)  3.8
                2. 发行版本  :一些软件公司以内核为基础，再添加一些软件和文档形成发行版本
                    - red hat  ： rhel ，centos
                    - debian   ： debian，ubuntu（桌面）
                    - android  
</code></pre><h4 id="2-安装linux系统"><a href="#2-安装linux系统" class="headerlink" title="2.安装linux系统"></a>2.安装linux系统</h4><pre><code>1. vmware安装 ： 创建虚拟机的软件 
   vitual box ：oracle 公司提供

2. 虚拟机安装
   - 直接安装
     - 创建虚拟机
 - 安装ubuntu镜像
   - 打开虚拟机镜像： 虚拟机+操作系统（ubuntu）
     1. 打开*.vmx 文件
     2. 用户名  itcast  密码  123
</code></pre><h4 id="3-linux系统环境"><a href="#3-linux系统环境" class="headerlink" title="3.linux系统环境"></a>3.linux系统环境</h4><pre><code>默认有6个命令交互通道和一个图形界面交互通道，默认进入到的是图形界面通道
  命令交互模式切换：ctrl+alt+f1---f6
  图形交互界面 ctrl+alt+f7

1.图形界面交互模式
  - terminal： 图形界面的命令终端，它是图形界面交互通道的延伸，要依赖于图形界面
</code></pre><blockquote>
<p>扩展<br><br>Linux的目录结构：<br>1.bin：存放的可执行的二进制文件(cd ls su passwd)<br> 2. boot：存放系统的引导文件的目录<br> 3.dev 存放设备文件的目录，linux把设置当做文件来处理<br> 4.etc：存放系统的配置文件的目录<br> 5.home：存放所有用户文件的根目录，root用户除外<br> 6.lib：共享库<br> 7.usr：好比 program files 存放应用的安装的路径<br><br>8.opt：自定义存放应用程序位置<br> 9.mnt：临时文件系统的挂靠点</p>
</blockquote>
<pre><code>2.命令交互模式 
   命令提示符：
   itcast@ubuntu:~$ 
     - itcast：用户名
 - ubuntu ：主机名
 - ~ ：路径 ，假如当前的路径正好是 该用户存放数据的根目录 ，则显示~
 - $ :用户的类型  $代表普通用户  #  代表 超级用户

3.linux文件系统 

 - 目录结构
 - 文件权限分析
   w ：可写   r： 只读  x：可执行  - ：无权限
   文件权限
    1. 字符表示法
      drwxr-xr-x 第一个字符 ：文件的类型  d ：普通文件  - ：文件夹  c ：串口文件  l ：连接文件
         2-4 字符：该文件的属主用户的权限 
         5-7 字符：与属主用户同一组的其他用户的权限
         8-10 字符：不同组的其他用户的权限
     2. 数字表示法
    -rw-r--r--   ：文件的默认权限   644
    drwxr-xr-x   ： 目录的默认权限  755  
</code></pre><h4 id="4-linux的常用命令"><a href="#4-linux的常用命令" class="headerlink" title="4.linux的常用命令"></a>4.linux的常用命令</h4><pre><code>1.注销、关机、重启
  - 注销 ：logout ：登出 exit 
  - 关机 ：
     shutdown - h  时间
   - h ：关机
   - 时间 ：
     1. now :马上
     2. 12.30 ：指定具体时间
     3. 3 几分钟以后

     sudo ： superuser do ：由超级用户来执行该命令

         要配置sudo 命令 ： 授权哪些用户能执行哪些命令
         由超级用户配置  sudo 
             /etc/sudoers 
             sudo shutdown -h now  当前账号：itcast
  - 重启 ：
     shutdown -r  时间
         -r ：restart 
2.linux基本命令 ：文件操作命令

  1. ls   ： 查看目录内容
     - l ：查看详细信息
 - a ：查看所有文件（隐藏）
     man ：manual ： 手工，帮助 ，帮助命令，好比windows help 
  命令： man ls
  2. mkdir ：创建目录 
       Desktop：
     - java
       - JEE ： aa.txt  bb.txt  
       - Android
  3. cd  切换目录
     - cd ..  记得要加空格
 - cd ./java  进入当前目录的子目录
 - cd ../xxx  进入上一级目录的子目录
    tab ：自动补全
  4. touch  ：创建一个空白的普通文件
     touch aa.txt 
  5. echo  :把内容重定向到指定的文件中 ，有则打开，无则创建
  6. cat、more  ：查看文件内容
     - cat ：查看文件内容
 - more ：分页查看文件内容，按空格键换页

  7. cp、mv、rm   
     - cp ：复制
    cp bj.txt ./java/jee
 - mv ：剪切、重命名
    1. 剪切 ：mv aa.txt ../android/
    2. 重命名 ：假如剪切的文件 存放在同一个目录中 ，则是重命名
        mv bb.txt cc.txt

 - rm ：删除文件或者文件夹
   -f ： 假如要删除的文件不存在，也不提示
   -i ： 删除前提示 ，默认不删除，要删除，输入y
   -d ： 删除空白目录 
   -r ：递归删除
  8. wc ：word count ：统计字符数
      154  233 3418 
  - 154 ：行数
  - 233 ：单词数
  - 3418 ：字符数
    命令： wc bj.txt

  9. ln :创建连接文件
     - 默认创建的是硬连接，好比复制 ，但是两个文件会同步 
    命令：ln ./java/android/aa.txt  aaa
 - s ：创建的是软连接

  10. pwd   ：查看当前目录的绝对路径 

  11. 管道命令 |
    命令： ls -la | wc 
  12. 重定向
     - &gt; :覆盖模式
 命令：  echo &quot;ww&quot;&gt;aaa
 - &gt;&gt;：追加模式
 命令： echo &quot;ww&quot;&gt;&gt;aaa
  13. passwd   :设置密码  ，ubuntu默认 root账号是没有开启 ，只要设置root密码即可开启
      sudo passwd root

  14. su  切换目录
      su root 
  root用户切换到其他账号不需要密码

3.linux 系统命令
  1.stat   ：查看文件的详细信息
    stat bj.txt
  2.who与whoami
    who : 查看在线的用户
    whoami ：查看当前自己的用户
  3.hostname ： 显示主机名
    hostname
  4.uname  ：显示系统信息
     -a ：显示完整的系统信息

  5.top ：显示当前耗时的进行的信息 ，每3秒刷新一次 
      cltr+c 中断 
  6.ps ：显示当前进程的快照 
    - axu
  7.du ：显示文件的大小信息 
  8.df ：磁盘使用情况  disk free
  9.ifconfig ：查看或者配置网卡信息 ，好比windows 的ipconfig
     ipv4：32位  2-32次方     ipv6  128位     是 ipv4  2-96次方倍数
 设置虚拟机ip地址：
   1. 设置vmware的连接方式
      - 共享宿主机的ip地址，在网上邻居找不到
      - 桥接方式，需要单独设置ip，可以在网上邻居查找
   2. 图形界面设置ip地址 
       edit connection --》ipv4--》manual（手工设置）--》add  （ip地址，子网掩码）
       3.命令方式设置ip地址
      静态设置ip：
      sudo ifconfig eth0 192.168.15.122 netmask 255.255.255.0 

  10.ping  测试与目标主机连接情况

  11.clear  ： 清除屏幕  windows： cls  
  12.man  ：帮助命令
      man 命令
  13.kill  ：杀死进程
     kill  pid 
  14.netstat  ：网络连接详细信息

  15. useradd 
     - 查看用户信息
    sudo cat /etc/passwd
  itcast:x:1000:1000:UbuntuA,,,:/home/itcast:/bin/bash
   - itcast:用户名
   - x ：密码 ：已经加密 ，密码存放在  /etc/shadow 
   - 1000: 账号id ，userId
   - 1000： 组id ，group id
       - UbuntuA,,,  ：账号描述
       - /home/itcast ：该账号存放文件的默认位置  ~
   - /bin/bash：该用户的shell脚本的解析方式  ，sh 、bash、rbash

     - 创建用户 
   sudo useradd lijun -d  /home/lijun   -s /bin/bash 
    -d :指定该用户的home 路径 
    - s ：该用户的shell解析方式
   步骤：
     1. 创建 /home/lijun 目录
     2. 执行 useradd 命令
     3. 用 passwd 设置密码
     4. su 切换用户
</code></pre><h4 id="5-打包、压缩文件"><a href="#5-打包、压缩文件" class="headerlink" title="5.打包、压缩文件"></a>5.打包、压缩文件</h4><pre><code>windows ： zip、rar    
linux ：gz ，bzip，zip

 1.tar :打包、拆包命令 
    tar - cxzjvf  &lt;打包后的文件&gt;   &lt;欲打包的目录&gt;
  - c ：创建的一个归档文件 ，即打包文件夹
  - x ：拆包
  - z ：以gzip 格式压缩，默认压缩倍数 6倍  （0-9）
  - j ：以bzip2格式压缩
  - v ：显示打包或者拆包的文件信息
  - f ： 后面紧接一个 归档文件

   - 打包文件
      tar -cvf news.tar  ./java   摘要  
   - 拆包文件
      tar -xvf news.tar
 2.gzip 、bzip2 压缩与解压
    1. 压缩文件
  gzip news.tar
2. 解压文件
  gzip -d news.tar.gz
    -d :解压
 3.打包及压缩 
   - 打包及压缩
      tar -czvf news.tar.gz ./java
   - 拆包及压解缩
      tar -xzvf  news.tar.gz
</code></pre><h4 id="6-软件管理"><a href="#6-软件管理" class="headerlink" title="6.软件管理"></a>6.软件管理</h4><pre><code>windows ： .exe     安装 、卸载 
   安装：  mysql.exe  cc.exe   
   卸载 ： 该软件唯一的标识  ，包名   alibaba
android : *.apk   卸载 包名
red hat ：*.rpm 
ubuntu  : 对debian的升级  *.deb 格式


 1.安装软件
   - dpkg ：debian  package 
      离线安装：
  安装 ： sudo dpkg - i  &lt;文件名&gt; 
    -i ：install
   命令：sudo dpkg -i ./tree_1.6.0-1_i386.deb
  卸载 ： sudo dpkg - r  &lt;包名&gt; 
    -r ：remove
       命令：sudo dpkg -r tree
   - apt-get  ：advance  package  tools 
   　　对dpkg命令的升级，在线安装
  安装 ： sudo apt-get -install  &lt;包名&gt;
  卸载 ： sudo apt-get -remove  &lt;包名&gt;
 2.vim 软件  ：好比记事本 ，但是比记事本要强大  

 1. 安装vim
 2. 使用vim 
   操作模式：
     1. 一般模式 ，默认进入的一般模式，该模式不能编辑文档 ，只能查看
        按 i（insert）  进入 插入模式 
     2. 编辑模式、插入模式 
         该模式可以编辑文档，按esc 退出插入模式，进入到一般模式 
     3. 命令模式 ：在 一般模式中按：进入命令模式
        - q： 安全退出，当没有操作该文档，则直接按q退出vim 
    - q！：当修改了内容，但是不想保存，则q！强制退出
    - wq ：保存退出
    - set number 显示行号
    - set nonumber 取消行号显示
</code></pre><h4 id="7-搭建Java服务器，并且实现远程安全访问linux系统"><a href="#7-搭建Java服务器，并且实现远程安全访问linux系统" class="headerlink" title="7.搭建Java服务器，并且实现远程安全访问linux系统"></a>7.搭建Java服务器，并且实现远程安全访问linux系统</h4><pre><code>1.通过ssh实现安全远程访问linux系统 
   ssh ：secure shell(安全外壳)
     加密：
       1. 对称加密 （加密密钥与解密密钥相同）
          des 、aes 技术
       2. 非对称加密（加密密钥与解密密钥不同）
          RSA ：公钥、私钥 
 数字摘要：
    两种数字加密方式：
    md5/sha1
        md5：用于数字签名(防止抵赖、防止篡改)

   1. 查看是否安装了ssh服务端与客户端
     sudo apt-cache policy openssh-client openssh-server
   2. 安装ssh 服务端与客户端软件
      sudo dpkg -i ./ssh/*
   3. 通过windows ssh客户端来访问linux服务端
        - putty ：远程登录
        - winscp433setup.exe ：文件传输

2. 安装jdk
   进入 root用户
   实现步骤：
    1. jdk 存放在哪里  /opt
    2. 把软件拷贝到/opt
    3. 绿色软件，解压 
    4.设置环境变量
        vim /etc/profile 
        export JAVA_HOME=&quot;/opt/jdk1.6.0_39&quot;
        export PATH=&quot;$JAVA_HOME/bin:$PATH&quot;
    5. 刷新配置 ，让配置生效
       source /etc/profile
    6. 编写Demo.java,测试 
       -javac Demo.java
           - java Demo

3. 安装tomcat 
   步骤：
    1. 安装在哪里 /opt
2. 拷贝、解压
   tar -xzvf  apache-tomcat.tar.gz
3. 运行
   - ./startup.sh
   - ./shutdown.sh


4. 安装Eclipse
   步骤：
     1.安装在/opt
 2. 拷贝、解压
   cp eclipse.tar.gz  /opt
   tar -xzvf  eclipse.tar.gz
</code></pre><h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><pre><code>1.linux系统环境
   命令交互通道
   命名提示符
2. linux 目录结构、文件权限
  drwxr-xr-x
3. linux 命令
  - 开关机
  - 文件操作 
  - 系统命令
     1. top 2. who 3. ifconfig 4. ping 5. kill 6. man 7.clear 8.netstat
4. 软件管理
   - dpkg ：离线  .deb  .rpm  .apk 
   - apt-get ：在线 
5. 压缩解压
   tar -cxgzvf 打包后的文件 要打包的文件
6. vim 的使用
   三种模式
7. ssh理解 secure shell
8. java开发环境搭建
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 学习</title>
    <url>/undefined/Reids/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis-FD"><a href="#Redis-FD" class="headerlink" title="Redis - FD"></a>Redis - FD</h2><p>Redis 是一个基于内存的高性能key-value数据库，通过提供多种键值数据类型来适应不同场景下的存储需求。<br></p>
<p>应用场景：1.会话缓存(session cache)(数据查询、短链接、新闻内容、商品内容等) 2.全页缓存(FPC) 3.任务队列(秒杀、抢购、12306) 4.排行榜/计数器 5.发布/订阅 6.分布式集群架构中的session分离 7.数据过期处理</p>
<blockquote>
<p>扩展：为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。NoSQL：not-Only SQL表示非关系型数据库，作为关系型数据库的良好补充。</p>
</blockquote>
<h4 id="1-Redis特点"><a href="#1-Redis特点" class="headerlink" title="1.Redis特点"></a>1.Redis特点</h4><p>优点：<br><br>1.速度快，因为数据都是存储在内存中的，类似于HashMap，HashMap的优势就在于查找和操作的时间复杂度都为O(1)。Redis在本质上是一个<code>KEY-VALUE</code>类型的内存数据库，很像<code>memcached</code>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。<br><br>2.由于其实纯内存操作，所以性能非常好，是已知性能最快的key-value DB。<br><br>3.reids支持保存多种数据结构，此外单个value的最大限制是1GB，不想memcached只能保存1MB数据。<br><br><a id="more"></a><br>4.支持丰富的数据类型，支持string，list，set，sorted set，hash。</p>
<p>5.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>6.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<p>缺点：<br><br>7.reids的缺点主要是，数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h4 id="2-Redis支持的数据类型"><a href="#2-Redis支持的数据类型" class="headerlink" title="2.Redis支持的数据类型"></a>2.Redis支持的数据类型</h4><ul>
<li>String  可以是字符串，整数或浮点数，对整个字符串或者字符串中的一部分执行操作。</li>
<li>List 表示一个链表</li>
<li>Sets 求交集/并集</li>
<li>Sorted Set</li>
<li>hashs</li>
</ul>
<h4 id="3-Redis需要将所有数据放到内存中的原因"><a href="#3-Redis需要将所有数据放到内存中的原因" class="headerlink" title="3.Redis需要将所有数据放到内存中的原因"></a>3.Redis需要将所有数据放到内存中的原因</h4><p>1.Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。<br><br>2.如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br><br>3.如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<blockquote>
<p>注意：1.reids是单进程单线程的，利用队列技术将并发访问变成串行访问，消除传统数据库串行控制的开销。<br>2.</p>
</blockquote>
<h4 id="4-Redis常见性能问题解决"><a href="#4-Redis常见性能问题解决" class="headerlink" title="4.Redis常见性能问题解决"></a>4.Redis常见性能问题解决</h4><p>1.master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。<br><br>2.如果数据比较重要，某个<code>Slave</code>开启<code>AOF</code>备份数据，策略设置为每秒同步一次。(slave?aof?是啥)<br><br>3.为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。<br><br>4.尽量避免在压力很大的主库上增加从库。<br><br>5.从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3等，这样的结构方便解决单点故障问题，实现Slave对Master的替换，如果Master挂了可以立刻启用Slave1做Master，其他不变。</p>
<h4 id="5-Redis与memcached的区别"><a href="#5-Redis与memcached的区别" class="headerlink" title="5.Redis与memcached的区别"></a>5.Redis与memcached的区别</h4><p>1.memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。<br><br>2.redis的速度比memcached快很多。<br><br>3.redis可以持久化其数据。(数据的持久化就是将内存中的数据模型转化为存储模型，数据模型是任何的数据结构或者是对象，存储模型可以是关系型/xml文件/二进制流) 狭义：持久化仅仅是将对象数据永久保存在数据库中。广义：持久化包括和数据库相关的各种操作，封装数据访问细节，为大部分业务逻辑提供面向对象的API。</p>
<h4 id="6-Redis持久化方案区别-优缺点"><a href="#6-Redis持久化方案区别-优缺点" class="headerlink" title="6.Redis持久化方案区别/优缺点"></a>6.Redis持久化方案区别/优缺点</h4><p>首先我们知道，Redis为我们提供两种持久化的方式，RDB(Redis DataBase)/AOF(Append Only File)。<br>1.RDB方式：快照式的持久化方法，将某一时刻的数据持久化到磁盘中。</p>
<pre><code>1.因为Redis在持久化的过程中，会首先将数据写入到一临时文件中，在持久化过程都结束之后才会用此临时文件替换已经持久化好的文件。所以因为这个特性让我随时进行备份。
2.于RDB方式，Redis单独创建一个子进程来进行持久化，主进程不会进行任何IO操作，这就确保Redis很好的性能。
3.如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
</code></pre><p>2.AOF方式：将执行过的 <code>写指令</code> 记录下来，在数据恢复时按照<code>从前到后</code>的顺序再将指令执行一遍。</p>
<pre><code>1.AOF 命令以Redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。默认的 AOF 持久化策略是每秒钟 fsync 一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。

2.如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。

3.因为此种是采用追加的方式，所以如果我们不做任何处理的话，AOF文件会变得越来越大。所以在此Redis提供AOF文件重写机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

4.在进行AOF重写时，我们仍然采用是先写临时文件，最后在全部完成之后再替换掉的流程，所以在断电、磁盘满等问题都不会影响AOF文件的可用性。
</code></pre><h4 id="7-如何维护集群之间的关系-集群之间如何建立连接"><a href="#7-如何维护集群之间的关系-集群之间如何建立连接" class="headerlink" title="7.如何维护集群之间的关系(集群之间如何建立连接)"></a>7.如何维护集群之间的关系(集群之间如何建立连接)</h4><p>集群？</p>
<h4 id="8-Redis存取实体的方式"><a href="#8-Redis存取实体的方式" class="headerlink" title="8.Redis存取实体的方式"></a>8.Redis存取实体的方式</h4><p>在存储的时候需要将实体 <code>序列化</code> ，然后可以当字符串一样存储，取数据也一样，取出来的数据要 <code>反序列化</code> 。</p>
<h4 id="9-Redis保留时间"><a href="#9-Redis保留时间" class="headerlink" title="9.Redis保留时间"></a>9.Redis保留时间</h4><p>Redis保留时间在未设置的情况下会一直存在，除非服务停掉且没有保存到磁盘。如果已手动或自动保存过，则再次启动服务还会存在。</p>
<p>待续……….</p>
<h4 id="10-Redis事务"><a href="#10-Redis事务" class="headerlink" title="10.Redis事务"></a>10.Redis事务</h4><hr>
<h2 id="Redis-SD"><a href="#Redis-SD" class="headerlink" title="Redis - SD"></a>Redis - SD</h2><h4 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1.安装配置"></a>1.安装配置</h4><p>1.首先去Redis的官网下载Redis的压缩包，然后编译Redis源码并启动。<br><br>2.启动Redis</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>BootStrap</title>
    <url>/undefined/bootstrap/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Bootstrap-包的内容"><a href="#Bootstrap-包的内容" class="headerlink" title="Bootstrap 包的内容"></a>Bootstrap 包的内容</h2><blockquote>
<p>1.基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构</p>
</blockquote>
<blockquote>
<p>2.CSS：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统</p>
</blockquote>
<blockquote>
<p>3.组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等</p>
</blockquote>
<blockquote>
<p>4.JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件</p>
</blockquote>
<blockquote>
<p>5.定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本<br><a id="more"></a><br>扩展</p>
<blockquote>
<p>meta标签中http-equiv属性<br>meta是head区的一个辅助性标签，而这个标签的作用是：搜索引擎优化(SEO)、定义页面使用语言、自动刷新并且指向新的页面。</p>
<blockquote>
<p>meta标签有两个属性：http-equiv/name属性 其中name属性用于描述网页，对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="Bootstrap-CSS"><a href="#Bootstrap-CSS" class="headerlink" title="Bootstrap CSS"></a>Bootstrap CSS</h2><h4 id="1-HTML5文档类型-doctype"><a href="#1-HTML5文档类型-doctype" class="headerlink" title="1.HTML5文档类型(doctype)"></a>1.HTML5文档类型(doctype)</h4><p>Bootstrap 使用了一些 HTML5 元素和 CSS 属性，所以为了让这些属性元素正常工作，需要使用HTML5文档类型。</p>
<pre><code>&lt;!DOCTYPE html&gt;
    &lt;html&gt;&lt;/html&gt;
</code></pre><blockquote>
<p>注意：如果在boostrap创建的页面中不使用文档类型(doctype)，页面会出现显示不一致的问题</p>
</blockquote>
<h4 id="2-移动设备优先"><a href="#2-移动设备优先" class="headerlink" title="2.移动设备优先"></a>2.移动设备优先</h4><p>为了让 Bootstrap 开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 head 之中添加<code>viewport meta</code>标签<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p>
<blockquote>
<p>1.width属性让网站能正确不同屏幕分辨率的设备上浏览显示</p>
</blockquote>
<blockquote>
<p>2.initial-scale 保证网页在加载的时候是以1:1的比例显示</p>
</blockquote>
<blockquote>
<p>注意：在移动设备浏览器上，通过为 <code>viewport meta</code> 标签添加 <code>user-scalable=no</code> 可以禁用其缩放（zooming）功能.通常情况下，参数<code>maximum-scale=1.0</code> 与 <code>user-scalable=no</code> 一起使用，禁用缩放功能，用户只能滚动屏幕进行网页查看。</p>
</blockquote>
<h4 id="3-响应式图像"><a href="#3-响应式图像" class="headerlink" title="3.响应式图像"></a>3.响应式图像</h4><p><code>&lt;img src=&quot;...&quot; class=&quot;img-responsive&quot; alt=&quot;响应式图像&quot;&gt;</code><br>通过添加 <code>img-responsive class</code> 可以让 Bootstrap 3<br>中的图像对响应式布局的支持更友好。在<code>img-responsive class</code> 中为图像设置的属性 <code>max-width: 100%;</code> 和<code>height: auto;</code> 属性，可以让图像按比例缩放，不超过其父元素的尺寸这说明了图像显示以<code>block</code>的方法，在设置元素的显示<code>display</code>为<code>block</code>时，以块级元素显示</p>
<blockquote>
<p>注意：如果需要使.img-responsive 类的图片水平居中，请使用 .center-block 类，不要用 .text-center</p>
</blockquote>
<h4 id="4-全局显示、排版和链接"><a href="#4-全局显示、排版和链接" class="headerlink" title="4.全局显示、排版和链接"></a>4.全局显示、排版和链接</h4><h5 id="1-基本的全局显示"><a href="#1-基本的全局显示" class="headerlink" title="1.基本的全局显示"></a>1.基本的全局显示</h5><p>Bootstrap 3 使用 <code>body {margin: 0;}</code> 来移除 body 的边距,一般的全局显示是<code>body{}</code>中设置，然后属性有：</p>
<pre><code>1.font-family:   //用于设置默认字体样式 
2.font-size:   //设置文本默认字体大小 
3.line-height:  //设置默认行高
4.color: //设置默认的文本颜色    
5.background-color:  //设置默认的背景颜色
</code></pre><h5 id="2-排版"><a href="#2-排版" class="headerlink" title="2.排版"></a>2.排版</h5><p>使用<code>@font-family-base</code> <code>@font-size-base</code> 和 <code>@line-height-base</code> 属性作为排版样式</p>
<h5 id="3-链接样式"><a href="#3-链接样式" class="headerlink" title="3.链接样式"></a>3.链接样式</h5><p>使用 <code>@link-color</code> 设置全局链接的颜色</p>
<pre><code>例子：
        //表示在鼠标悬停或者点击过链接时，颜色会变，然后会呈现一条下划线。然后点击过得链接还会出现样式
        a:hover,a:focus{color:#253544 text-decoration:underline}
        a:focous{outline:thin dotted #333;outline:5px auto --webkit-focus-ring-color;outline-offset: -2px;}
</code></pre><h5 id="4-避免跨浏览器的不一致"><a href="#4-避免跨浏览器的不一致" class="headerlink" title="4.避免跨浏览器的不一致"></a>4.避免跨浏览器的不一致</h5><p>Bootstrap 使用 <code>Normalize</code> 来建立跨浏览器的一致性，而 <code>Normalize.css</code> 文件是一个很小的css文件，在HTML元素默认的样式中提供更好的跨浏览器一致性</p>
<h5 id="5-容器"><a href="#5-容器" class="headerlink" title="5.容器"></a>5.容器</h5><p><code>&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code> 表示引用容器，然后再看cnotainer容器的属性：</p>
<pre><code>.container {
       padding-right: 15px;//内边距
       padding-left: 15px;
       margin-right: auto;//页边距，由浏览器决定
       margin-left: auto;
}
</code></pre><blockquote>
<p>注意：Bootstrap 3 CSS 有一个申请响应的<code>媒体查询</code>，在不同的媒体查询阈值范围内都为 <code>container</code> 设置了<code>max-width</code>，用以匹配网格系统。</p>
</blockquote>
<pre><code>@media (min-width: 768px) {
       .container {
              width: 750px;
    }
</code></pre><blockquote>
<p>注意：container与container-fluid之间的区别</p>
</blockquote>
<blockquote>
<blockquote>
<p>1.<code>container</code> 类和<code>container-fluid</code>类的区别体现在是否有随视口宽度改变的<code>margin</code>存在。<br>2.<code>container</code>类所谓的自适应也是通过<code>margin</code>的改变来完成，<code>container-fluid</code>类的百分百宽度是指在固有的<code>15px</code>的<code>padding</code>前提下宽度总是当前视口的宽度</p>
</blockquote>
</blockquote>
<h5 id="6-Bootstrap-浏览器-设备支持"><a href="#6-Bootstrap-浏览器-设备支持" class="headerlink" title="6.Bootstrap 浏览器/设备支持"></a>6.Bootstrap 浏览器/设备支持</h5><p>Bootstrap 可以在最新的桌面系统和移动端浏览器中很好的工作，然后在旧的浏览器可能无法很好的支持 bootstrap 网格系统.Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p>
<pre><code>1.网格(Grid)
    表示在网页设计过程中用于组织内容，让网站更容易浏览，降低用户端的负载

2.bootstrap的网格系统
    bootstrap3 是移动设备优先的，然后再扩展到大屏幕设备(pc端)上的组件和网格

3.移动设备优先策略
    1.内容

    2.布局
      1.优先设计更小的宽度
      2.基础的css是移动设备优先
    3.渐进增强
      随着屏幕的大小的增加而添加元素
</code></pre><blockquote>
<p>注意：响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p>
</blockquote>
<pre><code>4.bootstrap网格系统的工作原理
    网格系统通过一系列包含内容的行和列来创建页面布局

    1.行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）
    2.使用行来创建列的水平组
    3.内容应该放置在列内，且唯有列可以是行的直接子元素
    4.

5.媒体查询
    bootstrap的媒体查询允许我们基于视口大小移动、显示并隐藏内容

        /* 超小设备（手机，小于 768px） */
        /* Bootstrap 中默认情况下没有媒体查询 */

        /* 小型设备（平板电脑，768px 起） */
        @media (min-width: @screen-sm-min) { ... }

        /* 中型设备（台式电脑，992px 起） */
        @media (min-width: @screen-md-min) { ... }

        /* 大型设备（大台式电脑，1200px 起） */
        @media (min-width: @screen-lg-min) { ... }
</code></pre><blockquote>
<p>注意：有时候的媒体查询包含<code>max-width</code>，这样作用是将css的影响限制更小范围的屏幕大小之内</p>
</blockquote>
<pre><code>@media (max-width: @screen-xs-max) { ... }//限制css的影响
@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... }
@media (min-width: @screen-md-min) and (max-width: @screen-md-max) { ... }
@media (min-width: @screen-lg-min) { ... }
</code></pre><blockquote>
<p>注意：媒体查询包括：1.设备规范 2.大小规则</p>
</blockquote>
<pre><code>@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... }
表示：对于所有带有 min-width: @screen-sm-min 的设备，如果屏幕的宽度小于 @screen-sm-max，则会进行一些处理

6.网格选项
    class前缀：
        .col-xs- 表示超小设备手机（&lt;768px）    
        .col-sm- 表示小型设备平板电脑（≥768px）    
        .col-md- 表示中型设备台式电脑（≥992px）    
        .col-lg- 表示大型设备台式电脑（≥1200px）

    基本的网格选项
        案例：
            注意：
            1.`&lt;div class=&quot;container&quot;&gt;...&lt;/div&gt;` 元素被添加，确保居中和最大宽度
            2.在添加容器之后，需要考虑以行为单位，添加 `&lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;`，并在行内添加列 `&lt;div class=&quot;col-md-6&quot;&gt;&lt;/div&gt;`

            col-md-6 表示设备为中型台式设备(&gt;992px)，然后6表示一个列由六个单元组成

            3.网格中的每一行是由12个单元组成，我们可以使用这些单元定义列的尺寸，但是要确保最后的列所组成的单元的总和为12

7.响应式的列重置

    在案例中包含多个网格，在小设备浏览时无法确定网格显示的位置，所以我们可以使用 `.clearfix class` 和 `响应式实用工具` 来解决这个问题

    1.响应式使用工具：


8.偏移列

    如果希望在大屏幕显示器上使用偏移，使用 `.col-md-offset-*` 类,这些类会把一个列的左外边距（margin）增加 * 列，其中 * 范围是从 1 到 11（也就是整个列向右移*单元）

9.嵌套列

    在内容上嵌套默认的网格，需要添加一个新的 `.row` 然后在已有的 `.col-md-*` 列内添加一组 `.col-md-*` 列

10. 列排序

    我们可以以一种顺序编写列，然后以另一种顺序显示列 我们可以使用使用 `.col-md-push-*` 和 `.col-md-pull-*` 类来互换这两列的顺序
</code></pre><h2 id="Bootstrap-排版"><a href="#Bootstrap-排版" class="headerlink" title="Bootstrap 排版"></a>Bootstrap 排版</h2><pre><code>1.标题
    在bootstrap定义了所有的HTML标题(h1-h6)样式

2.
</code></pre><h2 id="Bootstrap-代码"><a href="#Bootstrap-代码" class="headerlink" title="Bootstrap 代码"></a>Bootstrap 代码</h2><p>Bootstrap 允许我们以两种方式显示代码：</p>
<pre><code>1.使用&lt;code&gt;标签，如果需要内联显示代码，那么需要使用&lt;code&gt;标签
2.使用&lt;pre&gt;标签，如果代码需要被显示为一个独立的块元素或者代码有多行，需要使用&lt;pre&gt;标签
</code></pre><blockquote>
<p>注意：当我们确认是使用<code>&lt;pre&gt;</code>标签还是<code>&lt;code&gt;</code>标签，我们在开始以及结束需要使用：<code>&amp;lt;</code>和 <code>&amp;gt;</code> 表示 &lt; 与 &gt;</p>
</blockquote>
<pre><code>&lt;var&gt; 表示变量显示
&lt;kbd&gt; 表示强调字体高亮
&lt;pre&gt; 表示多行代码
&lt;pre class=&quot;pre-scrollable&quot;&gt; 表示多行代码且带有滚动条
&lt;samp&gt; 表示一种样式，电脑输出
&lt;code&gt; 表示代码高亮，突出显示
</code></pre><h2 id="Bootstrap-表格"><a href="#Bootstrap-表格" class="headerlink" title="Bootstrap 表格"></a>Bootstrap 表格</h2><p>bootstrap提供给我们一个清晰的创建表格的布局</p>
<pre><code>&lt;table&gt;    为表格添加基础样式
&lt;thead&gt;    表格标题行的容器元素（&lt;tr&gt;），用来标识表格列
&lt;tbody&gt;    表格主体中的表格行的容器元素（&lt;tr&gt;）
&lt;tr&gt; 行
&lt;td&gt; 表格单元格
&lt;th&gt; 必须在&lt;thead&gt;中使用，用来表示列或行，特殊的表格单元格
&lt;caption&gt; 关于表格存储内容的描述或总结 备注

1.表格类

    .table 为任意 `&lt;table&gt;` 添加基本样式 (只有横向分隔线)
    .table-striped    在 `&lt;tbody&gt;` 内添加斑马线形式的条纹 ( IE8 不支持)
    .table-bordered    为所有表格的单元格添加边框
    .table-hover 在 &lt;tbody&gt; 内的任一行启用鼠标悬停状态
    .table-condensed 让表格更加紧凑

2.&lt;tr&gt;, &lt;th&gt; 和 &lt;td&gt; 类

    .active    将悬停的颜色应用在行或者单元格上
    .success 表示成功的操作
    .info 表示信息变化的操作 就是改变了行的背景色
    .warning 表示一个警告的操作
    .danger    表示一个危险的操作

3.基本的表格


4.可选的表格类


5.响应式表格

    通过把任意的 .table 包在 .table-responsive class 内，我们可以让表格水平滚动以适应小型设备（小于 768px）。当在大于 768px 宽的大型设备上查看时，将看不到任何的差别。
</code></pre><blockquote>
<p>扩展</p>
<blockquote>
<p>HTML属性hidden：该属性表示隐藏，是布尔属性，浏览器不显示已规定的hidden属性的元素，防止用户查看元素</p>
</blockquote>
</blockquote>
<h2 id="Bootstrap-表单"><a href="#Bootstrap-表单" class="headerlink" title="Bootstrap 表单"></a>Bootstrap 表单</h2><pre><code>1.表单布局
    1.垂直表单(默认)
    2.内联表单
    3.水平表单

2.垂直或基本表单

    基本的表单借结构是bootstrap自带的，个别的表单空间自动接收全局样式

    创建基本表单的步骤：
        1.向父&lt;form&gt;元素添加role=&quot;form&quot;  &lt;form role=&quot;form&quot;&gt;
        2.将标签和控制放在一个带有 class .form-group 的 &lt;div&gt; 中。这是获取最佳间距所必需的  &lt;div class=&quot;form-group&quot;&gt;
        3.向所有的文本元素 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 添加 class =&quot;form-control&quot;   &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; placeholder=&quot;请输入名称&quot;&gt;

3.内联表单

    如果需要创建一个表单，它的所有元素是内联的，向左对齐的，标签是并排的，需要向&lt;form&gt;标签添加`class.form-inline`  如：&lt;form class=&quot;form-inline&quot; role=&quot;form&quot;&gt;

    注意：1.默认情况下，Bootstrap 中的 input、select 和 textarea 标签有 100% 宽度。所以在使用内联表单时，需要在表单控件上设置一个宽度
          2.使用class .sr-only，可以隐藏内联表单的标签

4.水平表单

    水平表单与其他表单不仅标记的数量上不同，而且表单的呈现形式也不同。

    创建一个水平布局的表单步骤：
        1.向父 &lt;form&gt; 元素添加 class .form-horizontal      
        如：`&lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot;&gt;`

        2.把标签和控件放在一个带有 `class .form-group` 的 &lt;div&gt; 中
        如：`&lt;div class=&quot;form-group&quot;&gt;`

        3.向标签添加 class .control-label    
        如：&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;firstname&quot; placeholder=&quot;请输入名字&quot;&gt;

5.支持的表单控件

    bootstrap支持最常见的表单控件，主要是 input、textarea、checkbox、radio 和 select

    1.输入框（Input）

        &lt;input type=&quot;hidden&quot; value=&quot;${grade}&quot; id=&quot;slected-grade&quot;&gt;
        这段程序表示：隐藏域在页面中对于用户不可见，在表单中插入隐藏域的目的在于搜集或发送信息，以利于被处理表单的程序所使用。虽然在页面中隐藏了，但是还是具有form传值功能。

    2.文本框（Textarea）

    3.复选框（Checkbox）和单选框（Radio）
        注意：对一系列复选框和单选框使用 .checkbox-inline 或 .radio-inline class，控制它们显示在同一行上

    5.选择框（Select）
        注意：1.使用&lt;select&gt;标签展示列表选项，通常是那些用户很熟悉的选择列表 2.使用 multiple=&quot;multiple&quot; 允许用户选择多个选项

    6.静态控件
        需要在一个水平表单内的表单标签后放置纯文本时，请在 &lt;p&gt; 上使用 class .form-control-static

    7.表单控件状态


    8.表单控件大小
        分别用 class.input-lg 和.col-lg-* 来设置表单的高度和宽度

    9.表单帮助文本
        bootstrap表单控件可以在输入框input上有一个块级帮助文本。如果要添加一个占用整个宽度的内容块，需要在&lt;input&gt;之后使用.help-block   如：&lt;span class=&quot;help-block&quot;&gt;&lt;/span&gt;
</code></pre><h2 id="Bootstrap-按钮"><a href="#Bootstrap-按钮" class="headerlink" title="Bootstrap 按钮"></a>Bootstrap 按钮</h2><p>任何带有 <code>class .btn</code> 的元素都会继承圆角灰色按钮的默认外观。但是 Bootstrap 提供了一些选项来定义按钮的样式，同时这些样式还能够用于<code>&lt;a&gt; &lt;button&gt;</code> 或 <code>&lt;input&gt;</code> 元素。</p>
<p>如果一个按钮有多个属性，需要在class中将所有的属性都加上</p>
<pre><code>设置按钮的颜色
    .btn 为按钮添加基本样式
    .btn-default 默认/标准按钮
    .btn-primary 原始按钮样式（未被操作)
    .btn-success 表示成功的动作
    .btn-info 该样式可用于要弹出信息的按钮
    .btn-warning 表示需要谨慎操作的按钮
    .btn-danger 表示一个危险动作的按钮操作
    .btn-link 让按钮看起来像个链接 (仍然保留按钮行为)
    .btn-lg    制作一个大按钮
    .btn-sm    制作一个小按钮
    .btn-xs    制作一个超小按钮
    .btn-block 块级按钮(拉伸至父元素100%的宽度)
    .active    按钮被点击
    .disabled 禁用按钮

    class=&quot;btn btn-primary&quot; 原始按钮
</code></pre><h5 id="1-按钮状态"><a href="#1-按钮状态" class="headerlink" title="1.按钮状态"></a>1.按钮状态</h5><p>bootstrap提供激活、禁用等按钮状态class</p>
<p>1.激活状态：按钮在被激活时将会呈现被按压状态，使用<code>.active class</code> 来显示它是激活的。</p>
<p>2.禁用状态：一个按钮被禁用时，它的颜色会变淡50%，失去渐变 将<code>disabled</code>属性添加到<code>&lt;button&gt;</code>按钮实现禁用。</p>
<h2 id="Bootstrap-图片"><a href="#Bootstrap-图片" class="headerlink" title="Bootstrap 图片"></a>Bootstrap 图片</h2><p>Bootstrap 提供了三个可对图片应用简单样式的 class :</p>
<pre><code>1. .img-rounded：添加 border-radius:6px 来获得图片圆角
2. .img-circle：添加 border-radius:50% 来让整个图片变成圆形
3. .img-thumbnail：添加一些内边距（padding）和一个灰色的边框
</code></pre><h5 id="1-lt-img-gt-类"><a href="#1-lt-img-gt-类" class="headerlink" title="1.&lt;img&gt; 类"></a>1.<code>&lt;img&gt;</code> 类</h5><pre><code>.img-rounded 为图片添加圆角 (IE8 不支持)
.img-circle 将图片变为圆形 (IE8 不支持)
.img-thumbnail 缩略图功能
.img-responsive    图片响应式 (将很好地扩展到父元素)    
</code></pre><h5 id="2-响应式图片"><a href="#2-响应式图片" class="headerlink" title="2.响应式图片"></a>2.响应式图片</h5><p>通过在 <code>&lt;img&gt;</code> 标签添加 <code>.img-responsive</code> 类来让图片支持响应式设计，图片将很好地扩展到父元素。<code>.img-responsive</code> 类将 <code>max-width: 100%;</code> 和 <code>height: auto;</code> 样式应用在图片上。<br>    如：<br>        <img src="cinqueterre.jpg" class="img-responsive" alt="Cinque Terre"></p>
<h2 id="Bootstrap-辅助类"><a href="#Bootstrap-辅助类" class="headerlink" title="Bootstrap 辅助类"></a>Bootstrap 辅助类</h2><h5 id="1-文本"><a href="#1-文本" class="headerlink" title="1.文本"></a>1.文本</h5><p>不同的类展示了不同的文本颜色，如果文本是个链接鼠标移动到上面文本将会变暗</p>
<pre><code>.text-muted
.text-primary
</code></pre><h5 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h5><p>不同的类展示不同的背景颜色，如果文本是个链接，鼠标移动到文本上文本会变暗</p>
<pre><code>.bg-primary
.bg-success
.bg-info
.bg-warning
</code></pre><h5 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h5><pre><code>.pull-left 元素浮动到左边

.pull-right 元素浮动到右边

.center-block 设置元素为 display:block
    并居中显示(设置显示为块，并且居中显示)

.clearfix 清除浮动

.show 强制元素显示

.hidden    强制元素隐藏

.sr-only 除了屏幕阅读器外，其他设备上隐藏元素

.sr-only-focusable 与 .sr-only 类结合使用，在元素获取焦点时显示(如：键盘操作的用户)

.text-hide 将页面元素所包含的文本内容替换为背景图

.close 显示关闭按钮 只是一个标识

.caret 显示下拉式功能 一个标识
</code></pre><h5 id="4-更多"><a href="#4-更多" class="headerlink" title="4.更多"></a>4.更多</h5><p>内容居中：使用 <code>class center-block</code> 来居中元素</p>
<h2 id="Bootstrap-响应式实用工具"><a href="#Bootstrap-响应式实用工具" class="headerlink" title="Bootstrap 响应式实用工具"></a>Bootstrap 响应式实用工具</h2><p>bootstrap提供一些辅助类，通过媒体查询结合大型、中型和小型设备，实现内容对设备的显示和隐藏。</p>
<h2 id="Bootstrap-字体图标Glyphicons"><a href="#Bootstrap-字体图标Glyphicons" class="headerlink" title="Bootstrap 字体图标Glyphicons"></a>Bootstrap 字体图标<code>Glyphicons</code></h2><p>Bootstrap 捆绑了 200 多种字体格式的字形，字体图标是在WEB项目中使用的图标字体</p>
<pre><code>1.获取字体图标

2.使用方法

    如果需要使用图标，只需要使用代码： &lt;span class=&quot;glyphicon glyphicon-search&quot;&gt;&lt;/span&gt; 此外，还需要在文本和图标之间保持适当的空间

3.定制字体图标(只需要在所应用的类中标注class的属性即可)

    开始：

    &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;
          &lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt; User
    &lt;/button&gt;

    1.定制字体尺寸
        可以通过增加或减少图标的字体尺寸让图标看起来更大或更小
        在原先的基础上加上属性：style=&quot;font-size:90px&quot;

    2.定制字体颜色
        在原先的基础上加上属性：style=&quot;color:rgb(212,106,64);&quot;

    3.应用文本阴影
        在原先的基础上加上属性：style=&quot;text-shadow:black 5px 3px 3px;&quot;
</code></pre><h2 id="Bootstrap-下拉菜单（Dropdowns）"><a href="#Bootstrap-下拉菜单（Dropdowns）" class="headerlink" title="Bootstrap 下拉菜单（Dropdowns）"></a>Bootstrap 下拉菜单（Dropdowns）</h2><p>下拉菜单是可切换的，是以列表格式显示链接的上下文菜单<br>如果需要使用下拉菜单，在 <code>class .dropdown</code> 内加上下拉菜单即可。</p>
<h5 id="2-更多"><a href="#2-更多" class="headerlink" title="2.更多"></a>2.更多</h5><pre><code>.dropdown 指定下拉菜单，下拉菜单都包裹在 .dropdown 里

.dropdown-menu 创建下拉菜单    

.dropdown-menu-right 下拉菜单右对齐    

.dropdown-header 下拉菜单中添加标题

.dropup    指定向上弹出的下拉菜单

.disabled 下拉菜单中的禁用项

.divider 下拉菜单中的分割线
</code></pre><h2 id="Bootstrap-按钮组"><a href="#Bootstrap-按钮组" class="headerlink" title="Bootstrap 按钮组"></a>Bootstrap 按钮组</h2><p>按钮组允许多个按钮被叠放在同一行里</p>
<blockquote>
<p>按钮组中的重要类：</p>
</blockquote>
<pre><code>.btn-group 形成基本按钮组，在其中放置一系列带有 class.btn 的按钮

.btn-toolbar 将几组 .btn-group 结合到一个&lt;div&gt;中，获得更复杂的组件

.btn-group-lg  .btn-group-sm  .btn-group-xs 用于对按钮组的大小调整

.btn-group-vertical 让一组按钮垂直堆叠显示，不是水平堆叠显示

class=&quot;btn-group-xs&quot; btn-group-sm btn-group-lg 按钮组从小到大的显示
</code></pre><h2 id="Bootstrap-按钮下拉菜单"><a href="#Bootstrap-按钮下拉菜单" class="headerlink" title="Bootstrap 按钮下拉菜单"></a>Bootstrap 按钮下拉菜单</h2><p>如果需要向按钮中添加下拉菜单，只需要简单的在一个<code>.btn-group</code> 中放置按钮和下拉菜单即可。此外，也可以使用 <code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code> 来指示按钮作为下拉菜单</p>
<pre><code>1.分割的按钮下拉菜单
    按钮左边是原始的功能，右边显示下拉菜单的切换

2.按钮下拉菜单的大小

3.按钮上拉菜单
    在父  .btn-group 容器添加 .dropup 即可
</code></pre><h2 id="Bootstrap-输入框组"><a href="#Bootstrap-输入框组" class="headerlink" title="Bootstrap 输入框组"></a>Bootstrap 输入框组</h2><p>使用输入框组，可以很容易地向基于文本的输入框添加作为前缀和后缀的文本或按钮<br>通过向输入域添加前缀和后缀的内容，可以向用户输入添加公共的元素。例如，可以添加美元符号，或者应用程序接口所需要的其他公共的元素。</p>
<pre><code>向 .form-control 添加前缀或后缀元素的步骤：
    1.把前缀或后缀元素放在一个带有 class .input-group 的 &lt;div&gt; 中
    2.在相同的 &lt;div&gt; 内，在 class 为 .input-group-addon 的 &lt;span&gt; 内放置额外的内容
    3.把该 &lt;span&gt; 放置在 &lt;input&gt; 元素的前面或者后面

    如：
        &lt;div style=&quot;padding: 100px 100px 10px;&quot;&gt;
                &lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt;
                    &lt;div class=&quot;input-group&quot;&gt;
                            &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt;    //将其放在前面
                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;twitterhandle&quot;&gt;
                    &lt;/div&gt;
</code></pre><h5 id="2-输入框组大小"><a href="#2-输入框组大小" class="headerlink" title="2.输入框组大小"></a>2.输入框组大小</h5><pre><code>可以通过向 .input-group 添加相对表单大小的 class（比如 .input-group-lg、input-group-sm）来改变输入框组的大小
</code></pre><h5 id="3-复选框和单选插件"><a href="#3-复选框和单选插件" class="headerlink" title="3.复选框和单选插件"></a>3.复选框和单选插件</h5><pre><code>我们可以将复选框和单选插件作为输入框组的前缀或者后缀元素
</code></pre><h5 id="4-按钮插件"><a href="#4-按钮插件" class="headerlink" title="4.按钮插件"></a>4.按钮插件</h5><pre><code>将按钮作为输入框组的前缀或者后缀元素，这时不是添加 .input-group-addon class，而是需要使用 class .input-group-btn 来包裹按钮。注意：这是必需的，因为默认的浏览器样式不会被重写
</code></pre><h5 id="5-带下拉菜单的按钮"><a href="#5-带下拉菜单的按钮" class="headerlink" title="5.带下拉菜单的按钮"></a>5.带下拉菜单的按钮</h5><pre><code>输入框组添加带有下拉菜单的按钮，只需要在 .input-group-btn class 中包裹按钮和下拉菜单即可
</code></pre><h2 id="Bootstrap-导航元素"><a href="#Bootstrap-导航元素" class="headerlink" title="Bootstrap 导航元素"></a>Bootstrap 导航元素</h2><p>使用相同的标记和基类 <code>.nav</code></p>
<pre><code>1.表格导航或标签

    步骤：

    1.创建一个带有 class .nav 的无序列表
    2.添加 class .nav-tabs

2.胶囊式的导航菜单

    1.基本的导航菜单

        如果需要把标签改成胶囊的样式，只需要使用 class .nav-pills 代替 .nav-tabs 即可，创建步骤与上面相同

        步骤：        

        1.引入文件
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;  
        &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;

        2.编写导航栏，active 表示默认此
        3.在class一栏有 class=&quot;nav nav-pills&quot; 胶囊状的导航菜单

            &lt;p&gt;基本的胶囊式导航菜单&lt;/p&gt;
            &lt;ul class=&quot;nav nav-pills&quot;&gt;
                  &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;

    2.垂直的胶囊式导航菜单

        在使用class .nav .nav-pills 的同时使用 class .nav-stacked，让胶囊垂直堆叠 在上面例子中加入class=&quot;nav nav-pills nav-stacked&quot;

    3.两端对齐的导航

        通过使用 .nav、.nav-tabs 或 .nav、.nav-pills 的同时使用 class .nav-justified，让标签式或胶囊式导航菜单与父元素等宽 

    4.禁用连接

        对于每个 .nav class 如果添加.disabled class 则会创建一个灰色的链接，同时禁用该链接的 :hover 状态

    5.下拉菜单

        默认情况下，列表项的锚与一些数据属性协同合作来触发带有 .dropdown-menu class 的无序列表

        带有下拉菜单的标签

        步骤：
            1.以一个带有 class .nav 的无序列表开始
            2.添加 class .nav-tabs
            3.添加带有 .dropdown-menu class 的无序列表

        1.带有下拉菜单的胶囊

            步骤与创建带有下拉菜单的标签相同，只是需要把 .nav-tabs class 改为 .nav-pills

    6.更多
        标签页与胶囊标签页

            .tab-content 与 .tab-pane 和 data-toggle=&quot;tab&quot; (data-toggle=&quot;pill&quot; ) 一同使用, 设置标签页对应的内容随标签的切换而更改

            .tab-pane 与 .tab-content 和 data-toggle=&quot;tab&quot; (data-toggle=&quot;pill&quot;)一同使用, 设置标签页对应的内容随标签的切换而更改
</code></pre><h2 id="Bootstrap-导航栏"><a href="#Bootstrap-导航栏" class="headerlink" title="Bootstrap 导航栏"></a>Bootstrap 导航栏</h2><h5 id="1-默认导航栏创建步骤："><a href="#1-默认导航栏创建步骤：" class="headerlink" title="1.默认导航栏创建步骤："></a>1.默认导航栏创建步骤：</h5><pre><code>1.向 &lt;nav&gt; 标签添加 class .navbar、.navbar-default
2.向上面的元素添加 role=&quot;navigation&quot;，有助于增加可访问性
3.向 &lt;div&gt; 元素添加一个标题 class .navbar-header，内部包含了带有 class navbar-brand 的 &lt;a&gt; 元素。这会让文本看起来更大一号。
4.为了向导航栏添加链接，只需要简单地添加带有 class .nav、.navbar-nav 的无序列表即可
</code></pre><h5 id="2-响应式的导航栏"><a href="#2-响应式的导航栏" class="headerlink" title="2.响应式的导航栏"></a>2.响应式的导航栏</h5><p>给导航栏添加响应特性，要折叠的内容必须包裹在带有<code>class .collapse</code>、<code>.navbar-collapse</code> 的 <code>&lt;div&gt;</code> 中，折叠起来的导航栏实际是一个带有 <code>class .navbar-toggle</code> 及两个 <code>data-</code> 元素的按钮。第一个是 <code>data-toggle</code>，用于告诉 <code>JavaScript</code> 需要对按钮做什么，第二个是 <code>data-target</code>，指示要切换到哪一个元素。三个带有 <code>class .icon-bar</code> 的 <code>&lt;span&gt;</code> 创建所谓的汉堡按钮。这些会切换为 <code>.nav-collapse</code> <code>&lt;div&gt;</code> 中的元素。为了实现以上这些功能，您必须包含 Bootstrap 折叠<code>（Collapse）</code>插件</p>
<h5 id="3-导航栏的表单"><a href="#3-导航栏的表单" class="headerlink" title="3.导航栏的表单"></a>3.导航栏的表单</h5><p>使用 <code>class .navbar-form</code> 以至于能够确保表单适当的垂直对齐和在较窄的视口中折叠的行为，使用对齐方式来决定导航栏中的内容放置在哪。</p>
<h5 id="4-导航栏中的按钮"><a href="#4-导航栏中的按钮" class="headerlink" title="4.导航栏中的按钮"></a>4.导航栏中的按钮</h5><p>使用 <code>class .navbar-btn</code> 向不在<code>&lt;form&gt;</code>中的<code>&lt;button&gt;</code>元素添加按钮，按钮在导航栏上垂直居中。<code>.navbar-btn</code> 可被使用在 <code>&lt;a&gt;</code> 和 <code>&lt;input&gt;</code> 元素上</p>
<blockquote>
<p>注意：不要在 <code>.navbar-nav</code> 内的 <code>&lt;a&gt;</code> 元素上使用 <code>.navbar-btn</code>，因为它不是标准的 button class。</p>
</blockquote>
<h5 id="5-导航栏中的文本"><a href="#5-导航栏中的文本" class="headerlink" title="5.导航栏中的文本"></a>5.导航栏中的文本</h5><p>如果导航栏中需要包含文本字符串，使用 <code>class .navbar-text</code> 这通常与 <code>&lt;p&gt;</code> 标签一起使用，确保适当的前导和颜色。</p>
<h5 id="6-结合图标的导航链接"><a href="#6-结合图标的导航链接" class="headerlink" title="6.结合图标的导航链接"></a>6.结合图标的导航链接</h5><p>如果需要在常规的导航栏导航组件中使用图标，使用  <code>class glyphicon glyphicon-*</code> 来设置图标。</p>
<h5 id="7-组件的对齐方式"><a href="#7-组件的对齐方式" class="headerlink" title="7.组件的对齐方式"></a>7.组件的对齐方式</h5><p>使用实用工具 <code>class .navbar-left</code> 或 <code>.navbar-right</code> 向左或向右对齐导航栏中的 导航链接、表单、按钮或文本 这些组件。</p>
<h5 id="8-固定到顶部"><a href="#8-固定到顶部" class="headerlink" title="8.固定到顶部"></a>8.固定到顶部</h5><p>如果需要将导航栏固定在页面的顶端，在 <code>.navbar class</code> 添加 <code>class .navbar-fixed-top</code>    </p>
<blockquote>
<p>注意：放置导航栏与主体页面主体中的其他内容的顶部交错，在<code>&lt;body&gt;</code>标签中添加至少50px的内边距<code>(padding)</code>视情况而定。</p>
</blockquote>
<h5 id="9-固定到底部"><a href="#9-固定到底部" class="headerlink" title="9.固定到底部"></a>9.固定到底部</h5><p>向 <code>.navbar class</code> 添加 <code>class .navbar-fixed-bottom</code></p>
<h5 id="10-静态的顶部"><a href="#10-静态的顶部" class="headerlink" title="10.静态的顶部"></a>10.静态的顶部</h5><p>如果需要创建能够随着页面一起滚动的导航栏，添加<code>.navbar-static-top class</code>。该 class 不要求向 <code>&lt;body&gt;</code> 添加内边距<code>（padding）</code></p>
<h5 id="11-反色的导航栏"><a href="#11-反色的导航栏" class="headerlink" title="11.反色的导航栏"></a>11.反色的导航栏</h5><p>创建一个带有黑色背景白色文本的反色导航栏，向 <code>.navbar class</code> 添加 <code>.navbar-inverse class</code> 即可</p>
<blockquote>
<p>注意：为了防止导航栏与页面主体中的其他内容的顶部相交错，向<body>标签添加至少50px的内边距(padding) 内边距值视情况而定</body></p>
</blockquote>
<h2 id="Bootstrap-面包屑导航（Breadcrumbs）"><a href="#Bootstrap-面包屑导航（Breadcrumbs）" class="headerlink" title="Bootstrap 面包屑导航（Breadcrumbs）"></a>Bootstrap 面包屑导航（Breadcrumbs）</h2><p>面包屑导航（Breadcrumbs）是一种基于网站层次信息的显示方式。以博客为例，面包屑导航可以显示发布日期、类别或标签。它们表示当前页面在导航层次结构内的位置。</p>
<p>Bootstrap 中的面包屑导航（Breadcrumbs）是一个简单的带有 <code>.breadcrumb class</code> 的无序列表(只需要在使用的时候在class中加上class=”breadcrumb”)</p>
<h2 id="Bootstrap-分页"><a href="#Bootstrap-分页" class="headerlink" title="Bootstrap 分页"></a>Bootstrap 分页</h2><p>分页（Pagination），是一种无序列表，Bootstrap 像处理其他界面元素一样处理分页</p>
<pre><code>1.分页

    .pagination 添加该 class 来在页面上显示分页
    .disabled  .active 我们可以自定义链接，通过使用 .disabled 来定义不可点击的链接，通过使用 .active 来指示当前的页面
    pagination-lg, .pagination-sm 使用这些 class 来获取不同大小的项

2.默认的分页

    在class属性为pagination 表示默认的分页功能

3.分页的状态

    class属性为disabled/active

4.分页的大小

    表示 pagination-* 的用法 class   大：pagination-lg  中：pagination   小：pagination-sm

5.翻页

    如果需要创建一个简单的分页链接为用户提供导航，可以通过翻页来实现

    .pager 添加该 class 来获得翻页链接

    .previous  .next 使用 class .previous 把链接向左对齐，使用 .next 把链接向右对齐

    .disabled 添加该 class 来设置对应按钮禁止使用


6.对齐的链接

    .previous  .next
</code></pre><h2 id="Bootstrap-标签"><a href="#Bootstrap-标签" class="headerlink" title="Bootstrap 标签"></a>Bootstrap 标签</h2><p>标签可用于计数、提示或页面上其他的标记显示，使用 <code>class .label</code> 来显示标签。<br>我们可以使用修饰的<code>class   label-default/label-primary/label-success/label-info/label-warning/label-danger</code> 来改变标签的外观</p>
<pre><code>label-default 默认灰色标签
label-primary 蓝色标签
label-warning 黄色标签
</code></pre><h2 id="Bootstrap-徽章（Badges）"><a href="#Bootstrap-徽章（Badges）" class="headerlink" title="Bootstrap 徽章（Badges）"></a>Bootstrap 徽章（Badges）</h2><p>徽章与标签相似，主要的区别在于徽章的边角更加圆滑。徽章（Badges）主要用于突出显示新的或未读的项。如需使用徽章，只需要把<code>&lt;span class=&quot;badge&quot;&gt;</code> 添加到链接、Bootstrap 导航等这些元素上即可。</p>
<h5 id="1-激活导航状态"><a href="#1-激活导航状态" class="headerlink" title="1.激活导航状态"></a>1.激活导航状态</h5><p>可以在激活状态的胶囊导航和列表导航中放置徽章，通过使用<code>&lt;span class=&quot;badge&quot;&gt;</code> 来激活链接。</p>
<h2 id="Bootstrap-超大屏幕（Jumbotron）"><a href="#Bootstrap-超大屏幕（Jumbotron）" class="headerlink" title="Bootstrap 超大屏幕（Jumbotron）"></a>Bootstrap 超大屏幕（Jumbotron）</h2><p>该组件可以增加标题的大小，并且为登录页面内容添加更多的外边距(margin)</p>
<pre><code>步骤：
    1.创建一个带有 class .jumbotron 的容器 &lt;div&gt;
    2.除了更大的 &lt;h1&gt;，字体粗细 font-weight 被减为 200
</code></pre><blockquote>
<p>注意：为了获得占用全部宽度且不带圆角的超大屏幕，需要在 <code>.container class</code> 外使用 <code>.jumbotron class</code></p>
</blockquote>
<h2 id="Bootstrap-页面标题（Page-Header）"><a href="#Bootstrap-页面标题（Page-Header）" class="headerlink" title="Bootstrap 页面标题（Page Header）"></a>Bootstrap 页面标题（Page Header）</h2><p>它会在网页标题四周添加适当的间距，当一个网页中有多个标题且每个标题之间需要添加一定的间距时，这个功能就有很强的作用。如果需要使用页面标题这个功能，我们需要将我们的标题放在带有 <code>class .page-header</code> 的<code>&lt;div&gt;</code>中</p>
<h2 id="Bootstrap-缩略图"><a href="#Bootstrap-缩略图" class="headerlink" title="Bootstrap 缩略图"></a>Bootstrap 缩略图</h2><pre><code>使用bootstrap创建缩略图步骤：

    1.在图像周围添加带有 class .thumbnail 的 &lt;a&gt; 标签

    2.这会添加四个像素的内边距(padding)和一个灰色的边框 特点

    3.当鼠标悬停在图像上时，会动画显示出图像的轮廓 结果

1.添加自定义的内容

    我们有一个基本缩略图，我们可以向缩略图中添加各种HTML内容(标题、段落、按钮)

    步骤：
        1.把带有 class .thumbnail 的 &lt;a&gt; 标签改为 &lt;div&gt;

        2.在该 &lt;div&gt; 内，您可以添加任何您想要添加的东西。由于这是一个 &lt;div&gt;，我们可以使用默认的基于 span 的命名规则来调整大小

        3.如果需要给多个图像进行分组，请把它们放置在一个无序列表中，且每个列表项向左浮动
</code></pre><h2 id="Bootstrap-警告（Alerts）"><a href="#Bootstrap-警告（Alerts）" class="headerlink" title="Bootstrap 警告（Alerts）"></a>Bootstrap 警告（Alerts）</h2><p>我们可以通过创建一个<div> 并向其中添加一个 .alert class 和四个上下文 class（即 .alert-success、.alert-info、.alert-warning、.alert-danger）之一，来添加一个基本的警告框</div></p>
<pre><code>1.可取消的警告(dismissal Alert)

    创建步骤：
        1.通过创建一个&lt;div&gt; 同时向其中添加一个 .alert class 和四个上下文 class（即 .alert-success、.alert-info、.alert-warning、.alert-danger）之一，来添加一个基本的警告框

        2.在上面的&lt;div&gt; class 添加可选的 .alert-dismissable

        3.添加一个关闭按钮
2.警告中的链接

    在上面的例子中成功添加好一个警告框之后，然后使用 .alert-link 实体类来快速提供带有匹配颜色的链接
</code></pre><h2 id="Bootstrap-进度条"><a href="#Bootstrap-进度条" class="headerlink" title="Bootstrap 进度条"></a>Bootstrap 进度条</h2><blockquote>
<p>注意：Bootstrap 进度条使用 CSS3 过渡和动画来获得该效果。Internet Explorer 9 及之前的版本和旧版的 Firefox 不支持该特性，Opera 12 不支持动画。</p>
</blockquote>
<pre><code>1.默认的进度条

    步骤：
        1.添加一个带有class.progress的&lt;div&gt;
        2.在上面创建好了的&lt;div&gt;中添加一个带有 class.progress-bar 的空的&lt;/div&gt;
        3.添加一个带有百分比表示的宽度的style属性。如：style=&quot;width:60%&quot;;表示进度条在60%的位置

2.交替的进度条

    步骤：
        1.添加带有 class.progress的&lt;div&gt;
        2.在已经建好的&lt;div&gt;中添加 class.progress-bar和class.progress-bar-*的空的&lt;div&gt; 其中，*可以是：success/info/warning/danger
        3.添加一个带有百分比表示的宽度的style属性。如：style=&quot;60%&quot;;用来表示进度条的位置

3.条纹进度条

    步骤：
        1.添加一个带有 class .progress 和 .progress-striped 的 &lt;div&gt;

            &lt;div class=&quot;progress progress-striped&quot;&gt;

        2.在上面的 &lt;div&gt; 内，添加一个带有 class .progress-bar 和 class progress-bar-* 的空的 &lt;div&gt;。
          其中，* 可以是 success、info、warning、danger。

            div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot;

        3.添加一个带有百分比表示的宽度的 style 属性，例如 style=&quot;60%&quot;; 表示进度条在 60% 的位置

4.动画进度条

步骤：

    1.添加一个带有 class .progress 和 .progress-striped 的 &lt;div&gt;。同时添加 class .active

        &lt;div class=&quot;progress progress-striped active&quot;&gt;

    2.然后在上面的 &lt;div&gt; 内，添加一个带有 class .progress-bar 的空的 &lt;div&gt;

        &lt;div class=&quot;progress-bar progress-bar-success&quot;

    3.添加一个带有百分比表示的宽度的 style 属性，例如 style=&quot;60%&quot;; 表示进度条在 60% 的位置。

         style=&quot;width: 40%;&quot;&gt; //这将会使条纹具有从右向左的运动感。

5.堆叠的进度条

    将多个进度条放在相同的 .progress 中即可实现堆叠 &lt;div class=&quot;progress&quot;&gt;
</code></pre><h2 id="Bootstrap-多媒体对象（Media-Object）"><a href="#Bootstrap-多媒体对象（Media-Object）" class="headerlink" title="Bootstrap 多媒体对象（Media Object）"></a>Bootstrap 多媒体对象（Media Object）</h2><p><code>.media</code>：该 class 允许将媒体对象里的多媒体（图像、视频、音频）浮动到内容区块的左边或者右边</p>
<p><code>.media-list</code>：如果你需要一个列表，各项内容是无序列表的一部分，可以使用该 class。可用于评论列表与文章列表</p>
<h2 id="Bootstrap-列表组"><a href="#Bootstrap-列表组" class="headerlink" title="Bootstrap 列表组"></a>Bootstrap 列表组</h2><p>列表组件用于以列表的形式呈现复杂的和自定义的内容</p>
<pre><code>创建步骤：
    1.向元素&lt;ul&gt;中添加 class .list-group
    2.向&lt;li&gt;添加 class .list-group-item

1.向列表组添加徽章

    我们可以向任意的列表项中添加徽章组件，其会自动定义到右边，我们只需要在&lt;li&gt;元素中添加&lt;span class=&quot;badge&quot;&gt;即可

2.向列表组添加链接

    通过使用锚点标签代替列表项，我们可以向列表组添加链接 通过添加&lt;a&gt;标签

3.向列表组添加自定义内容

    表示此后为列表组：&lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;
    添加一标题：&lt;h4 class=&quot;list-group-item-heading&quot;&gt;24*7 支持&lt;/h4&gt;
    添加一个段落：&lt;p class=&quot;list-group-item-text&quot;&gt;我们提供 24*7 支持。&lt;/p&gt;    
</code></pre><h2 id="Bootstrap-面板（Panels）"><a href="#Bootstrap-面板（Panels）" class="headerlink" title="Bootstrap 面板（Panels）"></a>Bootstrap 面板（Panels）</h2><p>面板组件作用于将DOM组件插入到一个盒子中，而创建一个基本的面板只需要向<div>元素中添加 <code>class .panel</code> 和 <code>class .panel-default</code> 即可</div></p>
<pre><code>1.面板标题

    可以通过两种方式添加面板标题：
        1.使用 .panel-heading class 可以很简单的向面板添加标题容器
        2.使用带有 .panel-title class 的&lt;h1&gt;-&lt;h6&gt;来添加预定义样式的标题

        注意：class .panel-body 标注面板内容块

2.面板脚注

    我们可以向面板中添加脚注，我们只需要将按钮或者副文本放在带有 class .panel-footer 的&lt;div&gt;中便可

        &lt;div class=&quot;panel panel-default&quot;&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    这是一个基本的面板
                &lt;/div&gt;

                &lt;div class=&quot;panel-footer&quot;&gt;面板脚注&lt;/div&gt;
        &lt;/div&gt;
</code></pre><blockquote>
<p>注意：面板脚注不会从带语境色彩的面板中继承颜色和边框，因为其不是前景中的内容</p>
</blockquote>
<pre><code>3.带语境色彩的面板

    语境状态类：可以通过 panel-primary、panel-success、panel-info、panel-warning、panel-danger 这些语境状态类来设置带语境色彩的面板

4.带表格的面板

    如果希望在面板中创建一个没有边框的表格，我们可以在面板中使用 class .table 如果有个&lt;div&gt;中包含 .panel-body 我们可以向表格的顶部添加额外的边框用来分隔     
    如果没有包含 .panel-body 的 &lt;div&gt;，则组件会无中断地从面板头部移动到表格

5.带有列表组的面板

    可以在任何面板中包含列表组，通过在&lt;div&gt;元素中添加 .panel 和 .panel-default 类来创建面板，同时在面板中添加列表项

    在&lt;class=&quot;panel-body&quot;&gt;之后创建一个列表组&lt;list-group&gt;
</code></pre><h2 id="Bootstrap-Well"><a href="#Bootstrap-Well" class="headerlink" title="Bootstrap Well"></a>Bootstrap Well</h2><p>Well 是一种会引起内容凹陷显示或插图效果的容器<code>&lt;div&gt;</code>如果需要创建 Well，只需要简单地把内容放在带有 <code>class .well</code> 的<code>&lt;div&gt;</code> 中即可</p>
<pre><code>    &lt;div class=&quot;well&quot;&gt;您好，我在 Well 中！&lt;/div&gt;

1.尺寸大小

    我们可以使用 well-lg 或者 well-sm 来改变well尺寸的大小 此外，这两个类是结合 .well 类使用的，这两个类会影响内边距(padding)，根据使用的类，well会显示的更大或者更小
</code></pre><h2 id="Bootstrap-创建一个网页"><a href="#Bootstrap-创建一个网页" class="headerlink" title="Bootstrap 创建一个网页"></a>Bootstrap 创建一个网页</h2><pre><code>1.创建一个简单的响应式网页
</code></pre><hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code>bootstrap本地引用：

        1.引用的包有：

            &lt;script src=&quot;dist/js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;
                &lt;script src=&quot;dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
                &lt;link href=&quot;dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;

        注意：1.在IDEA中创建静态工程，在这个工程下面直接创建HTML文档，然后放在dist目录下，这样就能够使用了
              2.src=&quot;dist/js/bootstrap.min.js&quot;不能写成 src=&quot;/dist/js/bootstrap.min.js&quot; 因为是相对路径
              3.jquery-1.9.1.min.js不需要改成jquery.min.js也是可以的

bootstrap 远程 CDN

        引入远程文件的顺序：

            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;  
            &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre><hr>
<h2 id="BootStrap-插件"><a href="#BootStrap-插件" class="headerlink" title="BootStrap 插件"></a>BootStrap 插件</h2><pre><code>Bootstrap 自带 12 种 jQuery 插件，扩展了功能，可以给站点添加更多的互动。利用 Bootstrap 数据 API（Bootstrap Data API），大部分的插件可以在不编写任何代码的情况被触发。

站点引用bootstrap的方式两种：

    1.单独引用：使用 Bootstrap 的个别的 *.js 文件   注意：一些插件和 CSS 组件依赖于其他插件，所以在单独引用插件的时候需要确保插件之间的依赖关系
    2.编译的同时引用：使用 bootstrap.js 或者是压缩版的 bootstrap.min.js

注意：所有的插件都是依赖于jQuery，所以我们在引入插件文件之前需要引入jQuery 注意版本之间的支持

1.data属性

    通过data属性API使用所有的bootstrap插件(首选)

2.编程方式的API(重要)

    所有的bootstrap插件都提供了纯JavaScript方式的API，所以公开的API都是支持单独或链式调用方式，并且返回其所操作元素的集合

    所有的方法都可以接受一个可选的选项对象作为参数或者一个代表特定方法的字符串，或者不带任何参数（这种情况下，将会初始化插件为默认行为）

    1.$(&quot;#myModal&quot;).modal()  //初始化默认行为
    2.$(&quot;#myModal&quot;).modal({ keyboard: false })  //初始化不支持键盘
    3.$(&quot;#myModal&quot;).modal(&apos;show&apos;)  //初始化并立即调用show

    注意：如果需要获取某个特定插件的实例，可以直接通过页面元素调取： $(&apos;[rel=popover]&apos;).data(&apos;popover&apos;)

3.避免命名空间冲突

    某些时候bootstrap插件可能要与UI框架插件一起使用，如果在使用过程中发生命名空间冲突，可以通过调用插件 .noConflict 方法恢复期原始值

4.事件

    bootstrap为大多数的插件的独特行为提供了自定义的插件，两种形式：

        1.动词不定式，这会在事件开始时被触发 如：ex:show 动词不定式事件提供了preventDefault功能，使得在事件开始前可以停止操作的执行

            $(&apos;#myModal&apos;).on(&apos;show.bs.modal&apos;, function (e) {
                // 阻止模态框的显示
                  if (!data) return e.preventDefault() 
            })

        2.过去分词形式，这会在动作执行完毕之后被触发。例如 ex: shown
</code></pre><h2 id="Bootstrap-过渡效果（Transition）插件"><a href="#Bootstrap-过渡效果（Transition）插件" class="headerlink" title="Bootstrap 过渡效果（Transition）插件"></a>Bootstrap 过渡效果（Transition）插件</h2><pre><code>这一插件提供了简单的过渡效果

注意：如果需要单独引用该插件的功能，除了其它的JS文件之外，还需要引用 transition.js 或者是引用bootstrap.js或者压缩版的 bootstrap.min.js 
</code></pre><h2 id="Bootstrap-模态框（Modal）插件"><a href="#Bootstrap-模态框（Modal）插件" class="headerlink" title="Bootstrap 模态框（Modal）插件"></a>Bootstrap 模态框（Modal）插件</h2><p>模态框（Modal）是覆盖在父窗体上的子窗体。通常，目的是显示来自一个单独的源的内容，可以在不离开父窗体的情况下有一些互动。子窗体可提供信息、交互等。</p>
<pre><code>1.使用方法

    切换模态框(modal)插件的隐藏内容：

        1.通过data属性：将控制器元素(如：按钮或者链接)上设置属性 data-toggle=&quot;modal&quot;，同时设置 data-target=&quot;#identifier&quot;或者是href=&quot;#identifier&quot;来指定要切换的特定的模态框(id=&quot;identifier&quot;)

        2.通过JavaScript：使用这种技术，我们可以通过简单的一行JavaScript来调用带有 id=&quot;identifier&quot;的模态框

            $(&apos;#identifier&apos;).modal(options)

        3.源码分析

            1.使用模态窗口需要触发某种触发器(可以是按钮或者链接)

            2.data-target=&quot;#mymodal&quot;  表示向要在页面上加载的模态框目标，所以可以在页面上创建多个模态框，然后为每个模态框创建不同的触发器
</code></pre><blockquote>
<p>注意：虽然不能同时使用多个模块，但是可以在页面上创建多个模块不同时间加载</p>
</blockquote>
<pre><code>        3.注意两点：
                1. .modal用来将&lt;div&gt;的内容识别为模态框 
                2. .fade class 当模态框切换时，它会引起内容淡入淡出 

            4.aria-labelledby=&quot;myModalLabel&quot; 该属性引用模态框的标题(引用会在后面创建的标题)

            5.属性 aria-hidden=&quot;true&quot; 
            用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）

            6.&lt;div class=&quot;modal-header&quot;&gt; modal-header 是为模态窗口的头部定义样式的类

            7.class=&quot;close&quot; close 是一个 CSS class，用于为模态窗口的关闭按钮设置样式

            8.data-dismiss=&quot;modal&quot; 在这里它被用于关闭模态窗口，是一个自定义 HTML5 属性

            9.class=&quot;modal-body&quot; 是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的主体设置样式

            10.class=&quot;modal-footer&quot; 是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的底部设置样式

            11.data-toggle=&quot;modal&quot; HTML5 自定义的 data 属性 data-toggle 用于打开模态窗口

2.选项

    选项可以用来定制模态窗口的外观和感观，通过data属性或者JavaScript来传递

    1.backdrop (data-backdrop) 指定一个静态背景，当用户点击模态框外部时不会关闭模态框
    2.keyboard (data-keyboard) 当按下escape键时，设置为false时无效
    3.show (data-show) 当初始化时显示模态框
    4.remote (data-remote) 

3.方法

    1. .modal(options) 将内容作为模态框激活，接受一个可选的选项对象  

        $(&apos;#identifier&apos;).modal({
            keyboard: false
        })

    2. .modal(&apos;toggle&apos;) 手动切换模态框  $(&apos;#identifier&apos;).modal(&apos;toggle&apos;)

    3. .modal(&apos;show&apos;) 手动打开模态框 $(&apos;#identifier&apos;).modal(&apos;show&apos;)

    4. .modal(&apos;hide&apos;) 手动隐藏模态框 $(&apos;#identifier&apos;).modal(&apos;hide&apos;)

4.事件

    1.show.bs.modal    在调用 show 方法后触发 

        $(&apos;#identifier&apos;).on(&apos;show.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    2.shown.bs.modal 当模态框对用户可见时触发（将等待 CSS 过渡效果完成） 

        $(&apos;#identifier&apos;).on(&apos;shown.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    3.hide.bs.modal    当调用 hide 实例方法时触发

        $(&apos;#identifier&apos;).on(&apos;hide.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    4.hidden.bs.modal 当模态框完全对用户隐藏时触发。    

        $(&apos;#identifier&apos;).on(&apos;hidden.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    5.loaded.bs.modal 
</code></pre><h2 id="Bootstrap-下拉菜单（Dropdown）插件"><a href="#Bootstrap-下拉菜单（Dropdown）插件" class="headerlink" title="Bootstrap 下拉菜单（Dropdown）插件"></a>Bootstrap 下拉菜单（Dropdown）插件</h2><p>使用下拉菜单插件可以向任何组件添加下拉菜单，如果想要单独引用该插件的功能，需要引用<code>dropdown.js</code></p>
<pre><code>1.使用方法

    可以切换下拉菜单的隐藏内容

    通过data属性：通过向链接或者按钮添加 data-toggle=&quot;dropdown&quot; 来切换下拉菜单

    通过JavaScript：$(&apos;.dropdown-toggle&apos;).dropdown()

2.方法

    下拉菜单切换有一个简单的方法(显示隐藏下拉菜单) $().dropdown(&apos;toggle&apos;)

3.扩展

    bootstrap给 a 之类的元素都绑定上事件，终止链接默认行为。
    1.data-toggle 表示以什么事件触发，常用的有：modal/popover/tooltips等
    2.data-target 表示事件的目标

    所以上面的两者一起使用表示data-target所指的元素以data-toggle指定的形式显示
</code></pre><h2 id="Bootstrap-滚动监听（Scrollspy）插件"><a href="#Bootstrap-滚动监听（Scrollspy）插件" class="headerlink" title="Bootstrap 滚动监听（Scrollspy）插件"></a>Bootstrap 滚动监听（Scrollspy）插件</h2><p>滚动监听也就是自动更新导航插件，根据滚动条的位置自动更新对应的导航目标 基于滚动条的位置向导航栏中添加 <code>.active class</code></p>
<blockquote>
<p>注意：如果需要单独引用该插件的功能，需要引用<code>scrollspy.js</code></p>
</blockquote>
<pre><code>1.使用方法

    通过data属性：向我们想要监听的元素(body)中添加 data-spy=&quot;scroll&quot; 然后添加带有bootstrap .nav 组件的父元素的ID或者class属性 data-target

        &lt;body data-spy=&quot;scroll&quot; data-target=&quot;.navbar-example&quot;&gt;
            &lt;div class=&quot;navbar-example&quot;&gt;

    通过JavaScript：$(&apos;body&apos;).scrollspy({ target: &apos;.navbar-example&apos; })

2.方法
    通过JavaScript调用scrollspy方法时，需要调用 .refresh 方法更新DOM 

        $(&apos;[data-spy=&quot;scroll&quot;]&apos;).each(function () {
              var $spy = $(this).scrollspy(&apos;refresh&apos;)
        })

3.事件

    滚动监听要用到的事件，这些事件可以在函数中当做钩子使用

        activate.bs.scrollspy 每当一个新项目被滚动监听激活时，触发该事件

        $(&apos;#myScrollspy&apos;).on(&apos;activate.bs.scrollspy&apos;, function () {
              // 执行一些动作...
        })

4.选项

    通过data属性或JavaScript来传递

        Data属性名称：data-offset 作用：当计算滚动位置时，距离顶部的偏移像素
</code></pre><h2 id="Bootstrap-标签页（Tab）插件"><a href="#Bootstrap-标签页（Tab）插件" class="headerlink" title="Bootstrap 标签页（Tab）插件"></a>Bootstrap 标签页（Tab）插件</h2><p>通过这个插件我们可以把内容放置在标签页或者是胶囊式标签页甚至是下拉菜单标签页中</p>
<pre><code>1.使用方法

    通过data属性：需要添加 data-toggle=&quot;tab&quot; 或 data-toggle=&quot;pill&quot; 到锚文本链接中

        添加 nav 和 nav-tabs 类到 ul 中，将会应用 Bootstrap 标签样式，添加 nav 和 nav-pills 类到 ul 中，将会应用 Bootstrap 胶囊式样式

    通过JavaScript：

        $(&apos;#myTab a&apos;).click(function (e) {
              e.preventDefault()
              $(this).tab(&apos;show&apos;)
        })

2.淡入淡出效果

    如果需要为标签页设置淡入淡出效果，请添加 .fade 到每个 .tab-panel 后面。第一个标签页必须添加 .in 类，以便淡入显示初始内容

        &lt;div class=&quot;tab-pane fade in active&quot; id=&quot;home&quot;&gt;...&lt;/div&gt;
        &lt;div class=&quot;tab-pane fade&quot; id=&quot;svn&quot;&gt;...&lt;/div&gt;

3.方法

    .$().tab：该方法可以激活标签页元素和内容容器。标签页需要用一个 data-target 或者一个指向 DOM 中容器节点的 href

4.事件

    show.bs.tab 该事件在标签页显示时触发，但是必须在新标签页被显示之前。
    分别使用 event.target 和 event.relatedTarget 来定位到激活的标签页和前一个激活的标签页。

        $(&apos;a[data-toggle=&quot;tab&quot;]&apos;).on(&apos;show.bs.tab&apos;, function (e) {
              e.target // 激活的标签页
              e.relatedTarget // 前一个激活的标签页
        })

    shown.bs.tab 该事件在标签页显示时触发，但是必须在某个标签页已经显示之后。
    分别使用 event.target 和 event.relatedTarget 来定位到激活的标签页和前一个激活的标签页。

        $(&apos;a[data-toggle=&quot;tab&quot;]&apos;).on(&apos;shown.bs.tab&apos;, function (e) {
              e.target // 激活的标签页
              e.relatedTarget // 前一个激活的标签页
        })

5.tabindex

    模态框中tabindex属性规定元素的tab键控制顺序(此时tab键用于导航)，出了safari浏览器之外，其他浏览器都有tabindex属性
</code></pre><h2 id="Bootstrap-提示工具（Tooltip）插件"><a href="#Bootstrap-提示工具（Tooltip）插件" class="headerlink" title="Bootstrap 提示工具（Tooltip）插件"></a>Bootstrap 提示工具（Tooltip）插件</h2><pre><code>1.使用方法

    通过data属性：如果需要添加提示工具(tooltip)放在他们的触发元素里面，只需要向一个锚标签添加 data-toggle=&quot;tooltip&quot; 即可 默认情况下，插件将提示工具(tooltip)设置在顶部

    &lt;a href=&quot;#&quot; data-toggle=&quot;tooltip&quot; title=&quot;Example tooltip&quot;&gt;请悬停在我的上面&lt;/a&gt;

    通过JavaScript

    $(&apos;#identifier&apos;).tooltip(options)

    注意：使用该插件需要激活 $(function () { $(&quot;[data-toggle=&apos;tooltip&apos;]&quot;).tooltip(); });

2.选项
</code></pre><h2 id="Bootstrap-弹出框（Popover）插件"><a href="#Bootstrap-弹出框（Popover）插件" class="headerlink" title="Bootstrap 弹出框（Popover）插件"></a>Bootstrap 弹出框（Popover）插件</h2><pre><code>1.使用方法

    通过data属性：向一个锚标签添加 data-toggle=&quot;popover&quot; 即可 锚的title=&quot;弹出框(popover)&quot;的文本 默认情况下，插件将弹出框（popover）设置在顶部        

        &lt;a href=&quot;#&quot; data-toggle=&quot;popover&quot; title=&quot;Example popover&quot;&gt;
                    请悬停在我的上面
        &lt;/a&gt;

    通过JavaScript

        $(&apos;#identifier&apos;).popover(options)

    注意：使用该插件需要使用脚本来启用页面中的所有的弹出框(popover) $(function () { $(&quot;[data-toggle=&apos;popover&apos;]&quot;).popover(); });
</code></pre><h2 id="Bootstrap-警告框（Alert）插件"><a href="#Bootstrap-警告框（Alert）插件" class="headerlink" title="Bootstrap 警告框（Alert）插件"></a>Bootstrap 警告框（Alert）插件</h2><pre><code>使用警告框（Alert）插件，可以向所有的警告框消息添加可取消（dismiss）功能

1.使用方法

两种方式启用警告框的可取消功能

    通过data属性：向关闭按钮中添加 data-dismiss=&quot;alert&quot; 就会自动为警告框添加关闭功能

        &lt;a class=&quot;close&quot; data-dismiss=&quot;alert&quot; href=&quot;#&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/a&gt;

    通过JavaScript：$(&quot;.alert&quot;).alert()

2.方法

    .alert() 该方法让所有的警告框都带有关闭功能  语法：$(&apos;#identifier&apos;).alert();

    .alert(&apos;close&apos;)    关闭所有的警告框  语法：$(&apos;#identifier&apos;).alert(&apos;close&apos;);
</code></pre><blockquote>
<p>注意：如果需要在关闭时启用动画效果，需要添加 <code>.fade</code> 和 <code>.in class</code></p>
</blockquote>
<pre><code>3.事件

    close.bs.alert 当调用 close 实例方法时立即触发该事件

        $(&apos;#myalert&apos;).bind(&apos;close.bs.alert&apos;, function () {
              // 执行一些动作...
        })

    closed.bs.alert    当警告框被关闭时触发该事件（将等待 CSS 过渡效果完成）

        $(&apos;#myalert&apos;).bind(&apos;closed.bs.alert&apos;, function () {
                // 执行一些动作...
        })
</code></pre><h2 id="Bootstrap-按钮（Button）插件"><a href="#Bootstrap-按钮（Button）插件" class="headerlink" title="Bootstrap 按钮（Button）插件"></a>Bootstrap 按钮（Button）插件</h2><pre><code>通过按钮（Button）插件，我们可以添加进一些交互，比如控制按钮状态，或者为其他组件（如工具栏）创建按钮组

1.加载状态

    如果我们需要向按钮中添加加载状态，向button元素添加 data-loading-text=&quot;loading...&quot; 作为其属性便可

2.单个切换

    如果需要激活单个按钮的切换(即改变按钮的正常状态为按压状态，反之亦然)，向 button 元素添加 data-toggle=&quot;button&quot; 作为其属性即可

3.复选框

    创建复选框组，并通过向 btn-group 添加 data 属性 data-toggle=&quot;buttons&quot; 来添加复选框组的切换

4.单选按钮

    创建单选按钮组，通过向 btn-group 添加 data 属性 data-toggle=&quot;buttons&quot; 来添加单选按钮组的切换

注意：可以通过JavaScript启用按钮插件 $(&apos;.btn&apos;).button()
</code></pre><h2 id="Bootstrap-折叠（Collapse）插件"><a href="#Bootstrap-折叠（Collapse）插件" class="headerlink" title="Bootstrap 折叠（Collapse）插件"></a>Bootstrap 折叠（Collapse）插件</h2><pre><code>折叠（Collapse）插件可以很容易地让页面区域折叠起来

    1.data-toggle=&quot;collapse&quot; 添加到想要展开或折叠的组件的链接上

    2.href 或 data-target 属性添加到父组件，它的值是子组件的 id

    3.data-parent 属性把折叠面板（accordion）的 id 添加到要展开或折叠的组件的链接上

1.使用方法

    .collapse 隐藏内容
    .collapse.in 显示内容
    .collapsing 当过渡效果开始时被添加，当过渡效果完成时被移除
</code></pre><blockquote>
<p>注意：通过两种方式使用折叠插件 </p>
<blockquote>
<p>1.通过data属性：向元素添加 data-toggle=”collapse” 和 data-target，自动分配可折叠元素的控制，确保可折叠元素已经添加了class .collapse 同时如果希望在默认情况下是打开的，需要添加额外的class .in。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.通过JavaScript：$(‘.collapse’).collapse()</p>
</blockquote>
</blockquote>
<pre><code>2.方法

3.事件
</code></pre><h2 id="Bootstrap-轮播（Carousel）插件"><a href="#Bootstrap-轮播（Carousel）插件" class="headerlink" title="Bootstrap 轮播（Carousel）插件"></a>Bootstrap 轮播（Carousel）插件</h2><h5 id="1-可选的标题"><a href="#1-可选的标题" class="headerlink" title="1.可选的标题"></a>1.可选的标题</h5><p>可以通过 .item 内的 .carousel-caption 元素向幻灯片添加标题</p>
<h5 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h5><p>通过 data 属性：</p>
<p>使用 data 属性可以很容易控制轮播（Carousel）的位置<br>属性 <code>data-slide</code> 接受关键字 <code>prev</code> 或 <code>next</code>，用来改变幻灯片相对于当前位置的位置。<br>使用 <code>data-slide-to</code> 来向轮播传递一个原始滑动索引，<code>data-slide-to=&quot;2&quot;</code> 将把滑块移动到一个特定的索引，索引从 0 开始计数<br><code>data-ride=&quot;carousel&quot;</code> 属性用于标记轮播在页面加载时就开始动画播放。</p>
<p>通过 JavaScript：轮播（Carousel）可通过 JavaScript 手动调用 </p>
<blockquote>
<p><code>语法：$(&#39;.carousel&#39;).carousel()</code></p>
</blockquote>
<h2 id="Bootstrap-附加导航（Affix）插件"><a href="#Bootstrap-附加导航（Affix）插件" class="headerlink" title="Bootstrap 附加导航（Affix）插件"></a>Bootstrap 附加导航（Affix）插件</h2><pre><code>该插件允许指定&lt;div&gt;固定在页面的某个位置，不会随着页面其他部分一起滚动

1.使用方法

通过 JavaScript：您可以通过 JavaScript 手动为某个元素添加附加导航（Affix）

    $(&apos;#myAffix&apos;).affix({
           offset: {
                  top: 100, bottom: function () {
                     return (this.bottom = 
                            $(&apos;.bs-footer&apos;).outerHeight(true))
                         }
                  }
    })

通过data属性：如果要向元素添加附加导航行为，只需要向需要监听的元素添加 data-spy=&quot;affix&quot; 同时需要使用偏移来定义何时切换元素的锁定和移动

2.通过CSS定位

    注意：在使用附加导航插件的方式中，需要通过CSS定位内容，然后每种class都呈现特定的状态：.affix .affix-top .affix-bottom

    步骤：1.在插件添加 .affix-top 来指定元素在它最顶端位置    
          2.当滚动经过添加了附加导航的元素时，应触发实际的附加导航(affix)，此时的 .affix 会替代 .affix-top 同时设置 position:fixed;
          3.如果定义了底部偏移，当滚动到此位置时，应该将 .affix 替换为 .affix-bottom 注意：如果此时设置了此偏移，那么需要设置适当的css。在这种情况下，必要时候添加 position:absolute;

3.选项

    选项：offset  data属性名称：data-offset 当计算机滚动位置时，距离顶部的偏移像素。如果设置了属性值，则该偏移量将被应用到顶部或底部
</code></pre><hr>
<hr>
<blockquote>
<p>扩展</p>
<blockquote>
<p>freemaker FTL指令常用标签及语法 注意：使用freemarker要求所有标签必须闭合，否则freemarker标签无法解析。</p>
<blockquote>
<p>1.注释：&lt;#–注释内容–&gt;(格式)   2.取值：代替输出数据模型的部分，格式：${数据模型}或#{数据模型}</p>
<blockquote>
<p>freemarker语法及使用方法：</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code>1. ${var} Java基本类型及String引用类型。  
2. ${var!} 对null或者不存在的对象进行取值，可以设置默认值。如：${var! &apos;我是默认值&apos;} 表示有值时显示正常值，无值时显示默认值。
3. ${封装对象.属性} 用于对封装对象进行取值。 
4. ${date?String(&apos;yyyy-MM-dd&apos;)} 用于对日期格式进行取值，需要注意的是，定义Date类型的变量时，java.util.Date无法输出日期，必须使用java.sql.Date。 
5. ${var?html} 转移HTML。 
6. &lt;#assign num = 100 /&gt; 定义变量，支持计算和赋值。 

7.对List集合进行取值
&lt;#list  list集合  as  item&gt; 
    ${item} --取值
&lt;/#list&gt;

8.对Map集合进行取值
&lt;#list map?keys as key&gt;
    ${key}:${map[key]}
&lt;/#list&gt;
如：Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
    m.put(&quot;name&quot;,&quot;姓名&quot;);
    m.put(&quot;age&quot;,18);
    m.put(&quot;sex&quot;,&quot;男&quot;);
然后在页面中获取变量：
    &lt;#list m?keys as key&gt;
        ${key}:${m[key]}
    &lt;/#list&gt;
然后得到结果：
    name:姓名
    age:18
    sex:男

9.条件判断指令
    1.&lt;#if 条件&gt;
        输出
      &lt;#else&gt;
         输出
      &lt;/#if&gt;
    2.switch指令，经常与case、break和default指令一起使用，参数可以为字符串。
        &lt;#switch var&gt;
            &lt;#case 条件1&gt;
                输出
            &lt;#break&gt;
            &lt;#case 条件2&gt;
                输出
            &lt;#break&gt;
            &lt;#default&gt;
                输出
        &lt;/#switch&gt;

10.自定义指令
    &lt;@自定义指令名称 入参(key-value格式) ; 出参(list格式)&gt;
        运行条件
    &lt;/@自定义指令名称&gt;

     PS:不同的返回值用逗号间隔开

11.常用内建函数、macro(宏指令)、function(函数指令)
</code></pre>]]></content>
      <categories>
        <category>BootStrap</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/undefined/jQuery/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-jQuery语法"><a href="#1-jQuery语法" class="headerlink" title="1.jQuery语法"></a>1.jQuery语法</h2><pre><code>jQuery语法是通过选取 HTML 元素，并对选取的元素执行某些操作。

jQuery 入口函数与 JavaScript 入口函数的区别：

     1.jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   //文档就绪之后执行jQuery方法</span><br><span class="line">$(function()&#123;</span><br><span class="line">   	// 执行代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<pre><code>2.JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。
</code></pre><h2 id="2-jQuery-选择器"><a href="#2-jQuery-选择器" class="headerlink" title="2.jQuery 选择器"></a>2.jQuery 选择器</h2><p>jQuery 选择器(jQuery 选择器允许我们对 HTML 元素组或单个元素进行操作)基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素，jQuery 中所有选择器都以美元符号开头：$()。</p>
<p>  1.#id 选择器<br>    jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素，页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。</p>
<pre><code>语法：$(&quot;#test&quot;)
</code></pre><p>  2..class 选择器<br>    jQuery 类选择器可以通过指定的 class 查找元素</p>
<pre><code>语法：$(&quot;.test&quot;)
</code></pre><p>  3.元素选择器<br>    jQuery 元素选择器基于元素名选取元素</p>
<pre><code>语法：$(&quot;p&quot;) 表示选取页面中所有的&lt;p&gt;元素
</code></pre><p>  4.过滤选择器<br>    主要是通过特定的过滤规则筛选出所需要的DOM元素 过滤规则：选择器以(:)开头</p>
<pre><code>主要过滤选择器：
    1.:first 选取第一个元素
    2.:last 选取最后一个元素
    3.:header 选取所有的标题元素，如：h2/h3/h1等
    ...

案例：
    //改变第一个&lt;div&gt;元素的背景色
    $(&apos;div:first&apos;).css(&quot;background&quot;,&quot;#bbffaa&quot;);
</code></pre><h2 id="3-jQuery-事件"><a href="#3-jQuery-事件" class="headerlink" title="3.jQuery 事件"></a>3.jQuery 事件</h2><pre><code>事件(jQuery 是为事件处理特别设计的)：页面对不同访问者的响应叫做事件 事件处理程序指的是当HTML中发生某些事件时所调用的方法
</code></pre><h4 id="1-jQuery-事件方法语法"><a href="#1-jQuery-事件方法语法" class="headerlink" title="1.jQuery 事件方法语法"></a>1.jQuery 事件方法语法</h4><pre><code>在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法
1.$(&quot;p&quot;).click();//页面中点击事件的语法，然后在事件触发之后让其执行相关的事件处理程序
2.常用的jQuery事件方法
    1.click() 该方法是当按钮点击事件被触发时会调用的一个函数
        $(&quot;p&quot;).click(function(){
            $(this).hide();
        });
    2.dblclick() 当双击元素时，会发生dblclick事件
    3.mouseenter() 当鼠标指针穿过元素时，会发生 mouseenter 事件
    4.mouseleave() 当鼠标指针离开元素时，会发生 mouseleave 事件
    5.mousedown() 
    ...
3.
</code></pre><h4 id="2-事件绑定"><a href="#2-事件绑定" class="headerlink" title="2.事件绑定"></a>2.事件绑定</h4><pre><code>1.基本效果
在文档装载完成之后，如果需要为元素绑定事件来完成操作，可以使用bind()方法来对匹配元素进行特定事件的绑定。
格式：
    bind(type [,data],fn);
    1.type:事件类型
    2.可选参数，作为event、data属性值传递给事件对象的额外数据对象
    3.fn:用来绑定操作的处理函数
</code></pre><blockquote>
<p>注意：jQuery中的事件绑定类型比普通的JavaScript事件绑定类型少了on</p>
</blockquote>
<pre><code>案例：
    $(function(){
        $(&quot;#panel h5.head&quot;).bind(&quot;click&quot;,function(){
            $(this).next(&quot;div.content&quot;).show();
        })
    })
</code></pre><blockquote>
<p>注意：在jQuery中的关键字this，this引用的是携带相应行为的DOM元素</p>
</blockquote>
<pre><code>2.加强效果

3.改变事件的绑定类型

4.简写绑定事件
</code></pre><h2 id="4-jQuery效果"><a href="#4-jQuery效果" class="headerlink" title="4.jQuery效果"></a>4.jQuery效果</h2><pre><code>1.hide()/show() 通过hide()和show()方法来隐藏和显示HTML元素
    //hide()方法
    $(&quot;#hide&quot;).click(function(){
        $(&quot;p&quot;).hide();
    });
    //show()方法
    $(&quot;#show&quot;).click(function(){
        $(&quot;p&quot;).show();
    });
2.toggle() 使用 toggle() 方法来切换 hide() 和 show() 方法
3.fadeIn() 用于淡入已隐藏的元素
    //fadeIn()方法中的效果时长：&quot;slow&quot;/fast以及毫秒值
    $(&quot;button&quot;).click(function(){
        $(&quot;#div1&quot;).fadeIn();
        $(&quot;#div2&quot;).fadeIn(&quot;slow&quot;);
        $(&quot;#div3&quot;).fadeIn(3000);
    });
4.fadeOut() 方法用于淡出可见元素
    //类似于fadeIn()方法，其也能够控制效果时长
    $(&quot;button&quot;).click(function(){
        $(&quot;#div1&quot;).fadeOut();
        $(&quot;#div2&quot;).fadeOut(&quot;slow&quot;);
        $(&quot;#div3&quot;).fadeOut(3000);
    });
5.fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换
  如果元素已淡出，则fadeToggle()会向元素添加淡入效果 如果元素已淡入，则fadeToggle()会向元素添加淡出效果

6.fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）
  opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）
7.slideDown() 方法用于向下滑动元素
        $(&quot;#flip&quot;).click(function(){
            $(&quot;#panel&quot;).slideDown();
        });
8.slideUp() 方法用于向上滑动元素
        $(&quot;#flip&quot;).click(function(){
            $(&quot;#panel&quot;).slideUp();
        });
9.slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换
10.animate() 用于创建自定义动画
   语法：$(selector).animate({params},speed,callback);
   1.params:定义形成动画的css属性
   2.speed:可以是fast/slow/毫秒值
   3.callback:可选，表示动画完成之后所执行的函数名称
        $(&quot;button&quot;).click(function(){
            $(&quot;div&quot;).animate({left:&apos;250px&apos;});
        });
</code></pre><h2 id="5-jQuery-方法链接"><a href="#5-jQuery-方法链接" class="headerlink" title="5.jQuery 方法链接"></a>5.jQuery 方法链接</h2><p>有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。</p>
<blockquote>
<p>提示： 这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，只需简单地把该动作追加到之前的动作上。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//表示p1元素会首先变成红色，然后向上滑动，最后向下滑动</span><br><span class="line">$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000);</span><br></pre></td></tr></table></figure>
<pre><code>1.jQuery方法
    1. on()方法 该方法在被选元素及子元素上添加一个或多个事件处理程序
</code></pre><blockquote>
<p>注意：使用on()方法添加的事件处理程序适用于当前及未来的元素</p>
<blockquote>
<p>提示：<br>1.如果需要移除事件处理程序，使用off()方法 2.如需添加只运行一次的事件然后移除，请使用 one() 方法</p>
</blockquote>
</blockquote>
<pre><code>2.event.preventDefault() 方法 阻止元素发生默认的行为
例如：点击提交按钮时阻止对表单的提交或阻止URL的链接等 
</code></pre><blockquote>
<p>提示：请使用 event.isDefaultPrevented() 方法来检查指定的事件上是否调用了 preventDefault() 方法</p>
<blockquote>
<p>注意：参数event必须，是来自事件绑定绑定函数</p>
</blockquote>
</blockquote>
<h2 id="6-jQuery-获取内容和属性"><a href="#6-jQuery-获取内容和属性" class="headerlink" title="6.jQuery 获取内容和属性"></a>6.jQuery 获取内容和属性</h2><blockquote>
<p>前提：jQuery 提供一系列与 DOM(文档对象模型)<br>相关的方法，这使访问和操作元素和属性变得很容易</p>
</blockquote>
<h4 id="1-获取内容-方法"><a href="#1-获取内容-方法" class="headerlink" title="1.获取内容(方法)"></a>1.获取内容(方法)</h4><pre><code>1.text() - 设置或返回所选元素的文本内容
2.html() - 设置或返回所选元素的内容（包括 HTML 标记）
3.val() - 设置或返回表单字段的值
4.attr() 方法用于获取属性值
</code></pre><blockquote>
<p>注意：1.对于<code>HTML</code>元素本身就带有的固有属性，在处理时，使用 prop 方法。对于 HTML 元素我们自己自定义的 DOM 属性，在处理时，使用 attr 方法</p>
</blockquote>
<h4 id="2-设置内容和属性"><a href="#2-设置内容和属性" class="headerlink" title="2.设置内容和属性"></a>2.设置内容和属性</h4><pre><code>1.attr() 用于设置或改变一个或多个属性值
</code></pre><h4 id="3-添加元素"><a href="#3-添加元素" class="headerlink" title="3.添加元素"></a>3.添加元素</h4><pre><code>1.append() 在被选元素结尾插入内容
2.prepend() 在被选元素开头插入内容
3.after() 在被选元素之后插入内容
4.before() 在被选元素之前插入内容
</code></pre><blockquote>
<p>总结：1.append()/prepend() 是在选择元素内部嵌入 2.after()/before()是在元素外面追加</p>
</blockquote>
<h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><pre><code>如果需要删除元素，一般使用remove()/empty()方法。
1.remove() 删除被选元素以及子元素
    //此时删除的不仅是div1里面的内容，而且还有div1这个块
    $(&quot;#div1&quot;).remove();
2.empty() 从被选元素中删除子元素
    //此时仅仅删除的是div1里面的内容，并没有删除div1这个块
    $(&quot;#div1&quot;).empty();
3.过滤被删除的元素
    //即就是接受一个参数，删除该参数下所有的元素
    $(&quot;p&quot;).remove(&quot;.italic&quot;);//表示删除class=&quot;italic&quot;下面的所有&lt;p&gt;元素
</code></pre><h2 id="7-jQuery-css-方法"><a href="#7-jQuery-css-方法" class="headerlink" title="7.jQuery css() 方法"></a>7.jQuery css() 方法</h2><pre><code>1.css() 方法设置或返回被选元素的一个或多个样式属性
</code></pre><blockquote>
<p>扩展</p>
<blockquote>
<p>JavaScript Object.keys()方法<br><br>作用：返回对象的可枚举属性和方法的名称</p>
<blockquote>
<p>语法：Object.keys(object)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="8-jQuery-尺寸"><a href="#8-jQuery-尺寸" class="headerlink" title="8.jQuery 尺寸"></a>8.jQuery 尺寸</h2><pre><code>1.width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）
2.height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）
3.innerWidth() 方法返回元素的宽度（包括内边距）
4.innerHeight() 方法返回元素的高度（包括内边距）
5.outerWidth() 方法返回元素的宽度（包括内边距和边框）
6.outerHeight() 方法返回元素的高度（包括内边距和边框）
</code></pre><h2 id="9-jQuery-遍历"><a href="#9-jQuery-遍历" class="headerlink" title="9.jQuery 遍历"></a>9.jQuery 遍历</h2><h4 id="1-祖先"><a href="#1-祖先" class="headerlink" title="1.祖先"></a>1.祖先</h4><pre><code>通过 jQuery，能够向上遍历 DOM 树，以查找元素的祖先

1.parent() 方法返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历
        //表示只返回span元素的直接父元素(如：&lt;ul&gt;/&lt;li&gt;)
        $(document).ready(function(){
            $(&quot;span&quot;).parent();
        });
2.parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)
        //返回元素span的所有父元素
        $(document).ready(function(){
            $(&quot;span&quot;).parents();
        });
3.parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素
        //返回介于span元素与div元素之间所有的父元素
        $(document).ready(function(){
            $(&quot;span&quot;).parentsUntil(&quot;div&quot;);
        });
</code></pre><h4 id="2-后代"><a href="#2-后代" class="headerlink" title="2.后代"></a>2.后代</h4><pre><code>通过jQuery，我们可以向下遍历DOM树，查找元素的所有后代

1.children()方法 返回被选元素的所有直接子元素，该方法只会向下一级对 DOM 树进行遍历
        //返回div元素的所有子元素，不会越级返回元素
        $(document).ready(function(){
            $(&quot;div&quot;).children();
        });
</code></pre><blockquote>
<p>注意：可以使用可选参数来过滤子元素的搜索</p>
</blockquote>
<pre><code>//表示返回类名为class_1的所有&lt;p&gt;元素，且这些元素是&lt;div&gt;的直接子元素
$(document).ready(function(){
    $(&quot;div&quot;).children(&quot;p.class_1&quot;);
});

    2.find()方法 返回被选元素的后代元素，一路向下直到最后一个后代
            //表示返回div元素后代的所有span元素
            $(document).ready(function(){
                $(&quot;div&quot;).find(&quot;span&quot;);
            });

            //表示返回div元素的所有后代
            $(document).ready(function(){
                $(&quot;div&quot;).find(&quot;*&quot;);
            });
</code></pre><h4 id="3-同胞"><a href="#3-同胞" class="headerlink" title="3.同胞"></a>3.同胞</h4><blockquote>
<p>前提：同胞拥有相同的父元素，通过 jQuery，我们能够在 DOM 树中遍历元素的同胞元素</p>
</blockquote>
<pre><code>1.next() 方法返回被选元素的下一个同胞元素
        //表示返回h2元素的下一个同胞元素
        $(document).ready(function(){
            $(&quot;h2&quot;).next();
        });

2.nextAll() 方法返回被选元素的所有跟随的同胞元素
        //表示返回h2元素的所有跟随同胞元素
        $(document).ready(function(){
            $(&quot;h2&quot;).nextAll();
        });

3.nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素
        //返回介于h2-h6之间的所有的跟随同胞元素
        $(document).ready(function(){
            $(&quot;h2&quot;).nextUntil(&quot;h6&quot;);
        });

4.siblings() 方法返回被选元素的所有同胞元素
</code></pre><blockquote>
<p>注意：prev() prevAll() 以及 prevUntil()<br>方法的工作方式与上面的方法类似。只不过是工作方向相反而已，它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）</p>
</blockquote>
<h4 id="4-过滤"><a href="#4-过滤" class="headerlink" title="4.过滤"></a>4.过滤</h4><blockquote>
<p>基本的过滤方法：first()/last()和eq()，它们允许我们基于其在一组元素中的位置来选择一个特定的元素</p>
</blockquote>
<pre><code>1.first() 方法返回被选元素的首个元素
        //选取首个 &lt;div&gt; 元素内部的第一个 &lt;p&gt; 元素
        $(document).ready(function(){
            $(&quot;div p&quot;).first();
        });

2.last() 方法返回被选元素的最后一个元素
        //选择最后一个 &lt;div&gt; 元素中的最后一个 &lt;p&gt; 元素
        $(document).ready(function(){
            $(&quot;div p&quot;).last();
        });

3.eq() 方法返回被选元素中带有指定索引号的元素
        //索引号从 0 开始，因此首个元素的索引号是 0 而不是 1
        $(document).ready(function(){
            $(&quot;p&quot;).eq(1);
        });

4.filter() 方法允许我们规定一个标准，如果元素不匹配这个标准的会被从集合中删除，匹配的元素会被返回
        //返回带有类名 &quot;url&quot; 的所有 &lt;p&gt; 元素
        $(document).ready(function(){
            $(&quot;p&quot;).filter(&quot;.url&quot;);
        });
</code></pre><hr>
<h2 id="10-jQuery-AJAX"><a href="#10-jQuery-AJAX" class="headerlink" title="10.jQuery - AJAX"></a>10.jQuery - AJAX</h2><p>AJAX 与服务器交换的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。</p>
<blockquote>
<p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML） 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：ajax的工作原理相当于在用户和服务器之间加了一个中间层(AJAX引擎)，使用户操作与服务器响应异步化</p>
</blockquote>
</blockquote>
<p><code>jQuery</code> 提供多个与 <code>AJAX</code> 有关的方法，通过 <code>jQuery AJAX</code> 方法，我们能够使用 <code>HTTP Get</code> 和 <code>HTTP Post</code> 从远程服务器上<code>请求文本、HTML、XML 或 JSON</code>同时我们能够把这些外部数据直接载入网页的被选元素中 是用于创建快速动态网页的技术。</p>
<blockquote>
<p>Ajax只刷新局部网页的技术：</p>
</blockquote>
<pre><code>1.JavaScript：更新局部的网页
2.XML：一般用于请求数据和响应数据的封装
3.XMLHttpRequest对象：发送请求到服务器并获得返回结果(该对象是整个Ajax技术的核心，提供异步发送请求的能力)
4.异步：发送请求后不等返回结果，由回调函数处理结果
</code></pre><p>0.open()方法 建立与服务器的连接</p>
<pre><code>method：post/get 该参数指定请求的http方法
URL：该参数指定请求的地址
async：该参数指定是否使用异步请求
setRequestHeader：设置请求头信息
</code></pre><p>1.load() 方法是简单但强大的 AJAX 方法<br>作用：从服务器加载数据，并把返回的数据放入被选元素中</p>
<pre><code>1.URL参数规定所希望加载的URL 
2.data参数规定与请求一同发送的查询字符串键值对集合
语法：$(selector).load(URL,data,callback); 
如：
    $(&quot;#hello&quot;).load(&quot;text.html&quot;);
</code></pre><p>2.$.get() 方法<br>作用：通过 HTTP GET 请求从服务器上请求数据</p>
<pre><code>1.URL(String) 请求的HTML网页的URL地址
2.data 传递的数据 callback(data,status)：请求完成时的回调函数，data指从服务器响应的地址，status 指服务器请求的响应状态
语法：$.get(URL，data,callback)

    URL 参数规定您希望请求的 URL 
    callback 参数是请求成功后所执行的函数名(可选)
</code></pre><blockquote>
<p>语法：$.get(URL,callback);</p>
</blockquote>
<p>3.$.post() 方法通过 HTTP POST 请求向服务器提交数据</p>
<pre><code>1.URL 参数规定您希望请求的 URL 
2.data 参数规定连同请求发送的数据(可选) 
3.callback参数是请求成功后所执行的函数名(可选)
</code></pre><blockquote>
<p>语法：$.post(URL,data,callback); </p>
</blockquote>
<blockquote>
<blockquote>
<p>get与post请求的区别：1.get方法通常用来从指定的资源请求数据(可用于缓存、保存浏览器历史记录、只应当用于取回数据)。2.post方法通常用来向指定的资源提交要被处理的数据(post请求不会被缓存、请求不会保存在浏览器历史记录中、对请求数据长度没有限制、主要是向服务器提交数据，特别是大批量的数据)</p>
</blockquote>
</blockquote>
<p>4.ajax() 该方法通过HTTP请求加载远程数据，是jQurey底层AJAX实现，$.ajax() 返回其创建的 XMLHttpRequest 对象，在最简单的情况下，$.ajax()可以不带任何参数直接使用。</p>
<p>注意：所有的选项都可以通过 $.ajaxSetup() 函数来全局设置</p>
<blockquote>
<p>语法：jQuery.ajax([settings]) </p>
<blockquote>
<p>settings：用于配置AJAX请求的键值对集合 可以通过$.ajaxSetup() 设置任何选项的默认值</p>
</blockquote>
</blockquote>
<pre><code>该方法常见的参数：

    URL：发送请求的地址
    type：请求的方法(get/post)
    timeout：设置请求超时时间
    async：默认为true，表示为异步请求，false表示为同步请求
    beforeSend：发送请求前触发该事件
    cache：默认为true，表示从浏览器缓存中加载请求信息
    complete：请求结束后触发该事件
    contentType：发送信息到服务器时内容编码的类型
    data：发送到服务器的数据
    dataType：预期服务器返回的数据类型
    error：表示请求失败时调用的方法
    global：设置为false将不会触发全局ajax事件
    ifModified：仅在服务器数据改变时获取新数据 
    processData：发送的数据将被转换为对象 
    success：请求成功后回调函数
</code></pre><p>5.ajax提交form表单方法</p>
<p>在日常项目中经常使用到ajax提交form表单，而ajax提交表单有两种方式：</p>
<pre><code>1.无返回结果，直接将表单交给后台，让后台直接处理 最简单的：$(“#formid”).submit();//直接将form表单提交到后台。

2.有返回结果的，在这种情况下，后台不管执行成功还是失败，最终的信息都需要返回到前台。而ajax本身属于有返回结果的一类，其中的success方法就是处理后台返回结果的。

ajax提交表单有返回结果的两种实现方式：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将表单数据序列化</span><br><span class="line"></span><br><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;  </span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    type: &quot;POST&quot;,  </span><br><span class="line">   	//请求的类型 </span><br><span class="line">	url:your-url,  </span><br><span class="line">    //请求的路径</span><br><span class="line">	data:$(&apos;#yourformid&apos;).serialize(),  </span><br><span class="line">    //将数据序列化</span><br><span class="line">	async: false,  </span><br><span class="line">    //异步请求否</span><br><span class="line">	error: function(request) &#123;  </span><br><span class="line">    //发生错误调用函数</span><br><span class="line">		alert(&quot;Connection error&quot;);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    success: function(data) &#123;  </span><br><span class="line">	//成功调用的函数        </span><br><span class="line">	//接收后台返回的结果  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用这种方法的前提是form表单中要有name属性，后台获取的键值对为key=name值，value=各项值 无论是input标签还是span标签或者其他标签一定要有name属性，没有name属性，后台是获取不到该项的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.通过窗口查看form提交</span><br><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;  </span><br><span class="line">    //提交表单  </span><br><span class="line">  	var obj = document.getElementById(&quot;xx_iframe&quot;).contentWindow;  </span><br><span class="line">  	obj.$(&quot;#yourform&quot;).form(&quot;submit&quot;,&#123;  </span><br><span class="line">    success:function(data)&#123;  </span><br><span class="line">    //对结果处理  </span><br><span class="line">    &#125;);&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>注意：ajax中封装的post、get请求都是有返回结果的一类</p>
</blockquote>
<p>6.serizlize()方法<br><br>作用：将表单中的元素名称和值转换成URL参数格式。</p>
<pre><code>语法：$().serizlize() 
如：
    $(&quot;#form1&quot;).serizlize(); //表示把表单名称为form1的元素名称和值序列化
</code></pre><p>7.send() 方法<br>作用：该方法表示发送请求，其中参数为content表示指定请求的参数。</p>
<p>8.常用的属性</p>
<pre><code>1.onreadystatechange：指定回调函数
2.readyState：XMLHttpRequest的状态信息
3.status：http状态信息码
4.responseText：获取响应的文本内容
5.responseXML：获得响应的XML文档对象document
</code></pre><hr>
<h4 id="AJAX的封装"><a href="#AJAX的封装" class="headerlink" title="AJAX的封装"></a>AJAX的封装</h4><pre><code>1.函数封装
function ajax(url,Succ,Fail){    
    var aj=new XMLHttpRequest();     
    aj.open(&apos;Get&apos;,url,true);     
    aj.send();     
    aj.onreadystatechange=function(){        
        if(aj.readyState==4){            
            if(aj.status==200){                 
                Succ(aj.responseText)             
            }else{               
                    if(Fail){                     
                        Fail(aj.statusText)                 

                }            
            }         
        }    
    } 
}

2.获取JSON数据
&lt;input type=&quot;button&quot; value=&quot;测试按钮&quot;id=&quot;but&quot;&gt;     
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;     
    &lt;script&gt;        
        var but=document.getElementById(&quot;but&quot;);        
        var div1=document.getElementById(&quot;div1&quot;);         
        but.=function(){             
            ajax(&quot;test1.json&quot;,function(str){                
                var name=JSON.parse(str);                
                for(var i in name){                    
                    for(var j in name[i]){                           
                        var lis=document.createElement(&apos;li&apos;);                            lis.innerHTML=j+&apos;:&apos;+name[i][j];                            
                        div1.appendChild(lis);   
                    }  
                }    
            }),function(s){                 
                alert(s)   
            }   
        }    
    &lt;/script&gt;
</code></pre><h4 id="AJAX使用的步骤"><a href="#AJAX使用的步骤" class="headerlink" title="AJAX使用的步骤"></a>AJAX使用的步骤</h4><pre><code>1.创建XMLHttpRequest对象

    语法：

        var myAjax = new XMLHttpRequest();
    或  var myAjax = new ActiveXObject(&quot;microsoft.xmlhttp&quot;);

2.open()方法连接服务器
3.send()方法发送请求给服务器

    2.向服务器发送请求：使用open()方法和send()方法

        语法：

            open(method,url,async) 表示规定请求的类型、URL以及是否异步请求，method：请求类型，get/post
                                    url:文件在服务器上的位置 

            send(string):string 仅用于post请求

3.服务器响应

    如果我们需要获取来自服务器的响应，需要使用XMLHttpRequest对象的responseText或responseXML属性

        responseText属性：该属性返回字符串形式的响应
        responseXML属性：如果来自服务器的响应是XML，同时需要作为XML对象进行解析，需要使用responseXML属性


4.onreadystatechange属性连接函数responseText属性从服务器返回的数据

    onreadystatechange 事件，当请求被发送到服务器时，我们需要执行一些基于响应的任务。 
    每当 readyState 改变时，就会触发 onreadystatechange 事件。

        XMLHttpRequest 对象的三个重要的属性：
            onreadystatechange:存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。

            readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
                0: 请求未初始化
                1: 服务器连接已建立
                2: 请求已接收
                3: 请求处理中
                4: 请求已完成，且响应已就绪

            status:200: &quot;OK&quot;/404: 未找到页面
</code></pre><blockquote>
<p>注意：我们能够使用Ajax验证用户名是否存在。</p>
</blockquote>
<pre><code>步骤：
    1.使用文本框的onblur事件
    2.使用ajax技术实现异步交互
        1.创建XMLHttpRequest对象
        2.通过XMLHttpRequest对象设置请求信息
        3.向服务器发送请求
        4.创建回调函数，根据响应状态动态更新页面
</code></pre><blockquote>
<p>扩展：四种常用的ajax请求方式：</p>
</blockquote>
<pre><code>&lt;br&gt;
    1.$.ajax()返回其创建的 XMLHttpRequest 对象

        $.ajax() 只有一个参数：参数 key/value 对象，包含各配置及回调函数信息，如果你指定了dataType选项，那么需要保证服务器返回正确的MIME信息，(如 xml 返回 &quot;text/xml&quot;)

    2.通过远程http get请求载入信息

        比较复杂的$.ajax来说，get请求功能更简单，请求成功时可以调用回调函数，出错时还是使用$.ajax

    3.通过远程http post请求载入信息

        post请求相对比较简单，请求成功时可以调用回调函数，出错时也使用$.ajax请求

    4.通过http get请求载入JSON数据

        方法：$.getJSON(url,function(){})
</code></pre><hr>
<blockquote>
<p>扩展：jQuery DataTable 前端插件(与后端完全分离) 强大的功能支持：排序、分页、搜索等</p>
</blockquote>
<blockquote>
<blockquote>
<p>主要特点：自动分页处理、即时表格数据过滤、数据排序以及数据类型自动检测、自动处理列宽度、可通过CSS定制样式、支持隐藏列、易用、可扩展性和灵活性、国际化、动态创建表格。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>使用方法：<br>        1.首先构建我们需要的数据列表，以及页面显示表格<br>        2.在jQuery DataTable官网下载一份js库<br>        3.在页面中引入这两个文件，然后在两个文件要在最前面以至于能够被引用到<br>        4.编写前端程序，需要使用到ajax对后台进行请求，所以在配置datatable的时候，要加上{“serverSide”:ture}，以保证页面在加载时就请求后台，以及每次对datatable进行操作时也是请求后台。<br>        5.配置数据返回对应具体的列，在Datatable中，属性columns用来配置具体列的属性，包括对应的数据列名，是否支持搜索，是否显示，是否支持排序等。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>列 columns 和 columnDefs基本使用
    相同点：达到相同的效果
    不同点：作用和使用不一样
        1.columns：设置特定列的初始化属性，可以定义数组设置多列，数组长度必须等于表格的数量，只想使用默认值可以设为“NULL”，数组每个元素只能设置单列的属性。
        2.columnDefs：与columns非常相似，该数组可以针对特定的列，多列或者所有列定义。数组可以任意长度。通过targets参数设置一个列或者多列
            属性定义：
                0或正整数 - 从左边的列索引计数 
                负整数 - 列索引从右边计数 
                一个字符串 - 类名称将被匹配上的TH为列 
                字符串“_all” - 所有的列（即指定一个默认值） 
                两个参数可以同时使用，但是columns定义的优先级最高。 
                当columnDefs里对同一列有多个定义时，最开始的定义优先级最高
</code></pre><blockquote>
<p>注意：<br>DataTables的一些基础属性配置:    </p>
</blockquote>
<pre><code>    &quot;bPaginate&quot;: true, //翻页功能 
    &quot;bLengthChange&quot;: true, //改变每页显示数据数量 
    &quot;bFilter&quot;: true, //过滤功能 
    &quot;bSort&quot;: false, //排序功能 
    &quot;bInfo&quot;: true,//页脚信息 
    &quot;bAutoWidth&quot;: true//自动宽度 
    &quot;sPaginationType&quot;: &quot;full_numbers&quot;  //分页样式

1.数据排序：&quot;aaSorting&quot;: [ [ 4, &quot;desc&quot; ] ] };//表示从第0列开始，以第四列倒序排序

2.隐藏某列：

3.国际化：
</code></pre><hr>
<blockquote>
<p>扩展1</p>
<blockquote>
<p>控制台属性和方法：</p>
<blockquote>
<p>1.console.log 用于输出普通信息  2.console.info 用于输出提示性信息  3.console.error用于输出错误信息  4.console.warn用于输出警示信息    5.console.debug用于输出调试信息</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>注意：console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种</p>
</blockquote>
<pre><code>1.%o  //此占位符用来查看对象内部情况
2.
</code></pre><p>案例：</p>
<pre><code>console.log(&quot;%d年%d月%d日&quot;,2011,3,26);//表示输出日期
console.log(&quot;圆周率是%f&quot;,3.1415926);//输出数学表达式
</code></pre><p>控制台方法：</p>
<pre><code>1.console.assert 对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台。
2.console.count 用于统计代码被执行的次数。&lt;br/&gt;
3.console.dir 直接将该DOM结点以DOM树的结构进行输出，可以详细查对象的方法发展等。&lt;br/&gt;
4.console.time 计时开始&lt;br/&gt;
5.console.timeEnd 计时结束
6.console.trace 堆栈跟踪相关的调试
</code></pre><blockquote>
<p>扩展2</p>
<blockquote>
<p>jquery setTimeout()函数使用方法</p>
<blockquote>
<p>该方法表示从载入后延迟指定的时间去执行一个表达式或者是函数，仅仅执行一次。与<code>window.clean Timeout</code> 一起使用</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>window.location.reload()函数</p>
<blockquote>
<p>JS中实现刷新页面的方法，浏览器重新从服务器中请求资源</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="11-JSONP-JSON"><a href="#11-JSONP-JSON" class="headerlink" title="11.JSONP/JSON"></a>11.JSONP/JSON</h2><blockquote>
<p>简介：JSONP是JSON的一种使用模式，可以让网页从其他网站获取资料，实现跨域读取数据。</p>
<blockquote>
<p>同源策略：它是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。</p>
<blockquote>
<p>JSON.parse() 将数据转换为JavaScript对象。<br>语法：JSON.parse(text[, reviver])<br>text：一个有效的JSON字符串  reviver：转换结果的函数，将为对象的每个成员调用此函数</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="1-JSON-数组"><a href="#1-JSON-数组" class="headerlink" title="1.JSON 数组"></a>1.JSON 数组</h4><p>JSON数组在中括号中书写，数组可以包含多个对象。</p>
<pre><code>{
    &quot;sites&quot;: [
    { &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; }, 
    { &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; }, 
    { &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; }
    ]
}
</code></pre><h4 id="2-JSON使用JavaScript语法"><a href="#2-JSON使用JavaScript语法" class="headerlink" title="2.JSON使用JavaScript语法"></a>2.JSON使用JavaScript语法</h4><p>JSON使用JavaScript语法。通过JavaScript可以创建一个对象数组，并赋值。</p>
<pre><code>var sites = [
    { &quot;name&quot;:&quot;runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; }, 
    { &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; }, 
    { &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; }
];
</code></pre><blockquote>
<p>注意：JSON文件的类型是”.json” JSON 文本的MIME类型是”application/json”</p>
</blockquote>
<h4 id="3-JSON-对象"><a href="#3-JSON-对象" class="headerlink" title="3.JSON 对象"></a>3.JSON 对象</h4><pre><code>1.循环对象：

    使用for-in来循环对象的属性

    &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var myobject = {&quot;name&quot;:&quot;username&quot;,&quot;alexa&quot;:1000,&quot;site&quot;:null};
        for(x in myobject){
            document.getElementById(&quot;demo&quot;).innerHTML+=myobject[x]+&quot;&lt;br&gt;&quot;;
        }
    &lt;/script&gt;
</code></pre><h4 id="4-JSON-parse"><a href="#4-JSON-parse" class="headerlink" title="4.JSON.parse()"></a>4.JSON.parse()</h4><p>因为<code>JSON</code>经常用于与服务器交换数据，在接收服务器数据时一般是字符串，所以我们可以使用<code>JSON.parse()</code>方法将数据转换为<code>JavaScript</code>对象。</p>
<h4 id="5-JSON-stringify"><a href="#5-JSON-stringify" class="headerlink" title="5.JSON.stringify()"></a>5.JSON.stringify()</h4><p>因为JSON用于与服务端交换数据，向服务器发送数据时一般是字符串。我们可以使用 <code>JSON.stringify()</code> 方法将 <code>JavaScript</code> 对象转换为字符串。</p>
<hr>
<h2 id="12-jQuery-EasyUI"><a href="#12-jQuery-EasyUI" class="headerlink" title="12.jQuery EasyUI"></a>12.jQuery EasyUI</h2><p>jQuery EasyUI是一个基于jQuery的框架，集成了各种用户界面（UI）插件。jQuery EasyUI能够帮助Web开发者更轻松的打造出功能丰富并且美观的UI界面。</p>
<pre><code>两种方法声明UI组件：
    1.直接在HTML声明组件

        &lt;div class=&quot;easyui-dialog&quot; style=&quot;width:400px;height:200px&quot;data-options=&quot;title:&apos;My Dialog&apos;,collapsible:true,iconCls:&apos;icon-ok&apos;,onOpen:function(){}&quot;&gt;
                    dialog content.
        &lt;/div&gt;

    2.编写JavaScript来创建组件

        &lt;input id=&quot;cc&quot; style=&quot;width:200px&quot; /&gt; //HTML标签

        $(&apos;#cc&apos;).combobox({        //jQuery语法
            url: ...,
            required: true,
            valueField: &apos;id&apos;,
            textField: &apos;text&apos;
        });
</code></pre><p>EasyUI应用 创建CRUD应用</p>
<hr>
<h2 id="13-jQuery-Validate验证详解"><a href="#13-jQuery-Validate验证详解" class="headerlink" title="13.jQuery Validate验证详解"></a>13.jQuery Validate验证详解</h2><p>jQuery Validate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。</p>
<p>1.导入JS文件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jQuery.1.8.3.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt; </span><br><span class="line">&lt;script src=<span class="string">"jquery.validate.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt; </span><br><span class="line">&lt;script src=<span class="string">"messages_zh.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.默认校验规则</p>
<p>3.默认的提示</p>
<p>4.使用方法</p>
<pre><code>1.通过属性方式添加验证规则

2.metadata用法(将校验规则写到控件中或者在 class 属性填写规则（效果一样）)
注意：使用class=&quot;{}&quot;的方式需要引入包：jquery.metadata.js


3.将校验规则写到JS代码中
</code></pre><hr>
<h2 id="14-jQuery-树型菜单插件-Treeview"><a href="#14-jQuery-树型菜单插件-Treeview" class="headerlink" title="14.jQuery 树型菜单插件(Treeview)"></a>14.jQuery 树型菜单插件(Treeview)</h2><p>jQuery Treeview提供了一个无序灵活的树形菜单</p>
<p>1.首先引入 CSS 与 JS 文件</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://static.runoob.com/assets/js/jquery-treeview/jquery.treeview.css&quot;/&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;http://static.runoob.com/assets/js/jquery-treeview/screen.css&quot;/&gt;

&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://static.runoob.com/assets/js/jquery-treeview/jquery.cookie.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://static.runoob.com/assets/js/jquery-treeview/jquery.treeview.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
</code></pre><p>2.然后编写 JS 程序</p>
<pre><code>    $(&quot;#browser&quot;).treeview({
    toggle: function() {
        console.log(&quot;%s was toggled.&quot;, $(this).find(&quot;&gt;span&quot;).text());
    }
});
</code></pre><p>3.最后编写 HTML 文件</p>
<pre><code>//在类里面声明filetree treeview-famfamfam
&lt;ul id=&quot;browser&quot; class=&quot;filetree treeview-famfamfam&quot;&gt;
&lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Folder 1&lt;/span&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Item 1.1&lt;/span&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;span class=&quot;file&quot;&gt;Item 1.1.1&lt;/span&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Folder 2&lt;/span&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Subfolder 2.1&lt;/span&gt;
                    &lt;ul id=&quot;folder21&quot;&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.1.1&lt;/span&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.1.2&lt;/span&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Subfolder 2.2&lt;/span&gt;
                    &lt;ul&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.2.1&lt;/span&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.2.2&lt;/span&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li class=&quot;closed&quot;&gt;&lt;span class=&quot;folder&quot;&gt;Folder 3 (closed at start)&lt;/span&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 3.1&lt;/span&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 4&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>4.最后加上相关的按钮或者链接（整个HTML页面完成）</p>
<hr>
<h2 id="15-jQuery-Tooltip"><a href="#15-jQuery-Tooltip" class="headerlink" title="15.jQuery Tooltip"></a>15.jQuery Tooltip</h2><blockquote>
<p>提示：jQuery Tooltip 取代了原生的工具提示框，让其可以自定义，我们只需要调整其内容、位置和外观便可。</p>
</blockquote>
<p>使用步骤：<br>1.</p>
<hr>
<h2 id="16-jQuery-Prettydate"><a href="#16-jQuery-Prettydate" class="headerlink" title="16.jQuery Prettydate"></a>16.jQuery Prettydate</h2><p>jQuery Prettydate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。</p>
<p>1.使用方法<br>如果我们需要使用到此插件，需要我们在<code>title</code>标签中加上带有<code>ISO8601</code>日期</p>
<pre><code>&lt;a title=&quot;2008-01-28T20:24:17Z&quot;&gt;January 28th, 2008&lt;/a&gt; 
&lt;a title=&quot;2008-01-27T22:24:17Z&quot;&gt;January 27th, 2008&lt;/a&gt; 
&lt;a title=&quot;2008-01-26T22:24:17Z&quot;&gt;January 26th, 2008&lt;/a&gt;
</code></pre><p>然后对它们使用prettyDate()方法</p>
<pre><code>$(function() { $(&quot;a&quot;).prettyDate(); });
</code></pre><hr>
<h2 id="17-Password-Validation-插件"><a href="#17-Password-Validation-插件" class="headerlink" title="17.Password Validation 插件"></a>17.Password Validation 插件</h2><p>对于密码验证，这一插件提供了两种组件：<br>1.<br>2.</p>
<p>1.使用方式<br>如果我们需要使用到<code>password validation</code>插件，我们需要添加一个<code>class=&quot;password&quot;</code>到<code>input</code>中，同时添加<code>显示强度</code>的基本标记在表单的需要显示的地方。</p>
<pre><code>//首先设置验证器的默认情况，然后编写验证器的验证规则
jQuery.validator.setDefaults({
        debug: true,
        success: &quot;valid&quot;
});
$( &quot;#myform&quot; ).validate({
    rules: {
        password: &quot;required&quot;,
        password_again: {
            equalTo: &quot;#password&quot;
        }
    }
});
</code></pre><hr>
<h2 id="18-jQuery-Growl-插件"><a href="#18-jQuery-Growl-插件" class="headerlink" title="18.jQuery Growl 插件"></a>18.jQuery Growl 插件</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/undefined/mybatis/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Mybatis-FD"><a href="#Mybatis-FD" class="headerlink" title="Mybatis - FD"></a>Mybatis - FD</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="1-原生态JDBC程序存在问题"><a href="#1-原生态JDBC程序存在问题" class="headerlink" title="1.原生态JDBC程序存在问题"></a>1.原生态JDBC程序存在问题</h4><pre><code>public static void main(String[] args) {
    //设置连接为null
    Connection connection = null;
    //设置预处理状态为null
    PreparedStatement preparedStatement = null;
    //设置结果集为null
    ResultSet resultSet = null;
    //检查异常并抛出异常
</code></pre><a id="more"></a>
<pre><code>    try {
        //1、加载数据库驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2、通过驱动管理类获取数据库链接
        connection =  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;);
        //3、定义sql语句 ?表示占位符
        String sql = &quot;select * from user where username = ?&quot;;
        //4、获取预处理statement
        preparedStatement = connection.prepareStatement(sql);
        //5、设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值
        preparedStatement.setString(1, &quot;Aaron&quot;);
        //6、向数据库发出sql执行查询，查询出结果集
        resultSet =  preparedStatement.executeQuery();
        //7、遍历查询结果集
        while(resultSet.next()){
            System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }finally{
        //8、释放资源
        if(resultSet!=null){
            try {
                resultSet.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(preparedStatement!=null){
            try {
                preparedStatement.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(connection!=null){
            try {
                connection.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
</code></pre><blockquote>
<p>总结：1.JDBC在使用过程中数据库连接会频繁开启和关闭，会严重影响到数据库的性能。2.在程序中存在硬编码，数据库部分以及SQL执行部分。</p>
</blockquote>
<h2 id="Mybatis-框架原理"><a href="#Mybatis-框架原理" class="headerlink" title="Mybatis 框架原理"></a>Mybatis 框架原理</h2><pre><code>1.mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息。映射文件配置了SQL执行相关的信息。

2.mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂(sqlSessionFactory)。

3.通过SqlSessionFactory(会话工厂)，可以创建SqlSession即会话。Mybatis是通过SqlSession来操作数据库的。

4.SqlSession(会话)其本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。

5.Executor执行器要处理的SQL信息是封装到一个底层对象 MappedStatement 中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括Java的简单类型、HashMap集合对象、POJO对象类型。
</code></pre><hr>
<h2 id="Mybatis-入门程序"><a href="#Mybatis-入门程序" class="headerlink" title="Mybatis 入门程序"></a>Mybatis 入门程序</h2><h4 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h4><pre><code>1.创建数据表
2.添加相关依赖文件
3.添加log4j.properties文件(因为mybatis使用的日志包是log4j(在classpath路径下创建该文件))

    # Global logging configuration
    log4j.rootLogger=DEBUG, stdout
    # Console output...
    log4j.appender.stdout=org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
</code></pre><blockquote>
<p>注意：日志级别在开发阶段设置成DEBUG，在生产阶段设置成INFO或者ERROR。</p>
</blockquote>
<pre><code>4.编程步骤
    1.创建PO类，根据需求创建
        Public class User {
            private int id;
            private String username;// 用户姓名
            private String sex;// 性别
            private Date birthday;// 生日
            private String address;// 地址
            //以及一系列的get/set方法
            }
</code></pre><blockquote>
<p>注意：创建的po类属性名称应该和数据库表中的列名一致，如果表中的列名带有下划线，那么PO类中对应的属性名要采用驼峰式命名。驼峰式命名：骆驼式命名法就是当变量名或函数名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。</p>
</blockquote>
<pre><code>2.创建全局配置文件SqlMapConfig.xml(是在classpath路径下创建配置文件)
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE configuration
    PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
    &lt;configuration&gt;
    &lt;!-- 配置mybatis的环境信息 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!-- 配置数据源，采用dbcp连接池 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!—驱动和URL设置--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;/configuration&gt;

3.编写映射文件(xxxMapper.xml(mapper接口的实现类))
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE mapper    
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

4.加载映射文件，在SqlMapConfig.xml中进行加载
    &lt;!-- 加载mapper --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;
    &lt;/mappers&gt;

5.编写测试程序，即编写Java代码，连接并操作数据库
    public class MybatisFirst {

    @Test
    public void findUserByIdTest() throws Exception{
        //1、读取配置文件
        String resource = &quot;SqlMapConfig.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        //2、根据配置文件创建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //3、SqlSessionFactory创建SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //4、SqlSession执行statement，并返回映射结果
        //第一个参数：statement的id，建议：namespace.statementId（确保唯一）
        //第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致
        User user = sqlSession.selectOne(&quot;findUserById&quot;, 1);
        //打印输出结果集
        System.out.println(user);
        //5、关闭SqlSession
        sqlSession.close();
    }
}
</code></pre><blockquote>
<p>总结：1.首先读取配置文件，然后通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。<br>2.通过SqlSessionFactory创建SqlSession，然后调用SqlSession的操作数据库的方法。<br>3.最后关闭SqlSession。</p>
</blockquote>
<hr>
<blockquote>
<p>小结</p>
<blockquote>
<p>1.parameterType 指定输入参数的Java类型，可以填写别名或Java类的全限定名。</p>
<blockquote>
<p>2.resultType 指定输出结果的Java类型，可以填写别名或Java类的全限定名。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>#{}和${}
    #{}：相当于预处理中的占位符？。

    #{}里面的参数表示接收java输入参数的名称。

    #{}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，#{}里面可以是value，也可以是其他。

    #{}可以防止SQL注入。

    ${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。

    ${}会引起SQL注入，所以要谨慎使用。

    ${}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，${}里面只能是value。

selectOne：只能查询0或1条记录，大于1条记录的话，会报错
selectList：可以查询0或N条记录
</code></pre><hr>
<h2 id="Mybatis-开发DAO"><a href="#Mybatis-开发DAO" class="headerlink" title="Mybatis 开发DAO"></a>Mybatis 开发DAO</h2><p>我们知道，mybatis在项目开发中主要使用的地方就是开发DAO(数据访问层)。所以开发方式有两种。1.原始的DAO开发方式。2.Mapper代理开发方式。</p>
<h4 id="1-原始DAO开发方式"><a href="#1-原始DAO开发方式" class="headerlink" title="1.原始DAO开发方式"></a>1.原始DAO开发方式</h4><pre><code>实现步骤：
    1.根据需求创建po类
      这一步骤的实现所对应的属性名要与数据库中的属性名相对应
    2.编写全局配置文件
      这一步骤的实现是配置数据源等信息
    3.根据需求编写映射文件
      实现实体类与数据库之间的数据操作
    4.加载映射文件
    5.编写dao接口
        public interface UserDao {
            //根据用户ID来查询用户信息
            public User findUserById(int id);
            //根据用户名称来模糊查询用户信息列表
            public List&lt;User&gt; findUsersByName(String username);
            //添加用户
            public void insertUser(User user);
        }

    6.编写dao实现类
        public class UserDaoImpl implements UserDao {

            //注入SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;
            //使用构造方法来初始化SqlSessionFactory
            public UserDaoImpl(SqlSessionFactory sqlSessionFactory){
                this.sqlSessionFactory = sqlSessionFactory;
            }

            @Override
            public User findUserById(int id) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                //返回结果集
                return sqlSession.selectOne(&quot;test.findUserById&quot;, id);
            }

            @Override
            public List&lt;User&gt; findUsersByName(String username) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                return sqlSession.selectList(&quot;test.findUsersByName&quot;, username);
            }

            @Override
            public void insertUser(User user) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                sqlSession.insert(&quot;test.insertUser&quot;, user);
            }

        }

    7.编写测试代码
        public class UserDaoTest {

            //声明全局的SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;

            @Before
            //此方法在测试方法执行之前执行，spring开发方式
            public void setUp() throws Exception {
                // 1、读取配置文件
                String resource = &quot;SqlMapConfig.xml&quot;;
                InputStream inputStream = Resources.getResourceAsStream(resource);
                // 2、根据配置文件创建SqlSessionFactory
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            }

            @Test
            public void testFindUserById() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                User user = userDao.findUserById(1);

                System.out.println(user);
            }

            @Test
            public void testFindUsersByName() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                List&lt;User&gt; list = userDao.findUsersByName(&quot;小明&quot;);

                System.out.println(list);
            }

            @Test
            public void testInsertUser() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //构造User对象
                User user = new User();
                user.setUsername(&quot;东哥3&quot;);
                user.setAddress(&quot;清河宝盛西里3&quot;);

                //调用UserDao对象的方法
                userDao.insertUser(user);

                System.out.println(user.getId());
            }

        }
</code></pre><h4 id="2-mapper开发代理方式"><a href="#2-mapper开发代理方式" class="headerlink" title="2.mapper开发代理方式"></a>2.mapper开发代理方式</h4><p>使用Mapper代理的开发方式，我们只需要编写mapper接口，然后mybatis会自动为mapper接口生成动态代理实现类。</p>
<pre><code>1.mapper接口的全限定名要和mapper映射文件的namespace的值相同。
2.mapper接口的方法名称要和mapper映射文件中的statement的id相同。
3.mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。
4.mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致。
</code></pre><blockquote>
<p>提示：statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上，向数据库发送要执行的SQL语句，Statement对象用于执行不带参数的简单SQL语句。</p>
</blockquote>
<h2 id="Mybatis-映射文件"><a href="#Mybatis-映射文件" class="headerlink" title="Mybatis 映射文件"></a>Mybatis 映射文件</h2><pre><code>1.输入映射
    ParameterType

2.输出映射
    resultType

3.高级映射
    resultMap
</code></pre><h2 id="mybatis-高级映射"><a href="#mybatis-高级映射" class="headerlink" title="mybatis 高级映射"></a>mybatis 高级映射</h2><pre><code>1.mybatis框架执行过程：
  1.配置mybatis的配置文件(mybatis-config.xml)（名称不固定）。

  2.通过配置文件(mybatis-config.xml)，加载mybatis运行环境，创建SqlSessionFactory会话工厂,SqlSessionFactory在实际使用时按单例方式。

  3.通过SqlSessionFactory创建SqlSession，SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。

  4.调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。

  5.释放资源，关闭SqlSession

2.mybatis开发dao的方法
  1.使用原始的dao的方法
    这样需要编写dao接口和实现类，需要在dao实现类注入一个SqlSessionFactory工厂。

  2.mapper代理开发方法(推荐)
    0.编写mapper接口(dao接口)
      注意：在编写mapper.xml(映射文件)和mapper.java(接口)需要遵循开发规范

    1.mapper.xml中的namespace就是mapper.java的类的全路径名

    2.mapper.xml中statement的id值和mapper.java中方法名一致(如：insert/delete/update中的id值)

    3.mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法数据参数类型一致(parameterType类型与对应的接口方法参数类型一致)

    4.mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致(resultMap：定义出参，调用已经定义的&lt;resultMap&gt;&lt;/resultMap&gt;映射管理器的id值 

    resultType：定义出参，匹配普通Java类型或自定义pojo类型(出参类型若不指定，将为语句默认类型))
</code></pre><blockquote>
<p>注意：全局配置文件(mybatis-config.xml)可以配置properties属性、别名、mapper加载等。</p>
</blockquote>
<pre><code>3.输入映射
  1.parameterType：指定输入参数类型可以是简单类型、POJO、HashMap，而对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展。

4.输出映射
  1.resultType：查询到的列名和resultType指定的POJO的属性名一致，这样才能映射成功。
    作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中
    场合：

  2.resultMap：可以通过resultMap完成高级映射，如果查询到的列名和映射的POJO的属性名不一致时，通过resultMap设置别名和属性名之间的对应关系(映射关系)，可以完成映射。

    association
    作用：将关联查询信息映射到一个pojo对象中
    场合：为了方便查询关联信息可以使用association将关联 订单信息 映射为 用户对象 的pojo属性中。association适用于一对一查询。
</code></pre><blockquote>
<p>注意：使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap</p>
</blockquote>
<pre><code>collection
作用：将关联查询信息映射到一个list集合中
场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，而如果使用resultType无法将查询结果映射到list集合中。collection适用于一对多和多对多的查询。
</code></pre><blockquote>
<p>扩展：映射管理器<code>resultMap</code>：是<code>mybatis</code>中强大的工具，使用其可以进行 实体类之间 的映射，并且管理 结果和实体类 之间的映射关系。</p>
</blockquote>
<pre><code>resultMap映射管理器需要配置的属性：

    &lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;&lt;/resutlMap&gt;   
        id=&quot; &quot;:表示这个映射管理器的唯一标识，外部通过该值引用
        type = &quot; &quot;:表示需要映射的实体类

resultMap映射管理器需要配置的参数：

    &lt;id column = &quot; &quot; property= &quot; &quot; /&gt; 
        &lt;id&gt;标签指的是：结果集中结果唯一的列column(column：指定唯一标识用户信息的数据列)和实体属性property(property:映射到user实体类的哪个属性)的映射关系
            注意：&lt;id&gt;标签管理的列未必是主键列，需要根据具体需求指定

    &lt;result column= &quot; &quot; property=&quot; &quot; /&gt;  
        &lt;result&gt;标签指的是：结果集中普通列column和实体属性property的映射关系

resultMap映射管理器需要维护的关系：所谓关系维护是值在 主表查询时将其关联子表的结果也查询出来
</code></pre><hr>
<pre><code>resultMap元素中，允许有如下直接子元素：
    1.constructor：类在实例化时，用来注入结果到构造方法中,作用与result相同，同时可以标识出用这个字段值可以区分其他对象实例
        arg：注入到构造方法的一个普通结果
        idArg：ID参数，标记结果作为ID，可以帮助提高整体效能

    2.result：将数据表中的字段注入到Java对象属性中

    3.association：关联(一对一的关系)，表示在resultMap映射器中，通过&lt;association&gt;&lt;/association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来。

      作用：将关联查询的信息映射到一个POJO中
      &lt;association property=&quot;&quot; javaType=&quot;&quot;&gt;
          property：对象属性的名称，被维护实体在宿主实体(POJO)中的属性名
           javaType：对象属性的类型，被维护实体的类型
           column：所对应的外键字段名称
           select：使用另一个查询封装的结果

    4.collection：集合(一对多/多对多关系的维护)，对关联查询到的多条记录映射到集合对象中。

      作用：将关联查询用户信息映射到一个list集合中
      &lt;collection property=&quot;&quot; ofType=&quot;&quot;&gt;
      property=&quot;&quot; 将查询到的多条记录映射到相应的POJO类上对应的属性中
      ofType=&quot;&quot; 指定映射到List集合的pojo类型

    5.discriminator：使用结果集决定使用哪个个结果映射
</code></pre><blockquote>
<p>拓展：sql片段标签<sql>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用。</sql></p>
</blockquote>
<pre><code>注意：需要配置的属性，id=&quot;&quot; 表示需要改sql语句片段的唯一标识 引用：通过&lt;include refid=&quot;&quot;/&gt;标签引用，refid=&quot;&quot;中的值指向需要引用的&lt;sql&gt;中的id=&quot;&quot;属性。
</code></pre><blockquote>
<p>注意：在resultMap中应该注意两点</p>
</blockquote>
<pre><code>1.关联关系的维护可以根据实体类之间的实际情况进行嵌套维护

2.出现重复列名的处理，在实际操作过程中，查询到的结果可能会出现相同的列名，这样会对映射到实体属性带来影响甚至报错，所以可以通过对列取别名的方式来处理
</code></pre><p>5.高级映射<br>  1.将关联查询的列映射到一个POJO属性中(一对一)<br>  2.将关联查询的列映射到一个List<pojo>中(一对多)</pojo></p>
<hr>
<h2 id="mybatis动态sql语句"><a href="#mybatis动态sql语句" class="headerlink" title="mybatis动态sql语句"></a>mybatis动态sql语句</h2><p>6.常用的动态语句标签(通过动态sql标签可以进行条件判断，条件遍历等操作从而能够满足结果中的需要)</p>
<pre><code>&lt;where&gt;：这一标签的使用可以代替sql语句中的where关键字，一般放置在条件查询的最外层 
   where后面跟查询条件，简化sql语句中判断条件的书写 此中，mybatis会智能的将首个and或or给忽略

&lt;if&gt;：这一标签配置属性test=&quot;条件字符串&quot;，判断是否满足条件

&lt;set&gt;：这一标签常用于&lt;update&gt;更新语句中，替代sql的set关键字，特别是在联合&lt;if&gt;进行判断是否条件时，可以有效方式当某个参数为空或者不合法是错误的更新到数据库中
 mybatis set标签的使用：sql语句中的最后一个逗号会被set标记自动忽略

&lt;trim&gt;：在mapper.xml中对statement的定义，可以使用&lt;trim&gt;标签来填充和隐藏sql语句。
    功能：1.如果标签体中有SQL语句，就把修饰后的SQL语句拼接到之前的SQL语句上，如果标签体中没有SQL语句，那么这标签相当于不存在。2.这四个属性的默认值都是空字符串。

      trim属性 prefix：前缀   suffix：后缀 

      &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;,&quot; suffixOverrides=&quot;,&quot;&gt;

      属性：
        1.prefix=&quot;(&quot; 在trim标签定义的内容前填充对应内容
        2.suffix=&quot;)&quot; 在trim标签定义的内容后填充对应内容

        3.prefixOverrides=&quot;,&quot;  在trim定义的中，隐藏头部对应的内容。这个属性指定一个字符串，这个字符串一定是SQL语句的前缀，如果不是前缀，这个属性不起作用。会用prefix属性指定的字符串替换掉这个属性指定的字符串。

        4.suffixOverrides=&quot;,&quot; 在trim定义的中，隐藏尾部对应的内容。这个属性指定一个字符串，这个字符串位一定是SQL语句的后缀，如果不是后缀，这个属性不起作用。其会用suffix属性指定的字符串替换这个属性指定的字符串。

标签组：
  &lt;choose&gt;
    &lt;when&gt; //此元素的作用与Java中的switch效果差不多
    &lt;/when&gt;
    &lt;otherwise&gt;
    &lt;/otherwise&gt;
  &lt;/choose&gt; 
  也是一个用于条件判断的标签组，和&lt;if&gt;的不同之处在于条件从&lt;choose&gt;进入，去匹配&lt;when&gt;中的添加，一旦匹配马上结束，若到找不到匹配项，将执行&lt;otherwise&gt;中的语句；可以理解为&lt;if&gt;是 &amp;&amp; 关系 &lt;choose&gt;是 || 关系

  &lt;foreach&gt;标签：遍历集合类型的条件(在实现 mybatis in 语句查询时特别有用)
  属性：collection=&quot;array/list&quot; 是数组类型还是集合类型
        item=&quot; &quot; 参数名
    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;  开始符号，分隔符号，结束符号
    index=&quot;&quot; 结束下标位置，不配置该参数时，默认为全部遍历
</code></pre><blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>MySQL JOIN语法
    join用于多表中字段之间的联系(...FROM table1(左表) INNER|LEFT|RIGHT JOIN table2(右表) ON condition)
大致功能：
    1.INNER JOIN（内连接 取两表的交集）：取得两个表中存在连接匹配关系的记录(产生一组同时符合A和B的数据)
    2.LEFT JOIN（左连接）：取得左表（table1）完全记录，即是右表（table2）并无对应匹配记录
    3.RIGHT JOIN（右连接）：与 LEFT JOIN 相反，取得右表（table2）完全记录，即是左表（table1）并无匹配对应记录

条件ON与Where的执行顺序
    ON：用来决定如何从B表中检索数据行
</code></pre><hr>
<h2 id="mybatis高级查询"><a href="#mybatis高级查询" class="headerlink" title="mybatis高级查询"></a>mybatis高级查询</h2><p>1.关联查询<br>  在查询一个结果的时候，查询出其他关联的结果集</p>
<p>2.子查询<br>  关联查询一般可以使用子查询来实现，但是一般情况下子查询的效率低于关联查询</p>
<p>3.集合查询<br>  集合查询是关联查询的一种，只不过它是一对多而已</p>
<p>4.mapper.xml源码分析</p>
<pre><code>1.namespace：对应mapper接口(类似dao接口)
2.resultMap：
  1.id：
</code></pre><p>5.一对一查询(resultType 实现)</p>
<p>使用resultType来进行一对一结果映射，查询出的列的个数和映射的属性的个数要一致。而且映射的属性要存在与一个大的对象中，它是一种平铺式的映射，即数据库查询出多少条记录，则映射成多少个对象。</p>
<pre><code>一对一查询(resultMap 实现)

使用resultMap来进行一对一结果映射，它是将关联对象添加到主信息的对象中，具体说是一种对象嵌套另一种对象的一种映射方式。

&lt;resultMap type=&quot;mybatis.po.OrdersExt&quot; id=&quot;OrdersAndUserRstMap&quot;&gt;
    &lt;!-- 订单信息 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
    &lt;!-- 对象嵌套映射 --&gt;
    &lt;!-- association：一对一关联映射 --&gt;
    &lt;!-- property：关联信息查询的结果将要映射的扩展类中的对象属性名称 --&gt;
    &lt;!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --&gt;
    //association：表示在resultMap映射器中，通过&lt;association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来
    &lt;association property=&quot;user&quot; javaType=&quot;mybatis.po.User&quot;&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;/association&gt;
</code></pre><blockquote>
<p>总结：在一对一映射结果时，使用<code>resultType</code>更加简单方便，如果有特殊要求(对象嵌套对象)时，需要使用<code>resultMap</code>进行映射，关联查询出其关联信息。</p>
</blockquote>
<p>6.一对多查询</p>
<pre><code>1.多对一的查询引入association，进行联合查询

     &lt;resultMap id=&quot;resultUserArticleList&quot; type=&quot;Article&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
            &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
            &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;
            &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
                    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
                    &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
                    &lt;result property=&quot;userAddress&quot; column=&quot;userAddress&quot; /&gt;            
            &lt;/association&gt;        
        &lt;/resultMap&gt;

    &lt;select id=&quot;getUserArticles&quot; parameterType=&quot;int&quot; resultMap=&quot;resultUserArticleList&quot;&gt;
           select user.id,user.userName,user.userAddress,article.id aid,article.title,article.content from user,article where user.id=article.userid and user.id=#{id}
    &lt;/select&gt;
</code></pre><blockquote>
<p>总结：在上述配置之后，将select语句与resultMap对应的映射结合起来，可以看出，用association来得到关联的用户，得到的所有文章都是同一个用户的。</p>
</blockquote>
<pre><code>2.复用已经定义好的resultMap，将association中对应的映射独立抽取出来，以至于能够达到复用的目的

    1.首先定义好一个resultMap
            &lt;resultMap type=&quot;User&quot; id=&quot;resultListUser&quot;&gt;
                &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
                &lt;result column=&quot;userName&quot; property=&quot;userName&quot; /&gt;
                &lt;result column=&quot;userAge&quot; property=&quot;userAge&quot; /&gt;
                &lt;result column=&quot;userAddress&quot; property=&quot;userAddress&quot; /&gt;
            &lt;/resultMap&gt;

    2.然后在新定义的resultMap中引用已定义的resultMap
        &lt;resultMap id=&quot;resultUserArticleList-2&quot; type=&quot;Article&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
                &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
                &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;        
                &lt;association property=&quot;user&quot; javaType=&quot;User&quot; resultMap=&quot;resultListUser&quot; /&gt;  //在这里使用association复用已经定义好的resultMap           
           &lt;/resultMap&gt;
</code></pre><p>7.多对多映射查询(只是一对多映射的特例)</p>
<pre><code>多对多映射查询只不过是一对多映射的特例，其是在一对多的基础上添加多个&lt;collection&gt;来表明多个数据表单之间的关系的。

如：

    1.定义resultMap

    &lt;!-- 查询用户即购买的商品信息的ResultMap --&gt;
    &lt;resultMap type=&quot;com.mybatis.entity.User&quot; id=&quot;userAndItemsResultMap&quot;&gt;
        &lt;!-- 用户信息 --&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!-- 订单信息
        一个用户对应多个订单，使用collection映射 
        在用户信息中关联映射商品订单信息--&gt;
        &lt;collection property=&quot;ordersList&quot; ofType=&quot;com.mybatis.entity.Orders&quot;&gt;
             &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
             &lt;result column=&quot;user_id&quot; property=&quot;userid&quot;/&gt;
            &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
            &lt;result column=&quot;createtime&quot; property=&quot;createTime&quot;/&gt;
            &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;

         &lt;!-- 订单明细
                 一个订单包括多个明细
                 在商品订单中关联映射商品订单的多个明细
              --&gt;
              &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.mybatis.entity.OrderDetail&quot;&gt;
                      &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
                     &lt;result column=&quot;items_id&quot;   property=&quot;itemsId&quot;/&gt;
                     &lt;result column=&quot;items_num&quot;  property=&quot;itemsNum&quot;/&gt;
                     &lt;result column=&quot;orders_id&quot;  property=&quot;ordersId&quot;/&gt;
                     &lt;!-- 商品信息
                          一个订单明细对应一个商品
                          然后这儿是一对一的关联映射，所以使用的association进行两者之间的映射 
                       --&gt;
                   &lt;association property=&quot;items&quot; javaType=&quot;com.mybatis.entity.Items&quot;&gt;
                       &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;
                       &lt;result column=&quot;items_name&quot; property=&quot;itemsName&quot;/&gt;
                       &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;
                       &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;
                   &lt;/association&gt;
              &lt;/collection&gt;
          &lt;/collection&gt;

    &lt;/resultMap&gt;
&lt;!-- 查询用户及用户购买的商品信息，使用resulaMap--&gt;

2.定义statement(statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上向数据库发送要执行的SQL语句，Statement用于执行不带参数的简单SQL语句)

&lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;userAndItemsResultMap&quot;&gt;
        SELECT 
               t1.*,
               t2.username,
               t2.sex,
               t2.address,
               t3.id orderdetail_id,
               t3.items_id,
               t3.items_num,
               t3.orders_id,
               t4.itemsname items_name,
               t4.detail items_detail,
               t4.price items_price
        FROM
              orders t1,
              t_user t2,
              orderdetail t3,
              items t4
        WHERE t1.user_id =  t2.id AND  t3.orders_id=t1.id AND t3.items_id = t4.id
&lt;/select&gt;
</code></pre><blockquote>
<p>扩展<br><br>为了验证上述得到的结果是否正确，可以对其进行junit测试。</p>
</blockquote>
<pre><code>public class OrdersCustomMapperTest {
    //创建会话工厂
    private SqlSessionFactory sqlSessionFactory;
    //查询订单，关联查询用户信息，使用resultType实现的测试
    @Test
    public void TestFindOrdersUser() {
        //利用会话工厂创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 创建代理对象
        OrdersCustomMapper oc = sqlSession.getMapper(OrdersCustomMapper.class);
        // 调用mapper接口中的方法
        List&lt;OrdersCustom&gt; list = oc.findOrdersUser();
        //作为验证是否输出的list是否和要查询的结果正确
        System.out.println(list);
        //关闭会话
        sqlSession.close();
}
</code></pre><hr>
<h1 id="mybatis开发总结"><a href="#mybatis开发总结" class="headerlink" title="mybatis开发总结"></a>mybatis开发总结</h1><pre><code>1.一般的查询直接返回实体类型即可，而对于关联查询，处理方式之一就是：自己构造一个resultMap，名称为Map1。然后将自己所需要的字段在新建的resultMap中做一个映射，然后将查询结果设置为新建的Map1。
  注意：在Map1中可以多映射一些字段，为空的查询默认不映射

2.在Mapper层接口，我们一般设置该方法的返回值类型是：List&lt;Map&lt;String,Object&gt;&gt; 每一个list里面放有很多的map键值对

3.#{} 表示一个占位符，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，此外，#{}可以有效防止sql注入
  ${} 表示拼接sql串，通过${}可以将parameterType传入的内容拼接在sql中不进行jdbc类型转换

4.mybatis解决JDBC编程问题
  1.在SqlMapConfig.xml中配置数据库连接池管理数据库连接可以解决因为数据库频繁创建、释放连接而影响系统性能的问题

  2.模糊查询，resultType：表示是List的泛型类型 ${value} 固定写法只能写value表示拼接字符串
</code></pre><hr>
<h2 id="Mybatis整合Spring"><a href="#Mybatis整合Spring" class="headerlink" title="Mybatis整合Spring"></a>Mybatis整合Spring</h2><p>1.整合思路：</p>
<pre><code>1.数据源信息交给Spring管理
2.SqlSessionFactory交给Spring进行单例管理
3.由Spring来管理原始DAO的实现类或者Mapper代理的代理类
</code></pre><h4 id="2-1-具体整合步骤1："><a href="#2-1-具体整合步骤1：" class="headerlink" title="2.1 具体整合步骤1："></a>2.1 具体整合步骤1：</h4><pre><code>1.Mybatis
  1.在配置文件文件夹(config)下创建SqlMapConfig.xml
  2.配置属性文件(db.properties/log4j.properties)

注意：mybatis的配置文件中的数据源配置去掉，由spring进行管理配置。

2.Spring
  1.在配置文件文件夹(config)下创建application.xml
    1.加载Java的配置文件
    &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;
    2.创建数据源
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    //将数据库的驱动(driverClassName)、URL、username、password、maxActive、maxIdle属性值配置完

    3.配置SqlSessionFactory
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        //1.指定mybatis的全局配置文件路径
        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;&gt;
        //2.配置数据源
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3.整合代码
  1.原始DAO开发方式
    1.映射文件(User.xml)
    2.DAO接口代码以及DAO的实现类代码
    3.在application.xml中配置UserDao的实现类
        &lt;bean id=&quot;userDao&quot; class=&quot;xxx.xx.xxx.UserDaoImpl&quot;&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/proerty&gt;
        &lt;/bean&gt;
    4.编写测试代码

  2.mapper代理的方式
    1.映射文件(UserMapper.xml)
    2.Mapper接口
    3.配置mapper代理类
    1.单个mapper代理类的配置
        &lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
            //设置代理类接口
            &lt;property name=&quot;mapperInterface&quot; value=&quot;com.xx.xxx.xx.UserMapper&quot;&gt;&lt;/property&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;    
        &lt;/bean&gt;
    2.批量设置mapper代理类

              &lt;!--批量配置mapper代理类，默认bean的id为类名首字母小写--&gt;
            //通过MapperScannerConfigurer批量扫描创建代理对象
            &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
                &lt;!--配置扫描包--&gt;
                &lt;property name=&quot;basePackage&quot; value=&quot;cn.edu.xidian.c2.mapper&quot; /&gt;
                &lt;!--只有一个sqlSessionFactory时，默认不需要配置SqlSessionFactory,单独配置也可以--&gt;
                &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
</code></pre><hr>
<h4 id="2-2-具体整合步骤2："><a href="#2-2-具体整合步骤2：" class="headerlink" title="2.2 具体整合步骤2："></a>2.2 具体整合步骤2：</h4><pre><code>1.Maven引入需要的jar包(添加依赖 基本的依赖)

2.Spring与Mybatis的整合

  1.建立JDBC属性文件(jdbc.properties 文件编码改为utf-8)
  2.建立spring-mybatis.xml配置文件(用来完成spring和mybatis整合 主要是：自动扫描、自动注入、配置数据库)

3.Log4j的配置

  配置LOG4j的目的是为了更方便测试，使用日志来输出信息，然后所有的项目基本上都是这样一个基本的配置

  1.建立log4j.properties配置文件

4.JUnit测试

  1.创建测试用表
  2.利用MyBatis Generator自动创建代码 这个根据表自动创建实体类、mybatis映射文件、DAO接口

    使用MyBatis Generator自动创建代码 

  3.建立Service接口和实现类

  4.建立测试类

5.整合SpringMVC(springmvc的配置文件单独放，然后在web.xml文件中配置整合)

  1.配置springmvc.xml(主要是自动扫描控制器、视图模式、注解启动这三个的配置)
  2.配置web.xml文件 这里对spring-mybatis.xml配置文件的引入以及配置springmvc的servlet
</code></pre><hr>
<h2 id="Mybatis的逆向工程"><a href="#Mybatis的逆向工程" class="headerlink" title="Mybatis的逆向工程"></a>Mybatis的逆向工程</h2><p>概念：Mybatis提供来一个逆向工程工具，通过逆向工程，可以帮助程序员根据数据表单表来生成po类、mapper映射文件、mapper接口。<br>      就是通过数据库中的单表自动生成Java代码。</p>
<p>具体笔记见mybatis教案</p>
<h4 id="1-逆向工程使用步骤："><a href="#1-逆向工程使用步骤：" class="headerlink" title="1.逆向工程使用步骤："></a>1.逆向工程使用步骤：</h4><pre><code>1.创建generator配置文件
  generator.xml文件内容可以从逆向工程的jar包下的docs目录下的index.html文件中找到相关的源代码

2.使用java类来执行逆向工程

  public class Generator {
    public static void main(String[] args)  throws Exception{
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        File configFile = new File(&quot;config/generator.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    }

}

3.把生成的代码拷贝到项目中
  如果正式项目中已经有po类所在的包了，那么就只需要拷贝po类到指定包下就可以。如果正式项目中没有po包，那么就把逆向工程中整个po类的包拷贝过去。
Mapper.xml和mapper.java的拷贝与po类一样


4.在正式项目中使用逆向工程生成的代码

  public class ItemsMapperTest {

// spring上下文
private ApplicationContext ctx;

@Before
public void setUp() throws Exception {
    // 读取spring的上下文，然后封装到ctx
    ctx = new ClassPathXmlApplicationContext(
            &quot;spring/applicationContext.xml&quot;);
}

@Test
public void testSelectByExample() {
    ItemsMapper mapper = (ItemsMapper) ctx.getBean(&quot;itemsMapper&quot;);

    ItemsExample example = new ItemsExample();
    //使用它进行参数封装传递
    Criteria criteria = example.createCriteria();
    //设置参数
    criteria.andNameEqualTo(&quot;背包&quot;);

    List&lt;Items&gt; list = mapper.selectByExample(example);

    System.out.println(list);
}
</code></pre><p>}</p>
<pre><code>注意：
1.mapper.xml文件已经存在时，如果进行重新生成mapper.xml文件，内容不会被覆盖，而是进行mapper.xml文件内容的追加，结果会导致mybatis解析失败
解决方法：删除原来已经生成的mapper.xml文件再进行生成

2.mybatis自动生成的po以及mapper.java文件不是追加而是直接覆盖，所以不会出现此问题。
</code></pre><hr>
<h2 id="Mybatis-的查询缓存"><a href="#Mybatis-的查询缓存" class="headerlink" title="Mybatis 的查询缓存"></a>Mybatis 的查询缓存</h2><h4 id="1-mybatis缓存分析"><a href="#1-mybatis缓存分析" class="headerlink" title="1.mybatis缓存分析"></a>1.mybatis缓存分析</h4><p>mybatis提供查询缓存，如果缓存中有数据就不用从数据库中获取，用于减轻数据压力，提高系统性能。</p>
<pre><code>一级缓存：SqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)用于存储缓存数据，不同的sqlSession之间的缓存数据区域(HashMap)互相不影响。

二级缓存：mapper级别的缓存，多个SqlSession去操作同一个mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

注意：mybatis默认支持一级缓存

应用：在开发项目过程中，将mybatis与spring进行整合开发，事务控制在service中，一个service方法中包括很多mapper方法调用。
</code></pre><blockquote>
<p>注意：mybatis默认没有开启二级缓存</p>
</blockquote>
<h4 id="2-mybatis-开启二级缓存"><a href="#2-mybatis-开启二级缓存" class="headerlink" title="2.mybatis 开启二级缓存"></a>2.mybatis 开启二级缓存</h4><pre><code>1.在核心配置文件SqlMapConfig.xml中添加开启二级缓存总开关
  &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;

2.在UserMapper映射文件中开启二级缓存（开启mapper下的namespace的二级缓存，默认使用mybatis提供的PerpetualCache）
  &lt;cache&gt;&lt;/cache&gt;

3.实现序列化(因为二级缓存的数据不一定都是存储在内存中的，所以需要给缓存的对象执行序列化，如果该类存在父类，也需要给父类实现序列化)
</code></pre><h4 id="3-mybatis-禁用二级缓存"><a href="#3-mybatis-禁用二级缓存" class="headerlink" title="3.mybatis 禁用二级缓存"></a>3.mybatis 禁用二级缓存</h4><pre><code>在statement中设置userCache=false禁用当前select语句的二级缓存，每次查询都要去数据库中查询，默认情况下是true，该statement使用二级缓存。

&lt;select id=&quot;findUserById&quot;  parameterType=&quot;int&quot;  resultType=&quot;cn.itcast.mybatis.po.User&quot;  useCache=&quot;true&quot;&gt;
        SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre><h4 id="4-mybatis刷新二级缓存"><a href="#4-mybatis刷新二级缓存" class="headerlink" title="4.mybatis刷新二级缓存"></a>4.mybatis刷新二级缓存</h4><pre><code>见mybatis教案
</code></pre><hr>
<h4 id="5-mybatis-延迟加载"><a href="#5-mybatis-延迟加载" class="headerlink" title="5.mybatis 延迟加载"></a>5.mybatis 延迟加载</h4><pre><code>见mybatis教案
</code></pre><hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h4 id="1-Spring-MVC"><a href="#1-Spring-MVC" class="headerlink" title="1.Spring MVC"></a>1.Spring MVC</h4><pre><code>作用于WEB层，相当于Controller，用来处理用户请求。例：用户在地址栏输入http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法(虽然中间可能会包含很多业务，但是这些都不是SpringMVC来处理)
最终将结果返回给用户，并且返回相应的页面(可以只返回json/xml等格式数据)

总结：SpringMVC只负责跟用户打交道，做前面和后面的活，中间的实现过程等业务不是它负责。
</code></pre><h4 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2.Spring"></a>2.Spring</h4><pre><code>最常见，经常用到的是IOC容器，其可以装载bean(Java中的类，也包括service dao里面的)有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。
</code></pre><h4 id="3-mybatis"><a href="#3-mybatis" class="headerlink" title="3.mybatis"></a>3.mybatis</h4><pre><code>1.能够自由控制SQL
2.可以使用xml的方式来组织管理我们的SQL
</code></pre><hr>
<p>1.SSM整合</p>
<pre><code>1.Java各种对象的区分

PO 持久对象(entity) PO每个属性基本上都对应数据库表里面的某个字段，完全是一个符合Java Bean规范的Java对象，没有增强别的属性和方法。持久对象是由&lt;insert&gt;&lt;/insert&gt;数据库创建，由数据库&lt;delete&gt;&lt;/delete&gt;删除的。基本上持久对象生命周期和数据库密切相关。

VO 值对象 通常用于业务层(Service层)之间的数据传输，与PO一样只包含数据,此外应该抽象出业务对象。表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。

DTO 数据传输对象 是一种设计模式之间传输数据的软件应用系统 作用仅在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。

POJO 简单的Java对象 实际上可以理解POJO为简单的实体类 方便开发者使用数据库中的数据表
</code></pre><hr>
<h2 id="DTO-数据传输对象（起到数据封装与隔离的作用）"><a href="#DTO-数据传输对象（起到数据封装与隔离的作用）" class="headerlink" title="DTO 数据传输对象（起到数据封装与隔离的作用）"></a>DTO 数据传输对象（起到数据封装与隔离的作用）</h2><p>在实际的项目中，DTO分为两层传输</p>
<pre><code>1.Service层向Controller层，这一层的DTO封装Service执行结果给Controller简化业务数据，只提取部分业务相关字段或补充处理相关字段，不同业务可能有不同的此类dto，具有业务相关性。

2.Controller层向WEB前端，这一层DTO封装Controller执行结果，返回前端WEB，请求返回实体封装类，适用于所有ajax请求返回的类型实体，无业务相关性。
</code></pre><hr>
<h2 id="SSM整合知识点概括"><a href="#SSM整合知识点概括" class="headerlink" title="SSM整合知识点概括"></a>SSM整合知识点概括</h2><pre><code>1.Controller方法返回值(指定返回到哪个页面，指定返回到页面的数据)

    1)ModelAndView 

        modelAndView.addObject(&quot;itemList&quot;, list); 指定返回页面的数据

        modelAndView.setViewName(&quot;itemList&quot;);     指定返回的页面

    2)String(推荐使用)

        返回普通字符串,就是页面去掉扩展名的名称, 返回给页面数据通过Model来完成

        返回的字符串以forward:开头为请求转发

        返回的字符串以redirect:开头为重定向

    3)返回void(使用它破坏了springMvc的结构,所以不建议使用)

        可以使用request.setAttribut(因为我们写的是服务端，所以使用request对象向view中传输数据) 来给页面返回数据

        可以使用request.getRquestDispatcher().forward()来指定返回的页面

        如果controller返回值为void则不走springMvc的组件,所以要写页面的完整路径名称

    相对路径:相对于当前目录,也就是在当前类的目录下,这时候可以使用相对路径跳转

    绝对路径:从项目名后开始.
</code></pre><blockquote>
<p>注意：在springMvc中不管是forward还是redirect后面凡是以/开头的为绝对路径,不以/开头的为相对路径。</p>
</blockquote>
<pre><code>例如:
    forward:/items/itemEdit.action 为绝对路径

    forward:itemEdit.action为相对路径
</code></pre><hr>
<pre><code>2.架构级别异常处理

    此异常编写是实现全局异常处理器接口，目的主要为了防止项目上线后给用户抛500等异常信息,所以需要在架构级别上整体处理.hold住异常

    1.首先自定义全局异常处理器实现HandlerExceptionResolver接口
        public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {//....

    2.在spirngMvc.xml中配置生效
</code></pre><hr>
<pre><code>3.上传图片

    1)在tomcat中配置虚拟图片服务器

    2)导入fileupload的jar包

    3)在springMvc.xml中配置上传组件

    4)在页面上编写上传域,更改form标签的类型

    5)在controller方法中可以使用MultiPartFile接口接收上传的图片

    6)将文件名保存到数据库,将图片保存到磁盘中
</code></pre><hr>
<pre><code>4.JSON数据交互

    1.首先在pom.xml中配置好需要的jar包(jackson的jar包)

    2.@Requestbody:将页面传到controller中的json格式字符串自动转换成java的pojo对象
      @ResponseBody:将java中pojo对象自动转换成json格式字符串返回给页面
</code></pre><hr>
<pre><code>5.RestFul风格支持

    此风格就是对URL的命名标准，此标准要求URL中只能有名词，要求URL中不能用?传参

    传参数：
        页面：${pageContext.request.contextPath}/items/itemEdit/${item.id}
        方法：@RequestMapping(&quot;/itemEdit/{id}&quot;)
        方法：@PathVariable(&quot;id&quot;) Integer id
</code></pre><hr>
<pre><code>6.拦截器

    作用：拦截请求，一般在登录的时候用得比较多
    1.需要编写自定义拦截器类,实现HandlerInterceptor接口
        public class AuthorizedInterceptor implements HandlerInterceptor {//......
    2.在spirngMvc.xml中配置拦截器生效
</code></pre><hr>
<pre><code>7.登录权限验证

    1)编写登录的Controller，编写跳转到登录页面，编写登录验证方法
    2)编写登录页面
    3)编写拦截器
</code></pre><blockquote>
<p>总结：随意访问一个页面，拦截器会拦截请求，会验证session是否有登录信息。如果已经登录，放。如果未登录，跳转到登录页面<br>          在登录页面输入用户名、密码，点击登录按钮，拦截器会拦截请求，如果登录路径在Controller方法中判断用户名和密码正确则将登录信息方法session中。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>百度富文本</title>
    <url>/undefined/%E7%99%BE%E5%BA%A6%E5%AF%8C%E6%96%87%E6%9C%AC(Ueditor)/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-Ueditor和Spring-MVC-的整合"><a href="#1-Ueditor和Spring-MVC-的整合" class="headerlink" title="1.Ueditor和Spring MVC 的整合"></a>1.Ueditor和Spring MVC 的整合</h2><h4 id="1-config-json"><a href="#1-config-json" class="headerlink" title="1.config.json"></a>1.config.json</h4><p>该配置文件定义了支持的上传文件/图片的接口以及限制。<br><a id="more"></a></p>
<h4 id="2-集成步骤"><a href="#2-集成步骤" class="headerlink" title="2.集成步骤"></a>2.集成步骤</h4><p>1.采用maven的方式来组织构建<br><br>在下面的程序中可以看出引入了文件上传以及json的序列化与反序列化处理的依赖包。</p>
<pre><code>&lt;!-- 上传文件的支持 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.10&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- org.json --&gt;
&lt;!--JSON is a light-weight, language independent, data interchange format. See http://www.JSON.org/--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.json&lt;/groupId&gt;
    &lt;artifactId&gt;json&lt;/artifactId&gt;
    &lt;version&gt;20160212&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.资源访问配置<br><br>在我们将ueditor静态文件放入webapp目录下之后需要在springmvc.xml配置文件中进行设置排除。</p>
<p>3.引入ueditor的源码<br></p>
<p>4.添加Controller处理类<br><br>该controller处理类原先ueditor中的controller.jsp中的处理代码，改成springmvc的模式，其完成了编辑器初始化工作以及图片/文件的上传处理。</p>
<pre><code>@Controller
@RequestMapping(&quot;/ued&quot;)
public class UEditorController {

    @RequestMapping(value=&quot;/config&quot;)
    public void config(HttpServletRequest request, HttpServletResponse response) {

        response.setContentType(&quot;application/json&quot;);
        String rootPath = request.getSession()
                .getServletContext().getRealPath(&quot;/&quot;);

        try {
            String exec = new ActionEnter(request, rootPath).exec();
            PrintWriter writer = response.getWriter();
            writer.write(exec);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre><p>5.配置config.json文件<br><br>该配置文件定义了文件/图片的上传接口，以及各种限制(文件的大小上限)。这里将配置文件放在webapp/conf目录下，所以在读取路径配置的时候需要修改。在类ConfigManager中修改为：</p>
<pre><code>private String getConfigPath () {
return this.rootPath
        + File.separator + &quot;conf&quot;
        + File.separator + ConfigManager.configFileName;
}
</code></pre><p>6.修改ueditor.config.js配置配置文件<br><br>在这里需要制定编辑器访问服务器的初始化地址。</p>
<pre><code>window.UEDITOR_CONFIG = {

//为编辑器实例添加一个路径，这个不能被注释
UEDITOR_HOME_URL: URL

// 服务器统一请求接口路径
//      原先默认的
//, serverUrl: URL + &quot;jsp/controller.jsp&quot;
//      修改后的
, serverUrl: &quot;/ued/config&quot;
</code></pre><blockquote>
<p>注意：修改的serverUrl需要指向自己的服务器地址。</p>
</blockquote>
<h2 id="ueditor的配置、文件上传"><a href="#ueditor的配置、文件上传" class="headerlink" title="ueditor的配置、文件上传"></a>ueditor的配置、文件上传</h2><pre><code>1.ueditor.config.js的配置
  window.UEDITOR_HOME_URL = &quot;/项目名/ueditor/&quot;;

2.在页面中加载ueditor编辑页面
  在&lt;head&gt;&lt;/head&gt;之间引入三个script。注意：ueditor.config.js 一定要放在ueditor.all.min.js的前面，否则加载不出编辑页面。

3.在&lt;body&gt;&lt;/body&gt;之间实例化ueditor。注意：type=&quot;text/plain&quot;而不是type=&quot;text/javascript&quot;。同时在&lt;body&gt;&lt;/body&gt;中实例化编辑器。

    &lt;script type=&quot;text/javascript&quot;&gt;
        //实例化编辑器
        var ue = UE.getEditor(&apos;editor&apos;);
    &lt;script&gt;

4.配置图片上传的路径
  修改config.json中的&quot;imagePathFormat&quot;: &quot;/×××/upload/image/{yyyy}-{mm}-{dd}/{filename}&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */&lt;br&gt;
  xxx：表示在www目录下的项目名称，这样配置之后就会在项目名称目录下自动创建一个对应的文件夹upload/image/当前日期/

5.编辑的文章保存数据库
  在编辑的文章保存数据库的过程中其实只有HTML程序与相关的文字保存到数据库中。

  1.在编辑页面&lt;body&gt;&lt;/body&gt;中添加程序：

    &lt;form action=&quot;saveshowController&quot; method=&quot;post&quot;&gt;
        &lt;textarea id=&quot;wordtype&quot; name=&quot;wordtype&quot; style=&quot;display: none&quot;&gt;&lt;/textarea&gt;
        &lt;button id=&quot;submit&quot; onclick=&quot;getstring();&quot;&gt;提交&lt;/button&gt;
    &lt;/form&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;

        function getstring(){
            document.getElementById(&apos;wordtype&apos;).innerHTML=UE.getEditor(&apos;editor&apos;).getContent();
            //get.Content() 函数可以获得你所编辑的内容的html代码
        }
    &lt;/script&gt;

    注释：表示的是在当前页面中以post的方式将当前页面中表单的内容提交给后台saveshowController中，然后在saveshowController中以相应的方法获取textarea中的数据，然后操作数据库以实现数据包的保存。
</code></pre><h2 id="百度富文本开发案例"><a href="#百度富文本开发案例" class="headerlink" title="百度富文本开发案例"></a>百度富文本开发案例</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title>程序猿日常-编程随笔</title>
    <url>/undefined/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%97%A5%E5%B8%B8-%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>让优秀成为习惯，让知识成为信仰</p>
</blockquote>
<p>&nbsp;&nbsp;在刚接触编程时，总是问师哥师姐如何快速的高效率的学好编程，但是得到的回答总是让人拿捏不准。而那时候于我而言，只是觉得编程让我的逼格更高，更能得到别人的佩服，不会想到学习好编程会改变我们的思考方式和解决问题的逻辑，以此在这条路上也是给自己挖了很多的坑，现在填坑的过程真的是很痛苦，所以在这里分享一些自己的经验给各位有心学习编程的编程儿们，希望能够跳过这些坑~<br><a id="more"></a></p>
<h4 id="心理准备"><a href="#心理准备" class="headerlink" title="心理准备"></a>心理准备</h4><p>&nbsp;&nbsp;自学编程的弯路多得数不完，坑多得踩不完。如果你决定要自学编程，就意味着踏上了一条面对困难、挫折和失败的无尽之路，要想清楚自己能不能承受这些挫折，自己能不能坚持走到最后。</p>
<p>在自学编程的过程中总是会遇到这样或者那样的问题。</p>
<ul>
<li>编程的环境不会搭建(如：Java、Android以及Python等编程需要搭建开发环境)</li>
<li>学习编程时知识点多，一环紧扣一环，没有耐心和时间慢慢的搞懂每一个知识点</li>
<li>学习的路线曲折，刚学的知识点下一刻就忘得一干二净</li>
<li>编程语法，语言逻辑让人头大，完全不能理解其思路</li>
<li>跟着编程教程学习总是遇到这样或那样的问题</li>
<li>花了功夫，到头来运行程序全部出错</li>
<li>错误解决不了，改到怀疑人生</li>
<li>编程从入门到放弃</li>
<li>技术更新迭代很快，学习的旧的知识点很多都更新了(如：Java)</li>
</ul>
<p>在编程这条路上，如果我们学习的时候没有一颗能战胜这些苦恼的勇敢的心，趁早还是转行做其它，不然到头来受伤的还是自己。<strong>而如果喜欢挑战，并且在这一条路上不甘寂寞，砥砺前行，</strong>那么恭喜你可以踏上编程之路，能够努力的去追寻自己的梦想~</p>
<h4 id="努力的方向"><a href="#努力的方向" class="headerlink" title="努力的方向"></a>努力的方向</h4><blockquote>
<p>选择正确的方向，努力才会有意义</p>
</blockquote>
<p>编程的世界是多元纷繁的，大的方向就分前端开发、后端开发、移动开发、云计算、数据处理、智能硬件、物联网、虚拟现实等等，光编程语言都几十种。如果没有做过功课，贸然进入只会分分钟懵逼。<strong>所以最好是根据自己的兴趣爱好再结合市场前景，先选定一个方向，再选择一门语言，然后头也不回的深深扎进去。</strong></p>
<p>我当初开始自学编程的时候，因为开始的时候学了点C语言,就准备学C++，想在这上面学到很大神的那种境界。不过C++学了没几天，发现游戏编程的Unity 3D挺好玩的，就转学Unity 3D。Unity 3D学了段时间又觉得系统开发很有意思，然后又去学习JavaWeb开发。后面才意识到自己在移动应用上面有极大的兴趣并有一些自己的想法，再加上本人很喜欢Google,遂最终决定好好学习Android移动开发。</p>
<p>如果自己对自己兴趣爱好没有深刻的认识，没有明确的学习目标，只是一味茫然的去尝试，最终只会像猴子掰玉米一样，不但浪费了自己宝贵的时间，还会一无所获。</p>
<h4 id="制定学习目标计划"><a href="#制定学习目标计划" class="headerlink" title="制定学习目标计划"></a>制定学习目标计划</h4><p>选定了方向之后，剩下的就是朝着目的努力前进了。自学的过程是枯燥乏味的，也没有人陪伴督促，<strong>所以要想自学有一定成果，除了要有清晰明确的目标计划，还要有很强的自我约束能力，还要善于自我及激励。</strong>不然很容易自由涣散，三天打鱼两天晒网，看起来花了不少时间，实际上没学到什么。</p>
<p>我开始的时候就是凭兴趣漫无目的的学习，结果发现收效甚微，于是才制定学习计划，开始系统的学习。我先是学习了JAVA基础语法，然后将整个Android开发涉及到的所有知识面简单快速的学习一遍，这样对整个体系框架有一个全面大概的认识，然后在详细具体的学习每一部分，尽量搞明白其中的实现逻辑和原理，以达到掌握知识的目的。最后开发练习的时候再根据自己要实现什么功能，去查相关的资料。</p>
<h4 id="优化学习方式"><a href="#优化学习方式" class="headerlink" title="优化学习方式"></a>优化学习方式</h4><p><strong>一、做好笔记，记录经验</strong><br>我们大多数人并没有过目不忘的神技，很多时候我们学了也不一定马上掌握，需要过后花时间慢慢领悟，而且还有忘掉的风险，所以对于重要的知识点都要做好笔记。</p>
<p>编程的过程中总会遇到各种各样的问题，比如编程环境的配置，常用的快捷键，编程过程中的错误、异常，软件更新问题等等。这些问题往往会不只一次出现，所以我们面对这些问题都是如何解决的，一定要记录下来，一是增加自己解决问题的经验，而是以防下次出现。</p>
<p>我做笔记记录的方式：</p>
<ul>
<li>截图</li>
<li>拍照</li>
<li>写记事本</li>
<li>写Word文档</li>
</ul>
<p>除了最初用纸质笔记本做过笔记，后面都是用上面的方式。用电子的方式方便快捷易于分享，而且我还能传到手机上，利用其它时间随时随地阅读。</p>
<p><strong>二、认认真真敲代码</strong><br><strong>二、认认真真敲代码</strong><br><strong>二、认认真真敲代码</strong><br>编程没有捷径，只有勤奋努力。</p>
<p><strong>三、多看官方文档，外文资料</strong><br>互联网是一个更新迭代很快的行业，所有编程语言都会不断的更新新功能和修复旧Bug，网上查的资料很有可能是旧的解决方案，现在已经不适用了。所以最好最快的方法就是查看官方文档。</p>
<p>毕竟互联网技术还是国外发展起来的，所以在很多技术问题方面，人家还是有优势的。有些问题在国内不一定能找到答案就去外网找。</p>
<p><strong>四、进入行业圈子</strong><br>只有进入行业圈子与其他人交流，你才了解最新的行业动态，才知道自己需要更新哪些技能。最重要的是有了这群人，自己遇到问题解决起来嗖嗖的，那速度才叫“倍爽儿”。<br>进入行业圈子的方式：</p>
<ul>
<li>混迹各行业网站论坛个人技术博客<br>一般在搜问题时很容易就搜到这些网站</li>
<li>关注各种行业话题和人<br>比如知乎、微博、微信公众号等</li>
<li>QQ群、微信群<br>交流基地，技术后援团</li>
<li>Github<br>互联网圣地，行业大圈子就在这。</li>
</ul>
<p><strong>五、动手做项目</strong><br>我们学习编程的最终目的就是用所学的做出具有一定功能的项目，而做项目又是最好的学习和巩固知识的方式。如果前期能力不足就先做一些简单的功能模块，一步一步慢慢来，不要一开始就要实现各种酷炫炸天功能，遇到不会的就在网上查， 现在互联网这么发达，获取资源也及其方便。而且开发前也最好在网上查一下有没有已经成型的框架或模板，编程界有一句很流行的话“不要重复造轮子”，什么都自己做一是很耗费时间，二是自己技术能力不足还可能留下不少坑。</p>
<h4 id="收获回报"><a href="#收获回报" class="headerlink" title="收获回报"></a>收获回报</h4><p>自学编程说起来到处都是苦，但也并不是完全一无是处。客观地看，自学编程还是有很多好处的。</p>
<ul>
<li>培养自学能力</li>
<li>掌握一门技术</li>
<li>锻炼毅力和独处能力</li>
<li>提高解决问题能力</li>
<li>提高面对挫折失败的承受能力</li>
<li>改变思维方式</li>
<li>享受沉浸专注的快乐</li>
<li>享受创造的快乐</li>
</ul>
<h4 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h4><ol>
<li><p>自学视频网站：</p>
<p><strong><a href="http://www.imooc.com" target="_blank" rel="noopener">慕课网</a></strong>  本人主要学习网站，课程全部免费而且视频比较新，有课程计划和在线编程。<br><strong><a href="http://www.jikexueyuan.com" target="_blank" rel="noopener">极客学院</a></strong>  课程全多，部分课程需要VIP，有的课程比较旧。<br><strong><a href="http://www.maiziedu.com" target="_blank" rel="noopener">麦子学院</a></strong>  大多要报线上培训班，不过好像有免费入口，反正我看的Android全部免费。<br><strong><a href="http://edu.51cto.com/?www" target="_blank" rel="noopener">51CTO学院</a></strong>  没用过<br><strong><a href="http://study.163.com/" target="_blank" rel="noopener">网易云课堂</a></strong>  只用过网易公开课，没用过云课堂。<br><strong><a href="http://www.miguxue.com/" target="_blank" rel="noopener">咪咕学院</a></strong>  没用过<br><strong><a href="http://mooc.guokr.com/" target="_blank" rel="noopener">MOOC学院</a></strong> 果壳慕课网，比较杂，没用过。</p>
</li>
<li><p>手机应用</p>
<p><strong><a href="https://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a></strong>  专业互联网问答，有PC版。<br><strong><a href="http://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></strong>  程序员学习分享平台。<br><strong><a href="http://gold.xitu.io/welcome" target="_blank" rel="noopener">掘金</a></strong>  高质量技术分享平台<br><strong><a href="http://git.oschina.net/" target="_blank" rel="noopener">码云</a></strong>  OSChina旗下云端开发者服务平台<br><strong><a href="http://biji.baidu.com/inotes/" target="_blank" rel="noopener">涂书笔记</a></strong>  有道云笔记、印象笔记这些大家都知道了，图书笔记的特点是可以上传照片并识别照片中文字。主要针对读书人群。<br>Mindjet Maps   思维导图，大名鼎鼎MindManager的Android版，免费<br>极品思维导图 Android版，功能齐全<br><strong><a href="https://www.wunderlist.com/zh/" target="_blank" rel="noopener">奇妙清单</a></strong>  待办事项清单<br><strong><a href="http://www.idothing.com/" target="_blank" rel="noopener">种子习惯</a></strong>  习惯养成应用</p>
</li>
<li>翻墙软件<br>shadowsocks</li>
<li>浏览器<br>Chrome浏览器 各种开发工具，各种插件，开发者大多都用Chrome浏览器（去广告，翻译轻轻松松）</li>
</ol>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>希望大家和我一样在编程这条路上体会到编程的乐趣~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>编程之路</tag>
      </tags>
  </entry>
</search>
