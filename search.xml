<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>西电体检信息管理系统 - 接口文档</title>
    <url>/undefined/%E8%A5%BF%E7%94%B5%E4%BD%93%E6%A3%80%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%20-%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="西电体检信息管理系统-接口文档"><a href="#西电体检信息管理系统-接口文档" class="headerlink" title="西电体检信息管理系统  - 接口文档"></a>西电体检信息管理系统  - 接口文档</h2><p>[TOC]</p>
<h4 id="1-接口功能"><a href="#1-接口功能" class="headerlink" title="1.接口功能"></a>1.接口功能</h4><blockquote>
<p>此接口实现的是用户根据用户名、学号、身份证号查询用户的体检信息，如果用户输入的信息在体检信息库里面不存在，返回false。否则返回用户的具体体检信息。</p>
</blockquote>
<h4 id="2-接口链接-URL"><a href="#2-接口链接-URL" class="headerlink" title="2.接口链接(URL)"></a>2.接口链接(URL)</h4><blockquote>
<p><a href="http://bodycheckinfo/demand/result/" target="_blank" rel="noopener">http://bodycheckinfo/demand/result/</a></p>
</blockquote>
<h4 id="3-支持格式"><a href="#3-支持格式" class="headerlink" title="3.支持格式"></a>3.支持格式</h4><blockquote>
<p>JSON</p>
</blockquote>
<h4 id="4-HTTP请求方式"><a href="#4-HTTP请求方式" class="headerlink" title="4.HTTP请求方式"></a>4.HTTP请求方式</h4><blockquote>
<p>POST<br><a id="more"></a></p>
</blockquote>
<h4 id="5-请求参数"><a href="#5-请求参数" class="headerlink" title="5.请求参数"></a>5.请求参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>是否必选</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>idNum</td>
<td>true</td>
<td>String</td>
<td>用户身份证号</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>true</td>
<td>String</td>
<td>用户姓名</td>
<td></td>
</tr>
<tr>
<td>studentNum</td>
<td>true</td>
<td>String</td>
<td>用户学号</td>
<td></td>
</tr>
<tr>
<td>attachedWord</td>
<td>false</td>
<td>String</td>
<td>自动生成的秘钥</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="6-返回参数"><a href="#6-返回参数" class="headerlink" title="6.返回参数"></a>6.返回参数</h4><p>对当前接口返回参数的说明，即{“ret”:返回状态码,”data”:”返回的业务数据”,”msg”:”错误提示”}中的data部分进行说明。<br>在本地输入链接：<code>http://localhost:8000/bodycheckinfo/d/record?attachedWord=ec8(!37@fd865{s(f$-*2ADV.&amp;studentNum=18021211086</code>得到如下JSON数据结果返回。</p>
<pre><code>{
    &quot;ret&quot;: 200,
    &quot;data&quot;:{
    &quot;bodyCheck&quot;:&quot;正常&quot;,
    &quot;checkTime&quot;:1535558400000,
    &quot;hemorrhagic1&quot;:&quot;未注射&quot;,
    &quot;hemorrhagic2&quot;:&quot;未注射&quot;,
    &quot;hemorrhagic3&quot;:&quot;未注射&quot;,
    &quot;hepatitisA1&quot;:&quot;未注射&quot;,
    &quot;hepatitisA2&quot;:&quot;未注射&quot;,
    &quot;hepatitisB1&quot;:&quot;未注射&quot;,
    &quot;hepatitisB2&quot;:&quot;未注射&quot;,
    &quot;hepatitisB3&quot;:&quot;未注射&quot;,
    &quot;hepatitisBCheck&quot;:&quot;未检查&quot;,
    &quot;idNum&quot;:&quot;522224199410221612&quot;,
    &quot;kidney&quot;:&quot;未检查&quot;,
    &quot;listSubmit&quot;:0,
    &quot;listSubmitStr&quot;:&quot;未提交&quot;,
    &quot;liverFunction&quot;:&quot;正常&quot;,
    &quot;measles&quot;:&quot;未注射&quot;,
    &quot;name&quot;:&quot;张大大&quot;,
    &quot;ppdCheck&quot;:&quot;正常&quot;,
    &quot;sex&quot;:&quot;男&quot;,
    &quot;studentId&quot;:21018,
    &quot;studentNum&quot;:&quot;15289561248256&quot;
    },
    &quot;msg&quot;: &quot;&quot;
}
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bodyCheck</td>
<td>String</td>
<td>体检结果</td>
</tr>
<tr>
<td>checkTime</td>
<td>String</td>
<td>体检时间(时间戳)</td>
</tr>
<tr>
<td>hemorrhagic1</td>
<td>String</td>
<td>出血热第一针</td>
</tr>
<tr>
<td>hepatitisA1</td>
<td>String</td>
<td>甲肝疫苗第一针</td>
</tr>
<tr>
<td>hepatitisB1</td>
<td>String</td>
<td>乙肝疫苗第一针</td>
</tr>
<tr>
<td>hepatitisBCheck</td>
<td>String</td>
<td>乙肝</td>
</tr>
<tr>
<td>idNum</td>
<td>String</td>
<td>身份证号</td>
</tr>
<tr>
<td>kidney</td>
<td>String</td>
<td>肾功能检查</td>
</tr>
<tr>
<td>listSubmit</td>
<td>Integer</td>
<td>体检表是否提交</td>
</tr>
<tr>
<td>liverFunction</td>
<td>String</td>
<td>肝功能检查</td>
</tr>
<tr>
<td>measles</td>
<td>String</td>
<td>荨麻疹</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>姓名</td>
</tr>
<tr>
<td>ppdCheck</td>
<td>String</td>
<td>ppd检查</td>
</tr>
<tr>
<td>sex</td>
<td>String</td>
<td>性别</td>
</tr>
<tr>
<td>studentId</td>
<td>String</td>
<td>学生id</td>
</tr>
<tr>
<td>studentNum</td>
<td>String</td>
<td>学号</td>
</tr>
</tbody>
</table>
<h4 id="7-接口实例"><a href="#7-接口实例" class="headerlink" title="7.接口实例"></a>7.接口实例</h4><p>在浏览器输入链接：<code>http://localhost:8000/bodycheckinfo/d/record?attachedWord=ec8(!37@fd865{s(f$-*2ADV.&amp;studentNum=18021211086&amp;name=%E8%83%A1%E9%82%A6%E9%87%91</code>得到返回值。</p>
<pre><code>{
    &quot;data&quot;:{
                &quot;bodyCheck&quot;:&quot;正常&quot;,
                &quot;checkTime&quot;:1535558400000,
                &quot;hemorrhagic1&quot;:&quot;未注射&quot;,
                &quot;hemorrhagic2&quot;:&quot;未注射&quot;,
                &quot;hemorrhagic3&quot;:&quot;未注射&quot;,
                &quot;hepatitisA1&quot;:&quot;未注射&quot;,
                &quot;hepatitisA2&quot;:&quot;未注射&quot;,
                &quot;hepatitisB1&quot;:&quot;未注射&quot;,
                &quot;hepatitisB2&quot;:&quot;未注射&quot;,
                &quot;hepatitisB3&quot;:&quot;未注射&quot;,
                &quot;hepatitisBCheck&quot;:&quot;未检查&quot;,
                &quot;idNum&quot;:&quot;78256985465877425422454&quot;,
                &quot;kidney&quot;:&quot;未检查&quot;,
                &quot;listSubmit&quot;:0,
                &quot;listSubmitStr&quot;:&quot;未提交&quot;,
                &quot;liverFunction&quot;:&quot;正常&quot;,
                &quot;measles&quot;:&quot;未注射&quot;,
                &quot;name&quot;:&quot;张大大&quot;,
                &quot;ppdCheck&quot;:&quot;正常&quot;,
                &quot;sex&quot;:&quot;男&quot;,
                &quot;studentId&quot;:21018,
                &quot;studentNum&quot;:&quot;1234567891025&quot;
            },
        &quot;info&quot;:&quot;success&quot;
}
</code></pre>]]></content>
      <categories>
        <category>西电体检信息管理系统</category>
      </categories>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 浏览器开发者程序</title>
    <url>/undefined/Chrome%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%A1%E6%9F%A5%E5%85%83%E7%B4%A0(F12)%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Chrome开发者工具功能模块"><a href="#Chrome开发者工具功能模块" class="headerlink" title="Chrome开发者工具功能模块"></a>Chrome开发者工具功能模块</h2><h4 id="1-Elements"><a href="#1-Elements" class="headerlink" title="1.Elements"></a>1.Elements</h4><p>主要用来查看前端界面的html的Dom结构，和修改css的样式。查看或修改HTML元素的属性、CSS属性、监听事件、断点等。</p>
<h4 id="2-console"><a href="#2-console" class="headerlink" title="2.console"></a>2.console</h4><p>这个除了查看错误信息、打印调试信息(console.log())、写一些测试脚本以外，还可以当作Javascript API查看用。用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。例如我想查看console都有哪些方法和属性，我可以直接在Console中输入”console”并执行。<br><a id="more"></a></p>
<h4 id="3-Sources"><a href="#3-Sources" class="headerlink" title="3.Sources"></a>3.Sources</h4><p>该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。</p>
<h4 id="4-Network"><a href="#4-Network" class="headerlink" title="4.Network"></a>4.Network</h4><p>网络页面主要用于查看header等与网络连接相关的信息。</p>
<h4 id="5-技巧总结"><a href="#5-技巧总结" class="headerlink" title="5.技巧总结"></a>5.技巧总结</h4><pre><code>1.直接修改页面元素
  在elements面板双击进行修改，或者右击edit html进行修改。

2.颜色取色器
  在elements面板中的Styles窗口中有一个color小方块(如果没有可以自己加上color:red等)，然后会弹出颜色拾取器，我们可以在上面颜色画板中选择一个颜色，或者选择笔拾取一个颜色。

3.快速查找并定位文件
  Ctrl+p

4.编辑源码
  1.Console 下面输入框输入，回车直接执行，多行代码在别的编辑器编辑好之后复制进来执行。
  2.Sources 下面，点击左上角第二行Sources旁边的“&gt;&gt;”打开Snippets，点击“+ New Snippet”新建一个文件编辑脚本，写完右键“Save”保存，再右键点击这个文件“Run”运行。

  注意：如果是要覆盖页面JS程序，如果是函数，则是直接以相同的函数名重写方法即可。如果是要覆盖页面JS代码的按钮事件，则需要重新注册该事件，否则相同的多个事件会全部响应。

5.只分析异步请求资源
  Network 下面点击XHR，这样就只会显示XHR异步请求资源，以便于快速分析请求Header和Response。

6.在源码中快速调到指定行
  在Sources标签中打开一个文件之后，按Ctrl + G然后输入行号，chrome控制台就会跳转到你输入的行号所在的行。

7.使用多个插入符进行选择
  当编辑一个文件的时候，你可以按住Ctrl在你要编辑的地方点击鼠标，可以设置多个插入符，这样可以一次在多个地方编辑。
</code></pre>]]></content>
      <categories>
        <category>开发者工具</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/undefined/Git/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-git-rebase"><a href="#1-git-rebase" class="headerlink" title="1.git rebase"></a>1.git rebase</h2><p>git合并代码主要有两种方式：</p>
<pre><code>1.merge处理，这是我们比较能理解的方式。
2.rebase处理，中文此处翻译为衍合过程。
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-学习笔记</title>
    <url>/undefined/Java-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Java开发前奏"><a href="#Java开发前奏" class="headerlink" title="Java开发前奏"></a>Java开发前奏</h2><h3 id="1-计算机基础"><a href="#1-计算机基础" class="headerlink" title="1.计算机基础"></a>1.计算机基础<br></h3><h4 id="1-1-计算机"><a href="#1-1-计算机" class="headerlink" title="1.1.计算机"></a>1.1.计算机</h4><p>电子计算机，俗称电脑，是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。</p>
<h3 id="1-2-硬件和软件"><a href="#1-2-硬件和软件" class="headerlink" title="1.2.硬件和软件"></a>1.2.硬件和软件</h3><h4 id="1-2-1-硬件"><a href="#1-2-1-硬件" class="headerlink" title="1.2.1.硬件"></a>1.2.1.硬件</h4><pre><code>1.CPU是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成。作为整个系统的核心，CPU 也是整个系统最高的执行单元，因此CPU已成为决定电脑性能的核心部件，很多用户都以它为标准来判断电脑的档次。CPU的主频,即CPU内核工作的时钟频率（CPU Clock Speed）。该时钟速度越快，时间段内执行的指令就越多， 目前酷睿是2G-3G（1G是10000Mhz）例如，2MHz（200万次/秒），3GHz（三十亿次/秒）。
</code></pre><a id="more"></a>
<pre><code>2.内存是数据与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。

3.    存储设备：内存不能长久保存数据（非ROM），断电时信息就丢失，程序和数据都会被保存在存储设备中（例如硬盘），当程序和数据需要使用时，再加载进内存，注意：内存读取和写入的速度要比存储设备快的多。

    存储设备主要有：磁盘驱动器，光盘驱动器（cd dvd）USB闪存（U盘）。
</code></pre><h4 id="1-2-2-软件"><a href="#1-2-2-软件" class="headerlink" title="1.2.2.软件"></a>1.2.2.软件</h4><pre><code>软件的概述：按照一定顺序组织的计算机数据与指令的集合。
软件 = 数据+指令+文档

1.系统软件
    例如：Widows xp  Linux Unix 

2.应用软件
    例如：QQ、WPS、Photoshop、、微软的Office
软件开发：制作软件。
软件的本质 ：提高人与计算机交流效率，方便人与机器交互。
</code></pre><h3 id="1-3-人机交互的方式："><a href="#1-3-人机交互的方式：" class="headerlink" title="1.3.人机交互的方式："></a>1.3.人机交互的方式：</h3><pre><code>1.图形化界面：简单直观，容易操作，用户的体验好。
2.dos命令交互方式：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令,而且只能完成一些比较单一的功能。
    控制台打开的步骤：开始--所有程序---附件--命令行提示符
    或者开始-输入cmd即可。
</code></pre><h3 id="1-4-常见的dos命令"><a href="#1-4-常见的dos命令" class="headerlink" title="1.4.常见的dos命令"></a>1.4.常见的dos命令</h3><pre><code>盘符：进入指定的盘符下。
dir: 列出当前目录下的文件以及文件夹
md : 创建目录 
rd : 删除目录    注意：rd不能删除非空的文件夹，而且只能用于删除文件夹。
cd : 进入指定目录
cd.. : 退回到上一级目录
cd \ : 退回到根目录
echo &quot;hello java&quot;&gt;a.txt  写入文本到指定文件  
type a.txt 显示文件内容命令
del : 删除文件    注意：不能删除文件夹，只能删除文件。
exit : 推出dos命令行
cls  : 通知计算机将当前的命令清空
*:  是通配符。
方向键上下是找回上次你写过的命令。
</code></pre><h3 id="1-5-Java虚拟机（JVM）"><a href="#1-5-Java虚拟机（JVM）" class="headerlink" title="1.5 Java虚拟机（JVM）"></a>1.5 Java虚拟机（JVM）</h3><pre><code>Java Virtual Machine 一个软件模拟的计算机。Java源程序想象成我们的C源程序，Java源程序编译后生成的字节码（.class）就相当于C源程序编译后的二进制可执行文件。JVM虚拟机相当于计算机系统（操作系统+硬件环境），Java解释器相当于CPU。

.exe文件直接在windows操作系统下运行，在CPU上运行的是机器码（.exe文件）
.class字节码文件是运行在JVM虚拟机下的，在Java解释器上运行的是Java字节码。
Java解释器相当于运行Java字节码的“CPU”，但该“CPU”不是通过硬件实现的，而是用软件实现的。Java解释器实际上就是特定的平台下的一个应用程序。只要实现了特定平台下的解释器程序，Java字节码就能通过解释器程序在该平台下运行，这是Java跨平台的根本。当前，并不是在所有的平台 下都有相应Java解释器程序，这也是Java并不能在所有的平台下都能运行的原因，它只能在已实现了Java解释器程序的平台下运行。
</code></pre><hr>
<h2 id="Java-变量与关键字"><a href="#Java-变量与关键字" class="headerlink" title="Java 变量与关键字"></a>Java 变量与关键字</h2><pre><code>文档注释：
    1.需要使用sum给我们提供的javadoc工具生成一个html的说明文档。
    2.只能抽取public的属性或者方法内容。
    格式：javadoc –d 指定存储文档的路径 -version –author（可选） 目标文件

    @author 作者
    @version 版本
    @param 方法的参数
    @return 返回值
</code></pre><hr>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><hr>
<h2 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h2><pre><code>1.数组

注意：给数组分配空间时，必须指定数组能够存储的元素个数来确定数组大小。创建数组之后不能修改数组的大小，我们可以使用length属性获取数组的大小。

数组常见的异常：1.数组角标越界异常。2.空指针异常。

数组的内存分析：
    栈内存特点：存储的局部变量。处理方式：变量使用完离开自己的空间就马上释放。
    堆内存特点：存储的数组和对象，凡是new关键字创建的实体都是保存在堆内存里面的。1.每一个对象都有一个内存首地址。2.对象都有默认的初始值。

2.二维数组

    前提：
        toString()方法：将数组的元素以字符串的形式返回
        sort()方法：将数组按照升序排序
        binarySearch()：在指定数组中查找指定元素，返回元素的索引。如果没有找到，返回(-插入点-1) 注意：使用查找功能的时候，数组一定要先排序。
</code></pre><hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>1.匿名对象：表示没有名字的实体，即该实体没有对应的变量名进行引用。</p>
<pre><code>用途：对象对方法进行一次调用的时候，可以使用匿名对象对代码进行简化。同时匿名对象可以对实际参数进行传递。

使用：当只使用一次的时候可以使用匿名对象，执行完毕之后，对象就变成了垃圾。执行方法时，可以将匿名对象作为实际参数传递进去。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.匿名对象设置的属性永远无法获取，因为没有引用变量指向那个对象。
2.任何两个匿名对象使用==比较，永远返回false。
3.匿名对象主要用于实参。
</code></pre><p>2.构造方法</p>
<pre><code>作用：对对象进行初始化。
</code></pre><p>3.this关键字</p>
<pre><code>this关键字表示对对象的引用，表示this在指向一个对象时，所指向的对象就是调用该函数的对象引用。
this关键字表示所在函数所属对象的引用。
</code></pre><h2 id="字符串和文本I-O"><a href="#字符串和文本I-O" class="headerlink" title="字符串和文本I/O"></a>字符串和文本I/O</h2><pre><code>1.字符串的比较
    警告：如果使用像&gt; &gt;= &lt; &lt;=这样的比较运算符比较两个字符串，就会发生语法错误。替代的方法是：s1.compareTo(s2)来进行比较。

    注意：如果两个字符串相等，equals方法返回true；如果它们不等，方法返回false。compareTo()方法会根据一个字符串是否等于、大于或小于另一个字符串而返回0、正整数或负整数。

    警告：length()方法是String的一个方法，但它是数组对象的一个属性，所以要获取字符串s中的字符个数，必须使用 s.length() 而要获取数组a中的元素个数，必须使用s.length

2.文件类File
    File类特意提供了一种抽象，这种抽象表示以不依赖机器的方式处理很多文件和路径名依赖机器的复杂问题。

    注意：在windows中目录的分隔符是(\)，但是在Java中，反斜杠是一个特殊的字符，需要转义写成(\\)。

    注意：构建一个File实例并不会在机器上创建一个文件。不管文件是否存在，都可以创建任意文件名的File实例。我们可以调用File实例上的exists()方法判断文件是否存在。

3.文件的输入输出

    File对象封装了文件或路径的属性，但是这一File对象不包括创建文件以及向/从文件读/写数据的方法。为了完成I/O操作，我们需要使用恰当的Java I/O类创建对象。

        1.PrintWriter 写数据
            该类可以用来创建一个文件，并向文本文件中写入数据。
            注意：如果文件不存在，那么会调用PrintWriter的构造方法创建一个新的文件。如果文件已经存在，那么文件当前内容会被抛弃。

        2.使用Scanner读取数据
            java.util.Scanner类用来从控制台读取字符串和基本类型数值。为了能够从键盘读取，需要为System.in创建一个Scanner。
            注意：new Scanner(String) 为给定的字符串创建一个Scanner。为创建Scanner从文件中读取数据，需要使用构造方法 new File(filename) 利用 java.io.File 类创建File类的一个实例。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.字符串是封装在String类中的对象，要创建一个字符串，可以使用11种构造方法之一，也可以使用字符串直接量进行简洁初始化。
2.String 对象是不可变的，它的内容不能改变。
3.可以调用字符串的length()方法获取它的长度，使用charAt(index)方法从字符串中提取特定下标位置的字符，使用indexOf()方法和lastIndexOf()方法找出一个字符串中的某个字符或者某个子串。

4.substring()方法从字符串中提取子串

5.
</code></pre><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><pre><code>注意：使用语法 new int[5][]创建数组时，必须指定第一个下标。语法：new int[][]是错误的。
</code></pre><h2 id="异常处理-更多知识"><a href="#异常处理-更多知识" class="headerlink" title="异常处理 更多知识"></a>异常处理 更多知识</h2><pre><code>1.声明异常：
    注意：如果方法没有在父类中声明异常，那么就不能在子类中对其进行覆盖来声明异常。

2.抛出异常：
    注意：通常JAVA API 中的每个异常类至少有两个构造方法：1.无参构造方法。 2.一个带可描述此异常的String参数的构造方法。(该参数称为异常消息，可以使用getMessage()获取)

    注意：声明异常的关键字：throws 抛出异常的关键字：throw。

3.捕获异常

    注意：
        1.从一个通用父类可以派生出各种异常类，如果一个catch块可以捕获一个父类的异常对象，那么它就能够父类的所有子类的异常对象。

        2.在catch块中异常被指定的顺序非常重要，如果父类的catch块出现在子类的catch块之前，就会导致编译错误。

        3.Java强迫程序员必须处理必检异常，如果方法中声明了一个必须检验的异常(error或runtimeException)，就必须在try-catch块中调用它，或者在调用方法中声明要抛出异常。

4.使用异常的时机

    注意：异常处理过程中通常需要更多的时间和资源。

    1.异常出现在方法中，如果想让该方法的调用者处理异常，应该创建一个异常对象并将其抛出。如果能在发生异常的方法中处理异常，那么就不需要抛出异常或使用异常。

    注意：不要将异常处理用作简单的逻辑测试。而在哪种情况下使用异常需要我们自己判断。

5.重新抛出异常

    前提：如果异常处理器没有处理某个异常，或者处理器只是希望其调用者注意该异常，Java就允许处理器重新抛出异常。在try-catch块中最后使用throw关键字。这样就方便其他的调用者获得处理抛出异常的机会。

6.链式异常


7.自定义异常

    注意：因为Java提供了很多的异常类，所以在不是特殊的情况下尽量避免使用自定义异常类。

    通过派生Exception类或其子类(如:IOException)来创建自定义异常类。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.异常处理能够使得一个方法给它的调用者抛出一个异常。
2.异常发生在一个方法的执行过程中，RuntimeException/Error都是免检异常，其他所有的异常都是必须检验的异常。
3.当声明一个方法时，如果这个方法抛出一个必须检验的异常，则必须声明为必须检验异常，告诉编译器可能会出现什么错误。
4.声明异常的关键字：throws，抛出异常的关键字：throw

5.异常处理是将处理代码从正常的程序中分离出来，这样的话，程序更容易处理和理解。
6.我们不应该使用异常处理代替简单的测试，应该尽可能的测试简单异常，将异常处理保留为处理那些无法使用if语句处理的异常。
</code></pre><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><pre><code>1.抽象类

注意：抽象类和常规类很像，但是不能使用new关键字创建其实例。抽象方法只有定义没有实现，它的实现由子类提供，一个包含抽象方法的类必须声明为抽象类。

    抽象类的构造方法定义为protected，其只能被子类使用。

    注意：

        1.抽象方法不能定义在非抽象类中，如果抽象父类的子类不能实现所有的抽象方法，那么子类必须定义为抽象，同时注意抽象方法是 非静态 的。

        2.抽象类不能使用new关键字来初始化，但可以定义其构造方法，这个构造方法在它的子类的构造方法中可以被调用。

        3.包含抽象对象的类必须是抽象的，但可以定义一个不包含抽象方法的抽象类。此时不能使用new操作符创建该类的实例。

        4.如果一个类是具体的，但是其子类可以是抽象的。

2.接口

    注意：由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以Java允许忽略这些修饰符。

    提示：接口中定义的常量可以使用语法：接口名.常量名(如：T.k)来访问。
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1.抽象类和常规类一样，都有数据和方法，但是不能使用new操作符创建抽象类的实例。
2.非抽象类中不能包含抽象方法。如果抽象类的子类没有实现所有被继承的父类抽象方法，就必须将子类也定义为抽象类。
3.包含抽象方法的类必须是抽象类，但抽象类可以不包含抽象方法。

4.接口中只包含常量和抽象方法，接口与抽象类很类似，但是抽象类除了包含常量和抽象方法之外，还包含变量和具体方法。

5.接口java.lang.Comparable定义了compareTo()方法，Java类库中许多类都实现了Comparable。

6.
</code></pre><h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><pre><code>Java中处理输入输出，File对象封装文件或路径属性，不包含从/向文件读/写数据的方法。为了进行I/O操作，需要使用正确的Java I/O类创建对象。
</code></pre><blockquote>
<p>总结：I/O类可以分为文本I/O和二进制I/O，文本I/O将数据解释成字符序列，二进制I/O将数据解释成原始的二进制数值。Java自动完成对文本I/O的编码和解码。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/undefined/Reids/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis-FD"><a href="#Redis-FD" class="headerlink" title="Redis - FD"></a>Redis - FD</h2><p>Redis 是一个基于内存的高性能key-value数据库，通过提供多种键值数据类型来适应不同场景下的存储需求。<br></p>
<p>应用场景：1.会话缓存(session cache)(数据查询、短链接、新闻内容、商品内容等) 2.全页缓存(FPC) 3.任务队列(秒杀、抢购、12306) 4.排行榜/计数器 5.发布/订阅 6.分布式集群架构中的session分离 7.数据过期处理</p>
<blockquote>
<p>扩展：为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。NoSQL：not-Only SQL表示非关系型数据库，作为关系型数据库的良好补充。</p>
</blockquote>
<h4 id="1-Redis特点"><a href="#1-Redis特点" class="headerlink" title="1.Redis特点"></a>1.Redis特点</h4><p>优点：<br><br>1.速度快，因为数据都是存储在内存中的，类似于HashMap，HashMap的优势就在于查找和操作的时间复杂度都为O(1)。Redis在本质上是一个<code>KEY-VALUE</code>类型的内存数据库，很像<code>memcached</code>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。<br><br>2.由于其实纯内存操作，所以性能非常好，是已知性能最快的key-value DB。<br><br>3.reids支持保存多种数据结构，此外单个value的最大限制是1GB，不想memcached只能保存1MB数据。<br><br><a id="more"></a><br>4.支持丰富的数据类型，支持string，list，set，sorted set，hash。</p>
<p>5.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>6.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<p>缺点：<br><br>7.reids的缺点主要是，数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h4 id="2-Redis支持的数据类型"><a href="#2-Redis支持的数据类型" class="headerlink" title="2.Redis支持的数据类型"></a>2.Redis支持的数据类型</h4><ul>
<li>String  可以是字符串，整数或浮点数，对整个字符串或者字符串中的一部分执行操作。</li>
<li>List 表示一个链表</li>
<li>Sets 求交集/并集</li>
<li>Sorted Set</li>
<li>hashs</li>
</ul>
<h4 id="3-Redis需要将所有数据放到内存中的原因"><a href="#3-Redis需要将所有数据放到内存中的原因" class="headerlink" title="3.Redis需要将所有数据放到内存中的原因"></a>3.Redis需要将所有数据放到内存中的原因</h4><p>1.Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。<br><br>2.如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br><br>3.如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<blockquote>
<p>注意：1.reids是单进程单线程的，利用队列技术将并发访问变成串行访问，消除传统数据库串行控制的开销。<br>2.</p>
</blockquote>
<h4 id="4-Redis常见性能问题解决"><a href="#4-Redis常见性能问题解决" class="headerlink" title="4.Redis常见性能问题解决"></a>4.Redis常见性能问题解决</h4><p>1.master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。<br><br>2.如果数据比较重要，某个<code>Slave</code>开启<code>AOF</code>备份数据，策略设置为每秒同步一次。(slave?aof?是啥)<br><br>3.为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。<br><br>4.尽量避免在压力很大的主库上增加从库。<br><br>5.从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3等，这样的结构方便解决单点故障问题，实现Slave对Master的替换，如果Master挂了可以立刻启用Slave1做Master，其他不变。</p>
<h4 id="5-Redis与memcached的区别"><a href="#5-Redis与memcached的区别" class="headerlink" title="5.Redis与memcached的区别"></a>5.Redis与memcached的区别</h4><p>1.memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。<br><br>2.redis的速度比memcached快很多。<br><br>3.redis可以持久化其数据。(数据的持久化就是将内存中的数据模型转化为存储模型，数据模型是任何的数据结构或者是对象，存储模型可以是关系型/xml文件/二进制流) 狭义：持久化仅仅是将对象数据永久保存在数据库中。广义：持久化包括和数据库相关的各种操作，封装数据访问细节，为大部分业务逻辑提供面向对象的API。</p>
<h4 id="6-Redis持久化方案区别-优缺点"><a href="#6-Redis持久化方案区别-优缺点" class="headerlink" title="6.Redis持久化方案区别/优缺点"></a>6.Redis持久化方案区别/优缺点</h4><p>首先我们知道，Redis为我们提供两种持久化的方式，RDB(Redis DataBase)/AOF(Append Only File)。<br>1.RDB方式：快照式的持久化方法，将某一时刻的数据持久化到磁盘中。</p>
<pre><code>1.因为Redis在持久化的过程中，会首先将数据写入到一临时文件中，在持久化过程都结束之后才会用此临时文件替换已经持久化好的文件。所以因为这个特性让我随时进行备份。
2.于RDB方式，Redis单独创建一个子进程来进行持久化，主进程不会进行任何IO操作，这就确保Redis很好的性能。
3.如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
</code></pre><p>2.AOF方式：将执行过的 <code>写指令</code> 记录下来，在数据恢复时按照<code>从前到后</code>的顺序再将指令执行一遍。</p>
<pre><code>1.AOF 命令以Redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。默认的 AOF 持久化策略是每秒钟 fsync 一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。

2.如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。

3.因为此种是采用追加的方式，所以如果我们不做任何处理的话，AOF文件会变得越来越大。所以在此Redis提供AOF文件重写机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

4.在进行AOF重写时，我们仍然采用是先写临时文件，最后在全部完成之后再替换掉的流程，所以在断电、磁盘满等问题都不会影响AOF文件的可用性。
</code></pre><h4 id="7-如何维护集群之间的关系-集群之间如何建立连接"><a href="#7-如何维护集群之间的关系-集群之间如何建立连接" class="headerlink" title="7.如何维护集群之间的关系(集群之间如何建立连接)"></a>7.如何维护集群之间的关系(集群之间如何建立连接)</h4><p>集群？</p>
<h4 id="8-Redis存取实体的方式"><a href="#8-Redis存取实体的方式" class="headerlink" title="8.Redis存取实体的方式"></a>8.Redis存取实体的方式</h4><p>在存储的时候需要将实体 <code>序列化</code> ，然后可以当字符串一样存储，取数据也一样，取出来的数据要 <code>反序列化</code> 。</p>
<h4 id="9-Redis保留时间"><a href="#9-Redis保留时间" class="headerlink" title="9.Redis保留时间"></a>9.Redis保留时间</h4><p>Redis保留时间在未设置的情况下会一直存在，除非服务停掉且没有保存到磁盘。如果已手动或自动保存过，则再次启动服务还会存在。</p>
<p>待续……….</p>
<h4 id="10-Redis事务"><a href="#10-Redis事务" class="headerlink" title="10.Redis事务"></a>10.Redis事务</h4><hr>
<h2 id="Redis-SD"><a href="#Redis-SD" class="headerlink" title="Redis - SD"></a>Redis - SD</h2><h4 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1.安装配置"></a>1.安装配置</h4><p>1.首先去Redis的官网下载Redis的压缩包，然后编译Redis源码并启动。<br><br>2.启动Redis</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript-学习笔记</title>
    <url>/undefined/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-js简介"><a href="#1-js简介" class="headerlink" title="1.js简介"></a>1.js简介</h2><pre><code>1、js是什么
2、js作用
3、组成
4、引入方式
</code></pre><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h2><pre><code>1、变量
2、原始数据类型
3、引入数据类型
4、运算符
5、逻辑语句
</code></pre><h2 id="3-内建对象"><a href="#3-内建对象" class="headerlink" title="3.内建对象"></a>3.内建对象</h2><pre><code>(1)Number
    创建方式：
        var myNum=new Number(value);
        var myNum=Number(value);
    属性和方法：
        toString():转成字符串
        valueOf()：返回一个 Number 对象的基本数字值
</code></pre><a id="more"></a>
<pre><code>(2)Boolean
    创建方式：
        var bool = new Boolean(value);    
        var bool = Boolean(value);
    属性和方法：
        toString():转成字符串
        valueOf()：返回一个 Boolean 对象的基本值(boolean)

(3)String
    创建方式：
        var str = new String(s);
        var str = String(s);
    属性和方法：
        length:字符串的长度
        charAt():返回索引字符
        charCodeAt:返回索引字符unicode
        indexOf():返回字符的索引
        lastIndexOf();逆向返回字符的索引
        split();将字符串按照特殊字符切割成数组
        substr():从起始索引号提取字符串中指定数目的字符
        substring():提取字符串中两个指定的索引号之间的字符
        toUpperCase();转大写
    示例：

(4)Array
    创建方式：
        var arr = new Array();//空数组
        var arr = new Array(size);//创建一个指定长度的数据
        var arr = new Array(element0, element1, ..., elementn);//创建数组直接实例化元素
        var arr = [];//空数组
        var arr = [1,2,5,&quot;java&quot;];//创建数组直接实例化元素
    属性和方法：
        length:数组长度
        join()：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔一个
        pop():删除并返回最后元素
        push()：向数组的末尾添加一个或更多元素，并返回新的长度
        reverse();反转数组
        sort();排序

(5)Date
    创建方式：    
        var myDate = new Date();
        var myDate = new Date(毫秒值);//代表从1970-1-1到现在的一个毫秒值
    属性和方法
        getFullYear():年
        getMonth():月 0-11
        getDate():日 1-31
        getDay()：星期 0-6
        getTime():返回1970年1月1日午夜到指定日期（字符串）的毫秒数
        toLocalString();获得本地时间格式的字符串

(6)Math
    创建方式：    
        Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，
        不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。
    属性和方法
        PI：圆周率
        abs():绝对值
        ceil():对数进行上舍入
        floor():对数进行下舍入
        pow(x,y)：返回 x 的 y 次幂
        random():0-1之间的随机数
        round():四舍五入

(7)RegExp
    创建方式：    
        var reg = new RegExp(pattern);
        var reg = /^正则规则$/;
    规则的写法：
        [0-9] 
        [A-Z]
        [a-z]
        [A-z]
        \d 代表数据
        \D    非数字
        \w    查找单词字符
        \W    查找非单词字符
        \s    查找空白字符
        \S    查找非空白字符
        n+    出现至少一次
        n*    出现0次或多次
        n?    出现0次或1次
        {5} 出现5
        {2,8} 2到8次
    方法：    
        test(str):检索字符串中指定的值。返回 true 或 false
    需求：
        校验邮箱：
        var email = haohao_827@163.com
        var reg = /^[A-z]+[A-z0-9_-]*\@[A-z0-9]+\.[A-z]+$/;
        reg.test(email);
</code></pre><h2 id="4-js的函数"><a href="#4-js的函数" class="headerlink" title="4.js的函数"></a>4.js的函数</h2><pre><code>1、js函数定义的方式
    (1)普通方式
        语法：function 函数名(参数列表){函数体}
        示例：
            function method(){
                alert(&quot;xxx&quot;);
            }
            method();
    (2)匿名函数
        语法：function(参数列表){函数体}
        示例：
            var method = function(){
                alert(&quot;yyy&quot;);
            };
            method();
    (3)对象函数
        语法：new Function(参数1,参数2,...,函数体);
        注意：参数名称必须使用字符串形式、最后一个默认是函数体且函数体需要字符串形式
        示例：
            var fn = new Function(&quot;a&quot;,&quot;b&quot;,&quot;alert(a+b)&quot;);
            fn(2,5);
2、函数的参数
    (1)形参没有var去修饰
    (2)形参和实参个数不一定相等
    (3)arguments对象 是个数组 会将传递的实参进行封装
    function fn(a,b,c){
        //var sum = a+b+c;
        //alert(sum);
        //arguments是个数组 会将传递的实参进行封装
        for(var i=0;i&lt;arguments.length;i++){
            alert(arguments[i]);
        }
    }
    fn(1,2,4,8);

3、返回值
    (1)在定义函数的时候不必表明是否具有返回值
    (2)返回值仅仅通过return关键字就可以了 return后的代码不执行
    function fn(a,b){
        return a+b;
        //alert(&quot;xxxx&quot;);
    }
    alert(fn(2,3));

4、js的全局函数
    (1)编码和解码
        encodeURI()   decodeURI()
        encodeURIComponet()      decodeURIComponent()
        escape()    unescape()
        三者区别：
            进行编码的符号范围不同吧，实际开发中常使用第一种
    (2)强制转换
        Number()
        String()
        Boolean()
    (3)转成数字
        parseInt()
        parseFloat()
    (4)eval()方法    
        将字符串当作脚本进行解析运行
        //var str = &quot;var a=2;var b=3;alert(a+b)&quot;;
        //eval(str);
        function print(str){
            eval(str);
        }
        print(&quot;自定义逻辑&quot;);
</code></pre><h2 id="5-js的事件"><a href="#5-js的事件" class="headerlink" title="5.js的事件"></a>5.js的事件</h2><pre><code>事件
事件源
响应行为
1、js的常用事件
    onclick:点击事件
    onchange:域内容被改变的事件
        需求：实现二级联动
        &lt;select id=&quot;city&quot;&gt;
            &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;
            &lt;option value=&quot;tj&quot;&gt;天津&lt;/option&gt;
            &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;
        &lt;/select&gt;
        &lt;select id=&quot;area&quot;&gt;
            &lt;option&gt;海淀&lt;/option&gt;
            &lt;option&gt;朝阳&lt;/option&gt;
            &lt;option&gt;东城&lt;/option&gt;
        &lt;/select&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var select = document.getElementById(&quot;city&quot;);
            select.onchange = function(){
                var optionVal = select.value;
                switch(optionVal){
                    case &apos;bj&apos;:
                        var area = document.getElementById(&quot;area&quot;);
                        area.innerHTML = &quot;&lt;option&gt;海淀&lt;/option&gt;&lt;option&gt;朝阳&lt;/option&gt;&lt;option&gt;东城&lt;/option&gt;&quot;;
                        break;
                    case &apos;tj&apos;:
                        var area = document.getElementById(&quot;area&quot;);
                        area.innerHTML = &quot;&lt;option&gt;南开&lt;/option&gt;&lt;option&gt;西青&lt;/option&gt;&lt;option&gt;河西&lt;/option&gt;&quot;;
                        break;
                    case &apos;sh&apos;:
                        var area = document.getElementById(&quot;area&quot;);
                        area.innerHTML = &quot;&lt;option&gt;浦东&lt;/option&gt;&lt;option&gt;杨浦&lt;/option&gt;&quot;;
                        break;
                    default:
                        alert(&quot;error&quot;);
                }
            };                

        &lt;/script&gt;
    onfoucus:获得焦点的事件
    onblur:失去焦点的事件
        需求：    当输入框获得焦点的时候，提示输入的内容格式
                当输入框失去焦点的时候，提示输入有误
        &lt;label for=&quot;txt&quot;&gt;name&lt;/label&gt;
        &lt;input id=&quot;txt&quot; type=&quot;text&quot; /&gt;&lt;span id=&quot;action&quot;&gt;&lt;/span&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var txt = document.getElementById(&quot;txt&quot;);
            txt.onfocus = function(){
                //友好提示
                var span = document.getElementById(&quot;action&quot;);
                span.innerHTML = &quot;用户名格式最小8位&quot;;
                span.style.color = &quot;green&quot;;
            };
            txt.onblur = function(){
                //错误提示
                var span = document.getElementById(&quot;action&quot;);
                span.innerHTML = &quot;对不起 格式不正确&quot;;
                span.style.color = &quot;red&quot;;
            };
        &lt;/script&gt;

    onmouseover:鼠标悬浮的事件
    onmouseout:鼠标离开的事件
        需求：div元素 鼠标移入变为绿色 移出恢复原色
        #d1{background-color: red;width:200px;height: 200px;}
        &lt;div id=&quot;d1&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var div = document.getElementById(&quot;d1&quot;);
            div.onmouseover = function(){
                this.style.backgroundColor = &quot;green&quot;;
            };
            div.onmouseout = function(){
                this.style.backgroundColor = &quot;red&quot;;
            };
        &lt;/script&gt;


    onload:加载完毕的事件
        等到页面加载完毕在执行onload事件所指向的函数
        &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            window.onload = function(){
                var span = document.getElementById(&quot;span&quot;);
                alert(span);
                span.innerHTML = &quot;hello js&quot;;
            };
        &lt;/script&gt;

2、事件的绑定方式
    (1)将事件和响应行为都内嵌到html标签中
        &lt;input type=&quot;button&quot; value=&quot;button&quot;  onclick=&quot;alert(&apos;xxx&apos;)&quot;/&gt;
    (2)将事件内嵌到html中而响应行为用函数进行封装
        &lt;input type=&quot;button&quot; value=&quot;button&quot; onclick=&quot;fn()&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function fn(){
                alert(&quot;yyy&quot;);
            }
        &lt;/script&gt;
    (3)将事件和响应行为 与html标签完全分离
        &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot;/&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var btn = document.getElementById(&quot;btn&quot;);
            btn.onclick = function(){
                alert(&quot;zzz&quot;);
            };
        &lt;/script&gt;

    ****this关键字
        this经过事件的函数进行传递的是html标签对象
        &lt;input id=&quot;btn&quot; name=&quot;mybtn&quot; type=&quot;button&quot; value=&quot;button123&quot; onclick=&quot;fn(this)&quot;/&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function fn(obj){
                alert(obj.name);
            }
        &lt;/script&gt;

3、阻止事件的默认行为
    IE：window.event.returnValue = false;
    W3c: 传递过来的事件对象.preventDefault();
    //ie：window.event.returnValue = false;
    //W3c：传递过来的事件对象.preventDefault();
    //W3c标准
    if(e&amp;&amp;e.preventDefault){
        alert(&quot;w3c&quot;);
        e.preventDefault();
    //IE标签
    }else{
        alert(&quot;ie&quot;);
        window.event.returnValue = false;
    }


    //通过事件返回false也可以阻止事件的默认行为
    &lt;a href=&quot;demo11.html&quot; onclick=&quot;return false&quot;&gt;点击我吧&lt;/a&gt;

4、阻止事件的传播
    IE：window.event.cancelBubble = true;
    W3c: 传递过来的事件对象.stopPropagation();
    if(e&amp;&amp;e.stopPropagation){
        alert(&quot;w3c&quot;);
        e.stopPropagation();
    //IE标签
    }else{
        alert(&quot;ie&quot;);
        window.event.cancelBubble = true;
    }    
</code></pre><h2 id="6-js的bom"><a href="#6-js的bom" class="headerlink" title="6.js的bom"></a>6.js的bom</h2><pre><code>(1)window对象
    弹框的方法：
        提示框：alert(&quot;提示信息&quot;);
        确认框：confirm(&quot;确认信息&quot;);
            有返回值：如果点击确认返回true  如果点击取消 返回false
            var res = confirm(&quot;您确认要删除吗？&quot;);
            alert(res);
        输入框：prompt(&quot;提示信息&quot;);
            有返回值：如果点击确认返回输入框的文本 点击取消返回null
            var res =  prompt(&quot;请输入密码？&quot;);
            alert(res);
    open方法：
        window.open(&quot;url地址&quot;);            
        open(&quot;../jsCore/demo10.html&quot;);

    定时器：
        setTimeout(函数,毫秒值);
            setTimeout(
                function(){
                    alert(&quot;xx&quot;);
                },
                3000
            );
        clearTimeout(定时器的名称);
            var timer;
            var fn = function(){
                alert(&quot;x&quot;);
                timer = setTimeout(fn,2000);
            };
            var closer = function(){
                clearTimeout(timer);
            };
            fn();
        setInterval(函数,毫秒值);
        clearInterval(定时器的名称)
            var timer = setInterval(
            function(){
                alert(&quot;nihao&quot;);
            },
            2000
        );
        var closer = function(){
            clearInterval(timer);
        };

    需求：注册后5秒钟跳转首页
    恭喜您注册成功，&lt;span id=&quot;second&quot; style=&quot;color: red;&quot;&gt;5&lt;/span&gt;秒后跳转到首页，如果不跳转请&lt;a href=&quot;../jsCore/demo10.html&quot;&gt;点击这里&lt;/a&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var time = 5;
        var timer;
        timer = setInterval(
            function(){
                var second = document.getElementById(&quot;second&quot;);
                if(time&gt;=1){
                    second.innerHTML = time;
                    time--;
                }else{
                    clearInterval(timer);
                    location.href=&quot;../jsCore/demo10.html&quot;;
                }
            },
            1000
        );
    &lt;/script&gt;

(2)location    
    location.href=&quot;url地址&quot;;
(3)history
    back();
    forward();
    go();
    &lt;a href=&quot;demo7.html&quot;&gt;后一页&lt;/a&gt;
    &lt;input type=&quot;button&quot; value=&quot;上一页&quot; onclick=&quot;history.back()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;下一页&quot; onclick=&quot;history.forward()&quot;&gt;

    &lt;input type=&quot;button&quot; value=&quot;上一页&quot; onclick=&quot;history.go(-1)&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;下一页&quot; onclick=&quot;history.go(1)&quot;&gt;
</code></pre><h2 id="7-js的dom"><a href="#7-js的dom" class="headerlink" title="7.js的dom"></a>7.js的dom</h2><pre><code>1、理解一下文档对象模型
    html文件加载到内存之后会形成一颗dom树，根据这些节点对象可以进行脚本代码的动态修改
    在dom树当中 一切皆为节点对象
2、dom方法和属性
    笔记见代码
</code></pre><blockquote>
<p>附录：</p>
</blockquote>
<pre><code>JSDom常用方法：
    1.getElementById()：document对象中获取通过Id值得到的元素值
    2.getElementsByIdName()：document对象中通过元素的name属性获取所有元素的引用
    3.getElementsByTagName()：document对象中获取所有的input元素，返回值是数组    
    4.hasChildNodes()：document对象中返回元素是否还有子节点方法
    5.
</code></pre><h2 id="8-JavaScript-JSON"><a href="#8-JavaScript-JSON" class="headerlink" title="8.JavaScript JSON"></a>8.JavaScript JSON</h2><pre><code>JSON用于存储和传输数据的格式，通常用于服务端向网页传输数据。

注意：JSON使用JavaScript语法，但是JSON格式仅仅只是一个文本，文本可以被任何编程语言读取以及作为数据格式传递。
</code></pre><h2 id="9-扩展"><a href="#9-扩展" class="headerlink" title="9.扩展"></a>9.扩展</h2><pre><code>1.JavaScript forEach()方法
  forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。
  注意：forEach()对于空数组是不会执行回调函数的。
</code></pre>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC-学习笔记</title>
    <url>/undefined/Spring%20MVC/</url>
    <content><![CDATA[<h2 id="Spring-MVC-FD"><a href="#Spring-MVC-FD" class="headerlink" title="Spring MVC - FD"></a>Spring MVC - FD</h2><h2 id="1-Spring-MVC-中Controller层"><a href="#1-Spring-MVC-中Controller层" class="headerlink" title="1.Spring MVC 中Controller层"></a>1.Spring MVC 中Controller层</h2><p>SpringMVC中的Controller方法的参数可以是Integer，Double，自定义对象，ServletRequest，ServletResponse，ModelAndView等。</p>
<h3 id="MVC控制层作用："><a href="#MVC控制层作用：" class="headerlink" title="MVC控制层作用："></a>MVC控制层作用：</h3><p>接收客户端的请求，然后调用Service层业务逻辑，获取到数据，传递给视图（客户端）用于视觉呈现</p>
<blockquote>
<p>实现步骤：</p>
</blockquote>
<pre><code>1.在类上使用@Controller注解
  作用： 告诉springmvc的dispatcherServlet这是一个Controller然后被dispatcherServlet的上下文所管理，并且完成它的依赖注入

2.在类上使用@RequestMapping注解 @RequestMapping 该注解可以用指定的URL路径访问本控制层
  例如：@RequestMapping(“/user”) 
  作用： Controller负责处理的，根目录下的URL ，/user/** 下的所有路径都会被Controller所拦截

3.在方法上使用 @RequestMapping
  例如：@RequestMapping(value = “login.do”, method = RequestMethod.POST)
  作用：使该方法负责处理/user/login.do 这个url 并且是由post方法方法传递过来的请求

4.在方法的参数前绑定@RequestParam/@PathVariable/@Param注解
  @RequestParam 根据参数名从URL中取得参数值

   作用：负责把请求传入的参数，绑定到方法中的参数上，使方法中的参数值为请求传入的参数值
  例如这条请求：/user/login.do？username=”admin” &amp;password=”admin”
</code></pre><a id="more"></a>
<h2 id="2-Spring-MVC-DispatchServlet"><a href="#2-Spring-MVC-DispatchServlet" class="headerlink" title="2.Spring MVC  DispatchServlet"></a>2.Spring MVC  DispatchServlet</h2><p>在整个Spring MVC框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。</p>
<p>在看 DispatcherServlet 类之前，我们先来看一下请求处理的大致流程:</p>
<pre><code>1.Tomcat服务器启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化。在这个初始化过程中完成了：

对 web.xml 中初始化参数的加载；建立 WebApplicationContext (SpringMVC的IOC容器)，进行组件的初始化。

2.客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml 中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理。

3.DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping 接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler (执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器) 封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler 则退出循环。

4.DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有 HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象。

5.执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用 HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的 postHandler() 方法。

6.利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成 View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面。

7.最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。
</code></pre><h2 id="3-SpringMVC源码分析"><a href="#3-SpringMVC源码分析" class="headerlink" title="3.SpringMVC源码分析"></a>3.SpringMVC源码分析</h2><p>SpringMVC中有两个重要的接口，HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler，在两个接口是在Spring3.1版本之后加入的。</p>
<h4 id="3-1-SpringMVC处理请求的大致过程："><a href="#3-1-SpringMVC处理请求的大致过程：" class="headerlink" title="3.1 SpringMVC处理请求的大致过程："></a>3.1 SpringMVC处理请求的大致过程：</h4><pre><code>1.首先被DispatcherServlet截获，DispatcherServlet通过HandlerMapping获得HandlerExecutionChain，然后获得HandlerAdapter。

  注意：前端控制器DispatcherServlet是整个SpringMVC的核心，负责统一分发所有请求，在web.xml中进行配置。

    1.拦截符合特定格式的URL请求
      拦截规则：
        1. *.xxx，指定要拦截的特定类型，最简单实用的方式，并且不会拦截静态文件
        2. /，使用REST风格进行拦截，但是会导致静态文件被拦截不能正常显示
        3. /*，不能像Struts那样使用，会导致不能访问jsp
    注意：如果使用/进行拦截，并且希望正常访问静态文件，可以在DispatcherServlet之前，使用DefaultServlet先拦截特定类型的请求（如：*.js、*.css等）。
    2.初始化DispatcherServlet上下文对应的WebApplicationContext，并与业务层、持久化层建立联系
    3.初始化SpringMVC的各个组件，并装配到DispatcherServlet中

2.HandlerMapping(处理器映射)

  负责完成请求到控制器的映射。在servlet的配置文件中，进行uri与控制器的映射。同时，还可以对控制器进行拦截。
    1.SpringMVC默认的处理器映射，直接将uri与实现类进行绑定，书写方便，但是耦合性高(使用BeanNameUrlHandlerMapping类)
    2.使用SimpleUrlHandlerMapping，将uri与类的id进行绑定，彼此的耦合性低，更加灵活。
      注意：对控制器进行声明，首先应该声明拦截器，然后利用SimpleUrlHandlerMapping映射拦截器与控制器。

3.控制器Controller
  负责处理用户请求，完成之后返回ModelAndView对象给前端控制器。因为需要考虑并发，所以必须保证线程安全并且可重用。

  注意：SpringMVC中的Controller与Struts中的Action基本相同。通过实现Controller接口或继承父类的方式编写控制器

实现步骤：
    1.实现Controller接口
      public class HelloController implements Controller {
          // 相当于servlet的doGet和doPost方法
          public ModelAndView handleRequest(HttpServletRequest request,HttpServletResponse response) throws Exception {
            // 接收数据
            // 调用服务层
            return new ModelAndView(&quot;success&quot;,&quot;username&quot;,&quot;sean&quot;);
              }
        }

    2.继承类的实现
      1.继承AbstractController类，与接口类似需要重写里面的方法
      2.继承MultiActionController类，可以实现多个方法，处理多个请求
        public class MultiController extends MultiActionController {
              // 自定义处理请求的方法
              public ModelAndView insert(HttpServletRequest request,HttpServletResponse response) throws Exception {
                        return new ModelAndView(&quot;insertSuccess&quot;);
                  }
              public ModelAndView update(HttpServletRequest request,HttpServletResponse response) throws Exception {
                        return new ModelAndView(&quot;updateSuccess&quot;);
                  }
            }

        注意：在把实现类编写之后需要配置相应的配置文件
      3.继承AbstractCommandController类，用于获取页面的参数，将参数封装到指定的对象模型中。

4.HandlerAdapter在内部对于每个请求，都会实例化一个ServletInvocableHandlerMethod进行处理，ServletInvocableHandlerMethod在进行处理的时候，会分两部分别对请求跟响应进行处理。

5.然后HandlerAdapter得到ModelAndView，然后做相应的处理。

6.视图解析器ViewResolver
  负责对ModelAndView对象的解析，并查找对应的View对象。SpringMVC框架默认通过转发进行页面跳转，如果想通过重定向的方式进行跳转(直接跳转：return &quot;redirect:/index.jsp&quot;)。

注意：如果一个配置文件中出现多个视图解析器，可以通过设置order属性来设置优先级，值越低，优先级越高。
</code></pre><blockquote>
<p>总结：1.在web.xml中配置<code>DispatcherServlet</code>核心控制器<br><br>       2.在WEB-INF文件夹下创建springmvc-servlet.xml配置文件<br><br>       3.学会<code>@Controller</code>、<code>@RequestMapping</code>、<code>@RequestParam</code>以及<code>@Model</code>域对象的使用<br><br>       4.表单以post方式、get方式提交都是可以的</p>
</blockquote>
<h4 id="3-2-Spring-MVC-的工作原理"><a href="#3-2-Spring-MVC-的工作原理" class="headerlink" title="3.2 Spring MVC 的工作原理"></a>3.2 Spring MVC 的工作原理</h4><pre><code>1.将客户端请求提交给DispatcherServlet
2.根据&lt;servlet-name&gt;servlet.xml的配置，查找HandlerMapping
3.通过HandlerMapping找到处理请求的具体Controller
4.Controller调用业务逻辑处理
5.处理完成之后，返回ModelAndView对象给DispatcherServlet
6.通过ViewResolver找到负责显示的具体View
7.由View将结果渲染到客户端
</code></pre><h2 id="4-SpringMVC重要注解-ModelAttribute"><a href="#4-SpringMVC重要注解-ModelAttribute" class="headerlink" title="4.SpringMVC重要注解(@ModelAttribute)"></a>4.SpringMVC重要注解(<code>@ModelAttribute</code>)</h2><p>该注解的作用是将请求参数绑定到Model对象。值得注意的是，该注解只支持一个属性value，类型为String，表示参数绑定的属性名称。而且此注解注释的方法在controller每个方法执行前都会执行。在 <code>SpringMVC</code> 的 <code>Controller</code> 中使用 <code>@ModelAttribute</code> 时，应用位置包括下面几种：</p>
<pre><code>1.应用在方法上 
  注意：在被 @ModelAttribute 注解的方法会在Controller每个方法执行之前都执行，因此对于一个Controller中包含多个URL的时候，要谨慎使用。

1)使用 @ModelAttribute 注解无返回值的方法
@Controller
@RequestMapping(&quot;/modelattributeTest&quot;)
public class ModelAttributeTestController1 {

        @ModelAttribute//使用ModelAttribute注解无返回值的方法
        public void myModel(@RequestParam(required = false) String abc, Model model) {
            model.addAttribute(&quot;attributeName&quot;, abc);
       }
        @RequestMapping(value = &quot;/test1&quot;)
        public String test1() {
            return &quot;modelattributetest/test1&quot;;
            }
    }
</code></pre><blockquote>
<p>注意：最常用的方法是将上面的mymodel与test1合在一起使用，也是最常用的方法。</p>
</blockquote>
<pre><code>@RequestMapping(value = &quot;/test2&quot;)
public String test1(@RequestParam(required = false) String abc, Model model) {
        model.addAttribute(&quot;attributeName&quot;, abc);
        return &quot;modelattributetest/test1&quot;;
}

2)使用@ModelAttribute 注解带有返回值的方法
  @ModelAttribute
  public String myModel(@RequestParam(required = false) String abc) {
        return abc;
  }

  @ModelAttribute
  public Student myModel(@RequestParam(required = false) String abc) {
        Student stu = new Student(abc);
         return stu;
  }


  @ModelAttribute
  public int myModel(@RequestParam(required = false) int number) {
         return number;
  }

 上面的三种情况等同于
 model.addAttribute(&quot;string&quot;, abc);
 model.addAttribute(&quot;int&quot;, number);
 model.addAttribute(&quot;student&quot;, stu);


 自定义，给@ModelAttribute添加value属性
 @ModelAttribute(value = &quot;num&quot;)
  public int myModel(@RequestParam(required = false) int number) {
        return number;
 }
 相当于：model.addAttribute(“num”, number);


2.应用在方法的参数上(使用@ModelAttribute注解方法的参数)
  @Controller
  @RequestMapping(&quot;/modelattributeTest3&quot;)
  public class ModelAttributeTestController3 {

      @ModelAttribute(value = &quot;attributeName&quot;)
      public String myModel(@RequestParam(required = false) String abc) {
            return abc;
        }

       @ModelAttribute
      public void myModel3(Model model) {
        model.addAttribute(&quot;name&quot;, &quot;SHANHY&quot;);
        model.addAttribute(&quot;age&quot;, &quot;28&quot;);
      }

      @RequestMapping(value = &quot;/test1&quot;)
      public String test1(@ModelAttribute(&quot;attributeName&quot;) String str, 
        @ModelAttribute(&quot;name&quot;) String str2,
        @ModelAttribute(&quot;age&quot;) String str3) {
            return &quot;modelattributetest/test1&quot;;
        }
}
</code></pre><blockquote>
<p>注意：从上面的程序中可以看出，使用@ModelAttribute注解的参数，表示从前面的Model中提取对应名称的属性</p>
</blockquote>
<pre><code>3.应用在方法上，并且方法也使用了@RequestMapping
  @Controller
  @RequestMapping(&quot;/modelattributeTest4&quot;)
  public class ModelAttributeTestController4 {

      @RequestMapping(value = &quot;/test1&quot;)
      @ModelAttribute(&quot;name&quot;)
      public String test1(@RequestParam(required = false) String name) {
            return name;
        }
}
</code></pre><blockquote>
<p>注意：这种情况下，返回值String（或者其他对象，就不再是视图。还是我们上面将到的放入 Model 中的值，此时对应的页面就是 @RequestMapping的值 test1。</p>
</blockquote>
<blockquote>
<p>总结：@Controller 相当于创建了一个bean对象<br>       @RequestMapping(value=”..”) 就是一个请求映射，返回值return返回一个页面(前缀+逻辑视图+后缀)</p>
</blockquote>
<hr>
<h2 id="4-1-Spring-MVC-的常用注解"><a href="#4-1-Spring-MVC-的常用注解" class="headerlink" title="4.1 Spring MVC 的常用注解"></a>4.1 Spring MVC 的常用注解</h2><pre><code>@Controller：声明Action组件，负责注册bean到Spring上下文

@RequestMapping：用于为控制器指定可以处理的url请求(Springmvc页面向controller传递参数的方式)

@RequestParam：用于指定参数的name属性(Springmvc页面(ftl)向controller层传递参数的方式)


@RequestBody：用于读取Request请求的body部分数据
解释：
1. @requestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。
2. 通过@RequestBody可以将请求体中的JSON字符串绑定到相应的bean上，也可以将其绑定到对应的字符串上。
3. @RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为JSON、XML等格式的数据并绑定到Controller方法的参数上。

4. 最新解释：该注解将@Controller中方法的返回对象，根据request中头部(header)的accept的内容通过适当的转换，转换为指定的格式后输出到response对象。

5. 使用时机：返回数据不是HTML标签页，是其他格式数据(如：JSON/XML等)。


@ResponseBody：用于将控制器方法返回的对象写入到Response对象的body数据区
解释：
1. 将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或XML数据。
2. @ResponseBody注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据(JSON/XML)通过response响应给客户端。
3. @ResponseBody注解可被应用于方法上，标志该方法的返回值应该被直接写回到HTTP响应体中去(不会被放置到Model中或解释为一个视图名)。在实际开发中，返回JSON是最常见的一种方式。
原理：当一个处理请求的方法被标记为@ResponseBody时，就说明该方法需要输出其他视图(JSON/XML),Spring MVC通过已经定义的转化器做转化输出，默认输出JSON。
</code></pre><blockquote>
<p>注意：在使用此注解之后不会再走视图处理器（ViewResolver）是直接将数据写入到输入流中，等同于通过response对象输出指定格式的数据。</p>
</blockquote>
<blockquote>
<p>注意：@RequestBody是写在方法参数前，作用于方法参数。@ResponseBody是写在方法上，作用于方法返回值。 因为采用的是JSON格式进行数据交互。</p>
</blockquote>
<blockquote>
<p>重要：使用 <code>@ResponseBody</code> 注解，返回值直接作为http响应的内容的响应体部分发送给客户端，可以让我们将想要返回的内容直接返回给客户端。</p>
</blockquote>
<pre><code>@PathVariable：用于指定url作为参数 用来获得请求URL中的动态参数的，将请求URL的模板变量映射到功能处理方法的参数上。

@Resource：用于注入( 由J2EE提供 ) 默认按名称装配

@Autowired ：用于注入(由spring提供) 默认按类型装配

@ExceptionHandler：用于异常处理的方法
@ControllerAdvice：用于使控制器成为全局的异常处理类

@ModelAttribute：用于优先调用被注解的方法，或注解参数中的隐藏对象

@JsonFormat：用于将后台返回前台的Date变量转换为字符串类型，还可以实现前台到后台的类型转换(注：@JsonFormat注解的作用就是完成JSON字符串到Java对象的转换工作，与参数传递方向无关)
@DateTimeFormat：用于将前台传递到后台字符串变量转换成Date类型
</code></pre><blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>@RequestMapping 注解的六个属性
1.value/method
    value：指定请求的实际地址
    method：指定请求的method类型 get/post/put/delete等
2.consumes/produces
    consumes：指定处理请求的提交内容类型(content-type)，如：application/json text/html
    produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回
3.params/headers
    params：指定request中必须包含某些参数值时，才让该方法处理
    headers：指定request中必须包含某些指定的headers值，才让该方法处理请求
</code></pre><hr>
<p>@Deprecated、@Override、@SuppressWarnings这三个注解的@Retention注解的属性值分别是：</p>
<hr>
<pre><code>@Target 元注解

@Target 元注解决定一个注解可以标识到哪些成分上 如：表示在类上或者属性上或者方法上 @Target 默认值为任何元素成分


自定义注解：

使用 @interface 自定义注解，自动继承 java.lang.annotation.Annotation 接口

在定义自定义注解时不能继承其他的注解或接口

@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型(返回值类型只有基本类型、class、String、enum)

1.定义注解的格式

    public @interface 注解名{定义体}

2.注解参数的可支持数据类型

  1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)
  2.String类型
  3.Class类型
  4.enum类型
  5.Annotation类型
  6.以上所有类型的数组

4.注解元素的默认值

    注解元素需要有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，同时不是基本类型的注解元素不能为null。所以在使用空字符串或 0 作为默认值是一种常用的方法。


5.注解@Retention 用来修饰注解，是注解的注解，称为元注解

    @Retention 注解有一个属性 value 是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，
    这个枚举决定了Retention注解应该如何去保持，也可理解为Rentention 搭配 RententionPolicy使用。

    @Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候

    @Retention(RetentionPolicy.SOURCE )修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中

    @Retention(RetentionPolicy.RUNTIME )修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时

    所以他们可以用反射方式来读取，RetentionPolicy.RUNTIME 可以让你从JVM中读取Annotation注解的信息，以便在分析程序的时候使用。

6.注解@Documented 

    @Documented 注解表明这个注解应该被 JavaDoc 工具记录。默认情况下，javadoc是不包括注解的，如果声明注解时指定了@Documented 则其会被javadoc之类的工具处理，所以注解类型信息会被包括在生成的文档中。

7.@Target 注解

    @Target注解时为了说明Annotation所修饰的范围，Annotation可被用于 package、types(类、接口、枚举、Annotation类型)、类型成员、方法参数和本地变量

    1.CONSTRUCTOR:用于描述构造器 

    2.FIELD:用于描述域 

    3.LOCAL_VARIABLE:用于描述局部变量

    4.METHOD:用于描述方法

    5.PACKAGE:用于描述包 

    6.PARAMETER:用于描述参数

    7.TYPE:用于描述类、接口(包括注解类型) 或enum声明
</code></pre><hr>
<h2 id="4-2-拦截器"><a href="#4-2-拦截器" class="headerlink" title="4.2 拦截器"></a>4.2 拦截器</h2><p>Spring提供了<code>HandlerInterceptor</code>接口和<code>HandlerInterceptorAdapter</code>适配器。实现这个接口或继承此类，就可以实现自己的拦截器。接口<code>HandlerInterceptor</code>包含三个方法，每个方法的参数<code>handler</code>，用来指向下一个拦截器。</p>
<h4 id="1-Spring-MVC拦截器"><a href="#1-Spring-MVC拦截器" class="headerlink" title="1.Spring MVC拦截器"></a>1.Spring MVC拦截器</h4><p>定义在springmvc.xml配置下的<code>&lt;mvc:interceptor&gt;</code>表示对特定的请求进行拦截。</p>
<pre><code>    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt; 
           &lt;mvc:mapping path=&quot;/user/*&quot;/&gt; 
               &lt;bean class=&quot;com.wyb.interceptor.LoginInterceptor&quot;/&gt; 
        &lt;/mvc:interceptor&gt;  
     &lt;/mvc:interceptors&gt;
备注：
    1.preHandle()，在Action之前执行的预处理，可以进行编码、安全控制等处理
    2.postHandle()，在生成View之前执行的后处理，调用了Service并返回ModelAndView，但未进行页面渲染，可以修改ModelAndView
    3.afterCompletion()，最后执行的返回处理，这时已经进行了页面渲染，可以进行日志记录、释放资源等处理

所以在实现了接口之后，就可以在配置文件中进行拦截器的配置。
</code></pre><blockquote>
<p>注意：如果配置了<code>&lt;mvc:annotation-driven /&gt;</code>，会自动注册<code>DefaultAnnotationHandlerMapping</code>与<code>AnnotationMethodHandlerAdapter</code>这两个bean。这样就不能再注入<code>interceptors</code>属性，也就无法指定拦截器了。</p>
</blockquote>
<h2 id="4-3-ViewResolver接口实现类"><a href="#4-3-ViewResolver接口实现类" class="headerlink" title="4.3 ViewResolver接口实现类"></a>4.3 ViewResolver接口实现类</h2><p>InternalResourceViewResolver类(加入JSTL支持)</p>
<h2 id="4-4-springmvc-xml配置文件"><a href="#4-4-springmvc-xml配置文件" class="headerlink" title="4.4 springmvc.xml配置文件"></a>4.4 springmvc.xml配置文件</h2><hr>
<h1 id="5-Spring-MVC向页面传送参数的四种方式"><a href="#5-Spring-MVC向页面传送参数的四种方式" class="headerlink" title="5.Spring MVC向页面传送参数的四种方式"></a>5.Spring MVC向页面传送参数的四种方式</h1><p>1.使用<code>HttpServletRequest</code>和<code>Session</code>，然后<code>setAttribute()</code>（与Servlet一样） <code>request.setAttribute(&quot;user&quot;,user_data);</code>。</p>
<p>2.使用<code>ModelAndView</code>对象</p>
<pre><code>@RequestMapping(&quot;/login.do&quot;)   
public ModelAndView login(String name,String pass){   
    User user = userService.login(name,pwd); 
       Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();   
    data.put(&quot;user&quot;,user);   
    return newModelAndView(&quot;success&quot;,data); 
} 
</code></pre><p>3.使用<code>ModelMap</code>对象 <code>ModelMap</code> 数据会利用<code>HttpServletRequest</code>的<code>Attribute</code>传值到<code>success.jsp</code>中。</p>
<pre><code>@RequestMapping(&quot;/login.do&quot;) 
  public String login(String name,String pass ,ModelMap modelMap){
    User user = userService.login(name,pwd);//调用service层的login方法
    modelMap.addAttribute(&quot;user&quot;,user);  
    modelMap.put(&quot;name&quot;,name);  
    return &quot;success&quot;;  
 }  
</code></pre><p>4.使用<code>@ModelAttribute</code>注解 <code>@ModelAttribute</code> 数据会利用<code>HttpServletRequest</code>的<code>Attribute</code>传值到<code>success.jsp</code>中。</p>
<pre><code>@RequestMapping(&quot;/login.do&quot;)    
public String login(@ModelAttribute(&quot;user&quot;) User user) {    
    return &quot;success&quot;;   
}   
      @ModelAttribute(&quot;name&quot;)  
     public String getName(){
        return name;  
}
</code></pre><blockquote>
<p>注意：Spring MVC默认是采用转发来定位视图，如果要使用定向来转发视图，可以使用redirect前缀。</p>
</blockquote>
<pre><code>  public String login(){
    return &quot;redirect:registe.do&quot;;
}
</code></pre><hr>
<h1 id="6-Spring-MVC-的执行流程"><a href="#6-Spring-MVC-的执行流程" class="headerlink" title="6.Spring MVC 的执行流程"></a>6.Spring MVC 的执行流程</h1><pre><code>1.(前端)控制层(Controller)：接收请求、转发请求
2.(后端)控制层(Controller)：struts(action)：接受请求、处理请求数据
</code></pre><blockquote>
<p>注意：<code>Spring MVC</code>就是<code>Spring</code>，所以其<code>约束</code>与<code>Spring的约束</code>一致。</p>
<blockquote>
<p>查找方法：<br>    SpringMVC约束的查找是在..\jar\spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html路径下查找然后复制粘贴。</p>
</blockquote>
</blockquote>
<pre><code>3.程序实现流程
  1.配置默认处理器映射器(BeanNameUrlHandlerMapping)：映射器会将请求映射到Controller(根据bean(自定义Controller)的name属性的url去寻找执行类Controller)

  2.配置默认处理器适配器(SimpleUrlHandlerMapping)：负责执行UserController(依赖自定义的控制器bean，表示多个*.do文件可以访问一个或多个Controller)

  3.配置ControllerClassNameHandlerMapping：这个Mapping配置之后我们便能够使用Controller的【类名.do】来访问这个Controller

  4.SimpleControllerHandlerAdapter


4.代码层面的实现流程
  1.配置web.xml(配置前端控制器：DispatcherServlet)

  2.配置springmvc.xml
    1.配置处理器映射器(默认：BeanNameUrlHandlerMapping：根据自定义Controller的name属性的URL去寻找Handler(相当于Struts2中的Action))

    2.配置处理器适配器执行Controller(默认：SimpleControllerHandlerAdapter(执行Controller))

    3.配置自定义的Controller

    4.配置SpringMVC视图解析器：解析逻辑视图 后台返回逻辑视图(视图解析器解析出真正的物理视图：前缀+逻辑视图+后缀===/WEB-INF/jsps/index.jsp)

  3.自定义Controller(UserController implements Controller)

  4.配置自定义的Controller的bean(在springmvc.xml配置文件中配置Controller，表示这个对象交给Spring来创建)
  &lt;bean name=&quot;/hello.do&quot; class=&quot;cn.itcast.controller.UserController&quot;&gt;&lt;/bean&gt;（在bean中定义的name属性就是URL访问地址）

  5.配置视图解析器(如果Controller使用逻辑视图，必须配置视图解析器)

  6.访问 项目名+自定义的Controller的name属性URL
    http://localhost:8080/springmvc/hello.do
</code></pre><hr>
<h2 id="Struts2与SpringMVC的区别"><a href="#Struts2与SpringMVC的区别" class="headerlink" title="Struts2与SpringMVC的区别"></a>Struts2与SpringMVC的区别</h2><pre><code>1.实现机制
  Struts2底层是过滤器，是基于过滤器实现
  SpringMVC是基于Servlet实现的

2.执行速度
  Struts2是多列的，而SpringMVC是单列的，执行速度快。

3.参数封装
  Struts2参数封装是基于属性封装
  SpringMVC是基于方法封装的，颗粒更细
</code></pre><hr>
<h1 id="Spring-MVC-SD"><a href="#Spring-MVC-SD" class="headerlink" title="Spring MVC - SD"></a>Spring MVC - SD</h1><h2 id="Spring-MVC-的页面参数回显"><a href="#Spring-MVC-的页面参数回显" class="headerlink" title="Spring MVC 的页面参数回显"></a>Spring MVC 的页面参数回显</h2><p><code>SpringMVC</code>使用<code>Model</code>对象，<code>Model</code>对象相当于<code>application</code>(注意：application对象中数据可以是EL表达式进行获取)。</p>
<hr>
<h2 id="Spring-MVC-的URL模板映射"><a href="#Spring-MVC-的URL模板映射" class="headerlink" title="Spring MVC 的URL模板映射"></a>Spring MVC 的URL模板映射</h2><p>主要是为请求<code>restfull</code>(软件架构设计模式，请求更简洁、更安全，方便于搜索引擎收录)设计模式</p>
<blockquote>
<p>扩展：如果一个架构符合REST原则，就称它为RESTful架构。REST:表现层状态转化</p>
</blockquote>
<hr>
<h2 id="SpringMVC开发中Model的解释"><a href="#SpringMVC开发中Model的解释" class="headerlink" title="SpringMVC开发中Model的解释"></a>SpringMVC开发中Model的解释</h2><p>在<code>SpringMVC</code>开发中，<code>Model</code>是一种概念，而不是一种具体的参数或者是其他的具体的体现，<code>MVC</code>是软件工程中一种常见的规范的设计模式(model(模型层) view(视图层) Controller(控制层))</p>
<pre><code>1.Model(模型)包括：数据模型(POJO或Bean之类的东西)和业务逻辑(登录、注册操作等)，是用来从后台封装数据到页面的(后台定的实体类)。
</code></pre><blockquote>
<p>注意：POJO是一个域对象，用来接收并封装前台页面传递过来的数据。</p>
</blockquote>
<pre><code>2.Controller(控制)：使得Model层能在View层表示出来
</code></pre><h4 id="SpringMVC的model"><a href="#SpringMVC的model" class="headerlink" title="SpringMVC的model"></a>SpringMVC的model</h4><p>1.springmvc接收参数的时候可以自动注入<code>model</code>或者<code>modelAndView</code>这两个类 </p>
<pre><code>@RequestMapping(&quot;/aa&quot;)
public String aa(Model model) {
    model.addAttribute(&quot;key&quot;,&quot;value&quot;);
    return &quot;HH&quot;;
}
</code></pre><p>2.然后在页面中，这些value可以通过key取出来。这便就是简化了的<code>springmvc</code>的工作过程。</p>
<hr>
<p>3..RequestMapping</p>
<p>  注意：根路径就是用来隔离Controller里面的相同的方法</p>
<p>4.SpringMVC封装参数</p>
<blockquote>
<p>注意：SpringMVC没有成员变量，将需要传递参数对象放入方法中，当请求这个方法的时候，这个方法里面对象会被自动创建，需要封装的参数自动被封装到方法的对象中。</p>
</blockquote>
<hr>
<h2 id="Spring-MVC-的转发与重定向-springmvc-forward-redirect"><a href="#Spring-MVC-的转发与重定向-springmvc-forward-redirect" class="headerlink" title="Spring MVC 的转发与重定向(springmvc forward/redirect)"></a>Spring MVC 的转发与重定向(springmvc forward/redirect)</h2><p>语法：</p>
<pre><code>1.return &quot;forward:/index.do&quot;;//forward在跳转后可以去到值 forward跳转后地址栏URL不会改变
2.return &quot;redirect:/register.do&quot;;//redirect在跳转后无法取到值 redirect跳转后地址栏URL会改变
</code></pre><hr>
<h2 id="spring-mvc-的配置文件内容"><a href="#spring-mvc-的配置文件内容" class="headerlink" title="spring mvc 的配置文件内容"></a>spring mvc 的配置文件内容</h2><p><code>&lt;mvc:annotation-driven/&gt;</code>：默认创建多个对象 <code>RequestMappingHandlerMapping</code>(处理器映射器)/<code>RequestMappingHandlerAdapter</code>(处理器适配器)，默认提供<code>json</code>数据格式的支持。</p>
<blockquote>
<p>注意：以后在创建SpringMVC处理器映射器与适配器的时候可以直接使用<code>&lt;mvc:annnotation-driven/&gt;</code>作创建<code>springMVC</code>相关的操作。</p>
<blockquote>
<p>注意：<code>JavaBean</code>不能添加<code>@XmlRootElement</code>(这个只提供对xml的视图支持)</p>
</blockquote>
</blockquote>
<hr>
<p>注解@RequestBody、@ResponseBody</p>
<pre><code>1.@RequestBody作用：把前台页面传送json格式数据强制转换为JavaBean，可以将请求体中的JSON字符串绑定到响应的Bean上，也可以将其绑定在对应的字符串上面。

2.@ResponseBody作用：在后台将JavaBean转换成json格式的数据返回页面，是将Controller的方法返回的对象通过适当的转换器转换成指定的格式之后，写入到response对象的body区。
</code></pre><blockquote>
<p>注意：这两个注解不能直接使用，需要依赖于JACKson的jar包。</p>
</blockquote>
<p>开发实现步骤：</p>
<pre><code>1.导入jar包
  Jackson-core-asl-1.9.11.jar
  Jackson-mapper-asl-1.9.11.jar

2.配置json格式转换
  &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;bean class=&quot;MappingJacksonHttpMessageConverter.class&quot;&gt;
  &lt;/property&gt;
</code></pre><hr>
<h5 id="浅谈-RequestMapping-ResponseBody-和-RequestBody-注解的用法与区别"><a href="#浅谈-RequestMapping-ResponseBody-和-RequestBody-注解的用法与区别" class="headerlink" title="浅谈 @RequestMapping @ResponseBody 和 @RequestBody 注解的用法与区别"></a>浅谈 <code>@RequestMapping</code> <code>@ResponseBody</code> 和 <code>@RequestBody</code> 注解的用法与区别</h5><pre><code>1.@RequestMapping
  @RequestMapping是用来处理请求地址映射的注解，可用于类或方法上。
     用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；
  用于方法上，表示在类的父路径下追加方法上注解中的地址将会访问到该方法，此处需注意@RequestMapping用在类上可以没用，但是用在方法上必须有。

  例：原理也非常好了解，其对应的 action 就是“ （父路径） controller/（父路径下方法路经）method ”
  在类上注释的是@RequestMapping(value = &quot;/Controllers&quot;)
  在方法上注释的是 @RequestMapping(value = &quot;/method&quot;)
</code></pre><blockquote>
<p>注意： @PathVariable 注解，其用来获取请求路径（url）中的动态参数。</p>
</blockquote>
<pre><code>2.@ResponseBody
  @ResponseBody注解表示该方法的返回的结果直接写入 HTTP 响应正文（ResponseBody）中，一般在异步获取数据时使用，通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入HTTP 响应正文中。

  作用：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConvert转换为指定的格式后，写入到Response对象的body数据区
</code></pre><blockquote>
<p>注意：异步获取json数据，加上@Responsebody注解后，就会直接返回json数据</p>
</blockquote>
<pre><code>3.@RequestBody
  @RequestBody注解则是将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。

作用：

  1) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上。 
  2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。
</code></pre><hr>
<blockquote>
<p>@ResponseBody(将后台pojo转换成json对象，返回到页面)</p>
<blockquote>
<p>@RequestBody(接收前台json数据，将json数据自动封装到JavaBean)</p>
</blockquote>
</blockquote>
<p>上面两者的开发实现步骤：</p>
<pre><code>1.导入jar包（Jackson-core-asl-1.9.11.jar Jackson-mapper-asl-1.9.11.jar） 
2.修改springmvc.xml文件
  1.在springmvc.xml文件中的处理器适配器下配置我们的json转换对象(messageConverters)
    &lt;bean class=&quot;RequestMappingHandlerAdapter.class这个类&quot;&gt;
        &lt;property name=&quot;messageConverters&quot;&gt;
        &lt;bean class=&quot;MappingJacksonHttpMessageConverter这个类&quot;&gt;&lt;/bean&gt;//要转换的json格式的类数据
    &lt;/bean&gt;
3.页面传递json格式数据
  1.使用ajax传递json格式数据

4.自定义Controller类里面(后台)

  //1.请求json格式数据，返回json
  @RequestMapping(&quot;requestJson&quot;)
  public @ResponseBody(转换为json格式) User requestJson(@RequestBody(封装在user对象里面) User user){
        System.out.println(user);//测试user对象输出的值是否正确
        return user;
    }

  //2.跳转到RequestJson页面
  @RequestMapping(&quot;toJson&quot;)
  public String toJson(){
    return &quot;requestJson&quot;;
}

5.toJson.do(前台)

  1.首先引入在JSP页面引入js
    function requestJson(){
    //模拟json格式数据
    var jsonObj = JSON.stringify({&quot;username&quot;:&quot;张三&quot;，&quot;sex&quot;:&quot;男&quot;,&quot;address&quot;:&quot;东北那嘎达&quot;});

    $.ajax({
        type:&apos;POST&apos;,
        url:&apos;/springmvc19_day01_02/user/requestJson.do&apos;,
        contentType:&apos;qpplication/json;charset=utf-8&apos;,
        data:jsonObj,
        success:function(data){
            alert(data);
            }
        })
    }

另：请求Pojo，返回json
</code></pre><hr>
<h2 id="SpringMVC多视图"><a href="#SpringMVC多视图" class="headerlink" title="SpringMVC多视图"></a>SpringMVC多视图</h2><pre><code>开发步骤：
1.导入xml格式支持的jar包
spring-oxm-3.2.0.RELEASE.jar

2.配置springmvc.xml文件支持多视图
  &lt;bean class=&quot;ContentNegotiatingViewResolver这个对象的类&quot;&gt;
    //配置支持的媒体类型
    &lt;property name=&quot;contentNegotiationManager&quot;&gt;
        &lt;bean class=&quot;ContentNegotiationManagerFactory这个对象的类&quot;&gt;&lt;/bean&gt;
        &lt;property name=&quot;mediaTypes&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;json&quot; value=&quot;application/json&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;

    //指定默认视图
    &lt;property name=&quot;defaultViews&quot;&gt;
        //支持多个视图
        &lt;list&gt;
            //对json格式视图支持
            &lt;bean class=&quot;MappingJacksonJsonView这个类的URL&quot;&gt;&lt;/bean&gt;
            //对xml格式视图的支持
            &lt;bean class=&quot;MarshallingView这个类的URL&quot;&gt;
            &lt;constructor-arg&gt;
                &lt;bean class=&quot;Jaxb2Marshaller这个类URL&quot;&gt;
                    &lt;property name=&quot;classesToBeBound&quot;&gt;
                        &lt;list&gt;
                            &lt;value&gt; ... &lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/constructor-arg&gt;
        &lt;/list&gt;

    &lt;/property&gt;
  &lt;/bean&gt;


3.编写自定义UserController类
  @RequestMapping(&quot;multiView&quot;)
  public User multiView(){
    User user = new User();
    user1.setId(1);
    user1.setSex(&quot;男&quot;);
    user1.setUsername(&quot;张三丰&quot;);
    user1.setAddress(&quot;武当山&quot;);
    user1.setBirthday(new Date());

    return user1;

    }

4.访问
  约定rest目录下的所有以json和xml扩展名都支持相应的视图
</code></pre><hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><p>开发步骤：<br>    1.导入jar包(导入spring(包含springMVC)/mybatis/mybatis-spring整合)数据库驱动、JSTL、c3p0管理数据源、log4j。</p>
<pre><code>2.配置web.xml文件
</code></pre><p>后续添加…………….</p>
<hr>
<h2 id="SpringMVC的文件上传"><a href="#SpringMVC的文件上传" class="headerlink" title="SpringMVC的文件上传"></a>SpringMVC的文件上传</h2><pre><code>1.开启文件上传
  SpringMVC配置文件配置支持文件上传类
//配置文件上传解析器
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.CommonsMultipartResolver&quot;&gt;//id名称必须是如此class名称后面的部分
    //配置文件上传解析器参数
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10240000&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><hr>
<h2 id="Spring-MVC-的页面缓存"><a href="#Spring-MVC-的页面缓存" class="headerlink" title="Spring MVC 的页面缓存"></a>Spring MVC 的页面缓存</h2><p>使用Oscache实现页面缓存</p>
<p>测试页面缓存</p>
<pre><code>实现步骤：
    1.导入相关jar包
</code></pre><hr>
<blockquote>
<p>关于Controller里面的方法中的参数问题</p>
<blockquote>
<p>1.Model model</p>
</blockquote>
</blockquote>
<pre><code>model主要是用来传值的，与request、session的作用效果差不多

model的作用跟request的setAttribute(arg0,arg1)是一样的，都是把值或是对象进行一个保存，然后可以在视图上进行取值，同样都可以使用ognl表达式取值。

springmvc使用model的原因：
request只是一个请求，作用就是从客户端发起一个请求，并且携带客户端发起的这个请求所带的参数，在业务层中进行参数的获取并且做出相对应的处理，到这里这个request请求对象的工作就应该结束了，剩下的就是客户端对这个请求和参数做出处理结果并且生成响应response返回客户端。所以不应该用request进行存值，来达到模型层和视图层的一个连接，所以才使用model或是modelandview这个专门的对象来进行模型层的存在和视图层的取值model会在模型层进行存值，在视图层中，他会去检查model对象中是否用这个属性，有ta就会渲染出来，request请求结束后就会自动清除model的数据。
</code></pre><hr>
<blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>1.JSTL中&lt;c:forEach&gt;标签：forEach标签作用是做一个循环遍历使用

2.model.addAttribute()的作用：往前台传数据,可以传对象,可以传List,通过el表达式 ${}可以获取到，类似于request.setAttribute(&quot;sts&quot;,sts)效果一样

3.@ModelAttribute 用法：1.直接标记在方法上 2.标记在方法的参数上

4.@RequestParam(value=&quot;xxx&quot; required=false) 1.可以对传入参数指定参数名

5.可以通过required=false/true来要求@RequestParam配置的前端参数是否一定要传

6.如果@RequestParam注解的参数是int类型，并且required=false，此时如果不传参数的话会报错。
</code></pre><hr>
<h2 id="第11章-为Spring添加REST功能"><a href="#第11章-为Spring添加REST功能" class="headerlink" title="第11章 为Spring添加REST功能"></a>第11章 为Spring添加REST功能</h2><p>简洁的说<code>REST</code>就是将资源的状态以合适的形式从服务器端转移到客户端&lt;或者反之&gt;。<code>Spring 3</code>对<code>Spring MVC</code>的一些增强功能为<code>REST</code>提供了良好的支持。现在，Spring支持以下方式开发REST资源。</p>
<pre><code>1.控制器可以处理所有的HTTP方法，包括：get、put、delete和post方法

2.新的@PathVariable注解使得控制器能够处理参数化的URL(将变量输入作为URL的一部分)

3.Spring的表单绑定JSP标签库&lt;form:form&gt;标签以及新的HiddenHttpMethodFilter，使得通过HTML表单提交put和delete请求成为可能。

4.通过使用Spring的视图和视图解析器，资源可以以各种形式进行表述，包括将模型数据表现为：XML/JSON/ATOM/RSS的新视图实现。
</code></pre><hr>
<h2 id="Spring-MVC-TD"><a href="#Spring-MVC-TD" class="headerlink" title="Spring MVC - TD"></a>Spring MVC - TD</h2><h2 id="1-MVC概要"><a href="#1-MVC概要" class="headerlink" title="1.MVC概要"></a>1.MVC概要</h2><p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范，用一种将业务逻辑、数据、显示分离的方法组织代码。MVC主要作用是降低了视图与业务逻辑间的双向偶合。MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异</p>
<blockquote>
<p>注意：在WEB开发的早期，通常采用的是Model1(JSP兼顾View和Controller两种角色)，主要分为两层，视图层与模型层。而model2将项目分成三个部分，包括视图、控制、模型。</p>
</blockquote>
<hr>
<h2 id="2-控制器定义与-RequestMapping详解"><a href="#2-控制器定义与-RequestMapping详解" class="headerlink" title="2.控制器定义与@RequestMapping详解"></a>2.控制器定义与@RequestMapping详解</h2><p>控制器：提供访问应用程序的行为，通常通过服务接口定义或注解定义两种方式，控制器解析用户的请求并将其转换为一个模型。</p>
<blockquote>
<p>小结：实现接口Controller定义控制器是较老的办法，缺点是：一个控制器中只有一个Action，如果要多个Action则需要定义多个Controller。定义的方式比较麻烦。Spring 2.5以后采用注解的方式定义解决这些问题。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>@RequestMapping注释用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>路径变量占位、URI模板模式

    在SpringMVC中可是使用@PathVariable注释方法参数的值绑定到URI模板变量

    优点：使得路径名变得更加简洁，获得参数更加方便，框架会自动进行类型转换。
</code></pre><h2 id="3-请求处理方法Action详解"><a href="#3-请求处理方法Action详解" class="headerlink" title="3.请求处理方法Action详解"></a>3.请求处理方法Action详解</h2><p>1.Action参数类型</p>
<pre><code>@ModelAttribute模型特性

@ModelAttribute可以应用在方法参数上或方法上，他的作用主要是当注解在方法中时会将注解的参数对象添加到Model中；
当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会首先调用该方法。
</code></pre><blockquote>
<p>注意：boolean类型的值生成的get/set属性名称前是不带get与set的，这样会引起异常，建议手动修改。</p>
</blockquote>
<hr>
<h2 id="SpringMVC验证器Validator"><a href="#SpringMVC验证器Validator" class="headerlink" title="SpringMVC验证器Validator"></a>SpringMVC验证器Validator</h2><pre><code>SpringMVC验证器Validator是一个接口，通过实现该接口来定义对实体对象的验证。

1.验证器接口

    package org.springframework.validation;

    /**
     * Spring MVC内置的验证器接口
     */
    public interface Validator {

        /**
         * 是否可以验证该类型
         */
        boolean supports(Class&lt;?&gt; clazz);

        /**
         * 执行验证 target表示要验证的对象 error表示错误信息
         */
        void validate(Object target, Errors errors);
    }

2.定义验证器(实现该接口)

    package com.zhangguo.springmvc51.entities;

    import org.springframework.validation.Errors;
    import org.springframework.validation.ValidationUtils;
    import org.springframework.validation.Validator;

    /**
     * 产品验证器
     *
     */
    public class ProductValidator implements Validator {

        //当前验证器可以验证的类型，重写接口中的方法
        @Override
        public boolean supports(Class&lt;?&gt; clazz) {
            return Product.class.isAssignableFrom(clazz);
        }

        //执行校验，重写接口中的方法
        @Override
        public void validate(Object target, Errors errors) {
            //将要验证的对象转换成Product类型
            Product entity=(Product)target;
            //如果产品名称为空或为空格，使用工具类
            ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;name&quot;, &quot;required&quot;, &quot;产品名称必须填写&quot;);
            //价格，手动判断
            if(entity.getPrice()&lt;0){
                errors.rejectValue(&quot;price&quot;, &quot;product.price.gtZero&quot;, &quot;产品价格必须大于等于0&quot;);
            }
            //产品类型必须选择
            if(entity.getProductType().getId()==0){
                errors.rejectValue(&quot;productType.id&quot;, &quot;product.productType.id.required&quot;, &quot;请选择产品类型&quot;);
            }
        }

    }
</code></pre><blockquote>
<p>注意：ValidationUtils是一个工具类，中间有一些方法可以用于判断内容是否有误。</p>
</blockquote>
<pre><code>3.执行校验

    // 新增保存，如果新增成功转回列表页，如果失败回新增页，保持页面数据
    @RequestMapping(&quot;/addSave&quot;)
    public String addSave(Model model, Product product, BindingResult bindingResult) {

        // 创建一个产品验证器
        ProductValidator validator = new ProductValidator();
        // 执行验证，将验证的结果给bindingResult，该类型继承Errors
        validator.validate(product, bindingResult);

        // 获得所有的字段错误信息，非必要
        for (FieldError fielderror : bindingResult.getFieldErrors()) {
            System.out.println(fielderror.getField() + &quot;，&quot; + fielderror.getCode() + &quot;，&quot; + fielderror.getDefaultMessage());
        }

        // 是否存在错误，如果没有，执行添加
        if (!bindingResult.hasErrors()) {
            // 根据类型的编号获得类型对象
            product.setProductType(productTypeService.getProductTypeById(product.getProductType().getId()));
            productService.addProduct(product);
            return &quot;redirect:/&quot;;
        } else {
            // 与form绑定的模型
            model.addAttribute(&quot;product&quot;, product);
            // 用于生成下拉列表
            model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes());
            return &quot;product/add&quot;;
        }
    }
</code></pre><blockquote>
<p>注意：在参数中增加了一个BindingResult类型的对象，该类型继承自Errors，获得绑定结果，承载错误信息，该对象中有一些方法可以获得完整的错误信息，可以使用hasErrors方法判断是否产生了错误。</p>
</blockquote>
<pre><code>4.在UI中添加错误标签

    add.jsp
    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
    &lt;%@taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
    &lt;link href=&quot;styles/main.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;title&gt;新增产品&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;main&quot;&gt;
            &lt;h2 class=&quot;title&quot;&gt;&lt;span&gt;新增产品&lt;/span&gt;&lt;/h2&gt;
            &lt;form:form action=&quot;addSave&quot; modelAttribute=&quot;product&quot;&gt;
            &lt;fieldset&gt;
                &lt;legend&gt;产品&lt;/legend&gt;
                &lt;p&gt;
                    &lt;label for=&quot;name&quot;&gt;产品名称：&lt;/label&gt;
                    &lt;form:input path=&quot;name&quot;/&gt;
                    &lt;form:errors path=&quot;name&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt;
                &lt;/p&gt;
                &lt;p&gt;
                    &lt;label for=&quot;title&quot;&gt;产品类型：&lt;/label&gt;
                    &lt;form:select path=&quot;productType.id&quot;&gt;
                         &lt;form:option value=&quot;0&quot;&gt;--请选择--&lt;/form:option&gt;
                         &lt;form:options items=&quot;${productTypes}&quot;  itemLabel=&quot;name&quot; itemValue=&quot;id&quot;/&gt;
                    &lt;/form:select&gt;
                    &lt;form:errors path=&quot;productType.id&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt;
                &lt;/p&gt;
                &lt;p&gt;
                    &lt;label for=&quot;price&quot;&gt;产品价格：&lt;/label&gt;
                    &lt;form:input path=&quot;price&quot;/&gt;
                    &lt;form:errors path=&quot;price&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt;
                &lt;/p&gt;
                &lt;p&gt;
                  &lt;input type=&quot;submit&quot; value=&quot;保存&quot; class=&quot;btn out&quot;&gt;
                &lt;/p&gt;
            &lt;/fieldset&gt;
            &lt;/form:form&gt;
            &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt;
            &lt;p&gt;
                &lt;a href=&quot;&lt;c:url value=&quot;/&quot; /&gt;&quot;  class=&quot;abtn out&quot;&gt;返回列表&lt;/a&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre><hr>
<h2 id="JSR303验证器"><a href="#JSR303验证器" class="headerlink" title="JSR303验证器"></a>JSR303验证器</h2><p>JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。<br>JSR 303 – Bean Validation 是一个数据验证的规范。JSR303只是一个标准，是一验证规范，对这个标准的实现有：hibernate-validator，Apache BVal等。这里我们使用hibernate-validator实现校验。</p>
<hr>
<h2 id="使用jQuery扩展插件Validate实现前端校验"><a href="#使用jQuery扩展插件Validate实现前端校验" class="headerlink" title="使用jQuery扩展插件Validate实现前端校验"></a>使用jQuery扩展插件Validate实现前端校验</h2><p>jquery.validate是基于jQuery的一个B/S客户端验证插件，借助jQuery的优势，我们可以迅速验证一些常见的输入,大大提高了开发效率</p>
<pre><code>3.1、jQuery扩展插件validate—1基本使用方法 http://www.cnblogs.com/best/archive/2011/09/05/2167723.html
3.2、jQuery扩展插件validate—2通过参数设置验证规则 http://www.cnblogs.com/best/archive/2011/09/05/2167733.html
3.3、jQuery扩展插件validate—3通过参数设置错误信息 http://www.cnblogs.com/best/archive/2011/09/05/2167742.html
3.4、jQuery扩展插件validate—4设置错误提示的样式 http://www.cnblogs.com/best/archive/2011/09/05/2167756.html
3.5、jQuery扩展插件validate—5添加自定义验证方法 http://www.cnblogs.com/best/archive/2011/09/05/2167773.html
3.6、jQuery扩展插件validate—6radio、checkbox、select的验证 http://www.cnblogs.com/best/archive/2011/09/05/2167779.html
</code></pre><blockquote>
<p>注意：validate只是使验证变得方便，简单，本质还是使用js，不论多么强大的js验证，当用户把js禁用或使用机器直接发起请求时都不能确保数据的完整性，所有不要把希望寄托在客户端验证，个人认为每一个客户端验证都要服务器进行再次验证。</p>
</blockquote>
<hr>
<h2 id="Spring-MVC-的文件上传"><a href="#Spring-MVC-的文件上传" class="headerlink" title="Spring MVC 的文件上传"></a>Spring MVC 的文件上传</h2><p>在Spring MVC中有两种实现上传文件的办法，第一种是Servlet3.0以下的版本通过commons-fileupload与commons-io完成的通用上传，第二种是Servlet3.0以上的版本的Spring内置标准上传，不需借助第3方组件。通用上传也兼容Servlet3.0以上的版本。</p>
<pre><code>第一种方法编码上传步骤：
    1.添加上传依赖包
    2.编写上传页面
    3.修改配置文件，增加上传配置
      Spring MVC在默认情况下对文件上传的视图内容是不能解析的，要配置一个特别的解析器解析上传的内容，修改springmvc-servlet.xml配置文件
        springmvc-servlet.xml配置内容：
            &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
                    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt;//默认上传编码utf-8
                    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt;//上传最大限制
                    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt;//缓冲区大小
                &lt;/bean&gt;
    4.
</code></pre><hr>
<h2 id="FreeMark"><a href="#FreeMark" class="headerlink" title="FreeMark"></a>FreeMark</h2><p>FreeMarker是一款模板引擎，即一种基于模板和要改变的数据，并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。<br>模板编写为FreeMarkerTemplateLanguage(FTL)。它是简单的，专用的语言，不是像PHP那样成熟的编程语言。那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算，之后模板显示已经准备好的数据。<br>在模板中，你可以专注于如何展现数据，而在模板之外可以专注于要展示什么数据。</p>
<hr>
<h2 id="SpringMVC开发详解-总结"><a href="#SpringMVC开发详解-总结" class="headerlink" title="SpringMVC开发详解-总结"></a>SpringMVC开发详解-总结</h2><h4 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1.Controller"></a>1.Controller</h4><blockquote>
<p>注意1：在新建Controller之前应该首先建一个包，因为SpringMVC是没法再默认包下运行的</p>
<blockquote>
<p>注意2：类上的注解@RequestMapping(“/hi”)指定 Url路径前边一部分，方法上的注解@RequestMapping(“/say”)指定 Url路径最后一部分，也可以只把注解写在方法上，比如@RequestMapping(“/hi/say”)</p>
</blockquote>
</blockquote>
<h4 id="2-修改url-pattern-web-xml"><a href="#2-修改url-pattern-web-xml" class="headerlink" title="2.修改url-pattern(web.xml)"></a>2.修改url-pattern(web.xml)</h4><blockquote>
<p>注意：有关于ServletMapping的设置，通过这个设置，可以配置那些类型的url用那些servlet来处理<br>    在开发中我们发现IDEA默认配置一个Dispatcher的Servlet(这个servlet使用org.springframework.web.servlet.DispatcherServlet这个类来处理)，而这个servlet对应的url就是*.form</p>
</blockquote>
<h4 id="3-配置component-scan-dispatcher-servlet-xml"><a href="#3-配置component-scan-dispatcher-servlet-xml" class="headerlink" title="3.配置component-scan(dispatcher-servlet.xml)"></a>3.配置component-scan(dispatcher-servlet.xml)</h4><blockquote>
<p>注意：component-scan就是告诉Servlet去哪里找到相应的Controller</p>
</blockquote>
<h4 id="4-添加视图文件-jsp"><a href="#4-添加视图文件-jsp" class="headerlink" title="4.添加视图文件(.jsp)"></a>4.添加视图文件(.jsp)</h4><blockquote>
<p>注意：因为用户不能访问到WEB-INF路径下的资源，所以将创建好的view视图放在此路径下较安全</p>
</blockquote>
<h4 id="5-配置ViewResolver-dispatcher-servlet-xml"><a href="#5-配置ViewResolver-dispatcher-servlet-xml" class="headerlink" title="5.配置ViewResolver(dispatcher-servlet.xml)"></a>5.配置ViewResolver(dispatcher-servlet.xml)</h4><blockquote>
<p>注意：配置这一参数的原因是因为Controller中的返回值必须是View的绝对路径，所以在Controller中只想返回一个简写的话需要在dispatcher-servlet.xml文件中配置</p>
</blockquote>
<pre><code>&lt;!--指定视图解析器--&gt;
  &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
      &lt;!-- 视图的路径 --&gt;
      &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
      &lt;!-- 视图名称后缀  --&gt;
      &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
  &lt;/bean&gt;
</code></pre><blockquote>
<p>注意：记得修改完之后同步修改的Controller的返回值，不然又会报错404</p>
</blockquote>
<h4 id="6-通过Model向View传值"><a href="#6-通过Model向View传值" class="headerlink" title="6.通过Model向View传值"></a>6.通过Model向View传值</h4><pre><code>通过上面的操作已经完成了MVC中的VC了，所以M的修改开始
1.在Controller类里面修改
    package wormday.springmvc.helloworld;

    import org.springframework.stereotype.Controller;
    import org.springframework.ui.Model; // 这里导入了一个Model类
    import org.springframework.web.bind.annotation.RequestMapping;

    @Controller
    @RequestMapping(&quot;/hi&quot;)
    public class HiController {

            @RequestMapping(&quot;/say&quot;)
            public String say(Model model) { // 参数中传入Model
                model.addAttribute(&quot;name&quot;,&quot;wormday&quot;); // 指定Model的值
                model.addAttribute(&quot;url&quot;,&quot;http://www.cnblogs.com/wormday/p/8435617.html&quot;); // 指定Model的值
                    return &quot;say&quot;;
                    }
            }

2.然后打开View(.jsp)修改其中的值

    &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
    &lt;html&gt;
    &lt;head&gt;
            &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        hello world,${name}//添加上JSTL表达式
        &lt;br/&gt;${url}&lt;/body&gt;
    &lt;/html&gt;
</code></pre><h4 id="7-springMVC-Controller返回值的可选类型详解"><a href="#7-springMVC-Controller返回值的可选类型详解" class="headerlink" title="7.springMVC Controller返回值的可选类型详解"></a>7.springMVC Controller返回值的可选类型详解</h4><p><code>Spring MVC</code> 支持<code>ModelAndView/Model/ModelMap/Map/View/String/void</code>返回方式</p>
<pre><code>1.ModelAndView

    @RequestMapping(&quot;/hello&quot;)
      public ModelAndView helloWorld() { 
            String message = &quot;Hello World, Spring 3.x!&quot;;
            return new ModelAndView(&quot;hello&quot;, &quot;message&quot;, message);
      }

总结：通过ModelAndView构造方法可以指定返回页面的名称，同时也可以通过setViewName()方法跳转到指定页面

2.Map

    @RequestMapping(&quot;/demo2/show&quot;) 
      public Map&lt;String, String&gt; getMap() { 
            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); 
            map.put(&quot;key1&quot;, &quot;value-1&quot;); 
            map.put(&quot;key2&quot;, &quot;value-2&quot;); 
            return map; 
      }

总结：在前端页面.jsp页面中通过${key}获得到值，map.put()相当于request.setAttribute方法

3.View

    可以返回文件格式

4.String

    指定返回的视图页面名称，结合设置的返回地址路径加上页面名称后缀便能够访问到

    注意：如果方法上声明了注解@ResponseBody，那么就会直接将返回值输出到前端页面

    1.没有注解@ResponseBody的情况
      @RequestMapping(value=&quot;/showdog&quot;)
        public String hello1(){
            return &quot;hello&quot;;
        }

    2.在Controller控制器中有注解@ResponseBody的情况
      @RequestMapping(value=&quot;/print&quot;)
        @ResponseBody
        public String print(){
            String message = &quot;Hello World, Spring MVC!&quot;;
            return message;//返回前端结果输出界面处理  会直接将返回值输出到前端页面
        }

    3.在Controller控制器中有注解，返回JSON数据(使用Jackson)
      @RequestMapping(&quot;/load1&quot;)
        @ResponseBody
        public String load1(@RequestParam String name,@RequestParam String password) throws IOException{
            System.out.println(name+&quot; : &quot;+password); 
             //return name+&quot; : &quot;+password;
            MyDog dog=new MyDog();
            dog.setName(&quot;小哈&quot;);
            dog.setAge(&quot;1岁&quot;);
            dog.setColor(&quot;深灰&quot;);
            ObjectMapper objectMapper = new ObjectMapper();
            String jsonString=objectMapper.writeValueAsString(dog);
            System.out.println(jsonString);
            return jsonString;
      }

5.void

    如果返回值为空，那么响应的视图(View)页面对应为 访问地址

    @RequestMapping(&quot;/index&quot;)
      public void index() {
            return;//这里表示的返回值为空，那么响应的访问地址是浏览器中输入的访问地址
      }

    总结：所以其对应的逻辑视图名为&quot;index&quot;
</code></pre><blockquote>
<p>总结：</p>
<blockquote>
<p>1.String作为请求处理方法的返回值类型是比较通用的方法，因为这样的逻辑视图名不会和请求的URL绑定，具有很强的灵活性，而模型数据又可以通过ModelMap控制</p>
<blockquote>
<p>2.使用 void/map/Model 时，返回对应的逻辑视图名称真实url为：prefix前缀+视图名称 +suffix后缀组成</p>
<blockquote>
<p>3.使用String,ModelAndView返回视图名称可以不受请求的url绑定，ModelAndView可以设置返回的视图名称</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="Spring-MVC-FOD"><a href="#Spring-MVC-FOD" class="headerlink" title="Spring MVC - FOD"></a>Spring MVC - FOD</h2><h4 id="1-几种Spring-MVC-返回JSON数据比较"><a href="#1-几种Spring-MVC-返回JSON数据比较" class="headerlink" title="1.几种Spring MVC 返回JSON数据比较"></a>1.几种Spring MVC 返回JSON数据比较</h4><p>因为现阶段网站的前后端分离，所以让RESTful 接口开发成为后台开发的核心。JSON作为简单高效的数据交互格式是首选。Spring mvc 提供注解@ResponseBody协助处理返回数据格式，所以可以是JSON/XML</p>
<pre><code>1.后端的配置
  &lt;beans:bean id=&quot;jsonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
    &lt;beans:property name=&quot;supportedMediaTypes&quot;&gt;
        &lt;beans:list&gt;
            &lt;beans:value&gt;application/json;charset=UTF-8&lt;/beans:value&gt;
        &lt;/beans:list&gt;
    &lt;/beans:property&gt;
&lt;/beans:bean&gt;

2.返回格式的比较
  1.map格式

   public @ResponseBody Map&lt;String,Object&gt; getData() {
        return new HashMap&lt;String,Object&gt;;
   }
</code></pre><blockquote>
<p>注意：这种方式数据需要手动添加到map中。</p>
</blockquote>
<pre><code>2.业务类格式

  public @ResponseBody User getData() {
      return new User();
  }
  public @ResponseBody List&lt;User&gt; getData() {
      return new User();
  }
</code></pre><blockquote>
<p>注意：这种方式可以看出返回的业务数据类型，但是如果返回的数据有变动，那么需要变更业务类。</p>
</blockquote>
<pre><code>3.JSON格式

  //手动转换
  public @ResponseBody JSONObject getData(){  
      User user = userDao.getUser(); 
      JSONObject result = new JSONObject();
      result.put(&quot;id&quot;,user.getId());
      result.put(&quot;username&quot;,user.getUsername());
      if(user.getSex()==0){
          result.put(&quot;sex&quot;,&quot;男&quot;);
      }else{
          result.put(&quot;sex&quot;,&quot;女&quot;);
      }
      return result;
  }
  //自动转换
  public @ResponseBody JSONObject getData(){
      User user = userDao.getUser(); 
      JSONObject result = JSONObject.fromObject(user);
      return result;
  }
</code></pre>]]></content>
      <categories>
        <category>spring mvc</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/undefined/Linux/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="linux-操作系统-笔记"><a href="#linux-操作系统-笔记" class="headerlink" title="linux 操作系统 - 笔记"></a>linux 操作系统 - 笔记</h1><h4 id="1-Linux-操作系统概述"><a href="#1-Linux-操作系统概述" class="headerlink" title="1.Linux 操作系统概述"></a>1.Linux 操作系统概述</h4><pre><code>1.常见操作系统
   - 服务端操作系统 ： linux、unix、windows server 
   - 单机操作系统 ： windows（dos 、ucdos、win95、win98、win2000、xp、vista、win7、win8）
                     MAC 、linux（ubuntu）
   - 移动操作系统 Android、IOS 、Windows phone
</code></pre><a id="more"></a>
<pre><code>2.linux操作系统介绍
  - 为什么要学习linux操作系统 
    1. 大部分服务端都采用linux ，JEE部署到服务器中
    2. 一些企业和学校采用linux研发和教学 

    3. 很多嵌入式开发 用linux  
    4. 云计算、大数据 是集群网  linux : centos 

      - 特点   
        1. 开放、开源、多用户的网络操作系统

        2. 基于unix（unix--&gt;minix--&gt;linux(linus :林纳斯 芬兰 )），可以定制内核

        3. 假如了GNU组织（自由软件组织 ，copyLeft） ，通过GPL（通用公共许可） 许可对外发布  
            - linux组成
                1. linux内核（linus 团队管理）
                2. shell ：用户与内核交互的接口
                3. 文件系统 ： ext3、ext4 等  windows 有 fat32  、ntfs 
                4. 第三方应用软件 

            - linux操作系统版本   
                1. 内核版本 (linus 团队管理)  3.8
                2. 发行版本  :一些软件公司以内核为基础，再添加一些软件和文档形成发行版本
                    - red hat  ： rhel ，centos
                    - debian   ： debian，ubuntu（桌面）
                    - android  
</code></pre><h4 id="2-安装linux系统"><a href="#2-安装linux系统" class="headerlink" title="2.安装linux系统"></a>2.安装linux系统</h4><pre><code>1. vmware安装 ： 创建虚拟机的软件 
   vitual box ：oracle 公司提供

2. 虚拟机安装
   - 直接安装
     - 创建虚拟机
 - 安装ubuntu镜像
   - 打开虚拟机镜像： 虚拟机+操作系统（ubuntu）
     1. 打开*.vmx 文件
     2. 用户名  itcast  密码  123
</code></pre><h4 id="3-linux系统环境"><a href="#3-linux系统环境" class="headerlink" title="3.linux系统环境"></a>3.linux系统环境</h4><pre><code>默认有6个命令交互通道和一个图形界面交互通道，默认进入到的是图形界面通道
  命令交互模式切换：ctrl+alt+f1---f6
  图形交互界面 ctrl+alt+f7

1.图形界面交互模式
  - terminal： 图形界面的命令终端，它是图形界面交互通道的延伸，要依赖于图形界面
</code></pre><blockquote>
<p>扩展<br><br>Linux的目录结构：<br>1.bin：存放的可执行的二进制文件(cd ls su passwd)<br> 2. boot：存放系统的引导文件的目录<br> 3.dev 存放设备文件的目录，linux把设置当做文件来处理<br> 4.etc：存放系统的配置文件的目录<br> 5.home：存放所有用户文件的根目录，root用户除外<br> 6.lib：共享库<br> 7.usr：好比 program files 存放应用的安装的路径<br><br>8.opt：自定义存放应用程序位置<br> 9.mnt：临时文件系统的挂靠点</p>
</blockquote>
<pre><code>2.命令交互模式 
   命令提示符：
   itcast@ubuntu:~$ 
     - itcast：用户名
 - ubuntu ：主机名
 - ~ ：路径 ，假如当前的路径正好是 该用户存放数据的根目录 ，则显示~
 - $ :用户的类型  $代表普通用户  #  代表 超级用户

3.linux文件系统 

 - 目录结构
 - 文件权限分析
   w ：可写   r： 只读  x：可执行  - ：无权限
   文件权限
    1. 字符表示法
      drwxr-xr-x 第一个字符 ：文件的类型  d ：普通文件  - ：文件夹  c ：串口文件  l ：连接文件
         2-4 字符：该文件的属主用户的权限 
         5-7 字符：与属主用户同一组的其他用户的权限
         8-10 字符：不同组的其他用户的权限
     2. 数字表示法
    -rw-r--r--   ：文件的默认权限   644
    drwxr-xr-x   ： 目录的默认权限  755  
</code></pre><h4 id="4-linux的常用命令"><a href="#4-linux的常用命令" class="headerlink" title="4.linux的常用命令"></a>4.linux的常用命令</h4><pre><code>1.注销、关机、重启
  - 注销 ：logout ：登出 exit 
  - 关机 ：
     shutdown - h  时间
   - h ：关机
   - 时间 ：
     1. now :马上
     2. 12.30 ：指定具体时间
     3. 3 几分钟以后

     sudo ： superuser do ：由超级用户来执行该命令

         要配置sudo 命令 ： 授权哪些用户能执行哪些命令
         由超级用户配置  sudo 
             /etc/sudoers 
             sudo shutdown -h now  当前账号：itcast
  - 重启 ：
     shutdown -r  时间
         -r ：restart 
2.linux基本命令 ：文件操作命令

  1. ls   ： 查看目录内容
     - l ：查看详细信息
 - a ：查看所有文件（隐藏）
     man ：manual ： 手工，帮助 ，帮助命令，好比windows help 
  命令： man ls
  2. mkdir ：创建目录 
       Desktop：
     - java
       - JEE ： aa.txt  bb.txt  
       - Android
  3. cd  切换目录
     - cd ..  记得要加空格
 - cd ./java  进入当前目录的子目录
 - cd ../xxx  进入上一级目录的子目录
    tab ：自动补全
  4. touch  ：创建一个空白的普通文件
     touch aa.txt 
  5. echo  :把内容重定向到指定的文件中 ，有则打开，无则创建
  6. cat、more  ：查看文件内容
     - cat ：查看文件内容
 - more ：分页查看文件内容，按空格键换页

  7. cp、mv、rm   
     - cp ：复制
    cp bj.txt ./java/jee
 - mv ：剪切、重命名
    1. 剪切 ：mv aa.txt ../android/
    2. 重命名 ：假如剪切的文件 存放在同一个目录中 ，则是重命名
        mv bb.txt cc.txt

 - rm ：删除文件或者文件夹
   -f ： 假如要删除的文件不存在，也不提示
   -i ： 删除前提示 ，默认不删除，要删除，输入y
   -d ： 删除空白目录 
   -r ：递归删除
  8. wc ：word count ：统计字符数
      154  233 3418 
  - 154 ：行数
  - 233 ：单词数
  - 3418 ：字符数
    命令： wc bj.txt

  9. ln :创建连接文件
     - 默认创建的是硬连接，好比复制 ，但是两个文件会同步 
    命令：ln ./java/android/aa.txt  aaa
 - s ：创建的是软连接

  10. pwd   ：查看当前目录的绝对路径 

  11. 管道命令 |
    命令： ls -la | wc 
  12. 重定向
     - &gt; :覆盖模式
 命令：  echo &quot;ww&quot;&gt;aaa
 - &gt;&gt;：追加模式
 命令： echo &quot;ww&quot;&gt;&gt;aaa
  13. passwd   :设置密码  ，ubuntu默认 root账号是没有开启 ，只要设置root密码即可开启
      sudo passwd root

  14. su  切换目录
      su root 
  root用户切换到其他账号不需要密码

3.linux 系统命令
  1.stat   ：查看文件的详细信息
    stat bj.txt
  2.who与whoami
    who : 查看在线的用户
    whoami ：查看当前自己的用户
  3.hostname ： 显示主机名
    hostname
  4.uname  ：显示系统信息
     -a ：显示完整的系统信息

  5.top ：显示当前耗时的进行的信息 ，每3秒刷新一次 
      cltr+c 中断 
  6.ps ：显示当前进程的快照 
    - axu
  7.du ：显示文件的大小信息 
  8.df ：磁盘使用情况  disk free
  9.ifconfig ：查看或者配置网卡信息 ，好比windows 的ipconfig
     ipv4：32位  2-32次方     ipv6  128位     是 ipv4  2-96次方倍数
 设置虚拟机ip地址：
   1. 设置vmware的连接方式
      - 共享宿主机的ip地址，在网上邻居找不到
      - 桥接方式，需要单独设置ip，可以在网上邻居查找
   2. 图形界面设置ip地址 
       edit connection --》ipv4--》manual（手工设置）--》add  （ip地址，子网掩码）
       3.命令方式设置ip地址
      静态设置ip：
      sudo ifconfig eth0 192.168.15.122 netmask 255.255.255.0 

  10.ping  测试与目标主机连接情况

  11.clear  ： 清除屏幕  windows： cls  
  12.man  ：帮助命令
      man 命令
  13.kill  ：杀死进程
     kill  pid 
  14.netstat  ：网络连接详细信息

  15. useradd 
     - 查看用户信息
    sudo cat /etc/passwd
  itcast:x:1000:1000:UbuntuA,,,:/home/itcast:/bin/bash
   - itcast:用户名
   - x ：密码 ：已经加密 ，密码存放在  /etc/shadow 
   - 1000: 账号id ，userId
   - 1000： 组id ，group id
       - UbuntuA,,,  ：账号描述
       - /home/itcast ：该账号存放文件的默认位置  ~
   - /bin/bash：该用户的shell脚本的解析方式  ，sh 、bash、rbash

     - 创建用户 
   sudo useradd lijun -d  /home/lijun   -s /bin/bash 
    -d :指定该用户的home 路径 
    - s ：该用户的shell解析方式
   步骤：
     1. 创建 /home/lijun 目录
     2. 执行 useradd 命令
     3. 用 passwd 设置密码
     4. su 切换用户
</code></pre><h4 id="5-打包、压缩文件"><a href="#5-打包、压缩文件" class="headerlink" title="5.打包、压缩文件"></a>5.打包、压缩文件</h4><pre><code>windows ： zip、rar    
linux ：gz ，bzip，zip

 1.tar :打包、拆包命令 
    tar - cxzjvf  &lt;打包后的文件&gt;   &lt;欲打包的目录&gt;
  - c ：创建的一个归档文件 ，即打包文件夹
  - x ：拆包
  - z ：以gzip 格式压缩，默认压缩倍数 6倍  （0-9）
  - j ：以bzip2格式压缩
  - v ：显示打包或者拆包的文件信息
  - f ： 后面紧接一个 归档文件

   - 打包文件
      tar -cvf news.tar  ./java   摘要  
   - 拆包文件
      tar -xvf news.tar
 2.gzip 、bzip2 压缩与解压
    1. 压缩文件
  gzip news.tar
2. 解压文件
  gzip -d news.tar.gz
    -d :解压
 3.打包及压缩 
   - 打包及压缩
      tar -czvf news.tar.gz ./java
   - 拆包及压解缩
      tar -xzvf  news.tar.gz
</code></pre><h4 id="6-软件管理"><a href="#6-软件管理" class="headerlink" title="6.软件管理"></a>6.软件管理</h4><pre><code>windows ： .exe     安装 、卸载 
   安装：  mysql.exe  cc.exe   
   卸载 ： 该软件唯一的标识  ，包名   alibaba
android : *.apk   卸载 包名
red hat ：*.rpm 
ubuntu  : 对debian的升级  *.deb 格式


 1.安装软件
   - dpkg ：debian  package 
      离线安装：
  安装 ： sudo dpkg - i  &lt;文件名&gt; 
    -i ：install
   命令：sudo dpkg -i ./tree_1.6.0-1_i386.deb
  卸载 ： sudo dpkg - r  &lt;包名&gt; 
    -r ：remove
       命令：sudo dpkg -r tree
   - apt-get  ：advance  package  tools 
   　　对dpkg命令的升级，在线安装
  安装 ： sudo apt-get -install  &lt;包名&gt;
  卸载 ： sudo apt-get -remove  &lt;包名&gt;
 2.vim 软件  ：好比记事本 ，但是比记事本要强大  

 1. 安装vim
 2. 使用vim 
   操作模式：
     1. 一般模式 ，默认进入的一般模式，该模式不能编辑文档 ，只能查看
        按 i（insert）  进入 插入模式 
     2. 编辑模式、插入模式 
         该模式可以编辑文档，按esc 退出插入模式，进入到一般模式 
     3. 命令模式 ：在 一般模式中按：进入命令模式
        - q： 安全退出，当没有操作该文档，则直接按q退出vim 
    - q！：当修改了内容，但是不想保存，则q！强制退出
    - wq ：保存退出
    - set number 显示行号
    - set nonumber 取消行号显示
</code></pre><h4 id="7-搭建Java服务器，并且实现远程安全访问linux系统"><a href="#7-搭建Java服务器，并且实现远程安全访问linux系统" class="headerlink" title="7.搭建Java服务器，并且实现远程安全访问linux系统"></a>7.搭建Java服务器，并且实现远程安全访问linux系统</h4><pre><code>1.通过ssh实现安全远程访问linux系统 
   ssh ：secure shell(安全外壳)
     加密：
       1. 对称加密 （加密密钥与解密密钥相同）
          des 、aes 技术
       2. 非对称加密（加密密钥与解密密钥不同）
          RSA ：公钥、私钥 
 数字摘要：
    两种数字加密方式：
    md5/sha1
        md5：用于数字签名(防止抵赖、防止篡改)

   1. 查看是否安装了ssh服务端与客户端
     sudo apt-cache policy openssh-client openssh-server
   2. 安装ssh 服务端与客户端软件
      sudo dpkg -i ./ssh/*
   3. 通过windows ssh客户端来访问linux服务端
        - putty ：远程登录
        - winscp433setup.exe ：文件传输

2. 安装jdk
   进入 root用户
   实现步骤：
    1. jdk 存放在哪里  /opt
    2. 把软件拷贝到/opt
    3. 绿色软件，解压 
    4.设置环境变量
        vim /etc/profile 
        export JAVA_HOME=&quot;/opt/jdk1.6.0_39&quot;
        export PATH=&quot;$JAVA_HOME/bin:$PATH&quot;
    5. 刷新配置 ，让配置生效
       source /etc/profile
    6. 编写Demo.java,测试 
       -javac Demo.java
           - java Demo

3. 安装tomcat 
   步骤：
    1. 安装在哪里 /opt
2. 拷贝、解压
   tar -xzvf  apache-tomcat.tar.gz
3. 运行
   - ./startup.sh
   - ./shutdown.sh


4. 安装Eclipse
   步骤：
     1.安装在/opt
 2. 拷贝、解压
   cp eclipse.tar.gz  /opt
   tar -xzvf  eclipse.tar.gz
</code></pre><h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><pre><code>1.linux系统环境
   命令交互通道
   命名提示符
2. linux 目录结构、文件权限
  drwxr-xr-x
3. linux 命令
  - 开关机
  - 文件操作 
  - 系统命令
     1. top 2. who 3. ifconfig 4. ping 5. kill 6. man 7.clear 8.netstat
4. 软件管理
   - dpkg ：离线  .deb  .rpm  .apk 
   - apt-get ：在线 
5. 压缩解压
   tar -cxgzvf 打包后的文件 要打包的文件
6. vim 的使用
   三种模式
7. ssh理解 secure shell
8. java开发环境搭建
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap-学习笔记</title>
    <url>/undefined/bootstrap/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Bootstrap-包的内容"><a href="#Bootstrap-包的内容" class="headerlink" title="Bootstrap 包的内容"></a>Bootstrap 包的内容</h2><blockquote>
<p>1.基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构</p>
</blockquote>
<blockquote>
<p>2.CSS：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统</p>
</blockquote>
<blockquote>
<p>3.组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等</p>
</blockquote>
<blockquote>
<p>4.JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件</p>
</blockquote>
<blockquote>
<p>5.定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本<br><a id="more"></a><br>扩展</p>
<blockquote>
<p>meta标签中http-equiv属性<br>meta是head区的一个辅助性标签，而这个标签的作用是：搜索引擎优化(SEO)、定义页面使用语言、自动刷新并且指向新的页面。</p>
<blockquote>
<p>meta标签有两个属性：http-equiv/name属性 其中name属性用于描述网页，对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="Bootstrap-CSS"><a href="#Bootstrap-CSS" class="headerlink" title="Bootstrap CSS"></a>Bootstrap CSS</h2><h4 id="1-HTML5文档类型-doctype"><a href="#1-HTML5文档类型-doctype" class="headerlink" title="1.HTML5文档类型(doctype)"></a>1.HTML5文档类型(doctype)</h4><p>Bootstrap 使用了一些 HTML5 元素和 CSS 属性，所以为了让这些属性元素正常工作，需要使用HTML5文档类型。</p>
<pre><code>&lt;!DOCTYPE html&gt;
    &lt;html&gt;&lt;/html&gt;
</code></pre><blockquote>
<p>注意：如果在boostrap创建的页面中不使用文档类型(doctype)，页面会出现显示不一致的问题</p>
</blockquote>
<h4 id="2-移动设备优先"><a href="#2-移动设备优先" class="headerlink" title="2.移动设备优先"></a>2.移动设备优先</h4><p>为了让 Bootstrap 开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 head 之中添加<code>viewport meta</code>标签<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p>
<blockquote>
<p>1.width属性让网站能正确不同屏幕分辨率的设备上浏览显示</p>
</blockquote>
<blockquote>
<p>2.initial-scale 保证网页在加载的时候是以1:1的比例显示</p>
</blockquote>
<blockquote>
<p>注意：在移动设备浏览器上，通过为 <code>viewport meta</code> 标签添加 <code>user-scalable=no</code> 可以禁用其缩放（zooming）功能.通常情况下，参数<code>maximum-scale=1.0</code> 与 <code>user-scalable=no</code> 一起使用，禁用缩放功能，用户只能滚动屏幕进行网页查看。</p>
</blockquote>
<h4 id="3-响应式图像"><a href="#3-响应式图像" class="headerlink" title="3.响应式图像"></a>3.响应式图像</h4><p><code>&lt;img src=&quot;...&quot; class=&quot;img-responsive&quot; alt=&quot;响应式图像&quot;&gt;</code><br>通过添加 <code>img-responsive class</code> 可以让 Bootstrap 3<br>中的图像对响应式布局的支持更友好。在<code>img-responsive class</code> 中为图像设置的属性 <code>max-width: 100%;</code> 和<code>height: auto;</code> 属性，可以让图像按比例缩放，不超过其父元素的尺寸这说明了图像显示以<code>block</code>的方法，在设置元素的显示<code>display</code>为<code>block</code>时，以块级元素显示</p>
<blockquote>
<p>注意：如果需要使.img-responsive 类的图片水平居中，请使用 .center-block 类，不要用 .text-center</p>
</blockquote>
<h4 id="4-全局显示、排版和链接"><a href="#4-全局显示、排版和链接" class="headerlink" title="4.全局显示、排版和链接"></a>4.全局显示、排版和链接</h4><h5 id="1-基本的全局显示"><a href="#1-基本的全局显示" class="headerlink" title="1.基本的全局显示"></a>1.基本的全局显示</h5><p>Bootstrap 3 使用 <code>body {margin: 0;}</code> 来移除 body 的边距,一般的全局显示是<code>body{}</code>中设置，然后属性有：</p>
<pre><code>1.font-family:   //用于设置默认字体样式 
2.font-size:   //设置文本默认字体大小 
3.line-height:  //设置默认行高
4.color: //设置默认的文本颜色    
5.background-color:  //设置默认的背景颜色
</code></pre><h5 id="2-排版"><a href="#2-排版" class="headerlink" title="2.排版"></a>2.排版</h5><p>使用<code>@font-family-base</code> <code>@font-size-base</code> 和 <code>@line-height-base</code> 属性作为排版样式</p>
<h5 id="3-链接样式"><a href="#3-链接样式" class="headerlink" title="3.链接样式"></a>3.链接样式</h5><p>使用 <code>@link-color</code> 设置全局链接的颜色</p>
<pre><code>例子：
        //表示在鼠标悬停或者点击过链接时，颜色会变，然后会呈现一条下划线。然后点击过得链接还会出现样式
        a:hover,a:focus{color:#253544 text-decoration:underline}
        a:focous{outline:thin dotted #333;outline:5px auto --webkit-focus-ring-color;outline-offset: -2px;}
</code></pre><h5 id="4-避免跨浏览器的不一致"><a href="#4-避免跨浏览器的不一致" class="headerlink" title="4.避免跨浏览器的不一致"></a>4.避免跨浏览器的不一致</h5><p>Bootstrap 使用 <code>Normalize</code> 来建立跨浏览器的一致性，而 <code>Normalize.css</code> 文件是一个很小的css文件，在HTML元素默认的样式中提供更好的跨浏览器一致性</p>
<h5 id="5-容器"><a href="#5-容器" class="headerlink" title="5.容器"></a>5.容器</h5><p><code>&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code> 表示引用容器，然后再看cnotainer容器的属性：</p>
<pre><code>.container {
       padding-right: 15px;//内边距
       padding-left: 15px;
       margin-right: auto;//页边距，由浏览器决定
       margin-left: auto;
}
</code></pre><blockquote>
<p>注意：Bootstrap 3 CSS 有一个申请响应的<code>媒体查询</code>，在不同的媒体查询阈值范围内都为 <code>container</code> 设置了<code>max-width</code>，用以匹配网格系统。</p>
</blockquote>
<pre><code>@media (min-width: 768px) {
       .container {
              width: 750px;
    }
</code></pre><blockquote>
<p>注意：container与container-fluid之间的区别</p>
</blockquote>
<blockquote>
<blockquote>
<p>1.<code>container</code> 类和<code>container-fluid</code>类的区别体现在是否有随视口宽度改变的<code>margin</code>存在。<br>2.<code>container</code>类所谓的自适应也是通过<code>margin</code>的改变来完成，<code>container-fluid</code>类的百分百宽度是指在固有的<code>15px</code>的<code>padding</code>前提下宽度总是当前视口的宽度</p>
</blockquote>
</blockquote>
<h5 id="6-Bootstrap-浏览器-设备支持"><a href="#6-Bootstrap-浏览器-设备支持" class="headerlink" title="6.Bootstrap 浏览器/设备支持"></a>6.Bootstrap 浏览器/设备支持</h5><p>Bootstrap 可以在最新的桌面系统和移动端浏览器中很好的工作，然后在旧的浏览器可能无法很好的支持 bootstrap 网格系统.Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p>
<pre><code>1.网格(Grid)
    表示在网页设计过程中用于组织内容，让网站更容易浏览，降低用户端的负载

2.bootstrap的网格系统
    bootstrap3 是移动设备优先的，然后再扩展到大屏幕设备(pc端)上的组件和网格

3.移动设备优先策略
    1.内容

    2.布局
      1.优先设计更小的宽度
      2.基础的css是移动设备优先
    3.渐进增强
      随着屏幕的大小的增加而添加元素
</code></pre><blockquote>
<p>注意：响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p>
</blockquote>
<pre><code>4.bootstrap网格系统的工作原理
    网格系统通过一系列包含内容的行和列来创建页面布局

    1.行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）
    2.使用行来创建列的水平组
    3.内容应该放置在列内，且唯有列可以是行的直接子元素
    4.

5.媒体查询
    bootstrap的媒体查询允许我们基于视口大小移动、显示并隐藏内容

        /* 超小设备（手机，小于 768px） */
        /* Bootstrap 中默认情况下没有媒体查询 */

        /* 小型设备（平板电脑，768px 起） */
        @media (min-width: @screen-sm-min) { ... }

        /* 中型设备（台式电脑，992px 起） */
        @media (min-width: @screen-md-min) { ... }

        /* 大型设备（大台式电脑，1200px 起） */
        @media (min-width: @screen-lg-min) { ... }
</code></pre><blockquote>
<p>注意：有时候的媒体查询包含<code>max-width</code>，这样作用是将css的影响限制更小范围的屏幕大小之内</p>
</blockquote>
<pre><code>@media (max-width: @screen-xs-max) { ... }//限制css的影响
@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... }
@media (min-width: @screen-md-min) and (max-width: @screen-md-max) { ... }
@media (min-width: @screen-lg-min) { ... }
</code></pre><blockquote>
<p>注意：媒体查询包括：1.设备规范 2.大小规则</p>
</blockquote>
<pre><code>@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... }
表示：对于所有带有 min-width: @screen-sm-min 的设备，如果屏幕的宽度小于 @screen-sm-max，则会进行一些处理

6.网格选项
    class前缀：
        .col-xs- 表示超小设备手机（&lt;768px）    
        .col-sm- 表示小型设备平板电脑（≥768px）    
        .col-md- 表示中型设备台式电脑（≥992px）    
        .col-lg- 表示大型设备台式电脑（≥1200px）

    基本的网格选项
        案例：
            注意：
            1.`&lt;div class=&quot;container&quot;&gt;...&lt;/div&gt;` 元素被添加，确保居中和最大宽度
            2.在添加容器之后，需要考虑以行为单位，添加 `&lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;`，并在行内添加列 `&lt;div class=&quot;col-md-6&quot;&gt;&lt;/div&gt;`

            col-md-6 表示设备为中型台式设备(&gt;992px)，然后6表示一个列由六个单元组成

            3.网格中的每一行是由12个单元组成，我们可以使用这些单元定义列的尺寸，但是要确保最后的列所组成的单元的总和为12

7.响应式的列重置

    在案例中包含多个网格，在小设备浏览时无法确定网格显示的位置，所以我们可以使用 `.clearfix class` 和 `响应式实用工具` 来解决这个问题

    1.响应式使用工具：


8.偏移列

    如果希望在大屏幕显示器上使用偏移，使用 `.col-md-offset-*` 类,这些类会把一个列的左外边距（margin）增加 * 列，其中 * 范围是从 1 到 11（也就是整个列向右移*单元）

9.嵌套列

    在内容上嵌套默认的网格，需要添加一个新的 `.row` 然后在已有的 `.col-md-*` 列内添加一组 `.col-md-*` 列

10. 列排序

    我们可以以一种顺序编写列，然后以另一种顺序显示列 我们可以使用使用 `.col-md-push-*` 和 `.col-md-pull-*` 类来互换这两列的顺序
</code></pre><h2 id="Bootstrap-排版"><a href="#Bootstrap-排版" class="headerlink" title="Bootstrap 排版"></a>Bootstrap 排版</h2><pre><code>1.标题
    在bootstrap定义了所有的HTML标题(h1-h6)样式

2.
</code></pre><h2 id="Bootstrap-代码"><a href="#Bootstrap-代码" class="headerlink" title="Bootstrap 代码"></a>Bootstrap 代码</h2><p>Bootstrap 允许我们以两种方式显示代码：</p>
<pre><code>1.使用&lt;code&gt;标签，如果需要内联显示代码，那么需要使用&lt;code&gt;标签
2.使用&lt;pre&gt;标签，如果代码需要被显示为一个独立的块元素或者代码有多行，需要使用&lt;pre&gt;标签
</code></pre><blockquote>
<p>注意：当我们确认是使用<code>&lt;pre&gt;</code>标签还是<code>&lt;code&gt;</code>标签，我们在开始以及结束需要使用：<code>&amp;lt;</code>和 <code>&amp;gt;</code> 表示 &lt; 与 &gt;</p>
</blockquote>
<pre><code>&lt;var&gt; 表示变量显示
&lt;kbd&gt; 表示强调字体高亮
&lt;pre&gt; 表示多行代码
&lt;pre class=&quot;pre-scrollable&quot;&gt; 表示多行代码且带有滚动条
&lt;samp&gt; 表示一种样式，电脑输出
&lt;code&gt; 表示代码高亮，突出显示
</code></pre><h2 id="Bootstrap-表格"><a href="#Bootstrap-表格" class="headerlink" title="Bootstrap 表格"></a>Bootstrap 表格</h2><p>bootstrap提供给我们一个清晰的创建表格的布局</p>
<pre><code>&lt;table&gt;    为表格添加基础样式
&lt;thead&gt;    表格标题行的容器元素（&lt;tr&gt;），用来标识表格列
&lt;tbody&gt;    表格主体中的表格行的容器元素（&lt;tr&gt;）
&lt;tr&gt; 行
&lt;td&gt; 表格单元格
&lt;th&gt; 必须在&lt;thead&gt;中使用，用来表示列或行，特殊的表格单元格
&lt;caption&gt; 关于表格存储内容的描述或总结 备注

1.表格类

    .table 为任意 `&lt;table&gt;` 添加基本样式 (只有横向分隔线)
    .table-striped    在 `&lt;tbody&gt;` 内添加斑马线形式的条纹 ( IE8 不支持)
    .table-bordered    为所有表格的单元格添加边框
    .table-hover 在 &lt;tbody&gt; 内的任一行启用鼠标悬停状态
    .table-condensed 让表格更加紧凑

2.&lt;tr&gt;, &lt;th&gt; 和 &lt;td&gt; 类

    .active    将悬停的颜色应用在行或者单元格上
    .success 表示成功的操作
    .info 表示信息变化的操作 就是改变了行的背景色
    .warning 表示一个警告的操作
    .danger    表示一个危险的操作

3.基本的表格


4.可选的表格类


5.响应式表格

    通过把任意的 .table 包在 .table-responsive class 内，我们可以让表格水平滚动以适应小型设备（小于 768px）。当在大于 768px 宽的大型设备上查看时，将看不到任何的差别。
</code></pre><blockquote>
<p>扩展</p>
<blockquote>
<p>HTML属性hidden：该属性表示隐藏，是布尔属性，浏览器不显示已规定的hidden属性的元素，防止用户查看元素</p>
</blockquote>
</blockquote>
<h2 id="Bootstrap-表单"><a href="#Bootstrap-表单" class="headerlink" title="Bootstrap 表单"></a>Bootstrap 表单</h2><pre><code>1.表单布局
    1.垂直表单(默认)
    2.内联表单
    3.水平表单

2.垂直或基本表单

    基本的表单借结构是bootstrap自带的，个别的表单空间自动接收全局样式

    创建基本表单的步骤：
        1.向父&lt;form&gt;元素添加role=&quot;form&quot;  &lt;form role=&quot;form&quot;&gt;
        2.将标签和控制放在一个带有 class .form-group 的 &lt;div&gt; 中。这是获取最佳间距所必需的  &lt;div class=&quot;form-group&quot;&gt;
        3.向所有的文本元素 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 添加 class =&quot;form-control&quot;   &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; placeholder=&quot;请输入名称&quot;&gt;

3.内联表单

    如果需要创建一个表单，它的所有元素是内联的，向左对齐的，标签是并排的，需要向&lt;form&gt;标签添加`class.form-inline`  如：&lt;form class=&quot;form-inline&quot; role=&quot;form&quot;&gt;

    注意：1.默认情况下，Bootstrap 中的 input、select 和 textarea 标签有 100% 宽度。所以在使用内联表单时，需要在表单控件上设置一个宽度
          2.使用class .sr-only，可以隐藏内联表单的标签

4.水平表单

    水平表单与其他表单不仅标记的数量上不同，而且表单的呈现形式也不同。

    创建一个水平布局的表单步骤：
        1.向父 &lt;form&gt; 元素添加 class .form-horizontal      
        如：`&lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot;&gt;`

        2.把标签和控件放在一个带有 `class .form-group` 的 &lt;div&gt; 中
        如：`&lt;div class=&quot;form-group&quot;&gt;`

        3.向标签添加 class .control-label    
        如：&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;firstname&quot; placeholder=&quot;请输入名字&quot;&gt;

5.支持的表单控件

    bootstrap支持最常见的表单控件，主要是 input、textarea、checkbox、radio 和 select

    1.输入框（Input）

        &lt;input type=&quot;hidden&quot; value=&quot;${grade}&quot; id=&quot;slected-grade&quot;&gt;
        这段程序表示：隐藏域在页面中对于用户不可见，在表单中插入隐藏域的目的在于搜集或发送信息，以利于被处理表单的程序所使用。虽然在页面中隐藏了，但是还是具有form传值功能。

    2.文本框（Textarea）

    3.复选框（Checkbox）和单选框（Radio）
        注意：对一系列复选框和单选框使用 .checkbox-inline 或 .radio-inline class，控制它们显示在同一行上

    5.选择框（Select）
        注意：1.使用&lt;select&gt;标签展示列表选项，通常是那些用户很熟悉的选择列表 2.使用 multiple=&quot;multiple&quot; 允许用户选择多个选项

    6.静态控件
        需要在一个水平表单内的表单标签后放置纯文本时，请在 &lt;p&gt; 上使用 class .form-control-static

    7.表单控件状态


    8.表单控件大小
        分别用 class.input-lg 和.col-lg-* 来设置表单的高度和宽度

    9.表单帮助文本
        bootstrap表单控件可以在输入框input上有一个块级帮助文本。如果要添加一个占用整个宽度的内容块，需要在&lt;input&gt;之后使用.help-block   如：&lt;span class=&quot;help-block&quot;&gt;&lt;/span&gt;
</code></pre><h2 id="Bootstrap-按钮"><a href="#Bootstrap-按钮" class="headerlink" title="Bootstrap 按钮"></a>Bootstrap 按钮</h2><p>任何带有 <code>class .btn</code> 的元素都会继承圆角灰色按钮的默认外观。但是 Bootstrap 提供了一些选项来定义按钮的样式，同时这些样式还能够用于<code>&lt;a&gt; &lt;button&gt;</code> 或 <code>&lt;input&gt;</code> 元素。</p>
<p>如果一个按钮有多个属性，需要在class中将所有的属性都加上</p>
<pre><code>设置按钮的颜色
    .btn 为按钮添加基本样式
    .btn-default 默认/标准按钮
    .btn-primary 原始按钮样式（未被操作)
    .btn-success 表示成功的动作
    .btn-info 该样式可用于要弹出信息的按钮
    .btn-warning 表示需要谨慎操作的按钮
    .btn-danger 表示一个危险动作的按钮操作
    .btn-link 让按钮看起来像个链接 (仍然保留按钮行为)
    .btn-lg    制作一个大按钮
    .btn-sm    制作一个小按钮
    .btn-xs    制作一个超小按钮
    .btn-block 块级按钮(拉伸至父元素100%的宽度)
    .active    按钮被点击
    .disabled 禁用按钮

    class=&quot;btn btn-primary&quot; 原始按钮
</code></pre><h5 id="1-按钮状态"><a href="#1-按钮状态" class="headerlink" title="1.按钮状态"></a>1.按钮状态</h5><p>bootstrap提供激活、禁用等按钮状态class</p>
<p>1.激活状态：按钮在被激活时将会呈现被按压状态，使用<code>.active class</code> 来显示它是激活的。</p>
<p>2.禁用状态：一个按钮被禁用时，它的颜色会变淡50%，失去渐变 将<code>disabled</code>属性添加到<code>&lt;button&gt;</code>按钮实现禁用。</p>
<h2 id="Bootstrap-图片"><a href="#Bootstrap-图片" class="headerlink" title="Bootstrap 图片"></a>Bootstrap 图片</h2><p>Bootstrap 提供了三个可对图片应用简单样式的 class :</p>
<pre><code>1. .img-rounded：添加 border-radius:6px 来获得图片圆角
2. .img-circle：添加 border-radius:50% 来让整个图片变成圆形
3. .img-thumbnail：添加一些内边距（padding）和一个灰色的边框
</code></pre><h5 id="1-lt-img-gt-类"><a href="#1-lt-img-gt-类" class="headerlink" title="1.&lt;img&gt; 类"></a>1.<code>&lt;img&gt;</code> 类</h5><pre><code>.img-rounded 为图片添加圆角 (IE8 不支持)
.img-circle 将图片变为圆形 (IE8 不支持)
.img-thumbnail 缩略图功能
.img-responsive    图片响应式 (将很好地扩展到父元素)    
</code></pre><h5 id="2-响应式图片"><a href="#2-响应式图片" class="headerlink" title="2.响应式图片"></a>2.响应式图片</h5><p>通过在 <code>&lt;img&gt;</code> 标签添加 <code>.img-responsive</code> 类来让图片支持响应式设计，图片将很好地扩展到父元素。<code>.img-responsive</code> 类将 <code>max-width: 100%;</code> 和 <code>height: auto;</code> 样式应用在图片上。<br>    如：<br>        <img src="cinqueterre.jpg" class="img-responsive" alt="Cinque Terre"></p>
<h2 id="Bootstrap-辅助类"><a href="#Bootstrap-辅助类" class="headerlink" title="Bootstrap 辅助类"></a>Bootstrap 辅助类</h2><h5 id="1-文本"><a href="#1-文本" class="headerlink" title="1.文本"></a>1.文本</h5><p>不同的类展示了不同的文本颜色，如果文本是个链接鼠标移动到上面文本将会变暗</p>
<pre><code>.text-muted
.text-primary
</code></pre><h5 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h5><p>不同的类展示不同的背景颜色，如果文本是个链接，鼠标移动到文本上文本会变暗</p>
<pre><code>.bg-primary
.bg-success
.bg-info
.bg-warning
</code></pre><h5 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h5><pre><code>.pull-left 元素浮动到左边

.pull-right 元素浮动到右边

.center-block 设置元素为 display:block
    并居中显示(设置显示为块，并且居中显示)

.clearfix 清除浮动

.show 强制元素显示

.hidden    强制元素隐藏

.sr-only 除了屏幕阅读器外，其他设备上隐藏元素

.sr-only-focusable 与 .sr-only 类结合使用，在元素获取焦点时显示(如：键盘操作的用户)

.text-hide 将页面元素所包含的文本内容替换为背景图

.close 显示关闭按钮 只是一个标识

.caret 显示下拉式功能 一个标识
</code></pre><h5 id="4-更多"><a href="#4-更多" class="headerlink" title="4.更多"></a>4.更多</h5><p>内容居中：使用 <code>class center-block</code> 来居中元素</p>
<h2 id="Bootstrap-响应式实用工具"><a href="#Bootstrap-响应式实用工具" class="headerlink" title="Bootstrap 响应式实用工具"></a>Bootstrap 响应式实用工具</h2><p>bootstrap提供一些辅助类，通过媒体查询结合大型、中型和小型设备，实现内容对设备的显示和隐藏。</p>
<h2 id="Bootstrap-字体图标Glyphicons"><a href="#Bootstrap-字体图标Glyphicons" class="headerlink" title="Bootstrap 字体图标Glyphicons"></a>Bootstrap 字体图标<code>Glyphicons</code></h2><p>Bootstrap 捆绑了 200 多种字体格式的字形，字体图标是在WEB项目中使用的图标字体</p>
<pre><code>1.获取字体图标

2.使用方法

    如果需要使用图标，只需要使用代码： &lt;span class=&quot;glyphicon glyphicon-search&quot;&gt;&lt;/span&gt; 此外，还需要在文本和图标之间保持适当的空间

3.定制字体图标(只需要在所应用的类中标注class的属性即可)

    开始：

    &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;
          &lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt; User
    &lt;/button&gt;

    1.定制字体尺寸
        可以通过增加或减少图标的字体尺寸让图标看起来更大或更小
        在原先的基础上加上属性：style=&quot;font-size:90px&quot;

    2.定制字体颜色
        在原先的基础上加上属性：style=&quot;color:rgb(212,106,64);&quot;

    3.应用文本阴影
        在原先的基础上加上属性：style=&quot;text-shadow:black 5px 3px 3px;&quot;
</code></pre><h2 id="Bootstrap-下拉菜单（Dropdowns）"><a href="#Bootstrap-下拉菜单（Dropdowns）" class="headerlink" title="Bootstrap 下拉菜单（Dropdowns）"></a>Bootstrap 下拉菜单（Dropdowns）</h2><p>下拉菜单是可切换的，是以列表格式显示链接的上下文菜单<br>如果需要使用下拉菜单，在 <code>class .dropdown</code> 内加上下拉菜单即可。</p>
<h5 id="2-更多"><a href="#2-更多" class="headerlink" title="2.更多"></a>2.更多</h5><pre><code>.dropdown 指定下拉菜单，下拉菜单都包裹在 .dropdown 里

.dropdown-menu 创建下拉菜单    

.dropdown-menu-right 下拉菜单右对齐    

.dropdown-header 下拉菜单中添加标题

.dropup    指定向上弹出的下拉菜单

.disabled 下拉菜单中的禁用项

.divider 下拉菜单中的分割线
</code></pre><h2 id="Bootstrap-按钮组"><a href="#Bootstrap-按钮组" class="headerlink" title="Bootstrap 按钮组"></a>Bootstrap 按钮组</h2><p>按钮组允许多个按钮被叠放在同一行里</p>
<blockquote>
<p>按钮组中的重要类：</p>
</blockquote>
<pre><code>.btn-group 形成基本按钮组，在其中放置一系列带有 class.btn 的按钮

.btn-toolbar 将几组 .btn-group 结合到一个&lt;div&gt;中，获得更复杂的组件

.btn-group-lg  .btn-group-sm  .btn-group-xs 用于对按钮组的大小调整

.btn-group-vertical 让一组按钮垂直堆叠显示，不是水平堆叠显示

class=&quot;btn-group-xs&quot; btn-group-sm btn-group-lg 按钮组从小到大的显示
</code></pre><h2 id="Bootstrap-按钮下拉菜单"><a href="#Bootstrap-按钮下拉菜单" class="headerlink" title="Bootstrap 按钮下拉菜单"></a>Bootstrap 按钮下拉菜单</h2><p>如果需要向按钮中添加下拉菜单，只需要简单的在一个<code>.btn-group</code> 中放置按钮和下拉菜单即可。此外，也可以使用 <code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code> 来指示按钮作为下拉菜单</p>
<pre><code>1.分割的按钮下拉菜单
    按钮左边是原始的功能，右边显示下拉菜单的切换

2.按钮下拉菜单的大小

3.按钮上拉菜单
    在父  .btn-group 容器添加 .dropup 即可
</code></pre><h2 id="Bootstrap-输入框组"><a href="#Bootstrap-输入框组" class="headerlink" title="Bootstrap 输入框组"></a>Bootstrap 输入框组</h2><p>使用输入框组，可以很容易地向基于文本的输入框添加作为前缀和后缀的文本或按钮<br>通过向输入域添加前缀和后缀的内容，可以向用户输入添加公共的元素。例如，可以添加美元符号，或者应用程序接口所需要的其他公共的元素。</p>
<pre><code>向 .form-control 添加前缀或后缀元素的步骤：
    1.把前缀或后缀元素放在一个带有 class .input-group 的 &lt;div&gt; 中
    2.在相同的 &lt;div&gt; 内，在 class 为 .input-group-addon 的 &lt;span&gt; 内放置额外的内容
    3.把该 &lt;span&gt; 放置在 &lt;input&gt; 元素的前面或者后面

    如：
        &lt;div style=&quot;padding: 100px 100px 10px;&quot;&gt;
                &lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt;
                    &lt;div class=&quot;input-group&quot;&gt;
                            &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt;    //将其放在前面
                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;twitterhandle&quot;&gt;
                    &lt;/div&gt;
</code></pre><h5 id="2-输入框组大小"><a href="#2-输入框组大小" class="headerlink" title="2.输入框组大小"></a>2.输入框组大小</h5><pre><code>可以通过向 .input-group 添加相对表单大小的 class（比如 .input-group-lg、input-group-sm）来改变输入框组的大小
</code></pre><h5 id="3-复选框和单选插件"><a href="#3-复选框和单选插件" class="headerlink" title="3.复选框和单选插件"></a>3.复选框和单选插件</h5><pre><code>我们可以将复选框和单选插件作为输入框组的前缀或者后缀元素
</code></pre><h5 id="4-按钮插件"><a href="#4-按钮插件" class="headerlink" title="4.按钮插件"></a>4.按钮插件</h5><pre><code>将按钮作为输入框组的前缀或者后缀元素，这时不是添加 .input-group-addon class，而是需要使用 class .input-group-btn 来包裹按钮。注意：这是必需的，因为默认的浏览器样式不会被重写
</code></pre><h5 id="5-带下拉菜单的按钮"><a href="#5-带下拉菜单的按钮" class="headerlink" title="5.带下拉菜单的按钮"></a>5.带下拉菜单的按钮</h5><pre><code>输入框组添加带有下拉菜单的按钮，只需要在 .input-group-btn class 中包裹按钮和下拉菜单即可
</code></pre><h2 id="Bootstrap-导航元素"><a href="#Bootstrap-导航元素" class="headerlink" title="Bootstrap 导航元素"></a>Bootstrap 导航元素</h2><p>使用相同的标记和基类 <code>.nav</code></p>
<pre><code>1.表格导航或标签

    步骤：

    1.创建一个带有 class .nav 的无序列表
    2.添加 class .nav-tabs

2.胶囊式的导航菜单

    1.基本的导航菜单

        如果需要把标签改成胶囊的样式，只需要使用 class .nav-pills 代替 .nav-tabs 即可，创建步骤与上面相同

        步骤：        

        1.引入文件
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;  
        &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;

        2.编写导航栏，active 表示默认此
        3.在class一栏有 class=&quot;nav nav-pills&quot; 胶囊状的导航菜单

            &lt;p&gt;基本的胶囊式导航菜单&lt;/p&gt;
            &lt;ul class=&quot;nav nav-pills&quot;&gt;
                  &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;

    2.垂直的胶囊式导航菜单

        在使用class .nav .nav-pills 的同时使用 class .nav-stacked，让胶囊垂直堆叠 在上面例子中加入class=&quot;nav nav-pills nav-stacked&quot;

    3.两端对齐的导航

        通过使用 .nav、.nav-tabs 或 .nav、.nav-pills 的同时使用 class .nav-justified，让标签式或胶囊式导航菜单与父元素等宽 

    4.禁用连接

        对于每个 .nav class 如果添加.disabled class 则会创建一个灰色的链接，同时禁用该链接的 :hover 状态

    5.下拉菜单

        默认情况下，列表项的锚与一些数据属性协同合作来触发带有 .dropdown-menu class 的无序列表

        带有下拉菜单的标签

        步骤：
            1.以一个带有 class .nav 的无序列表开始
            2.添加 class .nav-tabs
            3.添加带有 .dropdown-menu class 的无序列表

        1.带有下拉菜单的胶囊

            步骤与创建带有下拉菜单的标签相同，只是需要把 .nav-tabs class 改为 .nav-pills

    6.更多
        标签页与胶囊标签页

            .tab-content 与 .tab-pane 和 data-toggle=&quot;tab&quot; (data-toggle=&quot;pill&quot; ) 一同使用, 设置标签页对应的内容随标签的切换而更改

            .tab-pane 与 .tab-content 和 data-toggle=&quot;tab&quot; (data-toggle=&quot;pill&quot;)一同使用, 设置标签页对应的内容随标签的切换而更改
</code></pre><h2 id="Bootstrap-导航栏"><a href="#Bootstrap-导航栏" class="headerlink" title="Bootstrap 导航栏"></a>Bootstrap 导航栏</h2><h5 id="1-默认导航栏创建步骤："><a href="#1-默认导航栏创建步骤：" class="headerlink" title="1.默认导航栏创建步骤："></a>1.默认导航栏创建步骤：</h5><pre><code>1.向 &lt;nav&gt; 标签添加 class .navbar、.navbar-default
2.向上面的元素添加 role=&quot;navigation&quot;，有助于增加可访问性
3.向 &lt;div&gt; 元素添加一个标题 class .navbar-header，内部包含了带有 class navbar-brand 的 &lt;a&gt; 元素。这会让文本看起来更大一号。
4.为了向导航栏添加链接，只需要简单地添加带有 class .nav、.navbar-nav 的无序列表即可
</code></pre><h5 id="2-响应式的导航栏"><a href="#2-响应式的导航栏" class="headerlink" title="2.响应式的导航栏"></a>2.响应式的导航栏</h5><p>给导航栏添加响应特性，要折叠的内容必须包裹在带有<code>class .collapse</code>、<code>.navbar-collapse</code> 的 <code>&lt;div&gt;</code> 中，折叠起来的导航栏实际是一个带有 <code>class .navbar-toggle</code> 及两个 <code>data-</code> 元素的按钮。第一个是 <code>data-toggle</code>，用于告诉 <code>JavaScript</code> 需要对按钮做什么，第二个是 <code>data-target</code>，指示要切换到哪一个元素。三个带有 <code>class .icon-bar</code> 的 <code>&lt;span&gt;</code> 创建所谓的汉堡按钮。这些会切换为 <code>.nav-collapse</code> <code>&lt;div&gt;</code> 中的元素。为了实现以上这些功能，您必须包含 Bootstrap 折叠<code>（Collapse）</code>插件</p>
<h5 id="3-导航栏的表单"><a href="#3-导航栏的表单" class="headerlink" title="3.导航栏的表单"></a>3.导航栏的表单</h5><p>使用 <code>class .navbar-form</code> 以至于能够确保表单适当的垂直对齐和在较窄的视口中折叠的行为，使用对齐方式来决定导航栏中的内容放置在哪。</p>
<h5 id="4-导航栏中的按钮"><a href="#4-导航栏中的按钮" class="headerlink" title="4.导航栏中的按钮"></a>4.导航栏中的按钮</h5><p>使用 <code>class .navbar-btn</code> 向不在<code>&lt;form&gt;</code>中的<code>&lt;button&gt;</code>元素添加按钮，按钮在导航栏上垂直居中。<code>.navbar-btn</code> 可被使用在 <code>&lt;a&gt;</code> 和 <code>&lt;input&gt;</code> 元素上</p>
<blockquote>
<p>注意：不要在 <code>.navbar-nav</code> 内的 <code>&lt;a&gt;</code> 元素上使用 <code>.navbar-btn</code>，因为它不是标准的 button class。</p>
</blockquote>
<h5 id="5-导航栏中的文本"><a href="#5-导航栏中的文本" class="headerlink" title="5.导航栏中的文本"></a>5.导航栏中的文本</h5><p>如果导航栏中需要包含文本字符串，使用 <code>class .navbar-text</code> 这通常与 <code>&lt;p&gt;</code> 标签一起使用，确保适当的前导和颜色。</p>
<h5 id="6-结合图标的导航链接"><a href="#6-结合图标的导航链接" class="headerlink" title="6.结合图标的导航链接"></a>6.结合图标的导航链接</h5><p>如果需要在常规的导航栏导航组件中使用图标，使用  <code>class glyphicon glyphicon-*</code> 来设置图标。</p>
<h5 id="7-组件的对齐方式"><a href="#7-组件的对齐方式" class="headerlink" title="7.组件的对齐方式"></a>7.组件的对齐方式</h5><p>使用实用工具 <code>class .navbar-left</code> 或 <code>.navbar-right</code> 向左或向右对齐导航栏中的 导航链接、表单、按钮或文本 这些组件。</p>
<h5 id="8-固定到顶部"><a href="#8-固定到顶部" class="headerlink" title="8.固定到顶部"></a>8.固定到顶部</h5><p>如果需要将导航栏固定在页面的顶端，在 <code>.navbar class</code> 添加 <code>class .navbar-fixed-top</code>    </p>
<blockquote>
<p>注意：放置导航栏与主体页面主体中的其他内容的顶部交错，在<code>&lt;body&gt;</code>标签中添加至少50px的内边距<code>(padding)</code>视情况而定。</p>
</blockquote>
<h5 id="9-固定到底部"><a href="#9-固定到底部" class="headerlink" title="9.固定到底部"></a>9.固定到底部</h5><p>向 <code>.navbar class</code> 添加 <code>class .navbar-fixed-bottom</code></p>
<h5 id="10-静态的顶部"><a href="#10-静态的顶部" class="headerlink" title="10.静态的顶部"></a>10.静态的顶部</h5><p>如果需要创建能够随着页面一起滚动的导航栏，添加<code>.navbar-static-top class</code>。该 class 不要求向 <code>&lt;body&gt;</code> 添加内边距<code>（padding）</code></p>
<h5 id="11-反色的导航栏"><a href="#11-反色的导航栏" class="headerlink" title="11.反色的导航栏"></a>11.反色的导航栏</h5><p>创建一个带有黑色背景白色文本的反色导航栏，向 <code>.navbar class</code> 添加 <code>.navbar-inverse class</code> 即可</p>
<blockquote>
<p>注意：为了防止导航栏与页面主体中的其他内容的顶部相交错，向<body>标签添加至少50px的内边距(padding) 内边距值视情况而定</body></p>
</blockquote>
<h2 id="Bootstrap-面包屑导航（Breadcrumbs）"><a href="#Bootstrap-面包屑导航（Breadcrumbs）" class="headerlink" title="Bootstrap 面包屑导航（Breadcrumbs）"></a>Bootstrap 面包屑导航（Breadcrumbs）</h2><p>面包屑导航（Breadcrumbs）是一种基于网站层次信息的显示方式。以博客为例，面包屑导航可以显示发布日期、类别或标签。它们表示当前页面在导航层次结构内的位置。</p>
<p>Bootstrap 中的面包屑导航（Breadcrumbs）是一个简单的带有 <code>.breadcrumb class</code> 的无序列表(只需要在使用的时候在class中加上class=”breadcrumb”)</p>
<h2 id="Bootstrap-分页"><a href="#Bootstrap-分页" class="headerlink" title="Bootstrap 分页"></a>Bootstrap 分页</h2><p>分页（Pagination），是一种无序列表，Bootstrap 像处理其他界面元素一样处理分页</p>
<pre><code>1.分页

    .pagination 添加该 class 来在页面上显示分页
    .disabled  .active 我们可以自定义链接，通过使用 .disabled 来定义不可点击的链接，通过使用 .active 来指示当前的页面
    pagination-lg, .pagination-sm 使用这些 class 来获取不同大小的项

2.默认的分页

    在class属性为pagination 表示默认的分页功能

3.分页的状态

    class属性为disabled/active

4.分页的大小

    表示 pagination-* 的用法 class   大：pagination-lg  中：pagination   小：pagination-sm

5.翻页

    如果需要创建一个简单的分页链接为用户提供导航，可以通过翻页来实现

    .pager 添加该 class 来获得翻页链接

    .previous  .next 使用 class .previous 把链接向左对齐，使用 .next 把链接向右对齐

    .disabled 添加该 class 来设置对应按钮禁止使用


6.对齐的链接

    .previous  .next
</code></pre><h2 id="Bootstrap-标签"><a href="#Bootstrap-标签" class="headerlink" title="Bootstrap 标签"></a>Bootstrap 标签</h2><p>标签可用于计数、提示或页面上其他的标记显示，使用 <code>class .label</code> 来显示标签。<br>我们可以使用修饰的<code>class   label-default/label-primary/label-success/label-info/label-warning/label-danger</code> 来改变标签的外观</p>
<pre><code>label-default 默认灰色标签
label-primary 蓝色标签
label-warning 黄色标签
</code></pre><h2 id="Bootstrap-徽章（Badges）"><a href="#Bootstrap-徽章（Badges）" class="headerlink" title="Bootstrap 徽章（Badges）"></a>Bootstrap 徽章（Badges）</h2><p>徽章与标签相似，主要的区别在于徽章的边角更加圆滑。徽章（Badges）主要用于突出显示新的或未读的项。如需使用徽章，只需要把<code>&lt;span class=&quot;badge&quot;&gt;</code> 添加到链接、Bootstrap 导航等这些元素上即可。</p>
<h5 id="1-激活导航状态"><a href="#1-激活导航状态" class="headerlink" title="1.激活导航状态"></a>1.激活导航状态</h5><p>可以在激活状态的胶囊导航和列表导航中放置徽章，通过使用<code>&lt;span class=&quot;badge&quot;&gt;</code> 来激活链接。</p>
<h2 id="Bootstrap-超大屏幕（Jumbotron）"><a href="#Bootstrap-超大屏幕（Jumbotron）" class="headerlink" title="Bootstrap 超大屏幕（Jumbotron）"></a>Bootstrap 超大屏幕（Jumbotron）</h2><p>该组件可以增加标题的大小，并且为登录页面内容添加更多的外边距(margin)</p>
<pre><code>步骤：
    1.创建一个带有 class .jumbotron 的容器 &lt;div&gt;
    2.除了更大的 &lt;h1&gt;，字体粗细 font-weight 被减为 200
</code></pre><blockquote>
<p>注意：为了获得占用全部宽度且不带圆角的超大屏幕，需要在 <code>.container class</code> 外使用 <code>.jumbotron class</code></p>
</blockquote>
<h2 id="Bootstrap-页面标题（Page-Header）"><a href="#Bootstrap-页面标题（Page-Header）" class="headerlink" title="Bootstrap 页面标题（Page Header）"></a>Bootstrap 页面标题（Page Header）</h2><p>它会在网页标题四周添加适当的间距，当一个网页中有多个标题且每个标题之间需要添加一定的间距时，这个功能就有很强的作用。如果需要使用页面标题这个功能，我们需要将我们的标题放在带有 <code>class .page-header</code> 的<code>&lt;div&gt;</code>中</p>
<h2 id="Bootstrap-缩略图"><a href="#Bootstrap-缩略图" class="headerlink" title="Bootstrap 缩略图"></a>Bootstrap 缩略图</h2><pre><code>使用bootstrap创建缩略图步骤：

    1.在图像周围添加带有 class .thumbnail 的 &lt;a&gt; 标签

    2.这会添加四个像素的内边距(padding)和一个灰色的边框 特点

    3.当鼠标悬停在图像上时，会动画显示出图像的轮廓 结果

1.添加自定义的内容

    我们有一个基本缩略图，我们可以向缩略图中添加各种HTML内容(标题、段落、按钮)

    步骤：
        1.把带有 class .thumbnail 的 &lt;a&gt; 标签改为 &lt;div&gt;

        2.在该 &lt;div&gt; 内，您可以添加任何您想要添加的东西。由于这是一个 &lt;div&gt;，我们可以使用默认的基于 span 的命名规则来调整大小

        3.如果需要给多个图像进行分组，请把它们放置在一个无序列表中，且每个列表项向左浮动
</code></pre><h2 id="Bootstrap-警告（Alerts）"><a href="#Bootstrap-警告（Alerts）" class="headerlink" title="Bootstrap 警告（Alerts）"></a>Bootstrap 警告（Alerts）</h2><p>我们可以通过创建一个<div> 并向其中添加一个 .alert class 和四个上下文 class（即 .alert-success、.alert-info、.alert-warning、.alert-danger）之一，来添加一个基本的警告框</div></p>
<pre><code>1.可取消的警告(dismissal Alert)

    创建步骤：
        1.通过创建一个&lt;div&gt; 同时向其中添加一个 .alert class 和四个上下文 class（即 .alert-success、.alert-info、.alert-warning、.alert-danger）之一，来添加一个基本的警告框

        2.在上面的&lt;div&gt; class 添加可选的 .alert-dismissable

        3.添加一个关闭按钮
2.警告中的链接

    在上面的例子中成功添加好一个警告框之后，然后使用 .alert-link 实体类来快速提供带有匹配颜色的链接
</code></pre><h2 id="Bootstrap-进度条"><a href="#Bootstrap-进度条" class="headerlink" title="Bootstrap 进度条"></a>Bootstrap 进度条</h2><blockquote>
<p>注意：Bootstrap 进度条使用 CSS3 过渡和动画来获得该效果。Internet Explorer 9 及之前的版本和旧版的 Firefox 不支持该特性，Opera 12 不支持动画。</p>
</blockquote>
<pre><code>1.默认的进度条

    步骤：
        1.添加一个带有class.progress的&lt;div&gt;
        2.在上面创建好了的&lt;div&gt;中添加一个带有 class.progress-bar 的空的&lt;/div&gt;
        3.添加一个带有百分比表示的宽度的style属性。如：style=&quot;width:60%&quot;;表示进度条在60%的位置

2.交替的进度条

    步骤：
        1.添加带有 class.progress的&lt;div&gt;
        2.在已经建好的&lt;div&gt;中添加 class.progress-bar和class.progress-bar-*的空的&lt;div&gt; 其中，*可以是：success/info/warning/danger
        3.添加一个带有百分比表示的宽度的style属性。如：style=&quot;60%&quot;;用来表示进度条的位置

3.条纹进度条

    步骤：
        1.添加一个带有 class .progress 和 .progress-striped 的 &lt;div&gt;

            &lt;div class=&quot;progress progress-striped&quot;&gt;

        2.在上面的 &lt;div&gt; 内，添加一个带有 class .progress-bar 和 class progress-bar-* 的空的 &lt;div&gt;。
          其中，* 可以是 success、info、warning、danger。

            div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot;

        3.添加一个带有百分比表示的宽度的 style 属性，例如 style=&quot;60%&quot;; 表示进度条在 60% 的位置

4.动画进度条

步骤：

    1.添加一个带有 class .progress 和 .progress-striped 的 &lt;div&gt;。同时添加 class .active

        &lt;div class=&quot;progress progress-striped active&quot;&gt;

    2.然后在上面的 &lt;div&gt; 内，添加一个带有 class .progress-bar 的空的 &lt;div&gt;

        &lt;div class=&quot;progress-bar progress-bar-success&quot;

    3.添加一个带有百分比表示的宽度的 style 属性，例如 style=&quot;60%&quot;; 表示进度条在 60% 的位置。

         style=&quot;width: 40%;&quot;&gt; //这将会使条纹具有从右向左的运动感。

5.堆叠的进度条

    将多个进度条放在相同的 .progress 中即可实现堆叠 &lt;div class=&quot;progress&quot;&gt;
</code></pre><h2 id="Bootstrap-多媒体对象（Media-Object）"><a href="#Bootstrap-多媒体对象（Media-Object）" class="headerlink" title="Bootstrap 多媒体对象（Media Object）"></a>Bootstrap 多媒体对象（Media Object）</h2><p><code>.media</code>：该 class 允许将媒体对象里的多媒体（图像、视频、音频）浮动到内容区块的左边或者右边</p>
<p><code>.media-list</code>：如果你需要一个列表，各项内容是无序列表的一部分，可以使用该 class。可用于评论列表与文章列表</p>
<h2 id="Bootstrap-列表组"><a href="#Bootstrap-列表组" class="headerlink" title="Bootstrap 列表组"></a>Bootstrap 列表组</h2><p>列表组件用于以列表的形式呈现复杂的和自定义的内容</p>
<pre><code>创建步骤：
    1.向元素&lt;ul&gt;中添加 class .list-group
    2.向&lt;li&gt;添加 class .list-group-item

1.向列表组添加徽章

    我们可以向任意的列表项中添加徽章组件，其会自动定义到右边，我们只需要在&lt;li&gt;元素中添加&lt;span class=&quot;badge&quot;&gt;即可

2.向列表组添加链接

    通过使用锚点标签代替列表项，我们可以向列表组添加链接 通过添加&lt;a&gt;标签

3.向列表组添加自定义内容

    表示此后为列表组：&lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;
    添加一标题：&lt;h4 class=&quot;list-group-item-heading&quot;&gt;24*7 支持&lt;/h4&gt;
    添加一个段落：&lt;p class=&quot;list-group-item-text&quot;&gt;我们提供 24*7 支持。&lt;/p&gt;    
</code></pre><h2 id="Bootstrap-面板（Panels）"><a href="#Bootstrap-面板（Panels）" class="headerlink" title="Bootstrap 面板（Panels）"></a>Bootstrap 面板（Panels）</h2><p>面板组件作用于将DOM组件插入到一个盒子中，而创建一个基本的面板只需要向<div>元素中添加 <code>class .panel</code> 和 <code>class .panel-default</code> 即可</div></p>
<pre><code>1.面板标题

    可以通过两种方式添加面板标题：
        1.使用 .panel-heading class 可以很简单的向面板添加标题容器
        2.使用带有 .panel-title class 的&lt;h1&gt;-&lt;h6&gt;来添加预定义样式的标题

        注意：class .panel-body 标注面板内容块

2.面板脚注

    我们可以向面板中添加脚注，我们只需要将按钮或者副文本放在带有 class .panel-footer 的&lt;div&gt;中便可

        &lt;div class=&quot;panel panel-default&quot;&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    这是一个基本的面板
                &lt;/div&gt;

                &lt;div class=&quot;panel-footer&quot;&gt;面板脚注&lt;/div&gt;
        &lt;/div&gt;
</code></pre><blockquote>
<p>注意：面板脚注不会从带语境色彩的面板中继承颜色和边框，因为其不是前景中的内容</p>
</blockquote>
<pre><code>3.带语境色彩的面板

    语境状态类：可以通过 panel-primary、panel-success、panel-info、panel-warning、panel-danger 这些语境状态类来设置带语境色彩的面板

4.带表格的面板

    如果希望在面板中创建一个没有边框的表格，我们可以在面板中使用 class .table 如果有个&lt;div&gt;中包含 .panel-body 我们可以向表格的顶部添加额外的边框用来分隔     
    如果没有包含 .panel-body 的 &lt;div&gt;，则组件会无中断地从面板头部移动到表格

5.带有列表组的面板

    可以在任何面板中包含列表组，通过在&lt;div&gt;元素中添加 .panel 和 .panel-default 类来创建面板，同时在面板中添加列表项

    在&lt;class=&quot;panel-body&quot;&gt;之后创建一个列表组&lt;list-group&gt;
</code></pre><h2 id="Bootstrap-Well"><a href="#Bootstrap-Well" class="headerlink" title="Bootstrap Well"></a>Bootstrap Well</h2><p>Well 是一种会引起内容凹陷显示或插图效果的容器<code>&lt;div&gt;</code>如果需要创建 Well，只需要简单地把内容放在带有 <code>class .well</code> 的<code>&lt;div&gt;</code> 中即可</p>
<pre><code>    &lt;div class=&quot;well&quot;&gt;您好，我在 Well 中！&lt;/div&gt;

1.尺寸大小

    我们可以使用 well-lg 或者 well-sm 来改变well尺寸的大小 此外，这两个类是结合 .well 类使用的，这两个类会影响内边距(padding)，根据使用的类，well会显示的更大或者更小
</code></pre><h2 id="Bootstrap-创建一个网页"><a href="#Bootstrap-创建一个网页" class="headerlink" title="Bootstrap 创建一个网页"></a>Bootstrap 创建一个网页</h2><pre><code>1.创建一个简单的响应式网页
</code></pre><hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code>bootstrap本地引用：

        1.引用的包有：

            &lt;script src=&quot;dist/js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;
                &lt;script src=&quot;dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
                &lt;link href=&quot;dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;

        注意：1.在IDEA中创建静态工程，在这个工程下面直接创建HTML文档，然后放在dist目录下，这样就能够使用了
              2.src=&quot;dist/js/bootstrap.min.js&quot;不能写成 src=&quot;/dist/js/bootstrap.min.js&quot; 因为是相对路径
              3.jquery-1.9.1.min.js不需要改成jquery.min.js也是可以的

bootstrap 远程 CDN

        引入远程文件的顺序：

            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;  
            &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre><hr>
<h2 id="BootStrap-插件"><a href="#BootStrap-插件" class="headerlink" title="BootStrap 插件"></a>BootStrap 插件</h2><pre><code>Bootstrap 自带 12 种 jQuery 插件，扩展了功能，可以给站点添加更多的互动。利用 Bootstrap 数据 API（Bootstrap Data API），大部分的插件可以在不编写任何代码的情况被触发。

站点引用bootstrap的方式两种：

    1.单独引用：使用 Bootstrap 的个别的 *.js 文件   注意：一些插件和 CSS 组件依赖于其他插件，所以在单独引用插件的时候需要确保插件之间的依赖关系
    2.编译的同时引用：使用 bootstrap.js 或者是压缩版的 bootstrap.min.js

注意：所有的插件都是依赖于jQuery，所以我们在引入插件文件之前需要引入jQuery 注意版本之间的支持

1.data属性

    通过data属性API使用所有的bootstrap插件(首选)

2.编程方式的API(重要)

    所有的bootstrap插件都提供了纯JavaScript方式的API，所以公开的API都是支持单独或链式调用方式，并且返回其所操作元素的集合

    所有的方法都可以接受一个可选的选项对象作为参数或者一个代表特定方法的字符串，或者不带任何参数（这种情况下，将会初始化插件为默认行为）

    1.$(&quot;#myModal&quot;).modal()  //初始化默认行为
    2.$(&quot;#myModal&quot;).modal({ keyboard: false })  //初始化不支持键盘
    3.$(&quot;#myModal&quot;).modal(&apos;show&apos;)  //初始化并立即调用show

    注意：如果需要获取某个特定插件的实例，可以直接通过页面元素调取： $(&apos;[rel=popover]&apos;).data(&apos;popover&apos;)

3.避免命名空间冲突

    某些时候bootstrap插件可能要与UI框架插件一起使用，如果在使用过程中发生命名空间冲突，可以通过调用插件 .noConflict 方法恢复期原始值

4.事件

    bootstrap为大多数的插件的独特行为提供了自定义的插件，两种形式：

        1.动词不定式，这会在事件开始时被触发 如：ex:show 动词不定式事件提供了preventDefault功能，使得在事件开始前可以停止操作的执行

            $(&apos;#myModal&apos;).on(&apos;show.bs.modal&apos;, function (e) {
                // 阻止模态框的显示
                  if (!data) return e.preventDefault() 
            })

        2.过去分词形式，这会在动作执行完毕之后被触发。例如 ex: shown
</code></pre><h2 id="Bootstrap-过渡效果（Transition）插件"><a href="#Bootstrap-过渡效果（Transition）插件" class="headerlink" title="Bootstrap 过渡效果（Transition）插件"></a>Bootstrap 过渡效果（Transition）插件</h2><pre><code>这一插件提供了简单的过渡效果

注意：如果需要单独引用该插件的功能，除了其它的JS文件之外，还需要引用 transition.js 或者是引用bootstrap.js或者压缩版的 bootstrap.min.js 
</code></pre><h2 id="Bootstrap-模态框（Modal）插件"><a href="#Bootstrap-模态框（Modal）插件" class="headerlink" title="Bootstrap 模态框（Modal）插件"></a>Bootstrap 模态框（Modal）插件</h2><p>模态框（Modal）是覆盖在父窗体上的子窗体。通常，目的是显示来自一个单独的源的内容，可以在不离开父窗体的情况下有一些互动。子窗体可提供信息、交互等。</p>
<pre><code>1.使用方法

    切换模态框(modal)插件的隐藏内容：

        1.通过data属性：将控制器元素(如：按钮或者链接)上设置属性 data-toggle=&quot;modal&quot;，同时设置 data-target=&quot;#identifier&quot;或者是href=&quot;#identifier&quot;来指定要切换的特定的模态框(id=&quot;identifier&quot;)

        2.通过JavaScript：使用这种技术，我们可以通过简单的一行JavaScript来调用带有 id=&quot;identifier&quot;的模态框

            $(&apos;#identifier&apos;).modal(options)

        3.源码分析

            1.使用模态窗口需要触发某种触发器(可以是按钮或者链接)

            2.data-target=&quot;#mymodal&quot;  表示向要在页面上加载的模态框目标，所以可以在页面上创建多个模态框，然后为每个模态框创建不同的触发器
</code></pre><blockquote>
<p>注意：虽然不能同时使用多个模块，但是可以在页面上创建多个模块不同时间加载</p>
</blockquote>
<pre><code>        3.注意两点：
                1. .modal用来将&lt;div&gt;的内容识别为模态框 
                2. .fade class 当模态框切换时，它会引起内容淡入淡出 

            4.aria-labelledby=&quot;myModalLabel&quot; 该属性引用模态框的标题(引用会在后面创建的标题)

            5.属性 aria-hidden=&quot;true&quot; 
            用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）

            6.&lt;div class=&quot;modal-header&quot;&gt; modal-header 是为模态窗口的头部定义样式的类

            7.class=&quot;close&quot; close 是一个 CSS class，用于为模态窗口的关闭按钮设置样式

            8.data-dismiss=&quot;modal&quot; 在这里它被用于关闭模态窗口，是一个自定义 HTML5 属性

            9.class=&quot;modal-body&quot; 是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的主体设置样式

            10.class=&quot;modal-footer&quot; 是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的底部设置样式

            11.data-toggle=&quot;modal&quot; HTML5 自定义的 data 属性 data-toggle 用于打开模态窗口

2.选项

    选项可以用来定制模态窗口的外观和感观，通过data属性或者JavaScript来传递

    1.backdrop (data-backdrop) 指定一个静态背景，当用户点击模态框外部时不会关闭模态框
    2.keyboard (data-keyboard) 当按下escape键时，设置为false时无效
    3.show (data-show) 当初始化时显示模态框
    4.remote (data-remote) 

3.方法

    1. .modal(options) 将内容作为模态框激活，接受一个可选的选项对象  

        $(&apos;#identifier&apos;).modal({
            keyboard: false
        })

    2. .modal(&apos;toggle&apos;) 手动切换模态框  $(&apos;#identifier&apos;).modal(&apos;toggle&apos;)

    3. .modal(&apos;show&apos;) 手动打开模态框 $(&apos;#identifier&apos;).modal(&apos;show&apos;)

    4. .modal(&apos;hide&apos;) 手动隐藏模态框 $(&apos;#identifier&apos;).modal(&apos;hide&apos;)

4.事件

    1.show.bs.modal    在调用 show 方法后触发 

        $(&apos;#identifier&apos;).on(&apos;show.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    2.shown.bs.modal 当模态框对用户可见时触发（将等待 CSS 过渡效果完成） 

        $(&apos;#identifier&apos;).on(&apos;shown.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    3.hide.bs.modal    当调用 hide 实例方法时触发

        $(&apos;#identifier&apos;).on(&apos;hide.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    4.hidden.bs.modal 当模态框完全对用户隐藏时触发。    

        $(&apos;#identifier&apos;).on(&apos;hidden.bs.modal&apos;, function () {
              // 执行一些动作...
        })

    5.loaded.bs.modal 
</code></pre><h2 id="Bootstrap-下拉菜单（Dropdown）插件"><a href="#Bootstrap-下拉菜单（Dropdown）插件" class="headerlink" title="Bootstrap 下拉菜单（Dropdown）插件"></a>Bootstrap 下拉菜单（Dropdown）插件</h2><p>使用下拉菜单插件可以向任何组件添加下拉菜单，如果想要单独引用该插件的功能，需要引用<code>dropdown.js</code></p>
<pre><code>1.使用方法

    可以切换下拉菜单的隐藏内容

    通过data属性：通过向链接或者按钮添加 data-toggle=&quot;dropdown&quot; 来切换下拉菜单

    通过JavaScript：$(&apos;.dropdown-toggle&apos;).dropdown()

2.方法

    下拉菜单切换有一个简单的方法(显示隐藏下拉菜单) $().dropdown(&apos;toggle&apos;)

3.扩展

    bootstrap给 a 之类的元素都绑定上事件，终止链接默认行为。
    1.data-toggle 表示以什么事件触发，常用的有：modal/popover/tooltips等
    2.data-target 表示事件的目标

    所以上面的两者一起使用表示data-target所指的元素以data-toggle指定的形式显示
</code></pre><h2 id="Bootstrap-滚动监听（Scrollspy）插件"><a href="#Bootstrap-滚动监听（Scrollspy）插件" class="headerlink" title="Bootstrap 滚动监听（Scrollspy）插件"></a>Bootstrap 滚动监听（Scrollspy）插件</h2><p>滚动监听也就是自动更新导航插件，根据滚动条的位置自动更新对应的导航目标 基于滚动条的位置向导航栏中添加 <code>.active class</code></p>
<blockquote>
<p>注意：如果需要单独引用该插件的功能，需要引用<code>scrollspy.js</code></p>
</blockquote>
<pre><code>1.使用方法

    通过data属性：向我们想要监听的元素(body)中添加 data-spy=&quot;scroll&quot; 然后添加带有bootstrap .nav 组件的父元素的ID或者class属性 data-target

        &lt;body data-spy=&quot;scroll&quot; data-target=&quot;.navbar-example&quot;&gt;
            &lt;div class=&quot;navbar-example&quot;&gt;

    通过JavaScript：$(&apos;body&apos;).scrollspy({ target: &apos;.navbar-example&apos; })

2.方法
    通过JavaScript调用scrollspy方法时，需要调用 .refresh 方法更新DOM 

        $(&apos;[data-spy=&quot;scroll&quot;]&apos;).each(function () {
              var $spy = $(this).scrollspy(&apos;refresh&apos;)
        })

3.事件

    滚动监听要用到的事件，这些事件可以在函数中当做钩子使用

        activate.bs.scrollspy 每当一个新项目被滚动监听激活时，触发该事件

        $(&apos;#myScrollspy&apos;).on(&apos;activate.bs.scrollspy&apos;, function () {
              // 执行一些动作...
        })

4.选项

    通过data属性或JavaScript来传递

        Data属性名称：data-offset 作用：当计算滚动位置时，距离顶部的偏移像素
</code></pre><h2 id="Bootstrap-标签页（Tab）插件"><a href="#Bootstrap-标签页（Tab）插件" class="headerlink" title="Bootstrap 标签页（Tab）插件"></a>Bootstrap 标签页（Tab）插件</h2><p>通过这个插件我们可以把内容放置在标签页或者是胶囊式标签页甚至是下拉菜单标签页中</p>
<pre><code>1.使用方法

    通过data属性：需要添加 data-toggle=&quot;tab&quot; 或 data-toggle=&quot;pill&quot; 到锚文本链接中

        添加 nav 和 nav-tabs 类到 ul 中，将会应用 Bootstrap 标签样式，添加 nav 和 nav-pills 类到 ul 中，将会应用 Bootstrap 胶囊式样式

    通过JavaScript：

        $(&apos;#myTab a&apos;).click(function (e) {
              e.preventDefault()
              $(this).tab(&apos;show&apos;)
        })

2.淡入淡出效果

    如果需要为标签页设置淡入淡出效果，请添加 .fade 到每个 .tab-panel 后面。第一个标签页必须添加 .in 类，以便淡入显示初始内容

        &lt;div class=&quot;tab-pane fade in active&quot; id=&quot;home&quot;&gt;...&lt;/div&gt;
        &lt;div class=&quot;tab-pane fade&quot; id=&quot;svn&quot;&gt;...&lt;/div&gt;

3.方法

    .$().tab：该方法可以激活标签页元素和内容容器。标签页需要用一个 data-target 或者一个指向 DOM 中容器节点的 href

4.事件

    show.bs.tab 该事件在标签页显示时触发，但是必须在新标签页被显示之前。
    分别使用 event.target 和 event.relatedTarget 来定位到激活的标签页和前一个激活的标签页。

        $(&apos;a[data-toggle=&quot;tab&quot;]&apos;).on(&apos;show.bs.tab&apos;, function (e) {
              e.target // 激活的标签页
              e.relatedTarget // 前一个激活的标签页
        })

    shown.bs.tab 该事件在标签页显示时触发，但是必须在某个标签页已经显示之后。
    分别使用 event.target 和 event.relatedTarget 来定位到激活的标签页和前一个激活的标签页。

        $(&apos;a[data-toggle=&quot;tab&quot;]&apos;).on(&apos;shown.bs.tab&apos;, function (e) {
              e.target // 激活的标签页
              e.relatedTarget // 前一个激活的标签页
        })

5.tabindex

    模态框中tabindex属性规定元素的tab键控制顺序(此时tab键用于导航)，出了safari浏览器之外，其他浏览器都有tabindex属性
</code></pre><h2 id="Bootstrap-提示工具（Tooltip）插件"><a href="#Bootstrap-提示工具（Tooltip）插件" class="headerlink" title="Bootstrap 提示工具（Tooltip）插件"></a>Bootstrap 提示工具（Tooltip）插件</h2><pre><code>1.使用方法

    通过data属性：如果需要添加提示工具(tooltip)放在他们的触发元素里面，只需要向一个锚标签添加 data-toggle=&quot;tooltip&quot; 即可 默认情况下，插件将提示工具(tooltip)设置在顶部

    &lt;a href=&quot;#&quot; data-toggle=&quot;tooltip&quot; title=&quot;Example tooltip&quot;&gt;请悬停在我的上面&lt;/a&gt;

    通过JavaScript

    $(&apos;#identifier&apos;).tooltip(options)

    注意：使用该插件需要激活 $(function () { $(&quot;[data-toggle=&apos;tooltip&apos;]&quot;).tooltip(); });

2.选项
</code></pre><h2 id="Bootstrap-弹出框（Popover）插件"><a href="#Bootstrap-弹出框（Popover）插件" class="headerlink" title="Bootstrap 弹出框（Popover）插件"></a>Bootstrap 弹出框（Popover）插件</h2><pre><code>1.使用方法

    通过data属性：向一个锚标签添加 data-toggle=&quot;popover&quot; 即可 锚的title=&quot;弹出框(popover)&quot;的文本 默认情况下，插件将弹出框（popover）设置在顶部        

        &lt;a href=&quot;#&quot; data-toggle=&quot;popover&quot; title=&quot;Example popover&quot;&gt;
                    请悬停在我的上面
        &lt;/a&gt;

    通过JavaScript

        $(&apos;#identifier&apos;).popover(options)

    注意：使用该插件需要使用脚本来启用页面中的所有的弹出框(popover) $(function () { $(&quot;[data-toggle=&apos;popover&apos;]&quot;).popover(); });
</code></pre><h2 id="Bootstrap-警告框（Alert）插件"><a href="#Bootstrap-警告框（Alert）插件" class="headerlink" title="Bootstrap 警告框（Alert）插件"></a>Bootstrap 警告框（Alert）插件</h2><pre><code>使用警告框（Alert）插件，可以向所有的警告框消息添加可取消（dismiss）功能

1.使用方法

两种方式启用警告框的可取消功能

    通过data属性：向关闭按钮中添加 data-dismiss=&quot;alert&quot; 就会自动为警告框添加关闭功能

        &lt;a class=&quot;close&quot; data-dismiss=&quot;alert&quot; href=&quot;#&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/a&gt;

    通过JavaScript：$(&quot;.alert&quot;).alert()

2.方法

    .alert() 该方法让所有的警告框都带有关闭功能  语法：$(&apos;#identifier&apos;).alert();

    .alert(&apos;close&apos;)    关闭所有的警告框  语法：$(&apos;#identifier&apos;).alert(&apos;close&apos;);
</code></pre><blockquote>
<p>注意：如果需要在关闭时启用动画效果，需要添加 <code>.fade</code> 和 <code>.in class</code></p>
</blockquote>
<pre><code>3.事件

    close.bs.alert 当调用 close 实例方法时立即触发该事件

        $(&apos;#myalert&apos;).bind(&apos;close.bs.alert&apos;, function () {
              // 执行一些动作...
        })

    closed.bs.alert    当警告框被关闭时触发该事件（将等待 CSS 过渡效果完成）

        $(&apos;#myalert&apos;).bind(&apos;closed.bs.alert&apos;, function () {
                // 执行一些动作...
        })
</code></pre><h2 id="Bootstrap-按钮（Button）插件"><a href="#Bootstrap-按钮（Button）插件" class="headerlink" title="Bootstrap 按钮（Button）插件"></a>Bootstrap 按钮（Button）插件</h2><pre><code>通过按钮（Button）插件，我们可以添加进一些交互，比如控制按钮状态，或者为其他组件（如工具栏）创建按钮组

1.加载状态

    如果我们需要向按钮中添加加载状态，向button元素添加 data-loading-text=&quot;loading...&quot; 作为其属性便可

2.单个切换

    如果需要激活单个按钮的切换(即改变按钮的正常状态为按压状态，反之亦然)，向 button 元素添加 data-toggle=&quot;button&quot; 作为其属性即可

3.复选框

    创建复选框组，并通过向 btn-group 添加 data 属性 data-toggle=&quot;buttons&quot; 来添加复选框组的切换

4.单选按钮

    创建单选按钮组，通过向 btn-group 添加 data 属性 data-toggle=&quot;buttons&quot; 来添加单选按钮组的切换

注意：可以通过JavaScript启用按钮插件 $(&apos;.btn&apos;).button()
</code></pre><h2 id="Bootstrap-折叠（Collapse）插件"><a href="#Bootstrap-折叠（Collapse）插件" class="headerlink" title="Bootstrap 折叠（Collapse）插件"></a>Bootstrap 折叠（Collapse）插件</h2><pre><code>折叠（Collapse）插件可以很容易地让页面区域折叠起来

    1.data-toggle=&quot;collapse&quot; 添加到想要展开或折叠的组件的链接上

    2.href 或 data-target 属性添加到父组件，它的值是子组件的 id

    3.data-parent 属性把折叠面板（accordion）的 id 添加到要展开或折叠的组件的链接上

1.使用方法

    .collapse 隐藏内容
    .collapse.in 显示内容
    .collapsing 当过渡效果开始时被添加，当过渡效果完成时被移除
</code></pre><blockquote>
<p>注意：通过两种方式使用折叠插件 </p>
<blockquote>
<p>1.通过data属性：向元素添加 data-toggle=”collapse” 和 data-target，自动分配可折叠元素的控制，确保可折叠元素已经添加了class .collapse 同时如果希望在默认情况下是打开的，需要添加额外的class .in。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.通过JavaScript：$(‘.collapse’).collapse()</p>
</blockquote>
</blockquote>
<pre><code>2.方法

3.事件
</code></pre><h2 id="Bootstrap-轮播（Carousel）插件"><a href="#Bootstrap-轮播（Carousel）插件" class="headerlink" title="Bootstrap 轮播（Carousel）插件"></a>Bootstrap 轮播（Carousel）插件</h2><h5 id="1-可选的标题"><a href="#1-可选的标题" class="headerlink" title="1.可选的标题"></a>1.可选的标题</h5><p>可以通过 .item 内的 .carousel-caption 元素向幻灯片添加标题</p>
<h5 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h5><p>通过 data 属性：</p>
<p>使用 data 属性可以很容易控制轮播（Carousel）的位置<br>属性 <code>data-slide</code> 接受关键字 <code>prev</code> 或 <code>next</code>，用来改变幻灯片相对于当前位置的位置。<br>使用 <code>data-slide-to</code> 来向轮播传递一个原始滑动索引，<code>data-slide-to=&quot;2&quot;</code> 将把滑块移动到一个特定的索引，索引从 0 开始计数<br><code>data-ride=&quot;carousel&quot;</code> 属性用于标记轮播在页面加载时就开始动画播放。</p>
<p>通过 JavaScript：轮播（Carousel）可通过 JavaScript 手动调用 </p>
<blockquote>
<p><code>语法：$(&#39;.carousel&#39;).carousel()</code></p>
</blockquote>
<h2 id="Bootstrap-附加导航（Affix）插件"><a href="#Bootstrap-附加导航（Affix）插件" class="headerlink" title="Bootstrap 附加导航（Affix）插件"></a>Bootstrap 附加导航（Affix）插件</h2><pre><code>该插件允许指定&lt;div&gt;固定在页面的某个位置，不会随着页面其他部分一起滚动

1.使用方法

通过 JavaScript：您可以通过 JavaScript 手动为某个元素添加附加导航（Affix）

    $(&apos;#myAffix&apos;).affix({
           offset: {
                  top: 100, bottom: function () {
                     return (this.bottom = 
                            $(&apos;.bs-footer&apos;).outerHeight(true))
                         }
                  }
    })

通过data属性：如果要向元素添加附加导航行为，只需要向需要监听的元素添加 data-spy=&quot;affix&quot; 同时需要使用偏移来定义何时切换元素的锁定和移动

2.通过CSS定位

    注意：在使用附加导航插件的方式中，需要通过CSS定位内容，然后每种class都呈现特定的状态：.affix .affix-top .affix-bottom

    步骤：1.在插件添加 .affix-top 来指定元素在它最顶端位置    
          2.当滚动经过添加了附加导航的元素时，应触发实际的附加导航(affix)，此时的 .affix 会替代 .affix-top 同时设置 position:fixed;
          3.如果定义了底部偏移，当滚动到此位置时，应该将 .affix 替换为 .affix-bottom 注意：如果此时设置了此偏移，那么需要设置适当的css。在这种情况下，必要时候添加 position:absolute;

3.选项

    选项：offset  data属性名称：data-offset 当计算机滚动位置时，距离顶部的偏移像素。如果设置了属性值，则该偏移量将被应用到顶部或底部
</code></pre><hr>
<hr>
<blockquote>
<p>扩展</p>
<blockquote>
<p>freemaker FTL指令常用标签及语法 注意：使用freemarker要求所有标签必须闭合，否则freemarker标签无法解析。</p>
<blockquote>
<p>1.注释：&lt;#–注释内容–&gt;(格式)   2.取值：代替输出数据模型的部分，格式：${数据模型}或#{数据模型}</p>
<blockquote>
<p>freemarker语法及使用方法：</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code>1. ${var} Java基本类型及String引用类型。  
2. ${var!} 对null或者不存在的对象进行取值，可以设置默认值。如：${var! &apos;我是默认值&apos;} 表示有值时显示正常值，无值时显示默认值。
3. ${封装对象.属性} 用于对封装对象进行取值。 
4. ${date?String(&apos;yyyy-MM-dd&apos;)} 用于对日期格式进行取值，需要注意的是，定义Date类型的变量时，java.util.Date无法输出日期，必须使用java.sql.Date。 
5. ${var?html} 转移HTML。 
6. &lt;#assign num = 100 /&gt; 定义变量，支持计算和赋值。 

7.对List集合进行取值
&lt;#list  list集合  as  item&gt; 
    ${item} --取值
&lt;/#list&gt;

8.对Map集合进行取值
&lt;#list map?keys as key&gt;
    ${key}:${map[key]}
&lt;/#list&gt;
如：Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
    m.put(&quot;name&quot;,&quot;姓名&quot;);
    m.put(&quot;age&quot;,18);
    m.put(&quot;sex&quot;,&quot;男&quot;);
然后在页面中获取变量：
    &lt;#list m?keys as key&gt;
        ${key}:${m[key]}
    &lt;/#list&gt;
然后得到结果：
    name:姓名
    age:18
    sex:男

9.条件判断指令
    1.&lt;#if 条件&gt;
        输出
      &lt;#else&gt;
         输出
      &lt;/#if&gt;
    2.switch指令，经常与case、break和default指令一起使用，参数可以为字符串。
        &lt;#switch var&gt;
            &lt;#case 条件1&gt;
                输出
            &lt;#break&gt;
            &lt;#case 条件2&gt;
                输出
            &lt;#break&gt;
            &lt;#default&gt;
                输出
        &lt;/#switch&gt;

10.自定义指令
    &lt;@自定义指令名称 入参(key-value格式) ; 出参(list格式)&gt;
        运行条件
    &lt;/@自定义指令名称&gt;

     PS:不同的返回值用逗号间隔开

11.常用内建函数、macro(宏指令)、function(函数指令)
</code></pre>]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/undefined/jQuery/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-jQuery语法"><a href="#1-jQuery语法" class="headerlink" title="1.jQuery语法"></a>1.jQuery语法</h2><pre><code>jQuery语法是通过选取 HTML 元素，并对选取的元素执行某些操作。

jQuery 入口函数与 JavaScript 入口函数的区别：

     1.jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   //文档就绪之后执行jQuery方法</span><br><span class="line">$(function()&#123;</span><br><span class="line">   	// 执行代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<pre><code>2.JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。
</code></pre><h2 id="2-jQuery-选择器"><a href="#2-jQuery-选择器" class="headerlink" title="2.jQuery 选择器"></a>2.jQuery 选择器</h2><p>jQuery 选择器(jQuery 选择器允许我们对 HTML 元素组或单个元素进行操作)基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素，jQuery 中所有选择器都以美元符号开头：$()。</p>
<p>  1.#id 选择器<br>    jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素，页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。</p>
<pre><code>语法：$(&quot;#test&quot;)
</code></pre><p>  2..class 选择器<br>    jQuery 类选择器可以通过指定的 class 查找元素</p>
<pre><code>语法：$(&quot;.test&quot;)
</code></pre><p>  3.元素选择器<br>    jQuery 元素选择器基于元素名选取元素</p>
<pre><code>语法：$(&quot;p&quot;) 表示选取页面中所有的&lt;p&gt;元素
</code></pre><p>  4.过滤选择器<br>    主要是通过特定的过滤规则筛选出所需要的DOM元素 过滤规则：选择器以(:)开头</p>
<pre><code>主要过滤选择器：
    1.:first 选取第一个元素
    2.:last 选取最后一个元素
    3.:header 选取所有的标题元素，如：h2/h3/h1等
    ...

案例：
    //改变第一个&lt;div&gt;元素的背景色
    $(&apos;div:first&apos;).css(&quot;background&quot;,&quot;#bbffaa&quot;);
</code></pre><h2 id="3-jQuery-事件"><a href="#3-jQuery-事件" class="headerlink" title="3.jQuery 事件"></a>3.jQuery 事件</h2><pre><code>事件(jQuery 是为事件处理特别设计的)：页面对不同访问者的响应叫做事件 事件处理程序指的是当HTML中发生某些事件时所调用的方法
</code></pre><h4 id="1-jQuery-事件方法语法"><a href="#1-jQuery-事件方法语法" class="headerlink" title="1.jQuery 事件方法语法"></a>1.jQuery 事件方法语法</h4><pre><code>在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法
1.$(&quot;p&quot;).click();//页面中点击事件的语法，然后在事件触发之后让其执行相关的事件处理程序
2.常用的jQuery事件方法
    1.click() 该方法是当按钮点击事件被触发时会调用的一个函数
        $(&quot;p&quot;).click(function(){
            $(this).hide();
        });
    2.dblclick() 当双击元素时，会发生dblclick事件
    3.mouseenter() 当鼠标指针穿过元素时，会发生 mouseenter 事件
    4.mouseleave() 当鼠标指针离开元素时，会发生 mouseleave 事件
    5.mousedown() 
    ...
3.
</code></pre><h4 id="2-事件绑定"><a href="#2-事件绑定" class="headerlink" title="2.事件绑定"></a>2.事件绑定</h4><pre><code>1.基本效果
在文档装载完成之后，如果需要为元素绑定事件来完成操作，可以使用bind()方法来对匹配元素进行特定事件的绑定。
格式：
    bind(type [,data],fn);
    1.type:事件类型
    2.可选参数，作为event、data属性值传递给事件对象的额外数据对象
    3.fn:用来绑定操作的处理函数
</code></pre><blockquote>
<p>注意：jQuery中的事件绑定类型比普通的JavaScript事件绑定类型少了on</p>
</blockquote>
<pre><code>案例：
    $(function(){
        $(&quot;#panel h5.head&quot;).bind(&quot;click&quot;,function(){
            $(this).next(&quot;div.content&quot;).show();
        })
    })
</code></pre><blockquote>
<p>注意：在jQuery中的关键字this，this引用的是携带相应行为的DOM元素</p>
</blockquote>
<pre><code>2.加强效果

3.改变事件的绑定类型

4.简写绑定事件
</code></pre><h2 id="4-jQuery效果"><a href="#4-jQuery效果" class="headerlink" title="4.jQuery效果"></a>4.jQuery效果</h2><pre><code>1.hide()/show() 通过hide()和show()方法来隐藏和显示HTML元素
    //hide()方法
    $(&quot;#hide&quot;).click(function(){
        $(&quot;p&quot;).hide();
    });
    //show()方法
    $(&quot;#show&quot;).click(function(){
        $(&quot;p&quot;).show();
    });
2.toggle() 使用 toggle() 方法来切换 hide() 和 show() 方法
3.fadeIn() 用于淡入已隐藏的元素
    //fadeIn()方法中的效果时长：&quot;slow&quot;/fast以及毫秒值
    $(&quot;button&quot;).click(function(){
        $(&quot;#div1&quot;).fadeIn();
        $(&quot;#div2&quot;).fadeIn(&quot;slow&quot;);
        $(&quot;#div3&quot;).fadeIn(3000);
    });
4.fadeOut() 方法用于淡出可见元素
    //类似于fadeIn()方法，其也能够控制效果时长
    $(&quot;button&quot;).click(function(){
        $(&quot;#div1&quot;).fadeOut();
        $(&quot;#div2&quot;).fadeOut(&quot;slow&quot;);
        $(&quot;#div3&quot;).fadeOut(3000);
    });
5.fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换
  如果元素已淡出，则fadeToggle()会向元素添加淡入效果 如果元素已淡入，则fadeToggle()会向元素添加淡出效果

6.fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）
  opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）
7.slideDown() 方法用于向下滑动元素
        $(&quot;#flip&quot;).click(function(){
            $(&quot;#panel&quot;).slideDown();
        });
8.slideUp() 方法用于向上滑动元素
        $(&quot;#flip&quot;).click(function(){
            $(&quot;#panel&quot;).slideUp();
        });
9.slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换
10.animate() 用于创建自定义动画
   语法：$(selector).animate({params},speed,callback);
   1.params:定义形成动画的css属性
   2.speed:可以是fast/slow/毫秒值
   3.callback:可选，表示动画完成之后所执行的函数名称
        $(&quot;button&quot;).click(function(){
            $(&quot;div&quot;).animate({left:&apos;250px&apos;});
        });
</code></pre><h2 id="5-jQuery-方法链接"><a href="#5-jQuery-方法链接" class="headerlink" title="5.jQuery 方法链接"></a>5.jQuery 方法链接</h2><p>有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。</p>
<blockquote>
<p>提示： 这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，只需简单地把该动作追加到之前的动作上。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//表示p1元素会首先变成红色，然后向上滑动，最后向下滑动</span><br><span class="line">$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000);</span><br></pre></td></tr></table></figure>
<pre><code>1.jQuery方法
    1. on()方法 该方法在被选元素及子元素上添加一个或多个事件处理程序
</code></pre><blockquote>
<p>注意：使用on()方法添加的事件处理程序适用于当前及未来的元素</p>
<blockquote>
<p>提示：<br>1.如果需要移除事件处理程序，使用off()方法 2.如需添加只运行一次的事件然后移除，请使用 one() 方法</p>
</blockquote>
</blockquote>
<pre><code>2.event.preventDefault() 方法 阻止元素发生默认的行为
例如：点击提交按钮时阻止对表单的提交或阻止URL的链接等 
</code></pre><blockquote>
<p>提示：请使用 event.isDefaultPrevented() 方法来检查指定的事件上是否调用了 preventDefault() 方法</p>
<blockquote>
<p>注意：参数event必须，是来自事件绑定绑定函数</p>
</blockquote>
</blockquote>
<h2 id="6-jQuery-获取内容和属性"><a href="#6-jQuery-获取内容和属性" class="headerlink" title="6.jQuery 获取内容和属性"></a>6.jQuery 获取内容和属性</h2><blockquote>
<p>前提：jQuery 提供一系列与 DOM(文档对象模型)<br>相关的方法，这使访问和操作元素和属性变得很容易</p>
</blockquote>
<h4 id="1-获取内容-方法"><a href="#1-获取内容-方法" class="headerlink" title="1.获取内容(方法)"></a>1.获取内容(方法)</h4><pre><code>1.text() - 设置或返回所选元素的文本内容
2.html() - 设置或返回所选元素的内容（包括 HTML 标记）
3.val() - 设置或返回表单字段的值
4.attr() 方法用于获取属性值
</code></pre><blockquote>
<p>注意：1.对于<code>HTML</code>元素本身就带有的固有属性，在处理时，使用 prop 方法。对于 HTML 元素我们自己自定义的 DOM 属性，在处理时，使用 attr 方法</p>
</blockquote>
<h4 id="2-设置内容和属性"><a href="#2-设置内容和属性" class="headerlink" title="2.设置内容和属性"></a>2.设置内容和属性</h4><pre><code>1.attr() 用于设置或改变一个或多个属性值
</code></pre><h4 id="3-添加元素"><a href="#3-添加元素" class="headerlink" title="3.添加元素"></a>3.添加元素</h4><pre><code>1.append() 在被选元素结尾插入内容
2.prepend() 在被选元素开头插入内容
3.after() 在被选元素之后插入内容
4.before() 在被选元素之前插入内容
</code></pre><blockquote>
<p>总结：1.append()/prepend() 是在选择元素内部嵌入 2.after()/before()是在元素外面追加</p>
</blockquote>
<h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><pre><code>如果需要删除元素，一般使用remove()/empty()方法。
1.remove() 删除被选元素以及子元素
    //此时删除的不仅是div1里面的内容，而且还有div1这个块
    $(&quot;#div1&quot;).remove();
2.empty() 从被选元素中删除子元素
    //此时仅仅删除的是div1里面的内容，并没有删除div1这个块
    $(&quot;#div1&quot;).empty();
3.过滤被删除的元素
    //即就是接受一个参数，删除该参数下所有的元素
    $(&quot;p&quot;).remove(&quot;.italic&quot;);//表示删除class=&quot;italic&quot;下面的所有&lt;p&gt;元素
</code></pre><h2 id="7-jQuery-css-方法"><a href="#7-jQuery-css-方法" class="headerlink" title="7.jQuery css() 方法"></a>7.jQuery css() 方法</h2><pre><code>1.css() 方法设置或返回被选元素的一个或多个样式属性
</code></pre><blockquote>
<p>扩展</p>
<blockquote>
<p>JavaScript Object.keys()方法<br><br>作用：返回对象的可枚举属性和方法的名称</p>
<blockquote>
<p>语法：Object.keys(object)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="8-jQuery-尺寸"><a href="#8-jQuery-尺寸" class="headerlink" title="8.jQuery 尺寸"></a>8.jQuery 尺寸</h2><pre><code>1.width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）
2.height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）
3.innerWidth() 方法返回元素的宽度（包括内边距）
4.innerHeight() 方法返回元素的高度（包括内边距）
5.outerWidth() 方法返回元素的宽度（包括内边距和边框）
6.outerHeight() 方法返回元素的高度（包括内边距和边框）
</code></pre><h2 id="9-jQuery-遍历"><a href="#9-jQuery-遍历" class="headerlink" title="9.jQuery 遍历"></a>9.jQuery 遍历</h2><h4 id="1-祖先"><a href="#1-祖先" class="headerlink" title="1.祖先"></a>1.祖先</h4><pre><code>通过 jQuery，能够向上遍历 DOM 树，以查找元素的祖先

1.parent() 方法返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历
        //表示只返回span元素的直接父元素(如：&lt;ul&gt;/&lt;li&gt;)
        $(document).ready(function(){
            $(&quot;span&quot;).parent();
        });
2.parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)
        //返回元素span的所有父元素
        $(document).ready(function(){
            $(&quot;span&quot;).parents();
        });
3.parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素
        //返回介于span元素与div元素之间所有的父元素
        $(document).ready(function(){
            $(&quot;span&quot;).parentsUntil(&quot;div&quot;);
        });
</code></pre><h4 id="2-后代"><a href="#2-后代" class="headerlink" title="2.后代"></a>2.后代</h4><pre><code>通过jQuery，我们可以向下遍历DOM树，查找元素的所有后代

1.children()方法 返回被选元素的所有直接子元素，该方法只会向下一级对 DOM 树进行遍历
        //返回div元素的所有子元素，不会越级返回元素
        $(document).ready(function(){
            $(&quot;div&quot;).children();
        });
</code></pre><blockquote>
<p>注意：可以使用可选参数来过滤子元素的搜索</p>
</blockquote>
<pre><code>//表示返回类名为class_1的所有&lt;p&gt;元素，且这些元素是&lt;div&gt;的直接子元素
$(document).ready(function(){
    $(&quot;div&quot;).children(&quot;p.class_1&quot;);
});

    2.find()方法 返回被选元素的后代元素，一路向下直到最后一个后代
            //表示返回div元素后代的所有span元素
            $(document).ready(function(){
                $(&quot;div&quot;).find(&quot;span&quot;);
            });

            //表示返回div元素的所有后代
            $(document).ready(function(){
                $(&quot;div&quot;).find(&quot;*&quot;);
            });
</code></pre><h4 id="3-同胞"><a href="#3-同胞" class="headerlink" title="3.同胞"></a>3.同胞</h4><blockquote>
<p>前提：同胞拥有相同的父元素，通过 jQuery，我们能够在 DOM 树中遍历元素的同胞元素</p>
</blockquote>
<pre><code>1.next() 方法返回被选元素的下一个同胞元素
        //表示返回h2元素的下一个同胞元素
        $(document).ready(function(){
            $(&quot;h2&quot;).next();
        });

2.nextAll() 方法返回被选元素的所有跟随的同胞元素
        //表示返回h2元素的所有跟随同胞元素
        $(document).ready(function(){
            $(&quot;h2&quot;).nextAll();
        });

3.nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素
        //返回介于h2-h6之间的所有的跟随同胞元素
        $(document).ready(function(){
            $(&quot;h2&quot;).nextUntil(&quot;h6&quot;);
        });

4.siblings() 方法返回被选元素的所有同胞元素
</code></pre><blockquote>
<p>注意：prev() prevAll() 以及 prevUntil()<br>方法的工作方式与上面的方法类似。只不过是工作方向相反而已，它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）</p>
</blockquote>
<h4 id="4-过滤"><a href="#4-过滤" class="headerlink" title="4.过滤"></a>4.过滤</h4><blockquote>
<p>基本的过滤方法：first()/last()和eq()，它们允许我们基于其在一组元素中的位置来选择一个特定的元素</p>
</blockquote>
<pre><code>1.first() 方法返回被选元素的首个元素
        //选取首个 &lt;div&gt; 元素内部的第一个 &lt;p&gt; 元素
        $(document).ready(function(){
            $(&quot;div p&quot;).first();
        });

2.last() 方法返回被选元素的最后一个元素
        //选择最后一个 &lt;div&gt; 元素中的最后一个 &lt;p&gt; 元素
        $(document).ready(function(){
            $(&quot;div p&quot;).last();
        });

3.eq() 方法返回被选元素中带有指定索引号的元素
        //索引号从 0 开始，因此首个元素的索引号是 0 而不是 1
        $(document).ready(function(){
            $(&quot;p&quot;).eq(1);
        });

4.filter() 方法允许我们规定一个标准，如果元素不匹配这个标准的会被从集合中删除，匹配的元素会被返回
        //返回带有类名 &quot;url&quot; 的所有 &lt;p&gt; 元素
        $(document).ready(function(){
            $(&quot;p&quot;).filter(&quot;.url&quot;);
        });
</code></pre><hr>
<h2 id="10-jQuery-AJAX"><a href="#10-jQuery-AJAX" class="headerlink" title="10.jQuery - AJAX"></a>10.jQuery - AJAX</h2><p>AJAX 与服务器交换的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。</p>
<blockquote>
<p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML） 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：ajax的工作原理相当于在用户和服务器之间加了一个中间层(AJAX引擎)，使用户操作与服务器响应异步化</p>
</blockquote>
</blockquote>
<p><code>jQuery</code> 提供多个与 <code>AJAX</code> 有关的方法，通过 <code>jQuery AJAX</code> 方法，我们能够使用 <code>HTTP Get</code> 和 <code>HTTP Post</code> 从远程服务器上<code>请求文本、HTML、XML 或 JSON</code>同时我们能够把这些外部数据直接载入网页的被选元素中 是用于创建快速动态网页的技术。</p>
<blockquote>
<p>Ajax只刷新局部网页的技术：</p>
</blockquote>
<pre><code>1.JavaScript：更新局部的网页
2.XML：一般用于请求数据和响应数据的封装
3.XMLHttpRequest对象：发送请求到服务器并获得返回结果(该对象是整个Ajax技术的核心，提供异步发送请求的能力)
4.异步：发送请求后不等返回结果，由回调函数处理结果
</code></pre><p>0.open()方法 建立与服务器的连接</p>
<pre><code>method：post/get 该参数指定请求的http方法
URL：该参数指定请求的地址
async：该参数指定是否使用异步请求
setRequestHeader：设置请求头信息
</code></pre><p>1.load() 方法是简单但强大的 AJAX 方法<br>作用：从服务器加载数据，并把返回的数据放入被选元素中</p>
<pre><code>1.URL参数规定所希望加载的URL 
2.data参数规定与请求一同发送的查询字符串键值对集合
语法：$(selector).load(URL,data,callback); 
如：
    $(&quot;#hello&quot;).load(&quot;text.html&quot;);
</code></pre><p>2.$.get() 方法<br>作用：通过 HTTP GET 请求从服务器上请求数据</p>
<pre><code>1.URL(String) 请求的HTML网页的URL地址
2.data 传递的数据 callback(data,status)：请求完成时的回调函数，data指从服务器响应的地址，status 指服务器请求的响应状态
语法：$.get(URL，data,callback)

    URL 参数规定您希望请求的 URL 
    callback 参数是请求成功后所执行的函数名(可选)
</code></pre><blockquote>
<p>语法：$.get(URL,callback);</p>
</blockquote>
<p>3.$.post() 方法通过 HTTP POST 请求向服务器提交数据</p>
<pre><code>1.URL 参数规定您希望请求的 URL 
2.data 参数规定连同请求发送的数据(可选) 
3.callback参数是请求成功后所执行的函数名(可选)
</code></pre><blockquote>
<p>语法：$.post(URL,data,callback); </p>
</blockquote>
<blockquote>
<blockquote>
<p>get与post请求的区别：1.get方法通常用来从指定的资源请求数据(可用于缓存、保存浏览器历史记录、只应当用于取回数据)。2.post方法通常用来向指定的资源提交要被处理的数据(post请求不会被缓存、请求不会保存在浏览器历史记录中、对请求数据长度没有限制、主要是向服务器提交数据，特别是大批量的数据)</p>
</blockquote>
</blockquote>
<p>4.ajax() 该方法通过HTTP请求加载远程数据，是jQurey底层AJAX实现，$.ajax() 返回其创建的 XMLHttpRequest 对象，在最简单的情况下，$.ajax()可以不带任何参数直接使用。</p>
<p>注意：所有的选项都可以通过 $.ajaxSetup() 函数来全局设置</p>
<blockquote>
<p>语法：jQuery.ajax([settings]) </p>
<blockquote>
<p>settings：用于配置AJAX请求的键值对集合 可以通过$.ajaxSetup() 设置任何选项的默认值</p>
</blockquote>
</blockquote>
<pre><code>该方法常见的参数：

    URL：发送请求的地址
    type：请求的方法(get/post)
    timeout：设置请求超时时间
    async：默认为true，表示为异步请求，false表示为同步请求
    beforeSend：发送请求前触发该事件
    cache：默认为true，表示从浏览器缓存中加载请求信息
    complete：请求结束后触发该事件
    contentType：发送信息到服务器时内容编码的类型
    data：发送到服务器的数据
    dataType：预期服务器返回的数据类型
    error：表示请求失败时调用的方法
    global：设置为false将不会触发全局ajax事件
    ifModified：仅在服务器数据改变时获取新数据 
    processData：发送的数据将被转换为对象 
    success：请求成功后回调函数
</code></pre><p>5.ajax提交form表单方法</p>
<p>在日常项目中经常使用到ajax提交form表单，而ajax提交表单有两种方式：</p>
<pre><code>1.无返回结果，直接将表单交给后台，让后台直接处理 最简单的：$(“#formid”).submit();//直接将form表单提交到后台。

2.有返回结果的，在这种情况下，后台不管执行成功还是失败，最终的信息都需要返回到前台。而ajax本身属于有返回结果的一类，其中的success方法就是处理后台返回结果的。

ajax提交表单有返回结果的两种实现方式：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将表单数据序列化</span><br><span class="line"></span><br><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;  </span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    type: &quot;POST&quot;,  </span><br><span class="line">   	//请求的类型 </span><br><span class="line">	url:your-url,  </span><br><span class="line">    //请求的路径</span><br><span class="line">	data:$(&apos;#yourformid&apos;).serialize(),  </span><br><span class="line">    //将数据序列化</span><br><span class="line">	async: false,  </span><br><span class="line">    //异步请求否</span><br><span class="line">	error: function(request) &#123;  </span><br><span class="line">    //发生错误调用函数</span><br><span class="line">		alert(&quot;Connection error&quot;);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    success: function(data) &#123;  </span><br><span class="line">	//成功调用的函数        </span><br><span class="line">	//接收后台返回的结果  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用这种方法的前提是form表单中要有name属性，后台获取的键值对为key=name值，value=各项值 无论是input标签还是span标签或者其他标签一定要有name属性，没有name属性，后台是获取不到该项的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.通过窗口查看form提交</span><br><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;  </span><br><span class="line">    //提交表单  </span><br><span class="line">  	var obj = document.getElementById(&quot;xx_iframe&quot;).contentWindow;  </span><br><span class="line">  	obj.$(&quot;#yourform&quot;).form(&quot;submit&quot;,&#123;  </span><br><span class="line">    success:function(data)&#123;  </span><br><span class="line">    //对结果处理  </span><br><span class="line">    &#125;);&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>注意：ajax中封装的post、get请求都是有返回结果的一类</p>
</blockquote>
<p>6.serizlize()方法<br><br>作用：将表单中的元素名称和值转换成URL参数格式。</p>
<pre><code>语法：$().serizlize() 
如：
    $(&quot;#form1&quot;).serizlize(); //表示把表单名称为form1的元素名称和值序列化
</code></pre><p>7.send() 方法<br>作用：该方法表示发送请求，其中参数为content表示指定请求的参数。</p>
<p>8.常用的属性</p>
<pre><code>1.onreadystatechange：指定回调函数
2.readyState：XMLHttpRequest的状态信息
3.status：http状态信息码
4.responseText：获取响应的文本内容
5.responseXML：获得响应的XML文档对象document
</code></pre><hr>
<h4 id="AJAX的封装"><a href="#AJAX的封装" class="headerlink" title="AJAX的封装"></a>AJAX的封装</h4><pre><code>1.函数封装
function ajax(url,Succ,Fail){    
    var aj=new XMLHttpRequest();     
    aj.open(&apos;Get&apos;,url,true);     
    aj.send();     
    aj.onreadystatechange=function(){        
        if(aj.readyState==4){            
            if(aj.status==200){                 
                Succ(aj.responseText)             
            }else{               
                    if(Fail){                     
                        Fail(aj.statusText)                 

                }            
            }         
        }    
    } 
}

2.获取JSON数据
&lt;input type=&quot;button&quot; value=&quot;测试按钮&quot;id=&quot;but&quot;&gt;     
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;     
    &lt;script&gt;        
        var but=document.getElementById(&quot;but&quot;);        
        var div1=document.getElementById(&quot;div1&quot;);         
        but.=function(){             
            ajax(&quot;test1.json&quot;,function(str){                
                var name=JSON.parse(str);                
                for(var i in name){                    
                    for(var j in name[i]){                           
                        var lis=document.createElement(&apos;li&apos;);                            lis.innerHTML=j+&apos;:&apos;+name[i][j];                            
                        div1.appendChild(lis);   
                    }  
                }    
            }),function(s){                 
                alert(s)   
            }   
        }    
    &lt;/script&gt;
</code></pre><h4 id="AJAX使用的步骤"><a href="#AJAX使用的步骤" class="headerlink" title="AJAX使用的步骤"></a>AJAX使用的步骤</h4><pre><code>1.创建XMLHttpRequest对象

    语法：

        var myAjax = new XMLHttpRequest();
    或  var myAjax = new ActiveXObject(&quot;microsoft.xmlhttp&quot;);

2.open()方法连接服务器
3.send()方法发送请求给服务器

    2.向服务器发送请求：使用open()方法和send()方法

        语法：

            open(method,url,async) 表示规定请求的类型、URL以及是否异步请求，method：请求类型，get/post
                                    url:文件在服务器上的位置 

            send(string):string 仅用于post请求

3.服务器响应

    如果我们需要获取来自服务器的响应，需要使用XMLHttpRequest对象的responseText或responseXML属性

        responseText属性：该属性返回字符串形式的响应
        responseXML属性：如果来自服务器的响应是XML，同时需要作为XML对象进行解析，需要使用responseXML属性


4.onreadystatechange属性连接函数responseText属性从服务器返回的数据

    onreadystatechange 事件，当请求被发送到服务器时，我们需要执行一些基于响应的任务。 
    每当 readyState 改变时，就会触发 onreadystatechange 事件。

        XMLHttpRequest 对象的三个重要的属性：
            onreadystatechange:存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。

            readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
                0: 请求未初始化
                1: 服务器连接已建立
                2: 请求已接收
                3: 请求处理中
                4: 请求已完成，且响应已就绪

            status:200: &quot;OK&quot;/404: 未找到页面
</code></pre><blockquote>
<p>注意：我们能够使用Ajax验证用户名是否存在。</p>
</blockquote>
<pre><code>步骤：
    1.使用文本框的onblur事件
    2.使用ajax技术实现异步交互
        1.创建XMLHttpRequest对象
        2.通过XMLHttpRequest对象设置请求信息
        3.向服务器发送请求
        4.创建回调函数，根据响应状态动态更新页面
</code></pre><blockquote>
<p>扩展：四种常用的ajax请求方式：</p>
</blockquote>
<pre><code>&lt;br&gt;
    1.$.ajax()返回其创建的 XMLHttpRequest 对象

        $.ajax() 只有一个参数：参数 key/value 对象，包含各配置及回调函数信息，如果你指定了dataType选项，那么需要保证服务器返回正确的MIME信息，(如 xml 返回 &quot;text/xml&quot;)

    2.通过远程http get请求载入信息

        比较复杂的$.ajax来说，get请求功能更简单，请求成功时可以调用回调函数，出错时还是使用$.ajax

    3.通过远程http post请求载入信息

        post请求相对比较简单，请求成功时可以调用回调函数，出错时也使用$.ajax请求

    4.通过http get请求载入JSON数据

        方法：$.getJSON(url,function(){})
</code></pre><hr>
<blockquote>
<p>扩展：jQuery DataTable 前端插件(与后端完全分离) 强大的功能支持：排序、分页、搜索等</p>
</blockquote>
<blockquote>
<blockquote>
<p>主要特点：自动分页处理、即时表格数据过滤、数据排序以及数据类型自动检测、自动处理列宽度、可通过CSS定制样式、支持隐藏列、易用、可扩展性和灵活性、国际化、动态创建表格。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>使用方法：<br>        1.首先构建我们需要的数据列表，以及页面显示表格<br>        2.在jQuery DataTable官网下载一份js库<br>        3.在页面中引入这两个文件，然后在两个文件要在最前面以至于能够被引用到<br>        4.编写前端程序，需要使用到ajax对后台进行请求，所以在配置datatable的时候，要加上{“serverSide”:ture}，以保证页面在加载时就请求后台，以及每次对datatable进行操作时也是请求后台。<br>        5.配置数据返回对应具体的列，在Datatable中，属性columns用来配置具体列的属性，包括对应的数据列名，是否支持搜索，是否显示，是否支持排序等。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>列 columns 和 columnDefs基本使用
    相同点：达到相同的效果
    不同点：作用和使用不一样
        1.columns：设置特定列的初始化属性，可以定义数组设置多列，数组长度必须等于表格的数量，只想使用默认值可以设为“NULL”，数组每个元素只能设置单列的属性。
        2.columnDefs：与columns非常相似，该数组可以针对特定的列，多列或者所有列定义。数组可以任意长度。通过targets参数设置一个列或者多列
            属性定义：
                0或正整数 - 从左边的列索引计数 
                负整数 - 列索引从右边计数 
                一个字符串 - 类名称将被匹配上的TH为列 
                字符串“_all” - 所有的列（即指定一个默认值） 
                两个参数可以同时使用，但是columns定义的优先级最高。 
                当columnDefs里对同一列有多个定义时，最开始的定义优先级最高
</code></pre><blockquote>
<p>注意：<br>DataTables的一些基础属性配置:    </p>
</blockquote>
<pre><code>    &quot;bPaginate&quot;: true, //翻页功能 
    &quot;bLengthChange&quot;: true, //改变每页显示数据数量 
    &quot;bFilter&quot;: true, //过滤功能 
    &quot;bSort&quot;: false, //排序功能 
    &quot;bInfo&quot;: true,//页脚信息 
    &quot;bAutoWidth&quot;: true//自动宽度 
    &quot;sPaginationType&quot;: &quot;full_numbers&quot;  //分页样式

1.数据排序：&quot;aaSorting&quot;: [ [ 4, &quot;desc&quot; ] ] };//表示从第0列开始，以第四列倒序排序

2.隐藏某列：

3.国际化：
</code></pre><hr>
<blockquote>
<p>扩展1</p>
<blockquote>
<p>控制台属性和方法：</p>
<blockquote>
<p>1.console.log 用于输出普通信息  2.console.info 用于输出提示性信息  3.console.error用于输出错误信息  4.console.warn用于输出警示信息    5.console.debug用于输出调试信息</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>注意：console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种</p>
</blockquote>
<pre><code>1.%o  //此占位符用来查看对象内部情况
2.
</code></pre><p>案例：</p>
<pre><code>console.log(&quot;%d年%d月%d日&quot;,2011,3,26);//表示输出日期
console.log(&quot;圆周率是%f&quot;,3.1415926);//输出数学表达式
</code></pre><p>控制台方法：</p>
<pre><code>1.console.assert 对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台。
2.console.count 用于统计代码被执行的次数。&lt;br/&gt;
3.console.dir 直接将该DOM结点以DOM树的结构进行输出，可以详细查对象的方法发展等。&lt;br/&gt;
4.console.time 计时开始&lt;br/&gt;
5.console.timeEnd 计时结束
6.console.trace 堆栈跟踪相关的调试
</code></pre><blockquote>
<p>扩展2</p>
<blockquote>
<p>jquery setTimeout()函数使用方法</p>
<blockquote>
<p>该方法表示从载入后延迟指定的时间去执行一个表达式或者是函数，仅仅执行一次。与<code>window.clean Timeout</code> 一起使用</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>window.location.reload()函数</p>
<blockquote>
<p>JS中实现刷新页面的方法，浏览器重新从服务器中请求资源</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="11-JSONP-JSON"><a href="#11-JSONP-JSON" class="headerlink" title="11.JSONP/JSON"></a>11.JSONP/JSON</h2><blockquote>
<p>简介：JSONP是JSON的一种使用模式，可以让网页从其他网站获取资料，实现跨域读取数据。</p>
<blockquote>
<p>同源策略：它是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。</p>
<blockquote>
<p>JSON.parse() 将数据转换为JavaScript对象。<br>语法：JSON.parse(text[, reviver])<br>text：一个有效的JSON字符串  reviver：转换结果的函数，将为对象的每个成员调用此函数</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="1-JSON-数组"><a href="#1-JSON-数组" class="headerlink" title="1.JSON 数组"></a>1.JSON 数组</h4><p>JSON数组在中括号中书写，数组可以包含多个对象。</p>
<pre><code>{
    &quot;sites&quot;: [
    { &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; }, 
    { &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; }, 
    { &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; }
    ]
}
</code></pre><h4 id="2-JSON使用JavaScript语法"><a href="#2-JSON使用JavaScript语法" class="headerlink" title="2.JSON使用JavaScript语法"></a>2.JSON使用JavaScript语法</h4><p>JSON使用JavaScript语法。通过JavaScript可以创建一个对象数组，并赋值。</p>
<pre><code>var sites = [
    { &quot;name&quot;:&quot;runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; }, 
    { &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; }, 
    { &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; }
];
</code></pre><blockquote>
<p>注意：JSON文件的类型是”.json” JSON 文本的MIME类型是”application/json”</p>
</blockquote>
<h4 id="3-JSON-对象"><a href="#3-JSON-对象" class="headerlink" title="3.JSON 对象"></a>3.JSON 对象</h4><pre><code>1.循环对象：

    使用for-in来循环对象的属性

    &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var myobject = {&quot;name&quot;:&quot;username&quot;,&quot;alexa&quot;:1000,&quot;site&quot;:null};
        for(x in myobject){
            document.getElementById(&quot;demo&quot;).innerHTML+=myobject[x]+&quot;&lt;br&gt;&quot;;
        }
    &lt;/script&gt;
</code></pre><h4 id="4-JSON-parse"><a href="#4-JSON-parse" class="headerlink" title="4.JSON.parse()"></a>4.JSON.parse()</h4><p>因为<code>JSON</code>经常用于与服务器交换数据，在接收服务器数据时一般是字符串，所以我们可以使用<code>JSON.parse()</code>方法将数据转换为<code>JavaScript</code>对象。</p>
<h4 id="5-JSON-stringify"><a href="#5-JSON-stringify" class="headerlink" title="5.JSON.stringify()"></a>5.JSON.stringify()</h4><p>因为JSON用于与服务端交换数据，向服务器发送数据时一般是字符串。我们可以使用 <code>JSON.stringify()</code> 方法将 <code>JavaScript</code> 对象转换为字符串。</p>
<hr>
<h2 id="12-jQuery-EasyUI"><a href="#12-jQuery-EasyUI" class="headerlink" title="12.jQuery EasyUI"></a>12.jQuery EasyUI</h2><p>jQuery EasyUI是一个基于jQuery的框架，集成了各种用户界面（UI）插件。jQuery EasyUI能够帮助Web开发者更轻松的打造出功能丰富并且美观的UI界面。</p>
<pre><code>两种方法声明UI组件：
    1.直接在HTML声明组件

        &lt;div class=&quot;easyui-dialog&quot; style=&quot;width:400px;height:200px&quot;data-options=&quot;title:&apos;My Dialog&apos;,collapsible:true,iconCls:&apos;icon-ok&apos;,onOpen:function(){}&quot;&gt;
                    dialog content.
        &lt;/div&gt;

    2.编写JavaScript来创建组件

        &lt;input id=&quot;cc&quot; style=&quot;width:200px&quot; /&gt; //HTML标签

        $(&apos;#cc&apos;).combobox({        //jQuery语法
            url: ...,
            required: true,
            valueField: &apos;id&apos;,
            textField: &apos;text&apos;
        });
</code></pre><p>EasyUI应用 创建CRUD应用</p>
<hr>
<h2 id="13-jQuery-Validate验证详解"><a href="#13-jQuery-Validate验证详解" class="headerlink" title="13.jQuery Validate验证详解"></a>13.jQuery Validate验证详解</h2><p>jQuery Validate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。</p>
<p>1.导入JS文件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jQuery.1.8.3.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt; </span><br><span class="line">&lt;script src=<span class="string">"jquery.validate.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt; </span><br><span class="line">&lt;script src=<span class="string">"messages_zh.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.默认校验规则</p>
<p>3.默认的提示</p>
<p>4.使用方法</p>
<pre><code>1.通过属性方式添加验证规则

2.metadata用法(将校验规则写到控件中或者在 class 属性填写规则（效果一样）)
注意：使用class=&quot;{}&quot;的方式需要引入包：jquery.metadata.js


3.将校验规则写到JS代码中
</code></pre><hr>
<h2 id="14-jQuery-树型菜单插件-Treeview"><a href="#14-jQuery-树型菜单插件-Treeview" class="headerlink" title="14.jQuery 树型菜单插件(Treeview)"></a>14.jQuery 树型菜单插件(Treeview)</h2><p>jQuery Treeview提供了一个无序灵活的树形菜单</p>
<p>1.首先引入 CSS 与 JS 文件</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://static.runoob.com/assets/js/jquery-treeview/jquery.treeview.css&quot;/&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;http://static.runoob.com/assets/js/jquery-treeview/screen.css&quot;/&gt;

&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://static.runoob.com/assets/js/jquery-treeview/jquery.cookie.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://static.runoob.com/assets/js/jquery-treeview/jquery.treeview.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
</code></pre><p>2.然后编写 JS 程序</p>
<pre><code>    $(&quot;#browser&quot;).treeview({
    toggle: function() {
        console.log(&quot;%s was toggled.&quot;, $(this).find(&quot;&gt;span&quot;).text());
    }
});
</code></pre><p>3.最后编写 HTML 文件</p>
<pre><code>//在类里面声明filetree treeview-famfamfam
&lt;ul id=&quot;browser&quot; class=&quot;filetree treeview-famfamfam&quot;&gt;
&lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Folder 1&lt;/span&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Item 1.1&lt;/span&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;span class=&quot;file&quot;&gt;Item 1.1.1&lt;/span&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Folder 2&lt;/span&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Subfolder 2.1&lt;/span&gt;
                    &lt;ul id=&quot;folder21&quot;&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.1.1&lt;/span&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.1.2&lt;/span&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;span class=&quot;folder&quot;&gt;Subfolder 2.2&lt;/span&gt;
                    &lt;ul&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.2.1&lt;/span&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 2.2.2&lt;/span&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li class=&quot;closed&quot;&gt;&lt;span class=&quot;folder&quot;&gt;Folder 3 (closed at start)&lt;/span&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 3.1&lt;/span&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;span class=&quot;file&quot;&gt;File 4&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>4.最后加上相关的按钮或者链接（整个HTML页面完成）</p>
<hr>
<h2 id="15-jQuery-Tooltip"><a href="#15-jQuery-Tooltip" class="headerlink" title="15.jQuery Tooltip"></a>15.jQuery Tooltip</h2><blockquote>
<p>提示：jQuery Tooltip 取代了原生的工具提示框，让其可以自定义，我们只需要调整其内容、位置和外观便可。</p>
</blockquote>
<p>使用步骤：<br>1.</p>
<hr>
<h2 id="16-jQuery-Prettydate"><a href="#16-jQuery-Prettydate" class="headerlink" title="16.jQuery Prettydate"></a>16.jQuery Prettydate</h2><p>jQuery Prettydate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。</p>
<p>1.使用方法<br>如果我们需要使用到此插件，需要我们在<code>title</code>标签中加上带有<code>ISO8601</code>日期</p>
<pre><code>&lt;a title=&quot;2008-01-28T20:24:17Z&quot;&gt;January 28th, 2008&lt;/a&gt; 
&lt;a title=&quot;2008-01-27T22:24:17Z&quot;&gt;January 27th, 2008&lt;/a&gt; 
&lt;a title=&quot;2008-01-26T22:24:17Z&quot;&gt;January 26th, 2008&lt;/a&gt;
</code></pre><p>然后对它们使用prettyDate()方法</p>
<pre><code>$(function() { $(&quot;a&quot;).prettyDate(); });
</code></pre><hr>
<h2 id="17-Password-Validation-插件"><a href="#17-Password-Validation-插件" class="headerlink" title="17.Password Validation 插件"></a>17.Password Validation 插件</h2><p>对于密码验证，这一插件提供了两种组件：<br>1.<br>2.</p>
<p>1.使用方式<br>如果我们需要使用到<code>password validation</code>插件，我们需要添加一个<code>class=&quot;password&quot;</code>到<code>input</code>中，同时添加<code>显示强度</code>的基本标记在表单的需要显示的地方。</p>
<pre><code>//首先设置验证器的默认情况，然后编写验证器的验证规则
jQuery.validator.setDefaults({
        debug: true,
        success: &quot;valid&quot;
});
$( &quot;#myform&quot; ).validate({
    rules: {
        password: &quot;required&quot;,
        password_again: {
            equalTo: &quot;#password&quot;
        }
    }
});
</code></pre><hr>
<h2 id="18-jQuery-Growl-插件"><a href="#18-jQuery-Growl-插件" class="headerlink" title="18.jQuery Growl 插件"></a>18.jQuery Growl 插件</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/undefined/mybatis/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Mybatis-FD"><a href="#Mybatis-FD" class="headerlink" title="Mybatis - FD"></a>Mybatis - FD</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="1-原生态JDBC程序存在问题"><a href="#1-原生态JDBC程序存在问题" class="headerlink" title="1.原生态JDBC程序存在问题"></a>1.原生态JDBC程序存在问题</h4><pre><code>public static void main(String[] args) {
    //设置连接为null
    Connection connection = null;
    //设置预处理状态为null
    PreparedStatement preparedStatement = null;
    //设置结果集为null
    ResultSet resultSet = null;
    //检查异常并抛出异常
</code></pre><a id="more"></a>
<pre><code>    try {
        //1、加载数据库驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2、通过驱动管理类获取数据库链接
        connection =  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;);
        //3、定义sql语句 ?表示占位符
        String sql = &quot;select * from user where username = ?&quot;;
        //4、获取预处理statement
        preparedStatement = connection.prepareStatement(sql);
        //5、设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值
        preparedStatement.setString(1, &quot;Aaron&quot;);
        //6、向数据库发出sql执行查询，查询出结果集
        resultSet =  preparedStatement.executeQuery();
        //7、遍历查询结果集
        while(resultSet.next()){
            System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }finally{
        //8、释放资源
        if(resultSet!=null){
            try {
                resultSet.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(preparedStatement!=null){
            try {
                preparedStatement.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(connection!=null){
            try {
                connection.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
</code></pre><blockquote>
<p>总结：1.JDBC在使用过程中数据库连接会频繁开启和关闭，会严重影响到数据库的性能。2.在程序中存在硬编码，数据库部分以及SQL执行部分。</p>
</blockquote>
<h2 id="Mybatis-框架原理"><a href="#Mybatis-框架原理" class="headerlink" title="Mybatis 框架原理"></a>Mybatis 框架原理</h2><pre><code>1.mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息。映射文件配置了SQL执行相关的信息。

2.mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂(sqlSessionFactory)。

3.通过SqlSessionFactory(会话工厂)，可以创建SqlSession即会话。Mybatis是通过SqlSession来操作数据库的。

4.SqlSession(会话)其本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。

5.Executor执行器要处理的SQL信息是封装到一个底层对象 MappedStatement 中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括Java的简单类型、HashMap集合对象、POJO对象类型。
</code></pre><hr>
<h2 id="Mybatis-入门程序"><a href="#Mybatis-入门程序" class="headerlink" title="Mybatis 入门程序"></a>Mybatis 入门程序</h2><h4 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h4><pre><code>1.创建数据表
2.添加相关依赖文件
3.添加log4j.properties文件(因为mybatis使用的日志包是log4j(在classpath路径下创建该文件))

    # Global logging configuration
    log4j.rootLogger=DEBUG, stdout
    # Console output...
    log4j.appender.stdout=org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
</code></pre><blockquote>
<p>注意：日志级别在开发阶段设置成DEBUG，在生产阶段设置成INFO或者ERROR。</p>
</blockquote>
<pre><code>4.编程步骤
    1.创建PO类，根据需求创建
        Public class User {
            private int id;
            private String username;// 用户姓名
            private String sex;// 性别
            private Date birthday;// 生日
            private String address;// 地址
            //以及一系列的get/set方法
            }
</code></pre><blockquote>
<p>注意：创建的po类属性名称应该和数据库表中的列名一致，如果表中的列名带有下划线，那么PO类中对应的属性名要采用驼峰式命名。驼峰式命名：骆驼式命名法就是当变量名或函数名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。</p>
</blockquote>
<pre><code>2.创建全局配置文件SqlMapConfig.xml(是在classpath路径下创建配置文件)
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE configuration
    PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
    &lt;configuration&gt;
    &lt;!-- 配置mybatis的环境信息 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!-- 配置数据源，采用dbcp连接池 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!—驱动和URL设置--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;/configuration&gt;

3.编写映射文件(xxxMapper.xml(mapper接口的实现类))
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE mapper    
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

4.加载映射文件，在SqlMapConfig.xml中进行加载
    &lt;!-- 加载mapper --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;
    &lt;/mappers&gt;

5.编写测试程序，即编写Java代码，连接并操作数据库
    public class MybatisFirst {

    @Test
    public void findUserByIdTest() throws Exception{
        //1、读取配置文件
        String resource = &quot;SqlMapConfig.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        //2、根据配置文件创建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //3、SqlSessionFactory创建SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //4、SqlSession执行statement，并返回映射结果
        //第一个参数：statement的id，建议：namespace.statementId（确保唯一）
        //第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致
        User user = sqlSession.selectOne(&quot;findUserById&quot;, 1);
        //打印输出结果集
        System.out.println(user);
        //5、关闭SqlSession
        sqlSession.close();
    }
}
</code></pre><blockquote>
<p>总结：1.首先读取配置文件，然后通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。<br>2.通过SqlSessionFactory创建SqlSession，然后调用SqlSession的操作数据库的方法。<br>3.最后关闭SqlSession。</p>
</blockquote>
<hr>
<blockquote>
<p>小结</p>
<blockquote>
<p>1.parameterType 指定输入参数的Java类型，可以填写别名或Java类的全限定名。</p>
<blockquote>
<p>2.resultType 指定输出结果的Java类型，可以填写别名或Java类的全限定名。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>#{}和${}
    #{}：相当于预处理中的占位符？。

    #{}里面的参数表示接收java输入参数的名称。

    #{}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，#{}里面可以是value，也可以是其他。

    #{}可以防止SQL注入。

    ${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。

    ${}会引起SQL注入，所以要谨慎使用。

    ${}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，${}里面只能是value。

selectOne：只能查询0或1条记录，大于1条记录的话，会报错
selectList：可以查询0或N条记录
</code></pre><hr>
<h2 id="Mybatis-开发DAO"><a href="#Mybatis-开发DAO" class="headerlink" title="Mybatis 开发DAO"></a>Mybatis 开发DAO</h2><p>我们知道，mybatis在项目开发中主要使用的地方就是开发DAO(数据访问层)。所以开发方式有两种。1.原始的DAO开发方式。2.Mapper代理开发方式。</p>
<h4 id="1-原始DAO开发方式"><a href="#1-原始DAO开发方式" class="headerlink" title="1.原始DAO开发方式"></a>1.原始DAO开发方式</h4><pre><code>实现步骤：
    1.根据需求创建po类
      这一步骤的实现所对应的属性名要与数据库中的属性名相对应
    2.编写全局配置文件
      这一步骤的实现是配置数据源等信息
    3.根据需求编写映射文件
      实现实体类与数据库之间的数据操作
    4.加载映射文件
    5.编写dao接口
        public interface UserDao {
            //根据用户ID来查询用户信息
            public User findUserById(int id);
            //根据用户名称来模糊查询用户信息列表
            public List&lt;User&gt; findUsersByName(String username);
            //添加用户
            public void insertUser(User user);
        }

    6.编写dao实现类
        public class UserDaoImpl implements UserDao {

            //注入SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;
            //使用构造方法来初始化SqlSessionFactory
            public UserDaoImpl(SqlSessionFactory sqlSessionFactory){
                this.sqlSessionFactory = sqlSessionFactory;
            }

            @Override
            public User findUserById(int id) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                //返回结果集
                return sqlSession.selectOne(&quot;test.findUserById&quot;, id);
            }

            @Override
            public List&lt;User&gt; findUsersByName(String username) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                return sqlSession.selectList(&quot;test.findUsersByName&quot;, username);
            }

            @Override
            public void insertUser(User user) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                sqlSession.insert(&quot;test.insertUser&quot;, user);
            }

        }

    7.编写测试代码
        public class UserDaoTest {

            //声明全局的SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;

            @Before
            //此方法在测试方法执行之前执行，spring开发方式
            public void setUp() throws Exception {
                // 1、读取配置文件
                String resource = &quot;SqlMapConfig.xml&quot;;
                InputStream inputStream = Resources.getResourceAsStream(resource);
                // 2、根据配置文件创建SqlSessionFactory
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            }

            @Test
            public void testFindUserById() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                User user = userDao.findUserById(1);

                System.out.println(user);
            }

            @Test
            public void testFindUsersByName() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                List&lt;User&gt; list = userDao.findUsersByName(&quot;小明&quot;);

                System.out.println(list);
            }

            @Test
            public void testInsertUser() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //构造User对象
                User user = new User();
                user.setUsername(&quot;东哥3&quot;);
                user.setAddress(&quot;清河宝盛西里3&quot;);

                //调用UserDao对象的方法
                userDao.insertUser(user);

                System.out.println(user.getId());
            }

        }
</code></pre><h4 id="2-mapper开发代理方式"><a href="#2-mapper开发代理方式" class="headerlink" title="2.mapper开发代理方式"></a>2.mapper开发代理方式</h4><p>使用Mapper代理的开发方式，我们只需要编写mapper接口，然后mybatis会自动为mapper接口生成动态代理实现类。</p>
<pre><code>1.mapper接口的全限定名要和mapper映射文件的namespace的值相同。
2.mapper接口的方法名称要和mapper映射文件中的statement的id相同。
3.mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。
4.mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致。
</code></pre><blockquote>
<p>提示：statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上，向数据库发送要执行的SQL语句，Statement对象用于执行不带参数的简单SQL语句。</p>
</blockquote>
<h2 id="Mybatis-映射文件"><a href="#Mybatis-映射文件" class="headerlink" title="Mybatis 映射文件"></a>Mybatis 映射文件</h2><pre><code>1.输入映射
    ParameterType

2.输出映射
    resultType

3.高级映射
    resultMap
</code></pre><h2 id="mybatis-高级映射"><a href="#mybatis-高级映射" class="headerlink" title="mybatis 高级映射"></a>mybatis 高级映射</h2><pre><code>1.mybatis框架执行过程：
  1.配置mybatis的配置文件(mybatis-config.xml)（名称不固定）。

  2.通过配置文件(mybatis-config.xml)，加载mybatis运行环境，创建SqlSessionFactory会话工厂,SqlSessionFactory在实际使用时按单例方式。

  3.通过SqlSessionFactory创建SqlSession，SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。

  4.调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。

  5.释放资源，关闭SqlSession

2.mybatis开发dao的方法
  1.使用原始的dao的方法
    这样需要编写dao接口和实现类，需要在dao实现类注入一个SqlSessionFactory工厂。

  2.mapper代理开发方法(推荐)
    0.编写mapper接口(dao接口)
      注意：在编写mapper.xml(映射文件)和mapper.java(接口)需要遵循开发规范

    1.mapper.xml中的namespace就是mapper.java的类的全路径名

    2.mapper.xml中statement的id值和mapper.java中方法名一致(如：insert/delete/update中的id值)

    3.mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法数据参数类型一致(parameterType类型与对应的接口方法参数类型一致)

    4.mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致(resultMap：定义出参，调用已经定义的&lt;resultMap&gt;&lt;/resultMap&gt;映射管理器的id值 

    resultType：定义出参，匹配普通Java类型或自定义pojo类型(出参类型若不指定，将为语句默认类型))
</code></pre><blockquote>
<p>注意：全局配置文件(mybatis-config.xml)可以配置properties属性、别名、mapper加载等。</p>
</blockquote>
<pre><code>3.输入映射
  1.parameterType：指定输入参数类型可以是简单类型、POJO、HashMap，而对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展。

4.输出映射
  1.resultType：查询到的列名和resultType指定的POJO的属性名一致，这样才能映射成功。
    作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中
    场合：

  2.resultMap：可以通过resultMap完成高级映射，如果查询到的列名和映射的POJO的属性名不一致时，通过resultMap设置别名和属性名之间的对应关系(映射关系)，可以完成映射。

    association
    作用：将关联查询信息映射到一个pojo对象中
    场合：为了方便查询关联信息可以使用association将关联 订单信息 映射为 用户对象 的pojo属性中。association适用于一对一查询。
</code></pre><blockquote>
<p>注意：使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap</p>
</blockquote>
<pre><code>collection
作用：将关联查询信息映射到一个list集合中
场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，而如果使用resultType无法将查询结果映射到list集合中。collection适用于一对多和多对多的查询。
</code></pre><blockquote>
<p>扩展：映射管理器<code>resultMap</code>：是<code>mybatis</code>中强大的工具，使用其可以进行 实体类之间 的映射，并且管理 结果和实体类 之间的映射关系。</p>
</blockquote>
<pre><code>resultMap映射管理器需要配置的属性：

    &lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;&lt;/resutlMap&gt;   
        id=&quot; &quot;:表示这个映射管理器的唯一标识，外部通过该值引用
        type = &quot; &quot;:表示需要映射的实体类

resultMap映射管理器需要配置的参数：

    &lt;id column = &quot; &quot; property= &quot; &quot; /&gt; 
        &lt;id&gt;标签指的是：结果集中结果唯一的列column(column：指定唯一标识用户信息的数据列)和实体属性property(property:映射到user实体类的哪个属性)的映射关系
            注意：&lt;id&gt;标签管理的列未必是主键列，需要根据具体需求指定

    &lt;result column= &quot; &quot; property=&quot; &quot; /&gt;  
        &lt;result&gt;标签指的是：结果集中普通列column和实体属性property的映射关系

resultMap映射管理器需要维护的关系：所谓关系维护是值在 主表查询时将其关联子表的结果也查询出来
</code></pre><hr>
<pre><code>resultMap元素中，允许有如下直接子元素：
    1.constructor：类在实例化时，用来注入结果到构造方法中,作用与result相同，同时可以标识出用这个字段值可以区分其他对象实例
        arg：注入到构造方法的一个普通结果
        idArg：ID参数，标记结果作为ID，可以帮助提高整体效能

    2.result：将数据表中的字段注入到Java对象属性中

    3.association：关联(一对一的关系)，表示在resultMap映射器中，通过&lt;association&gt;&lt;/association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来。

      作用：将关联查询的信息映射到一个POJO中
      &lt;association property=&quot;&quot; javaType=&quot;&quot;&gt;
          property：对象属性的名称，被维护实体在宿主实体(POJO)中的属性名
           javaType：对象属性的类型，被维护实体的类型
           column：所对应的外键字段名称
           select：使用另一个查询封装的结果

    4.collection：集合(一对多/多对多关系的维护)，对关联查询到的多条记录映射到集合对象中。

      作用：将关联查询用户信息映射到一个list集合中
      &lt;collection property=&quot;&quot; ofType=&quot;&quot;&gt;
      property=&quot;&quot; 将查询到的多条记录映射到相应的POJO类上对应的属性中
      ofType=&quot;&quot; 指定映射到List集合的pojo类型

    5.discriminator：使用结果集决定使用哪个个结果映射
</code></pre><blockquote>
<p>拓展：sql片段标签<sql>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用。</sql></p>
</blockquote>
<pre><code>注意：需要配置的属性，id=&quot;&quot; 表示需要改sql语句片段的唯一标识 引用：通过&lt;include refid=&quot;&quot;/&gt;标签引用，refid=&quot;&quot;中的值指向需要引用的&lt;sql&gt;中的id=&quot;&quot;属性。
</code></pre><blockquote>
<p>注意：在resultMap中应该注意两点</p>
</blockquote>
<pre><code>1.关联关系的维护可以根据实体类之间的实际情况进行嵌套维护

2.出现重复列名的处理，在实际操作过程中，查询到的结果可能会出现相同的列名，这样会对映射到实体属性带来影响甚至报错，所以可以通过对列取别名的方式来处理
</code></pre><p>5.高级映射<br>  1.将关联查询的列映射到一个POJO属性中(一对一)<br>  2.将关联查询的列映射到一个List<pojo>中(一对多)</pojo></p>
<hr>
<h2 id="mybatis动态sql语句"><a href="#mybatis动态sql语句" class="headerlink" title="mybatis动态sql语句"></a>mybatis动态sql语句</h2><p>6.常用的动态语句标签(通过动态sql标签可以进行条件判断，条件遍历等操作从而能够满足结果中的需要)</p>
<pre><code>&lt;where&gt;：这一标签的使用可以代替sql语句中的where关键字，一般放置在条件查询的最外层 
   where后面跟查询条件，简化sql语句中判断条件的书写 此中，mybatis会智能的将首个and或or给忽略

&lt;if&gt;：这一标签配置属性test=&quot;条件字符串&quot;，判断是否满足条件

&lt;set&gt;：这一标签常用于&lt;update&gt;更新语句中，替代sql的set关键字，特别是在联合&lt;if&gt;进行判断是否条件时，可以有效方式当某个参数为空或者不合法是错误的更新到数据库中
 mybatis set标签的使用：sql语句中的最后一个逗号会被set标记自动忽略

&lt;trim&gt;：在mapper.xml中对statement的定义，可以使用&lt;trim&gt;标签来填充和隐藏sql语句。
    功能：1.如果标签体中有SQL语句，就把修饰后的SQL语句拼接到之前的SQL语句上，如果标签体中没有SQL语句，那么这标签相当于不存在。2.这四个属性的默认值都是空字符串。

      trim属性 prefix：前缀   suffix：后缀 

      &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;,&quot; suffixOverrides=&quot;,&quot;&gt;

      属性：
        1.prefix=&quot;(&quot; 在trim标签定义的内容前填充对应内容
        2.suffix=&quot;)&quot; 在trim标签定义的内容后填充对应内容

        3.prefixOverrides=&quot;,&quot;  在trim定义的中，隐藏头部对应的内容。这个属性指定一个字符串，这个字符串一定是SQL语句的前缀，如果不是前缀，这个属性不起作用。会用prefix属性指定的字符串替换掉这个属性指定的字符串。

        4.suffixOverrides=&quot;,&quot; 在trim定义的中，隐藏尾部对应的内容。这个属性指定一个字符串，这个字符串位一定是SQL语句的后缀，如果不是后缀，这个属性不起作用。其会用suffix属性指定的字符串替换这个属性指定的字符串。

标签组：
  &lt;choose&gt;
    &lt;when&gt; //此元素的作用与Java中的switch效果差不多
    &lt;/when&gt;
    &lt;otherwise&gt;
    &lt;/otherwise&gt;
  &lt;/choose&gt; 
  也是一个用于条件判断的标签组，和&lt;if&gt;的不同之处在于条件从&lt;choose&gt;进入，去匹配&lt;when&gt;中的添加，一旦匹配马上结束，若到找不到匹配项，将执行&lt;otherwise&gt;中的语句；可以理解为&lt;if&gt;是 &amp;&amp; 关系 &lt;choose&gt;是 || 关系

  &lt;foreach&gt;标签：遍历集合类型的条件(在实现 mybatis in 语句查询时特别有用)
  属性：collection=&quot;array/list&quot; 是数组类型还是集合类型
        item=&quot; &quot; 参数名
    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;  开始符号，分隔符号，结束符号
    index=&quot;&quot; 结束下标位置，不配置该参数时，默认为全部遍历
</code></pre><blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>MySQL JOIN语法
    join用于多表中字段之间的联系(...FROM table1(左表) INNER|LEFT|RIGHT JOIN table2(右表) ON condition)
大致功能：
    1.INNER JOIN（内连接 取两表的交集）：取得两个表中存在连接匹配关系的记录(产生一组同时符合A和B的数据)
    2.LEFT JOIN（左连接）：取得左表（table1）完全记录，即是右表（table2）并无对应匹配记录
    3.RIGHT JOIN（右连接）：与 LEFT JOIN 相反，取得右表（table2）完全记录，即是左表（table1）并无匹配对应记录

条件ON与Where的执行顺序
    ON：用来决定如何从B表中检索数据行
</code></pre><hr>
<h2 id="mybatis高级查询"><a href="#mybatis高级查询" class="headerlink" title="mybatis高级查询"></a>mybatis高级查询</h2><p>1.关联查询<br>  在查询一个结果的时候，查询出其他关联的结果集</p>
<p>2.子查询<br>  关联查询一般可以使用子查询来实现，但是一般情况下子查询的效率低于关联查询</p>
<p>3.集合查询<br>  集合查询是关联查询的一种，只不过它是一对多而已</p>
<p>4.mapper.xml源码分析</p>
<pre><code>1.namespace：对应mapper接口(类似dao接口)
2.resultMap：
  1.id：
</code></pre><p>5.一对一查询(resultType 实现)</p>
<p>使用resultType来进行一对一结果映射，查询出的列的个数和映射的属性的个数要一致。而且映射的属性要存在与一个大的对象中，它是一种平铺式的映射，即数据库查询出多少条记录，则映射成多少个对象。</p>
<pre><code>一对一查询(resultMap 实现)

使用resultMap来进行一对一结果映射，它是将关联对象添加到主信息的对象中，具体说是一种对象嵌套另一种对象的一种映射方式。

&lt;resultMap type=&quot;mybatis.po.OrdersExt&quot; id=&quot;OrdersAndUserRstMap&quot;&gt;
    &lt;!-- 订单信息 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
    &lt;!-- 对象嵌套映射 --&gt;
    &lt;!-- association：一对一关联映射 --&gt;
    &lt;!-- property：关联信息查询的结果将要映射的扩展类中的对象属性名称 --&gt;
    &lt;!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --&gt;
    //association：表示在resultMap映射器中，通过&lt;association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来
    &lt;association property=&quot;user&quot; javaType=&quot;mybatis.po.User&quot;&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;/association&gt;
</code></pre><blockquote>
<p>总结：在一对一映射结果时，使用<code>resultType</code>更加简单方便，如果有特殊要求(对象嵌套对象)时，需要使用<code>resultMap</code>进行映射，关联查询出其关联信息。</p>
</blockquote>
<p>6.一对多查询</p>
<pre><code>1.多对一的查询引入association，进行联合查询

     &lt;resultMap id=&quot;resultUserArticleList&quot; type=&quot;Article&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
            &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
            &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;
            &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
                    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
                    &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
                    &lt;result property=&quot;userAddress&quot; column=&quot;userAddress&quot; /&gt;            
            &lt;/association&gt;        
        &lt;/resultMap&gt;

    &lt;select id=&quot;getUserArticles&quot; parameterType=&quot;int&quot; resultMap=&quot;resultUserArticleList&quot;&gt;
           select user.id,user.userName,user.userAddress,article.id aid,article.title,article.content from user,article where user.id=article.userid and user.id=#{id}
    &lt;/select&gt;
</code></pre><blockquote>
<p>总结：在上述配置之后，将select语句与resultMap对应的映射结合起来，可以看出，用association来得到关联的用户，得到的所有文章都是同一个用户的。</p>
</blockquote>
<pre><code>2.复用已经定义好的resultMap，将association中对应的映射独立抽取出来，以至于能够达到复用的目的

    1.首先定义好一个resultMap
            &lt;resultMap type=&quot;User&quot; id=&quot;resultListUser&quot;&gt;
                &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
                &lt;result column=&quot;userName&quot; property=&quot;userName&quot; /&gt;
                &lt;result column=&quot;userAge&quot; property=&quot;userAge&quot; /&gt;
                &lt;result column=&quot;userAddress&quot; property=&quot;userAddress&quot; /&gt;
            &lt;/resultMap&gt;

    2.然后在新定义的resultMap中引用已定义的resultMap
        &lt;resultMap id=&quot;resultUserArticleList-2&quot; type=&quot;Article&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
                &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
                &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;        
                &lt;association property=&quot;user&quot; javaType=&quot;User&quot; resultMap=&quot;resultListUser&quot; /&gt;  //在这里使用association复用已经定义好的resultMap           
           &lt;/resultMap&gt;
</code></pre><p>7.多对多映射查询(只是一对多映射的特例)</p>
<pre><code>多对多映射查询只不过是一对多映射的特例，其是在一对多的基础上添加多个&lt;collection&gt;来表明多个数据表单之间的关系的。

如：

    1.定义resultMap

    &lt;!-- 查询用户即购买的商品信息的ResultMap --&gt;
    &lt;resultMap type=&quot;com.mybatis.entity.User&quot; id=&quot;userAndItemsResultMap&quot;&gt;
        &lt;!-- 用户信息 --&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!-- 订单信息
        一个用户对应多个订单，使用collection映射 
        在用户信息中关联映射商品订单信息--&gt;
        &lt;collection property=&quot;ordersList&quot; ofType=&quot;com.mybatis.entity.Orders&quot;&gt;
             &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
             &lt;result column=&quot;user_id&quot; property=&quot;userid&quot;/&gt;
            &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
            &lt;result column=&quot;createtime&quot; property=&quot;createTime&quot;/&gt;
            &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;

         &lt;!-- 订单明细
                 一个订单包括多个明细
                 在商品订单中关联映射商品订单的多个明细
              --&gt;
              &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.mybatis.entity.OrderDetail&quot;&gt;
                      &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
                     &lt;result column=&quot;items_id&quot;   property=&quot;itemsId&quot;/&gt;
                     &lt;result column=&quot;items_num&quot;  property=&quot;itemsNum&quot;/&gt;
                     &lt;result column=&quot;orders_id&quot;  property=&quot;ordersId&quot;/&gt;
                     &lt;!-- 商品信息
                          一个订单明细对应一个商品
                          然后这儿是一对一的关联映射，所以使用的association进行两者之间的映射 
                       --&gt;
                   &lt;association property=&quot;items&quot; javaType=&quot;com.mybatis.entity.Items&quot;&gt;
                       &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;
                       &lt;result column=&quot;items_name&quot; property=&quot;itemsName&quot;/&gt;
                       &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;
                       &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;
                   &lt;/association&gt;
              &lt;/collection&gt;
          &lt;/collection&gt;

    &lt;/resultMap&gt;
&lt;!-- 查询用户及用户购买的商品信息，使用resulaMap--&gt;

2.定义statement(statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上向数据库发送要执行的SQL语句，Statement用于执行不带参数的简单SQL语句)

&lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;userAndItemsResultMap&quot;&gt;
        SELECT 
               t1.*,
               t2.username,
               t2.sex,
               t2.address,
               t3.id orderdetail_id,
               t3.items_id,
               t3.items_num,
               t3.orders_id,
               t4.itemsname items_name,
               t4.detail items_detail,
               t4.price items_price
        FROM
              orders t1,
              t_user t2,
              orderdetail t3,
              items t4
        WHERE t1.user_id =  t2.id AND  t3.orders_id=t1.id AND t3.items_id = t4.id
&lt;/select&gt;
</code></pre><blockquote>
<p>扩展<br><br>为了验证上述得到的结果是否正确，可以对其进行junit测试。</p>
</blockquote>
<pre><code>public class OrdersCustomMapperTest {
    //创建会话工厂
    private SqlSessionFactory sqlSessionFactory;
    //查询订单，关联查询用户信息，使用resultType实现的测试
    @Test
    public void TestFindOrdersUser() {
        //利用会话工厂创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 创建代理对象
        OrdersCustomMapper oc = sqlSession.getMapper(OrdersCustomMapper.class);
        // 调用mapper接口中的方法
        List&lt;OrdersCustom&gt; list = oc.findOrdersUser();
        //作为验证是否输出的list是否和要查询的结果正确
        System.out.println(list);
        //关闭会话
        sqlSession.close();
}
</code></pre><hr>
<h1 id="mybatis开发总结"><a href="#mybatis开发总结" class="headerlink" title="mybatis开发总结"></a>mybatis开发总结</h1><pre><code>1.一般的查询直接返回实体类型即可，而对于关联查询，处理方式之一就是：自己构造一个resultMap，名称为Map1。然后将自己所需要的字段在新建的resultMap中做一个映射，然后将查询结果设置为新建的Map1。
  注意：在Map1中可以多映射一些字段，为空的查询默认不映射

2.在Mapper层接口，我们一般设置该方法的返回值类型是：List&lt;Map&lt;String,Object&gt;&gt; 每一个list里面放有很多的map键值对

3.#{} 表示一个占位符，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，此外，#{}可以有效防止sql注入
  ${} 表示拼接sql串，通过${}可以将parameterType传入的内容拼接在sql中不进行jdbc类型转换

4.mybatis解决JDBC编程问题
  1.在SqlMapConfig.xml中配置数据库连接池管理数据库连接可以解决因为数据库频繁创建、释放连接而影响系统性能的问题

  2.模糊查询，resultType：表示是List的泛型类型 ${value} 固定写法只能写value表示拼接字符串
</code></pre><hr>
<h2 id="Mybatis整合Spring"><a href="#Mybatis整合Spring" class="headerlink" title="Mybatis整合Spring"></a>Mybatis整合Spring</h2><p>1.整合思路：</p>
<pre><code>1.数据源信息交给Spring管理
2.SqlSessionFactory交给Spring进行单例管理
3.由Spring来管理原始DAO的实现类或者Mapper代理的代理类
</code></pre><h4 id="2-1-具体整合步骤1："><a href="#2-1-具体整合步骤1：" class="headerlink" title="2.1 具体整合步骤1："></a>2.1 具体整合步骤1：</h4><pre><code>1.Mybatis
  1.在配置文件文件夹(config)下创建SqlMapConfig.xml
  2.配置属性文件(db.properties/log4j.properties)

注意：mybatis的配置文件中的数据源配置去掉，由spring进行管理配置。

2.Spring
  1.在配置文件文件夹(config)下创建application.xml
    1.加载Java的配置文件
    &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;
    2.创建数据源
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    //将数据库的驱动(driverClassName)、URL、username、password、maxActive、maxIdle属性值配置完

    3.配置SqlSessionFactory
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        //1.指定mybatis的全局配置文件路径
        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;&gt;
        //2.配置数据源
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3.整合代码
  1.原始DAO开发方式
    1.映射文件(User.xml)
    2.DAO接口代码以及DAO的实现类代码
    3.在application.xml中配置UserDao的实现类
        &lt;bean id=&quot;userDao&quot; class=&quot;xxx.xx.xxx.UserDaoImpl&quot;&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/proerty&gt;
        &lt;/bean&gt;
    4.编写测试代码

  2.mapper代理的方式
    1.映射文件(UserMapper.xml)
    2.Mapper接口
    3.配置mapper代理类
    1.单个mapper代理类的配置
        &lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
            //设置代理类接口
            &lt;property name=&quot;mapperInterface&quot; value=&quot;com.xx.xxx.xx.UserMapper&quot;&gt;&lt;/property&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;    
        &lt;/bean&gt;
    2.批量设置mapper代理类

              &lt;!--批量配置mapper代理类，默认bean的id为类名首字母小写--&gt;
            //通过MapperScannerConfigurer批量扫描创建代理对象
            &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
                &lt;!--配置扫描包--&gt;
                &lt;property name=&quot;basePackage&quot; value=&quot;cn.edu.xidian.c2.mapper&quot; /&gt;
                &lt;!--只有一个sqlSessionFactory时，默认不需要配置SqlSessionFactory,单独配置也可以--&gt;
                &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
</code></pre><hr>
<h4 id="2-2-具体整合步骤2："><a href="#2-2-具体整合步骤2：" class="headerlink" title="2.2 具体整合步骤2："></a>2.2 具体整合步骤2：</h4><pre><code>1.Maven引入需要的jar包(添加依赖 基本的依赖)

2.Spring与Mybatis的整合

  1.建立JDBC属性文件(jdbc.properties 文件编码改为utf-8)
  2.建立spring-mybatis.xml配置文件(用来完成spring和mybatis整合 主要是：自动扫描、自动注入、配置数据库)

3.Log4j的配置

  配置LOG4j的目的是为了更方便测试，使用日志来输出信息，然后所有的项目基本上都是这样一个基本的配置

  1.建立log4j.properties配置文件

4.JUnit测试

  1.创建测试用表
  2.利用MyBatis Generator自动创建代码 这个根据表自动创建实体类、mybatis映射文件、DAO接口

    使用MyBatis Generator自动创建代码 

  3.建立Service接口和实现类

  4.建立测试类

5.整合SpringMVC(springmvc的配置文件单独放，然后在web.xml文件中配置整合)

  1.配置springmvc.xml(主要是自动扫描控制器、视图模式、注解启动这三个的配置)
  2.配置web.xml文件 这里对spring-mybatis.xml配置文件的引入以及配置springmvc的servlet
</code></pre><hr>
<h2 id="Mybatis的逆向工程"><a href="#Mybatis的逆向工程" class="headerlink" title="Mybatis的逆向工程"></a>Mybatis的逆向工程</h2><p>概念：Mybatis提供来一个逆向工程工具，通过逆向工程，可以帮助程序员根据数据表单表来生成po类、mapper映射文件、mapper接口。<br>      就是通过数据库中的单表自动生成Java代码。</p>
<p>具体笔记见mybatis教案</p>
<h4 id="1-逆向工程使用步骤："><a href="#1-逆向工程使用步骤：" class="headerlink" title="1.逆向工程使用步骤："></a>1.逆向工程使用步骤：</h4><pre><code>1.创建generator配置文件
  generator.xml文件内容可以从逆向工程的jar包下的docs目录下的index.html文件中找到相关的源代码

2.使用java类来执行逆向工程

  public class Generator {
    public static void main(String[] args)  throws Exception{
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        File configFile = new File(&quot;config/generator.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    }

}

3.把生成的代码拷贝到项目中
  如果正式项目中已经有po类所在的包了，那么就只需要拷贝po类到指定包下就可以。如果正式项目中没有po包，那么就把逆向工程中整个po类的包拷贝过去。
Mapper.xml和mapper.java的拷贝与po类一样


4.在正式项目中使用逆向工程生成的代码

  public class ItemsMapperTest {

// spring上下文
private ApplicationContext ctx;

@Before
public void setUp() throws Exception {
    // 读取spring的上下文，然后封装到ctx
    ctx = new ClassPathXmlApplicationContext(
            &quot;spring/applicationContext.xml&quot;);
}

@Test
public void testSelectByExample() {
    ItemsMapper mapper = (ItemsMapper) ctx.getBean(&quot;itemsMapper&quot;);

    ItemsExample example = new ItemsExample();
    //使用它进行参数封装传递
    Criteria criteria = example.createCriteria();
    //设置参数
    criteria.andNameEqualTo(&quot;背包&quot;);

    List&lt;Items&gt; list = mapper.selectByExample(example);

    System.out.println(list);
}
</code></pre><p>}</p>
<pre><code>注意：
1.mapper.xml文件已经存在时，如果进行重新生成mapper.xml文件，内容不会被覆盖，而是进行mapper.xml文件内容的追加，结果会导致mybatis解析失败
解决方法：删除原来已经生成的mapper.xml文件再进行生成

2.mybatis自动生成的po以及mapper.java文件不是追加而是直接覆盖，所以不会出现此问题。
</code></pre><hr>
<h2 id="Mybatis-的查询缓存"><a href="#Mybatis-的查询缓存" class="headerlink" title="Mybatis 的查询缓存"></a>Mybatis 的查询缓存</h2><h4 id="1-mybatis缓存分析"><a href="#1-mybatis缓存分析" class="headerlink" title="1.mybatis缓存分析"></a>1.mybatis缓存分析</h4><p>mybatis提供查询缓存，如果缓存中有数据就不用从数据库中获取，用于减轻数据压力，提高系统性能。</p>
<pre><code>一级缓存：SqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)用于存储缓存数据，不同的sqlSession之间的缓存数据区域(HashMap)互相不影响。

二级缓存：mapper级别的缓存，多个SqlSession去操作同一个mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

注意：mybatis默认支持一级缓存

应用：在开发项目过程中，将mybatis与spring进行整合开发，事务控制在service中，一个service方法中包括很多mapper方法调用。
</code></pre><blockquote>
<p>注意：mybatis默认没有开启二级缓存</p>
</blockquote>
<h4 id="2-mybatis-开启二级缓存"><a href="#2-mybatis-开启二级缓存" class="headerlink" title="2.mybatis 开启二级缓存"></a>2.mybatis 开启二级缓存</h4><pre><code>1.在核心配置文件SqlMapConfig.xml中添加开启二级缓存总开关
  &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;

2.在UserMapper映射文件中开启二级缓存（开启mapper下的namespace的二级缓存，默认使用mybatis提供的PerpetualCache）
  &lt;cache&gt;&lt;/cache&gt;

3.实现序列化(因为二级缓存的数据不一定都是存储在内存中的，所以需要给缓存的对象执行序列化，如果该类存在父类，也需要给父类实现序列化)
</code></pre><h4 id="3-mybatis-禁用二级缓存"><a href="#3-mybatis-禁用二级缓存" class="headerlink" title="3.mybatis 禁用二级缓存"></a>3.mybatis 禁用二级缓存</h4><pre><code>在statement中设置userCache=false禁用当前select语句的二级缓存，每次查询都要去数据库中查询，默认情况下是true，该statement使用二级缓存。

&lt;select id=&quot;findUserById&quot;  parameterType=&quot;int&quot;  resultType=&quot;cn.itcast.mybatis.po.User&quot;  useCache=&quot;true&quot;&gt;
        SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre><h4 id="4-mybatis刷新二级缓存"><a href="#4-mybatis刷新二级缓存" class="headerlink" title="4.mybatis刷新二级缓存"></a>4.mybatis刷新二级缓存</h4><pre><code>见mybatis教案
</code></pre><hr>
<h4 id="5-mybatis-延迟加载"><a href="#5-mybatis-延迟加载" class="headerlink" title="5.mybatis 延迟加载"></a>5.mybatis 延迟加载</h4><pre><code>见mybatis教案
</code></pre><hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h4 id="1-Spring-MVC"><a href="#1-Spring-MVC" class="headerlink" title="1.Spring MVC"></a>1.Spring MVC</h4><pre><code>作用于WEB层，相当于Controller，用来处理用户请求。例：用户在地址栏输入http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法(虽然中间可能会包含很多业务，但是这些都不是SpringMVC来处理)
最终将结果返回给用户，并且返回相应的页面(可以只返回json/xml等格式数据)

总结：SpringMVC只负责跟用户打交道，做前面和后面的活，中间的实现过程等业务不是它负责。
</code></pre><h4 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2.Spring"></a>2.Spring</h4><pre><code>最常见，经常用到的是IOC容器，其可以装载bean(Java中的类，也包括service dao里面的)有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。
</code></pre><h4 id="3-mybatis"><a href="#3-mybatis" class="headerlink" title="3.mybatis"></a>3.mybatis</h4><pre><code>1.能够自由控制SQL
2.可以使用xml的方式来组织管理我们的SQL
</code></pre><hr>
<p>1.SSM整合</p>
<pre><code>1.Java各种对象的区分

PO 持久对象(entity) PO每个属性基本上都对应数据库表里面的某个字段，完全是一个符合Java Bean规范的Java对象，没有增强别的属性和方法。持久对象是由&lt;insert&gt;&lt;/insert&gt;数据库创建，由数据库&lt;delete&gt;&lt;/delete&gt;删除的。基本上持久对象生命周期和数据库密切相关。

VO 值对象 通常用于业务层(Service层)之间的数据传输，与PO一样只包含数据,此外应该抽象出业务对象。表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。

DTO 数据传输对象 是一种设计模式之间传输数据的软件应用系统 作用仅在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。

POJO 简单的Java对象 实际上可以理解POJO为简单的实体类 方便开发者使用数据库中的数据表
</code></pre><hr>
<h2 id="DTO-数据传输对象（起到数据封装与隔离的作用）"><a href="#DTO-数据传输对象（起到数据封装与隔离的作用）" class="headerlink" title="DTO 数据传输对象（起到数据封装与隔离的作用）"></a>DTO 数据传输对象（起到数据封装与隔离的作用）</h2><p>在实际的项目中，DTO分为两层传输</p>
<pre><code>1.Service层向Controller层，这一层的DTO封装Service执行结果给Controller简化业务数据，只提取部分业务相关字段或补充处理相关字段，不同业务可能有不同的此类dto，具有业务相关性。

2.Controller层向WEB前端，这一层DTO封装Controller执行结果，返回前端WEB，请求返回实体封装类，适用于所有ajax请求返回的类型实体，无业务相关性。
</code></pre><hr>
<h2 id="SSM整合知识点概括"><a href="#SSM整合知识点概括" class="headerlink" title="SSM整合知识点概括"></a>SSM整合知识点概括</h2><pre><code>1.Controller方法返回值(指定返回到哪个页面，指定返回到页面的数据)

    1)ModelAndView 

        modelAndView.addObject(&quot;itemList&quot;, list); 指定返回页面的数据

        modelAndView.setViewName(&quot;itemList&quot;);     指定返回的页面

    2)String(推荐使用)

        返回普通字符串,就是页面去掉扩展名的名称, 返回给页面数据通过Model来完成

        返回的字符串以forward:开头为请求转发

        返回的字符串以redirect:开头为重定向

    3)返回void(使用它破坏了springMvc的结构,所以不建议使用)

        可以使用request.setAttribut(因为我们写的是服务端，所以使用request对象向view中传输数据) 来给页面返回数据

        可以使用request.getRquestDispatcher().forward()来指定返回的页面

        如果controller返回值为void则不走springMvc的组件,所以要写页面的完整路径名称

    相对路径:相对于当前目录,也就是在当前类的目录下,这时候可以使用相对路径跳转

    绝对路径:从项目名后开始.
</code></pre><blockquote>
<p>注意：在springMvc中不管是forward还是redirect后面凡是以/开头的为绝对路径,不以/开头的为相对路径。</p>
</blockquote>
<pre><code>例如:
    forward:/items/itemEdit.action 为绝对路径

    forward:itemEdit.action为相对路径
</code></pre><hr>
<pre><code>2.架构级别异常处理

    此异常编写是实现全局异常处理器接口，目的主要为了防止项目上线后给用户抛500等异常信息,所以需要在架构级别上整体处理.hold住异常

    1.首先自定义全局异常处理器实现HandlerExceptionResolver接口
        public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {//....

    2.在spirngMvc.xml中配置生效
</code></pre><hr>
<pre><code>3.上传图片

    1)在tomcat中配置虚拟图片服务器

    2)导入fileupload的jar包

    3)在springMvc.xml中配置上传组件

    4)在页面上编写上传域,更改form标签的类型

    5)在controller方法中可以使用MultiPartFile接口接收上传的图片

    6)将文件名保存到数据库,将图片保存到磁盘中
</code></pre><hr>
<pre><code>4.JSON数据交互

    1.首先在pom.xml中配置好需要的jar包(jackson的jar包)

    2.@Requestbody:将页面传到controller中的json格式字符串自动转换成java的pojo对象
      @ResponseBody:将java中pojo对象自动转换成json格式字符串返回给页面
</code></pre><hr>
<pre><code>5.RestFul风格支持

    此风格就是对URL的命名标准，此标准要求URL中只能有名词，要求URL中不能用?传参

    传参数：
        页面：${pageContext.request.contextPath}/items/itemEdit/${item.id}
        方法：@RequestMapping(&quot;/itemEdit/{id}&quot;)
        方法：@PathVariable(&quot;id&quot;) Integer id
</code></pre><hr>
<pre><code>6.拦截器

    作用：拦截请求，一般在登录的时候用得比较多
    1.需要编写自定义拦截器类,实现HandlerInterceptor接口
        public class AuthorizedInterceptor implements HandlerInterceptor {//......
    2.在spirngMvc.xml中配置拦截器生效
</code></pre><hr>
<pre><code>7.登录权限验证

    1)编写登录的Controller，编写跳转到登录页面，编写登录验证方法
    2)编写登录页面
    3)编写拦截器
</code></pre><blockquote>
<p>总结：随意访问一个页面，拦截器会拦截请求，会验证session是否有登录信息。如果已经登录，放。如果未登录，跳转到登录页面<br>          在登录页面输入用户名、密码，点击登录按钮，拦截器会拦截请求，如果登录路径在Controller方法中判断用户名和密码正确则将登录信息方法session中。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>百度富文本</title>
    <url>/undefined/%E7%99%BE%E5%BA%A6%E5%AF%8C%E6%96%87%E6%9C%AC(Ueditor)/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="1-Ueditor和Spring-MVC-的整合"><a href="#1-Ueditor和Spring-MVC-的整合" class="headerlink" title="1.Ueditor和Spring MVC 的整合"></a>1.Ueditor和Spring MVC 的整合</h2><h4 id="1-config-json"><a href="#1-config-json" class="headerlink" title="1.config.json"></a>1.config.json</h4><p>该配置文件定义了支持的上传文件/图片的接口以及限制。<br><a id="more"></a></p>
<h4 id="2-集成步骤"><a href="#2-集成步骤" class="headerlink" title="2.集成步骤"></a>2.集成步骤</h4><p>1.采用maven的方式来组织构建<br><br>在下面的程序中可以看出引入了文件上传以及json的序列化与反序列化处理的依赖包。</p>
<pre><code>&lt;!-- 上传文件的支持 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.10&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- org.json --&gt;
&lt;!--JSON is a light-weight, language independent, data interchange format. See http://www.JSON.org/--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.json&lt;/groupId&gt;
    &lt;artifactId&gt;json&lt;/artifactId&gt;
    &lt;version&gt;20160212&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.资源访问配置<br><br>在我们将ueditor静态文件放入webapp目录下之后需要在springmvc.xml配置文件中进行设置排除。</p>
<p>3.引入ueditor的源码<br></p>
<p>4.添加Controller处理类<br><br>该controller处理类原先ueditor中的controller.jsp中的处理代码，改成springmvc的模式，其完成了编辑器初始化工作以及图片/文件的上传处理。</p>
<pre><code>@Controller
@RequestMapping(&quot;/ued&quot;)
public class UEditorController {

    @RequestMapping(value=&quot;/config&quot;)
    public void config(HttpServletRequest request, HttpServletResponse response) {

        response.setContentType(&quot;application/json&quot;);
        String rootPath = request.getSession()
                .getServletContext().getRealPath(&quot;/&quot;);

        try {
            String exec = new ActionEnter(request, rootPath).exec();
            PrintWriter writer = response.getWriter();
            writer.write(exec);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre><p>5.配置config.json文件<br><br>该配置文件定义了文件/图片的上传接口，以及各种限制(文件的大小上限)。这里将配置文件放在webapp/conf目录下，所以在读取路径配置的时候需要修改。在类ConfigManager中修改为：</p>
<pre><code>private String getConfigPath () {
return this.rootPath
        + File.separator + &quot;conf&quot;
        + File.separator + ConfigManager.configFileName;
}
</code></pre><p>6.修改ueditor.config.js配置配置文件<br><br>在这里需要制定编辑器访问服务器的初始化地址。</p>
<pre><code>window.UEDITOR_CONFIG = {

//为编辑器实例添加一个路径，这个不能被注释
UEDITOR_HOME_URL: URL

// 服务器统一请求接口路径
//      原先默认的
//, serverUrl: URL + &quot;jsp/controller.jsp&quot;
//      修改后的
, serverUrl: &quot;/ued/config&quot;
</code></pre><blockquote>
<p>注意：修改的serverUrl需要指向自己的服务器地址。</p>
</blockquote>
<h2 id="ueditor的配置、文件上传"><a href="#ueditor的配置、文件上传" class="headerlink" title="ueditor的配置、文件上传"></a>ueditor的配置、文件上传</h2><pre><code>1.ueditor.config.js的配置
  window.UEDITOR_HOME_URL = &quot;/项目名/ueditor/&quot;;

2.在页面中加载ueditor编辑页面
  在&lt;head&gt;&lt;/head&gt;之间引入三个script。注意：ueditor.config.js 一定要放在ueditor.all.min.js的前面，否则加载不出编辑页面。

3.在&lt;body&gt;&lt;/body&gt;之间实例化ueditor。注意：type=&quot;text/plain&quot;而不是type=&quot;text/javascript&quot;。同时在&lt;body&gt;&lt;/body&gt;中实例化编辑器。

    &lt;script type=&quot;text/javascript&quot;&gt;
        //实例化编辑器
        var ue = UE.getEditor(&apos;editor&apos;);
    &lt;script&gt;

4.配置图片上传的路径
  修改config.json中的&quot;imagePathFormat&quot;: &quot;/×××/upload/image/{yyyy}-{mm}-{dd}/{filename}&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */&lt;br&gt;
  xxx：表示在www目录下的项目名称，这样配置之后就会在项目名称目录下自动创建一个对应的文件夹upload/image/当前日期/

5.编辑的文章保存数据库
  在编辑的文章保存数据库的过程中其实只有HTML程序与相关的文字保存到数据库中。

  1.在编辑页面&lt;body&gt;&lt;/body&gt;中添加程序：

    &lt;form action=&quot;saveshowController&quot; method=&quot;post&quot;&gt;
        &lt;textarea id=&quot;wordtype&quot; name=&quot;wordtype&quot; style=&quot;display: none&quot;&gt;&lt;/textarea&gt;
        &lt;button id=&quot;submit&quot; onclick=&quot;getstring();&quot;&gt;提交&lt;/button&gt;
    &lt;/form&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;

        function getstring(){
            document.getElementById(&apos;wordtype&apos;).innerHTML=UE.getEditor(&apos;editor&apos;).getContent();
            //get.Content() 函数可以获得你所编辑的内容的html代码
        }
    &lt;/script&gt;

    注释：表示的是在当前页面中以post的方式将当前页面中表单的内容提交给后台saveshowController中，然后在saveshowController中以相应的方法获取textarea中的数据，然后操作数据库以实现数据包的保存。
</code></pre><h2 id="百度富文本开发案例"><a href="#百度富文本开发案例" class="headerlink" title="百度富文本开发案例"></a>百度富文本开发案例</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title>程序猿日常-编程之美</title>
    <url>/undefined/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%97%A5%E5%B8%B8-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="程序猿日常-编程之美"><a href="#程序猿日常-编程之美" class="headerlink" title="程序猿日常-编程之美"></a>程序猿日常-编程之美</h1><h2 id="程序猿日常"><a href="#程序猿日常" class="headerlink" title="程序猿日常"></a>程序猿日常</h2><h3 id="微信公众号：iProgrammer-ing"><a href="#微信公众号：iProgrammer-ing" class="headerlink" title="微信公众号：iProgrammer_ing"></a>微信公众号：iProgrammer_ing</h3><h4 id="这应该就是了吧。"><a href="#这应该就是了吧。" class="headerlink" title="这应该就是了吧。"></a>这应该就是了吧。</h4><p>这就是文章的魅力吗？</p>
<p><strong>文章：</strong>这就是</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>程序猿日常-编程随笔</title>
    <url>/undefined/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%97%A5%E5%B8%B8-%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>让优秀成为习惯，让知识成为信仰</p>
</blockquote>
<p>&nbsp;&nbsp;在刚接触编程时，总是问师哥师姐如何快速的高效率的学好编程，但是得到的回答总是让人拿捏不准。而那时候于我而言，只是觉得编程让我的逼格更高，更能得到别人的佩服，不会想到学习好编程会改变我们的思考方式和解决问题的逻辑，以此在这条路上也是给自己挖了很多的坑，现在填坑的过程真的是很痛苦，所以在这里分享一些自己的经验给各位有心学习编程的编程儿们，希望能够跳过这些坑~<br><a id="more"></a></p>
<h4 id="心理准备"><a href="#心理准备" class="headerlink" title="心理准备"></a>心理准备</h4><p>&nbsp;&nbsp;自学编程的弯路多得数不完，坑多得踩不完。如果你决定要自学编程，就意味着踏上了一条面对困难、挫折和失败的无尽之路，要想清楚自己能不能承受这些挫折，自己能不能坚持走到最后。</p>
<p>在自学编程的过程中总是会遇到这样或者那样的问题。</p>
<ul>
<li>编程的环境不会搭建(如：Java、Android以及Python等编程需要搭建开发环境)</li>
<li>学习编程时知识点多，一环紧扣一环，没有耐心和时间慢慢的搞懂每一个知识点</li>
<li>学习的路线曲折，刚学的知识点下一刻就忘得一干二净</li>
<li>编程语法，语言逻辑让人头大，完全不能理解其思路</li>
<li>跟着编程教程学习总是遇到这样或那样的问题</li>
<li>花了功夫，到头来运行程序全部出错</li>
<li>错误解决不了，改到怀疑人生</li>
<li>编程从入门到放弃</li>
<li>技术更新迭代很快，学习的旧的知识点很多都更新了(如：Java)</li>
</ul>
<p>在编程这条路上，如果我们学习的时候没有一颗能战胜这些苦恼的勇敢的心，趁早还是转行做其它，不然到头来受伤的还是自己。<strong>而如果喜欢挑战，并且在这一条路上不甘寂寞，砥砺前行，</strong>那么恭喜你可以踏上编程之路，能够努力的去追寻自己的梦想~</p>
<h4 id="努力的方向"><a href="#努力的方向" class="headerlink" title="努力的方向"></a>努力的方向</h4><blockquote>
<p>选择正确的方向，努力才会有意义</p>
</blockquote>
<p>编程的世界是多元纷繁的，大的方向就分前端开发、后端开发、移动开发、云计算、数据处理、智能硬件、物联网、虚拟现实等等，光编程语言都几十种。如果没有做过功课，贸然进入只会分分钟懵逼。<strong>所以最好是根据自己的兴趣爱好再结合市场前景，先选定一个方向，再选择一门语言，然后头也不回的深深扎进去。</strong></p>
<p>我当初开始自学编程的时候，因为开始的时候学了点C语言,就准备学C++，想在这上面学到很大神的那种境界。不过C++学了没几天，发现游戏编程的Unity 3D挺好玩的，就转学Unity 3D。Unity 3D学了段时间又觉得系统开发很有意思，然后又去学习JavaWeb开发。后面才意识到自己在移动应用上面有极大的兴趣并有一些自己的想法，再加上本人很喜欢Google,遂最终决定好好学习Android移动开发。</p>
<p>如果自己对自己兴趣爱好没有深刻的认识，没有明确的学习目标，只是一味茫然的去尝试，最终只会像猴子掰玉米一样，不但浪费了自己宝贵的时间，还会一无所获。</p>
<h4 id="制定学习目标计划"><a href="#制定学习目标计划" class="headerlink" title="制定学习目标计划"></a>制定学习目标计划</h4><p>选定了方向之后，剩下的就是朝着目的努力前进了。自学的过程是枯燥乏味的，也没有人陪伴督促，<strong>所以要想自学有一定成果，除了要有清晰明确的目标计划，还要有很强的自我约束能力，还要善于自我及激励。</strong>不然很容易自由涣散，三天打鱼两天晒网，看起来花了不少时间，实际上没学到什么。</p>
<p>我开始的时候就是凭兴趣漫无目的的学习，结果发现收效甚微，于是才制定学习计划，开始系统的学习。我先是学习了JAVA基础语法，然后将整个Android开发涉及到的所有知识面简单快速的学习一遍，这样对整个体系框架有一个全面大概的认识，然后在详细具体的学习每一部分，尽量搞明白其中的实现逻辑和原理，以达到掌握知识的目的。最后开发练习的时候再根据自己要实现什么功能，去查相关的资料。</p>
<h4 id="优化学习方式"><a href="#优化学习方式" class="headerlink" title="优化学习方式"></a>优化学习方式</h4><p><strong>一、做好笔记，记录经验</strong><br>我们大多数人并没有过目不忘的神技，很多时候我们学了也不一定马上掌握，需要过后花时间慢慢领悟，而且还有忘掉的风险，所以对于重要的知识点都要做好笔记。</p>
<p>编程的过程中总会遇到各种各样的问题，比如编程环境的配置，常用的快捷键，编程过程中的错误、异常，软件更新问题等等。这些问题往往会不只一次出现，所以我们面对这些问题都是如何解决的，一定要记录下来，一是增加自己解决问题的经验，而是以防下次出现。</p>
<p>我做笔记记录的方式：</p>
<ul>
<li>截图</li>
<li>拍照</li>
<li>写记事本</li>
<li>写Word文档</li>
</ul>
<p>除了最初用纸质笔记本做过笔记，后面都是用上面的方式。用电子的方式方便快捷易于分享，而且我还能传到手机上，利用其它时间随时随地阅读。</p>
<p><strong>二、认认真真敲代码</strong><br><strong>二、认认真真敲代码</strong><br><strong>二、认认真真敲代码</strong><br>编程没有捷径，只有勤奋努力。</p>
<p><strong>三、多看官方文档，外文资料</strong><br>互联网是一个更新迭代很快的行业，所有编程语言都会不断的更新新功能和修复旧Bug，网上查的资料很有可能是旧的解决方案，现在已经不适用了。所以最好最快的方法就是查看官方文档。</p>
<p>毕竟互联网技术还是国外发展起来的，所以在很多技术问题方面，人家还是有优势的。有些问题在国内不一定能找到答案就去外网找。</p>
<p><strong>四、进入行业圈子</strong><br>只有进入行业圈子与其他人交流，你才了解最新的行业动态，才知道自己需要更新哪些技能。最重要的是有了这群人，自己遇到问题解决起来嗖嗖的，那速度才叫“倍爽儿”。<br>进入行业圈子的方式：</p>
<ul>
<li>混迹各行业网站论坛个人技术博客<br>一般在搜问题时很容易就搜到这些网站</li>
<li>关注各种行业话题和人<br>比如知乎、微博、微信公众号等</li>
<li>QQ群、微信群<br>交流基地，技术后援团</li>
<li>Github<br>互联网圣地，行业大圈子就在这。</li>
</ul>
<p><strong>五、动手做项目</strong><br>我们学习编程的最终目的就是用所学的做出具有一定功能的项目，而做项目又是最好的学习和巩固知识的方式。如果前期能力不足就先做一些简单的功能模块，一步一步慢慢来，不要一开始就要实现各种酷炫炸天功能，遇到不会的就在网上查， 现在互联网这么发达，获取资源也及其方便。而且开发前也最好在网上查一下有没有已经成型的框架或模板，编程界有一句很流行的话“不要重复造轮子”，什么都自己做一是很耗费时间，二是自己技术能力不足还可能留下不少坑。</p>
<h4 id="收获回报"><a href="#收获回报" class="headerlink" title="收获回报"></a>收获回报</h4><p>自学编程说起来到处都是苦，但也并不是完全一无是处。客观地看，自学编程还是有很多好处的。</p>
<ul>
<li>培养自学能力</li>
<li>掌握一门技术</li>
<li>锻炼毅力和独处能力</li>
<li>提高解决问题能力</li>
<li>提高面对挫折失败的承受能力</li>
<li>改变思维方式</li>
<li>享受沉浸专注的快乐</li>
<li>享受创造的快乐</li>
</ul>
<h4 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h4><ol>
<li><p>自学视频网站：</p>
<p><strong><a href="http://www.imooc.com" target="_blank" rel="noopener">慕课网</a></strong>  本人主要学习网站，课程全部免费而且视频比较新，有课程计划和在线编程。<br><strong><a href="http://www.jikexueyuan.com" target="_blank" rel="noopener">极客学院</a></strong>  课程全多，部分课程需要VIP，有的课程比较旧。<br><strong><a href="http://www.maiziedu.com" target="_blank" rel="noopener">麦子学院</a></strong>  大多要报线上培训班，不过好像有免费入口，反正我看的Android全部免费。<br><strong><a href="http://edu.51cto.com/?www" target="_blank" rel="noopener">51CTO学院</a></strong>  没用过<br><strong><a href="http://study.163.com/" target="_blank" rel="noopener">网易云课堂</a></strong>  只用过网易公开课，没用过云课堂。<br><strong><a href="http://www.miguxue.com/" target="_blank" rel="noopener">咪咕学院</a></strong>  没用过<br><strong><a href="http://mooc.guokr.com/" target="_blank" rel="noopener">MOOC学院</a></strong> 果壳慕课网，比较杂，没用过。</p>
</li>
<li><p>手机应用</p>
<p><strong><a href="https://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a></strong>  专业互联网问答，有PC版。<br><strong><a href="http://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></strong>  程序员学习分享平台。<br><strong><a href="http://gold.xitu.io/welcome" target="_blank" rel="noopener">掘金</a></strong>  高质量技术分享平台<br><strong><a href="http://git.oschina.net/" target="_blank" rel="noopener">码云</a></strong>  OSChina旗下云端开发者服务平台<br><strong><a href="http://biji.baidu.com/inotes/" target="_blank" rel="noopener">涂书笔记</a></strong>  有道云笔记、印象笔记这些大家都知道了，图书笔记的特点是可以上传照片并识别照片中文字。主要针对读书人群。<br>Mindjet Maps   思维导图，大名鼎鼎MindManager的Android版，免费<br>极品思维导图 Android版，功能齐全<br><strong><a href="https://www.wunderlist.com/zh/" target="_blank" rel="noopener">奇妙清单</a></strong>  待办事项清单<br><strong><a href="http://www.idothing.com/" target="_blank" rel="noopener">种子习惯</a></strong>  习惯养成应用</p>
</li>
<li>翻墙软件<br>shadowsocks</li>
<li>浏览器<br>Chrome浏览器 各种开发工具，各种插件，开发者大多都用Chrome浏览器（去广告，翻译轻轻松松）</li>
</ol>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>希望大家和我一样在编程这条路上体会到编程的乐趣~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>编程之路</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序开发项目经验</title>
    <url>/undefined/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="1-Tomcat与jetty"><a href="#1-Tomcat与jetty" class="headerlink" title="1.Tomcat与jetty"></a>1.Tomcat与jetty</h3><p>jetty和Tomcat是两款著名的开源webserver/servlet容器。</p>
<pre><code>两者之间的比较：

    1.jetty更加的轻量级
    2.jetty更加灵活，表现在可扩展性
</code></pre><hr>
<h3 id="2-web-xml文件配置"><a href="#2-web-xml文件配置" class="headerlink" title="2.web.xml文件配置"></a>2.web.xml文件配置</h3><p>修改在<code>webapp</code>路径下的<code>web.xml</code>文件需要根据规定的顺序添加操作权限，否则会报错。或者将<code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</code>这一段校验代码删掉，问题就解决了。这时因为我们添加的部分的代码符合<code>xml</code>文档规范，但是不符合<code>web-app_2_3.dtd</code>所定义的规范。</p>
<hr>
<a id="more"></a>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><blockquote>
<p>注意：在使用IDEA开发的时候，mapper类只能建立在resource目录下，不能建立在Java的包下面，不然会映射不了。</p>
</blockquote>
<pre><code>1.首先编写entity
2.然后编写接口
3.接下来使用mapper
4.最后编写测试用例，直接使用junit测试
    //测试dao层
    // 使用Springtest测试框架
    @RunWith(SpringJUnit4ClassRunner.class)
    // 加载配置
    @ContextConfiguration(&quot;/spring/spring-*.xml&quot;) 
    public class MyBatisTest {
        @Autowired
        private ScoreDao scoreDao;

        @Test
        public void testAddScore() {
            Score score = new Score();
            score.setChangeType(&quot;充钱钱&quot;);
            score.setScore(10);
            int insert = scoreDao.insertScore(score);
            System.out.print(&quot;insert :&quot;+insert);
        }
    }

5.测试整个框架(使用SpringMVC)
    1.编写业务逻辑接口
    2.然后编写业务逻辑接口的实现类
    3.然后编写controller将springmvc的解析视图解析出来
</code></pre><hr>
<h3 id="4-Redis-单机版以及测试版"><a href="#4-Redis-单机版以及测试版" class="headerlink" title="4.Redis 单机版以及测试版"></a>4.Redis 单机版以及测试版</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/undefined/Spring/</url>
    <content><![CDATA[<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Spring-FD"><a href="#Spring-FD" class="headerlink" title="Spring - FD"></a>Spring - FD</h1><p>Spring提供一种方法管理你的业务对象，主要有两个功能为我们的业务对象管理提供便捷</p>
<ul>
<li>1.DI 依赖注入</li>
<li>2.AOP 面向切面编程</li>
</ul>
<h4 id="1-Java-Bean"><a href="#1-Java-Bean" class="headerlink" title="1.Java Bean"></a>1.Java Bean</h4><p>每一个实现Bean的规范才可以由Spring来接管，而Bean的规范是：</p>
<pre><code>1.必须是个共有类 
2.有无参构造函数 
3.用公有方法暴露内部成员属性(setter/getter) 实现了这样的规范的类才叫做JavaBean(一种可重用组件)
</code></pre><h4 id="2-DI-依赖注入"><a href="#2-DI-依赖注入" class="headerlink" title="2.DI-依赖注入"></a>2.DI-依赖注入</h4><p> 简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p>
<h4 id="3-AOP-面向切面对象"><a href="#3-AOP-面向切面对象" class="headerlink" title="3.AOP-面向切面对象"></a>3.AOP-面向切面对象</h4><p>在执行某个操作前后需要输出日志，但是如果是手工加代码会非常吃力，维护也非常艰难，所以这就需要面向切面编程</p>
<a id="more"></a>
<hr>
<h2 id="Spring框架的主要内容"><a href="#Spring框架的主要内容" class="headerlink" title="Spring框架的主要内容"></a>Spring框架的主要内容</h2><h4 id="1-Spring框架运行环境"><a href="#1-Spring框架运行环境" class="headerlink" title="1.Spring框架运行环境"></a>1.Spring框架运行环境</h4><pre><code>Data Access/Integration：JDBC ORM OXM JMS Transaction 
Web：WebSocket Servlet Web Portlet
Core Container：Beans Core Context SpEL

AOP Aspects Instrumentation Messaging

Test


Test：Spring支持Junit单元测试
</code></pre><blockquote>
<p>核心容器(IOC)：Bean(Bean工厂/创建对象)、Core(一切的基础)、Context(上下文)、SpEL(Spring的表达式语言)</p>
</blockquote>
<blockquote>
<p>AOP：AOP、Aspects</p>
</blockquote>
<blockquote>
<p>数据访问的支持:JDBC、ORM、Transaction、JMS(Java邮件服务)</p>
</blockquote>
<blockquote>
<p>Web的支持：Spring MVC</p>
</blockquote>
<hr>
<h4 id="2-Ioc-Inversion-of-control-控制反转"><a href="#2-Ioc-Inversion-of-control-控制反转" class="headerlink" title="2.Ioc(Inversion of control)控制反转"></a>2.Ioc(Inversion of control)控制反转</h4><p>这是一种设计思想，在Java开发中，Ioc意味着将你设计好的对象交给容器控制管理，不像传统的在对象内部直接控制。</p>
<p>解释：在传统的Java程序设计中，在对象内部通过new进行创建对象，是程序主动去创建依赖对象，Ioc专门有一个容器来创建这些对象，即由Ioc容器来控制对象的创建。Ioc容器控制了对象，主要控制了外部资源的获取。</p>
<hr>
<h4 id="3-DI-Dependency-Injection-依赖注入"><a href="#3-DI-Dependency-Injection-依赖注入" class="headerlink" title="3.DI(Dependency Injection)依赖注入"></a>3.DI(Dependency Injection)依赖注入</h4><p>组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>解释：应用程序依赖于Ioc容器。应用程序需要Ioc容器来提供对象需要的外部资源。Ioc容器注入应用程序某个对象，应用程序依赖的对象。注入某个对象所需要的外部资源(对象、资源、常量数据)。</p>
<blockquote>
<p>一般项目开发的模块：</p>
</blockquote>
<pre><code>注意：
    DAO层、Service层、Controller层和View层详解
    1.DAO层
      主要做数据持久层的工作，负责与数据库进行联络的一些任务封装在此。
        1)设计DAO层的接口
        2)在Spring配置文件中定义此接口的实现类
        3)在模块中调用此接口来进行数据业务的处理，不需要关心此接口的具体实现类是哪个类
        注意：DAO层的数据源配置以及有关数据库连接的参数都在Spring的配置文件中进行配置

    2.Service层
      此层主要负责业务模块的逻辑应用设计
        1)首先设计接口，再设计其实现类，最后再在配置文件中配置其实现的关联，从而在应用中调用service接口来进行业务处理。
        2)service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用业务逻辑的独立性和重复利用性。

    3.Controller层
      此层负责具体的业务模块流程的控制，在此层要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行

    4.View层
      View层与控制层结合比较紧密，View层主要负责网页前台的JSP页面的表示
</code></pre><blockquote>
<p>1.首先给出Ioc(控制反转)思想程序：</p>
</blockquote>
<pre><code>1.定义DAO接口UserDao
2.定义DAO接口实现类UserDaoMysqlImpl和UserDaoOracleImpl
3.定义Service层接口UserService，实现具体的业务
4.定义Service接口的实现类UserServiceImpl,Service层的业务实现，具体要调用到已定义的Dao层的接口
</code></pre><blockquote>
<blockquote>
<p>注意：控制反转(Ioc)的设计思想，我们不需要应用程序本身来创建对象，而是将创建对象的任务交付给Ioc容器</p>
</blockquote>
</blockquote>
<hr>
<h1 id="Spring-SD"><a href="#Spring-SD" class="headerlink" title="Spring - SD"></a>Spring - SD</h1><hr>
<h2 id="Spring的bean管理-xml方式"><a href="#Spring的bean管理-xml方式" class="headerlink" title="Spring的bean管理(xml方式)"></a>Spring的bean管理(xml方式)</h2><pre><code>对象创建的细节：
  1.对象创建的时间
   1)scope=&quot;prototype&quot;(默认值) 在用到对象时才创建 (多例 action对象)
   2)scope=&quot;singleton&quot; 在启动(容器初始化之前)就已经创建了对象，整个web应用只有一个单例(dao/service/工具类)
  2.是否延迟创建
   1)lazy-init=&quot;false&quot;(默认值) 不延迟创建，即在启动时就创建
   2)lazy-init=&quot;true&quot; 延迟初始化，在用到对象的时候才创建
</code></pre><h2 id="Bean实例化的方式"><a href="#Bean实例化的方式" class="headerlink" title="Bean实例化的方式"></a>Bean实例化的方式</h2><pre><code>1.在Spring里面通过配置文件创建对象

2.Bean实例化三种方式实现(创建对象的几种方式)

  1)使用类的无参数构造创建(重点)
    &lt;bean id=&quot;user&quot; class=&quot;cn.itcase.ioc.User&quot;&gt;&lt;/bean&gt;
    注意：如果类里面没有无参数构造，会出现异常，所以一般要在类里面有有参构造的前提下重写无参构造方法

  2)带参构造创建
    &lt;bean id=&quot;user2&quot; class=&quot;cn.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; type=&quot;int&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;Jack&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

  3)使用静态工厂创建
    创建静态方法，返回类对象
        &lt;!-- # 3.2 工厂类： 静态方法 --&gt;
    &lt;!-- 
        class 指定的就是工厂类型
        factory-method  一定是工厂里面的“静态方法”
     --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;cn.ObjectFactory&quot; factory-method=&quot;getStaticInstance&quot;&gt;&lt;/bean&gt;

  4)使用实例工厂创建
    创建不是静态的方法，返回类对象
        &lt;!-- 3. 工厂类创建对象 --&gt;
    &lt;!-- # 3.1 工厂类，实例方法 --&gt;
    &lt;!-- 先创建工厂 --&gt;
    &lt;bean id=&quot;factory&quot; class=&quot;cn.ObjectFactory&quot;&gt;&lt;/bean&gt;
    &lt;!-- 在创建user对象，用factory方的实例方法 --&gt;
    &lt;bean id=&quot;user4&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;
</code></pre><blockquote>
<p>注意：</p>
</blockquote>
<pre><code>Spring管理Bean

Spring容器通常理解为BeanFactory或者ApplicationContext 

在Spring的Ioc容器能够帮助我们创建对象，对象交给Spring管理之后我们不用手动去new对象
</code></pre><h2 id="对象依赖关系"><a href="#对象依赖关系" class="headerlink" title="对象依赖关系"></a>对象依赖关系</h2><pre><code>Spring常用的几种注入方式：
    1.通过构造器

    2.通过set方法给属性注入值(最常用)
</code></pre><hr>
<h2 id="Servlet监听器"><a href="#Servlet监听器" class="headerlink" title="Servlet监听器"></a>Servlet监听器</h2><p>定义：监听器就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p>
<p>在Servlet规范中定义了多种类型的监听器，它们用于监听的事件源分别为 ServletContext, HttpSession 和 ServletRequest 这三个域对象。</p>
<pre><code>1.监听ServletContext域对象的创建和销毁
  ServletContextListener接口用于监听ServletContext对象的创建与销毁事件
      创建：服务器启动针对每一个web应用创建servletcontext
    销毁：服务器关闭前先关闭代表每一个web应用的servletContext

2.编写Servlet监听器
  1.实现一个特定的接口，并且针对相应的动作覆盖接口中相应的方法
  2.servlet监听器注册是由web容器负责，我们只需要在web.xml文件中使用&lt;listener&gt;标签配置好监听器，web容器就会自动将监听器注册到事件源中
  3.一个web.xml文件中可以配置多个servlet事件监听器，web服务器按照它们的web.xml文件中的注册顺序来加载和注册这些servlet监听器

3.监听HttpSession域对象创建与销毁
  HttpSessionListener接口用于监听HttpSession的创建和销毁
    创建：调用sessionCreated(HttpSessionEvent se)方法
    销毁：sessionDestroyed (HttpSessionEvent se)方法

4.监听HttpRequest域对象创建与销毁

    创建：用户的每一次访问都会创建一个request
    销毁：当前访问结束，request对象就会销毁
</code></pre><blockquote>
<p>注意：session域对象在每一次访问时被创建，而如果用户的session在30分钟内没有使用，服务器就会销毁session，在web.xml中也可以配置session的失效时间</p>
</blockquote>
<hr>
<h2 id="Spring注解注入详解"><a href="#Spring注解注入详解" class="headerlink" title="Spring注解注入详解"></a>Spring注解注入详解</h2><h4 id="1-Resource注解"><a href="#1-Resource注解" class="headerlink" title="1.@Resource注解"></a>1.@Resource注解</h4><p>这一注解是JSR-250标准注解，推荐使用其代替Spring专有的@Autowired注解，@Resource的作用相当于@Autowired，只不过@Autowired按 byType 自动注入，而@Resource默认按 byName 自动注入罢了。</p>
<p>@Resource有两个比较重要的属性，分别是name与type，Spring注解的name属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType<br>自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</p>
<h4 id="2-Component注解"><a href="#2-Component注解" class="headerlink" title="2.@Component注解"></a>2.@Component注解</h4><p>在对应的类上加上一个@Component注解就定义该类是Bean </p>
<h4 id="3-Scope注解"><a href="#3-Scope注解" class="headerlink" title="3.@Scope注解"></a>3.@Scope注解</h4><p>在使用XML定义bean的时候，有些时候需要通过bean的scope属性来定义一个bean的作用范围</p>
<hr>
<h2 id="Spring-Ioc快速入门"><a href="#Spring-Ioc快速入门" class="headerlink" title="Spring Ioc快速入门"></a>Spring Ioc快速入门</h2><p>  1.下载Spring的开发包</p>
<p>  2.了解Spring的目录结构 1)docs：Spring的开发文档 2)libs：Spring的开发包 3)schema：约束文档</p>
<p>  3.创建一个项目引入jar包</p>
<p>  4.引入Spring的配置文件</p>
<p>  5.编写测试类</p>
<p>IOC：控制反转，将Bean创建反转给Spring容器<br>DI：依赖注入，在Spring创建这个类的过程中，将这个类的依赖的属性注入，设置属性值</p>
<p>两者之间的关系：依赖注入不能单独存在，需要在Ioc的基础上完成操作</p>
<p>Ioc与DI之间的区别</p>
<ul>
<li></li>
</ul>
<p>Spring的工厂类</p>
<p>  1.ApplicationContext</p>
<pre><code>- ClassPathXmlApplicationContext：解析类路径下的XML
- FileSystemXmlApplicationContext：解析本地磁盘上的XML
</code></pre><p>注意：BeanFactory和ApplicationContext都是Spring中的工厂，BeanFactory是Spring的老版的工厂类(第一次调用getBean方法的时候实例化类)<br>      ApplicationContext是Spring的新版本的工厂类(在加载核心配置文件的时候，将所有的类实例化)</p>
<p>Spring的Bean管理(基于XML方式)</p>
<pre><code>1.Spring实例化Bean方式

  无参构造方式(最常用)
   &lt;!-- 无参数构造方法方式 --&gt;
   //引入Spring的配置文件(1.引入约束 2.编写标签)
   &lt;bean id=&quot;bean1&quot; class=&quot;cn.augmentum.spring.demo3.Bean1&quot;&gt;&lt;/bean&gt;
   //编写测试类
   @Test
   /**
    * 无参数构造
    */
   public void demo1() {
       // 加载核心配置文件:
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
               &quot;applicationContext.xml&quot;);
       Bean1 bean1 = (Bean1) applicationContext.getBean(&quot;bean1&quot;);//getBean()是用来获取applicationContext.xml文件里bean的
       System.out.println(bean1);
   }

  静态工厂实例化方式

  Bean2的静态工厂:

  public class Bean2Factory {
     public static Bean2 getBean2(){
         return new Bean2();
    }
  }

 配置文件:
   &lt;!-- 静态工厂实例化方式 --&gt;
   &lt;bean id=&quot;bean2&quot; class=&quot;cn.augmentum.spring.demo3.Bean2Factory&quot; factory-method=&quot;getBean2&quot;/&gt;

 代码:
   @Test
   /**
    * 静态工厂实例化
    */
   public void demo2() {
       // 加载核心配置文件:
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
               &quot;applicationContext.xml&quot;);
       Bean2 bean2 = (Bean2) applicationContext.getBean(&quot;bean2&quot;);
       System.out.println(bean2);
   }


 实例工厂:
 public class Bean3Factory {

    public Bean3 getBean3(){
       System.out.println(&quot;实例工厂执行了...&quot;);
       return new Bean3();
    }
 }

 配置文件:
   &lt;!-- 实例工厂实例化方式 --&gt;
   &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.spring.demo3.Bean3Factory&quot;/&gt;
   &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;/&gt;

 代码:
   @Test
   /**
    * 实例工厂实例化
    */
   public void demo3() {
       // 加载核心配置文件:
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
               &quot;applicationContext.xml&quot;);
       Bean3 bean3 = (Bean3) applicationContext.getBean(&quot;bean3&quot;);
       System.out.println(bean3);
   }
</code></pre><h2 id="Spring的Bean的常用配置"><a href="#Spring的Bean的常用配置" class="headerlink" title="Spring的Bean的常用配置"></a>Spring的Bean的常用配置</h2><h4 id="1-标签的id和name属性"><a href="#1-标签的id和name属性" class="headerlink" title="1.标签的id和name属性"></a>1.<bean>标签的id和name属性</bean></h4><pre><code>id与name的区别：
  id：使用xml约束中id约束，不可以出现特殊字符
  name：出现特殊字符，如果使用name没有id，那么name可以作为id使用
</code></pre><h4 id="2-上生命周期的配置"><a href="#2-上生命周期的配置" class="headerlink" title="2.上生命周期的配置"></a>2.<bean>上生命周期的配置</bean></h4><pre><code>@Test
    /**
     * Bean的生命周期的相关配置:
     *     * init-method
     *     * destory-method :只能针对单例对象有效.必须在工厂关闭之后才会销毁对象.
     */
    public void demo1(){
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        EmployeeService employeeService = (EmployeeService) applicationContext
                .getBean(&quot;employeeService&quot;);
        employeeService.save();
        applicationContext.close();
    }
</code></pre><h4 id="3-上的作用范围的配置"><a href="#3-上的作用范围的配置" class="headerlink" title="3.上的作用范围的配置:"></a>3.<bean>上的作用范围的配置:</bean></h4><pre><code>scope属性:

 - singleton :单例的(默认)
 - prototype :多例的
 - request :WEB项目中,创建一个对象,保存到request域中
 - session :WEB项目中,创建一个对象,保存到session域中
 - globalsession :WEB项目中,特殊环境.分布式开发环境.如果没有分布式环境,相当于session
</code></pre><h4 id="4-Bean的生命周期"><a href="#4-Bean的生命周期" class="headerlink" title="4.Bean的生命周期"></a>4.Bean的生命周期</h4><hr>
<h2 id="Spring属性注入"><a href="#Spring属性注入" class="headerlink" title="Spring属性注入"></a>Spring属性注入</h2><p>属性注入：创建对象的时候，向类里面属性设置值，这一过程就是属性注入</p>
<pre><code> 1.有参构造方法的属性注入
    &lt;bean id=&quot;car&quot; class=&quot;cn.augmentum.spring.demo6.Car&quot;&gt;//创建类，然后在类中添加属性值
　　   &lt;constructor-arg name=&quot;name&quot; value=&quot;宝马&quot;/&gt;
　     &lt;constructor-arg name=&quot;price&quot; value=&quot;1000000&quot;/&gt;
    &lt;/bean&gt;

    //第一种 有参构造注入属性值(一般情况下的属性赋值方式)
    public class User{
        private String name;
        public User(String name){
            this.name=name;
        }
    }
    User user=new User(&quot;lucy&quot;);

 2.set方法的属性注入

   &lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot;&gt;//1.创建car2对象
　    &lt;property name=&quot;name&quot; value=&quot;奇瑞QQ&quot;/&gt;//2.属性注入(对象中属性的值的设定) name属性值：类里面定义的属性名称 value属性：设置具体的值
　　  &lt;property name=&quot;price&quot; value=&quot;30000&quot;/&gt;
   &lt;/bean&gt;  

    //第二种 使用set方法注入属性值(在一般情况下使用的属性赋值方式)
     public class User{
        private String name;
        public void setName(String name){
            this.name=name;
        }
    }
    User user=new User();
    user.setName(&quot;张三&quot;);

 //第三种 使用接口方式注入
 public interface Dao{
     public void delete(String name);
    }

 public class DaoImpl implements Dao{
    private String name;
    public void delete(String name){
        this.name=name;
        }
    }

注意：在spring框架中只支持前面两种方式
      1)set方法注入(重点)
      2)有参数构造注入

 3.Spring的2.5支持p名称空间注入

   p名称空间语法

    普通属性：p:name=&quot;&quot;
    对象类型属性：p:name-ref=&quot;&quot;

 4.p名称空间的使用

   1.引入p名称空间

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   2.p名称空间的注入

&lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot; p:name=&quot;长安奔奔&quot; p:price=&quot;25000&quot;/&gt;
&lt;bean id=&quot;employee&quot; class=&quot;cn.augmentum.spring.demo6.Employee&quot; p:name=&quot;马凤&quot; p:car2-ref=&quot;car2&quot;/&gt;  ref：表示引用其他bean对象    

 5.Spring3.0的SpEL的属性注入
   SpEL语法：#{SpEL}

1.属性配置
 &lt;bean id=&quot;carInfo&quot; class=&quot;cn.augmentum.spring.demo6.CarInfo&quot;&gt;
 &lt;/bean&gt;

2.属性注入
 &lt;!-- SpEL的方式的属性注入 --&gt;
&lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot;&gt;
　　&lt;property name=&quot;name&quot; value=&quot;#{carInfo.carName}&quot;/&gt;
　　&lt;property name=&quot;price&quot; value=&quot;#{carInfo.calculatorPrice()}&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;employee&quot; class=&quot;cn.augmentum.spring.demo6.Employee&quot;&gt;
　 &lt;property name=&quot;name&quot; value=&quot;涛哥&quot;/&gt;
　 &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt;
&lt;/bean&gt;

 6.Spring中数组或集合的复杂类型属性注入(在创建好类之后便要创建类的对象，此时创建对象的操作交给Spring容器，然后注入对象的属性值)

   1.注入复杂属性值，首先创建类型对象
    &lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt;
        //2.然后在创建的对象中注入属性值
        &lt;property name=&quot;arrs&quot;&gt;//加入的属性名称
　　            &lt;list&gt;
　　　　            &lt;value&gt;老马&lt;/value&gt;
　　　　            &lt;value&gt;马凤&lt;/value&gt;
　 　　             &lt;value&gt;马如花&lt;/value&gt;
　　            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;



&lt;!--List集合的属性的注入:--&gt;
&lt;property name=&quot;list&quot;&gt;
　　&lt;list&gt;
　　　　&lt;value&gt;马芙蓉&lt;/value&gt;
　　　　&lt;value&gt;马大帅&lt;/value&gt;
　　　　&lt;value&gt;马大彪&lt;/value&gt;
　　&lt;/list&gt;
&lt;/property&gt;

&lt;!--Set集合的属性的注入:--&gt;
&lt;property name=&quot;set&quot;&gt;
　　&lt;set&gt;
　　　　&lt;value&gt;马云&lt;/value&gt;
　　　　&lt;value&gt;马化腾&lt;/value&gt;
　　　　&lt;value&gt;马大哈&lt;/value&gt;
　　&lt;/set&gt;
&lt;/property&gt;

&lt;!--Map集合的属性的注入:--&gt;
&lt;property name=&quot;map&quot;&gt;
　　&lt;map&gt;
　　　　&lt;entry key=&quot;aaa&quot; value=&quot;刘能&quot;/&gt;
　　　　&lt;entry key=&quot;bbb&quot; value=&quot;赵四&quot;/&gt;
　　　  &lt;entry key=&quot;ccc&quot; value=&quot;王五&quot;/&gt;
　 &lt;/map&gt;
&lt;/property&gt;

&lt;!--Properties的属性的注入:--&gt;
&lt;property name=&quot;properties&quot;&gt;
　　&lt;props&gt;
　　　　&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
　　　　&lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;
　　&lt;/props&gt;
&lt;/property&gt;


 7.Spring中的分配置文件进行开发
   1.加载配置文件时候加载多个配置文件

   2.总配置文件中引入其他配置文件
</code></pre><h4 id="2-注入对象类型属性-重点"><a href="#2-注入对象类型属性-重点" class="headerlink" title="2.注入对象类型属性(重点)"></a>2.注入对象类型属性(重点)</h4><pre><code>1.创建service类和dao类
  1)在service得到dao对象

2.具体实现过程
    1)在service里面将dao作为类型属性
    2)生成dao类型属性的set方法

    public class UserService{
        //1.定义dao类型属性
        private UserDao userDao;
        //2.生成set方法
        public void setUserDao(UserDao userDao){
            this.userDao=userDao;
        }

    }

 3)配置文件中注入关系

    1.配置service和dao对象
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt;&lt;/bean&gt;

    2.注入dao对象 name属性值，service类里面属性名称，现在不要写value属性，因为刚写的是字符串，现在是对象，写ref属性，dao配置bean标签中id值
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
</code></pre><h4 id="3-Bean标签常用属性"><a href="#3-Bean标签常用属性" class="headerlink" title="3.Bean标签常用属性"></a>3.Bean标签常用属性</h4><pre><code>1)id属性：为后面查找类起的名称，id属性值名称任意命名，id属性值不能包含特殊字符，根据id值得到配置对象
2)class属性：创建对象所在的类的全路径
3)name属性：功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊字符
4)scope属性：
  - singleton :单例的(默认) 创建的实例是一个对象
  - prototype :多例的 创建的实例是多个对象
  - request :WEB项目中,创建一个对象,保存到request域中
  - session :WEB项目中,创建一个对象,保存到session域中
  - globalsession :WEB项目中,特殊环境.分布式开发环境.如果没有分布式环境,相当于session
</code></pre><h2 id="Spring整合Web项目原理"><a href="#Spring整合Web项目原理" class="headerlink" title="Spring整合Web项目原理"></a>Spring整合Web项目原理</h2><pre><code>1.加载Spring核心配置文件，根据配置创建对象
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
    //1)new对象,虽然这一过程功能可以实现，但是实现效率很低

2.提高这一过程实现效率的思想：将加载配置文件和创建对象的过程在服务器启动的过程完后

3.上述思想实现原理

    1)ServletContext对象
    2)监听器

    3)具体使用
      - 在服务器启动的使用，会为每个项目创建一个ServletContext对象
      - 在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候被创建
      - 使用监听器监听到ServletContext对象创建的时候
        --加载Spring配置文件，将配置文件配置对象创建
        --将创建出来的对象放到ServletContext域对象里面(setAttribute方法)
      - 获取对象的时候，到ServletContext域之中得到(getAttribute方法)
</code></pre><hr>
<h1 id="Spring-TD"><a href="#Spring-TD" class="headerlink" title="Spring - TD"></a>Spring - TD</h1><h2 id="Spring的Bean管理-注解"><a href="#Spring的Bean管理-注解" class="headerlink" title="Spring的Bean管理(注解)"></a>Spring的Bean管理(注解)</h2><blockquote>
<p>注解(程序里面的图书特殊标记，使用注解可以完成功能 写法：@注解名称(属性名称=属性值)) &gt;&gt;注解可以使用在类上面、方法上面以及属性上面</p>
</blockquote>
<h4 id="1-Spring注解开发准备"><a href="#1-Spring注解开发准备" class="headerlink" title="1.Spring注解开发准备"></a>1.Spring注解开发准备</h4><pre><code>1.导入jar包
 1.导入基本的jar包
 2.导入aop的jar包
2.创建类、创建方法

3.创建Spring配置文件，引入约束
 1.在刚开始做Ioc基本功能的时候，引入的约束是beans
 2.但是在做Spring的Ioc注解开发的时候需要引入新的约束(../spring-context.xsd)

4.开启注解扫描(到包里面扫描类、方法、属性上面是否有注解)
 &lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt;
 //另外一个开启扫描注解配置程序
 &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;//这只会扫描属性上面的注解
</code></pre><h4 id="2-注解创建对象"><a href="#2-注解创建对象" class="headerlink" title="2.注解创建对象"></a>2.注解创建对象</h4><pre><code>1.在创建对象的类上面使用注解实现
    @ Component(value=&quot;user&quot;) // &lt;bean id=&quot;user&quot; class=&quot;&quot;/&gt;
    public class User{
        //...
        }

2.创建对象有四个注解

    下面三个的让标注类的用途清晰，在后续Spring版本中对其增强
    @ Controller ：web层
    @ Service ：业务层
    @ Repository ：持久层
    @ Component 和上面的三个注解等效


3.创建对象单实例还是多实例
    @ Scope(value=&quot;prototype&quot;)
</code></pre><h4 id="3-注解注入属性"><a href="#3-注解注入属性" class="headerlink" title="3.注解注入属性"></a>3.注解注入属性</h4><pre><code>注入属性注解：
    1.@Autowired 
    2.@Resource 

1.@Autowired 
  创建service类，创建dao类，在service类中得到dao对象
  1)使用注解创建dao类与service类的对象
    @Service(value=&quot;userService&quot;)
    public class UserService{
        //...
        }

    @Component(value=&quot;userService&quot;)
    public class UserService{
        //...
        }

  2)得到dao对象(在service类里面定义dao类型属性)
    - 1.定义dao类型属性，在dao属性上面使用注解完成对象注入
    @Autowired(自动装配)
    private UserDao userDao;
    //使用注解方式的时候不需要使用set方法注入属性值

2.@Resource 
  name属性值写注解创建dao对象value值
  @Resource(name=&quot;userDao&quot;)
  private UserDao userDao;



配置文件和注解混合使用

  1.创建对象操作使用配置文件方式实现
    &lt;bean id=&quot;bookService&quot; class=&quot;cn.itcast&quot;&gt;&lt;/bean&gt;    
  2.注入属性的操作使用注解方式实现
    //得到类的对象，使用注解的方式
    @Resource(name=&quot;bookDao&quot;)
    private BookDao bookDao;

    @Resource(name=&quot;ordersDao&quot;)
    private OrdersDao ordersDao;


3.多种装配Bean方式的比较

  1.基于xml配置(适用于Bean来自第三方、使用其他命名空间)
    bean定义：&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;
    bean名称：通过id或name指定
    bean属性注入：&lt;property&gt;或者p命名空间
    生命过程/bean作用范围：init-method/destory-method 范围：scope属性

  2.基于注解配置（Bean的实现类由用户自己开发）
    bean定义：
    @Component(@Repository)
    @Service
    @Controller

    bean名称：@Component(&quot;person&quot;)

    bean属性注入：@Autowired 按类型注入
          @Qualifier 按名称注入

    生命过程：

  3.基于Java类配置
    bean注入：在方法内部编写注入代码逻辑
</code></pre><hr>
<h2 id="AOP-面向切面-方面-编程"><a href="#AOP-面向切面-方面-编程" class="headerlink" title="AOP(面向切面(方面)编程)"></a>AOP(面向切面(方面)编程)</h2><p>动态代理实现的过程</p>
<h4 id="1-AOP概念"><a href="#1-AOP概念" class="headerlink" title="1.AOP概念"></a>1.AOP概念</h4><ul>
<li>1)面向切面编程，扩展功能不修改源程序实现  </li>
<li>2)AOP采取横向抽取机制，取代了传统纵向继承体系(纵向抽取机制：一个类文件继承另一个类文件的机制)重复性代码</li>
</ul>
<h4 id="2-AOP原理"><a href="#2-AOP原理" class="headerlink" title="2.AOP原理"></a>2.AOP原理</h4><p>AOP(横向抽取机制) 底层使用动态代理方式实现(实现过程)</p>
<h4 id="3-AOP底层使用动态代理实现"><a href="#3-AOP底层使用动态代理实现" class="headerlink" title="3.AOP底层使用动态代理实现"></a>3.AOP底层使用动态代理实现</h4><ul>
<li>第一种情况，有接口的情况，使用动态代理创建接口实现类代理对象</li>
<li>第二种情况，没有接口的情况，使用动态代理创建类的子类代理对象</li>
</ul>
<blockquote>
<p>第一种情况：</p>
</blockquote>
<pre><code>public interface Dao{
    public void add();
}

public class DaoImpl implements Dao{
    public void add(){
        //添加实现逻辑
    }
}
</code></pre><blockquote>
<p>注意：使用动态代理方式，创建接口实现类代理对象 (创建和DaoImpl类平级的对象 这个对象不是真正的对象，是一个代理对象，实现和DaoImpl相同的功能)</p>
</blockquote>
<blockquote>
<p>第二种情况：</p>
</blockquote>
<pre><code>public class User{
    public void add(){

    }
}
</code></pre><p>动态代理实现(使用cglib动态代理，针对没有接口的情况)</p>
<ul>
<li>创建User类的子类的代理对象</li>
<li>在子类里面调用父类的方法完成增强</li>
</ul>
<h4 id="4-AOP操作术语"><a href="#4-AOP操作术语" class="headerlink" title="4.AOP操作术语"></a>4.AOP操作术语</h4><ul>
<li><p>横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
</li>
<li><p>PointCut(切入点)：在类里面可以有很多方法被增强，比如实际操作中，只是增强了类里面的add()方法和update()方法，实际增强的方法就称为切入点</p>
</li>
<li><p>JoinPoint(连接点)：类里面的哪些方法可以被增强，这些方法就成为连接点，所以这些连接点指的是方法</p>
</li>
<li><p>Advice(通知/增强)：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能就称为增强</p>
<p>前置通知：在方法之前执行<br>后置通知：在方法之后执行<br>异常通知：方法出现异常执行<br>最终通知：在后置之后执行<br>环绕通知：在方法之前和之后执行</p>
</li>
<li><p>Aspect(切面)：将增强应用到具体方法上面，这一过程称为切面(将增强应用到切入点的过程就称为切面) 对横切关注点的抽象</p>
</li>
</ul>
<blockquote>
<p>切面：简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
</blockquote>
<blockquote>
<blockquote>
<p>使用横切系统，AOP把软件系统分为两个部分：核心关注点(业务处理的主要流程)和横切关注点。</p>
</blockquote>
</blockquote>
<hr>
<h4 id="5-代理"><a href="#5-代理" class="headerlink" title="5.代理"></a>5.代理</h4><pre><code>1.JDK动态代理

2.使用cglib生成代理
  对于不使用接口的业务类，无法使用jdk动态代理，而cglib采用非常底层字节码技术，可以为一个类创建子类，解决无接口代理问题

3.关于intercept拦截方法
     /**
     * @param obj CGlib根据指定父类生成的代理对象
     * @param method 拦截的方法
     * @param args 拦截方法的参数数组
     * @param proxy 方法的代理对象，用于执行父类的方法
     * @return
    */
    public Object intercept(Object obj, Method method, Object[] args,
           MethodProxy proxy) throws Throwable {
        ... ...
    }
</code></pre><blockquote>
<p>注意：最新版本Spring已经将CGLib开发类引入spring-core-3.2.0.RELEASE.jar</p>
</blockquote>
<blockquote>
<p>总结：Spring AOP底层就是通过JDK动态代理或CGLIB动态代理技术为目标Bean执行横向织入</p>
</blockquote>
<pre><code>1.若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。
2.若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。

  程序中应该优先对接口创建代理，便于程序解耦维护

  标记为final的方法，不能被代理，因为无法进行覆盖

JDK动态代理，是针对接口生成子类，接口中方法不能使用final修饰
CGLib 是针对目标类生产子类，因此类或方法不能是final的

  Spring只支持方法连接点，不提供属性连接
</code></pre><hr>
<h1 id="Spring的AOP操作-FOD"><a href="#Spring的AOP操作-FOD" class="headerlink" title="Spring的AOP操作 - FOD"></a>Spring的AOP操作 - FOD</h1><p>  1.在Spring里面进行AOP操作，使用aspectj实现<br>    AspectJ：面向切面的框架，不是Spring的一部分，与Spring一起做AOP开发</p>
<p>  2.使用aspectj实现AOP有两种方式<br>    1)基于aspectj的xml配置<br>    2)基于aspectj的注解方式</p>
<h4 id="AOP操作准备"><a href="#AOP操作准备" class="headerlink" title="AOP操作准备"></a>AOP操作准备</h4><p>   1.除了导入基本的jar包之外，还需要导入aop相关的jar包<br>   2.创建一个Spring的核心配置文件，导入aop约束</p>
<h4 id="使用表达式配置切入点"><a href="#使用表达式配置切入点" class="headerlink" title="使用表达式配置切入点"></a>使用表达式配置切入点</h4><p>  1.切入点，实际增强的方法<br>  2.常用表达式<br>    execution</p>
<pre><code>1)execution(*cn.itcast.aop.Book.add(..))
2)execution(*cn.itcast.aop.Book.*(..))
3)execution(**.*(..))
4)匹配所有save开头的方法execution(*save*(..))
</code></pre><h4 id="使用AOP方式操作步骤"><a href="#使用AOP方式操作步骤" class="headerlink" title="使用AOP方式操作步骤"></a>使用AOP方式操作步骤</h4><pre><code>1.配置两个类的对象
&lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;myBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;

2.配置aop操作(1.配置切入点(使用表达式的方式) 2.配置切面(将增强用到方法上面去)  expression：上面所诉表达式 id：名字)
&lt;aop:config&gt;
    &lt;aop:pointcut expression=&quot;&quot; id=&quot;&quot;/&gt;
    &lt;aop:aspect ref=&quot;增强的对象&quot;&gt;
    //配置增强类型
    &lt;aop:before method=&quot;增强类里面所使用的方法&quot; pointcut-ref=&quot;切入点的引用&quot;/&gt;    
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><h2 id="log4j介绍"><a href="#log4j介绍" class="headerlink" title="log4j介绍"></a>log4j介绍</h2><p>1.通过log4j可以看到程序运行过程中更详细的信息(加载的配置文件、日志文件)</p>
<pre><code>log4j使用步骤：
1.导入log4j的jar包
2.复制log4j的配置文件，复制到src下面
  log4j.propertises(配置文件)

3.设置日志的级别
  log4j.rootLogger=info,stdout
    1)info：看到基本的信息
    2)debug：看到更详细的信息
</code></pre><h2 id="Spring整合Web项目演示"><a href="#Spring整合Web项目演示" class="headerlink" title="Spring整合Web项目演示"></a>Spring整合Web项目演示</h2><pre><code>1.演示问题
1.action调用service，service里面调用dao方式，每次访问action的时候都会加载配置文件
2.解决方案
  1)在服务器启动的时候，创建对象加载配置文件
  2)底层使用监听器、ServletContext对象

3.在Spring里面不需要我们自己写代码实现，框架已经帮我们封装好了
  1)封装了一个监听器，只需要配置好监听器就行了
  2)配置监听器之前需要导入Spring整合web项目的jar包
  3)指定加载配置文件的位置

    指定Spring配置文件的位置
    &lt;context-param&gt;
        &lt;param-name&gt;..&lt;/param-name&gt;
        &lt;param-value&gt;...&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre><hr>
<h2 id="基于aspectj的注解aop"><a href="#基于aspectj的注解aop" class="headerlink" title="基于aspectj的注解aop"></a>基于aspectj的注解aop</h2><h4 id="1-使用注解方式实现aop操作"><a href="#1-使用注解方式实现aop操作" class="headerlink" title="1.使用注解方式实现aop操作"></a>1.使用注解方式实现aop操作</h4><pre><code>1.首先引入aop编程的相关jar包
2.然后在bean.xml文件中引入aop名称空间
3.其次在bean.xml文件中开启aop扫描&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;
4.然后开启aop注解方式，默认是false &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
5.开始写一个切面类
  1.@Component：加入IOC容器 @Aspect：指定当前类为切面类 
  2.在类里面指定切入点表达式，拦截那些方法，即为那些类生成代理对象(@Pointcut(&quot;execution(* com.bie.aop.UserDao.*(..))&quot;))
    注意：在类里面可以开启前置增强(@Before(&quot;pointCut()&quot;)) 开启后置增强(@After(&quot;pointCut()&quot;))
6.在写好切面类之后写执行目标对象方法(接口/接口实现类)以及最后的测试类
</code></pre><blockquote>
<p>注意：如果目标对象是有实现接口，spring会自动选择”jdk代理(动态代理)”动态代理标识：<code>class com.sun.proxy.$Proxy10</code> 如果对象没有实现接口，spring会自动调用”cglib代理”</p>
</blockquote>
<pre><code>1)创建对象
  &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;//创建Book对象，被增强类
  &lt;bean id=&quot;MyBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;//创建增强类MyBook对象
2)在Spring核心配置文件中开启aop操作
  &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt;
3)在增强类上面使用注解方式来完成增强配置
  @Aspect
  public class MyBook{
      //在方法上面使用注解完成增强配置
      @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;)
      public void before(){
          System.out.println(&quot;before.......&quot;);
      }
  }
</code></pre><h4 id="2-Spring的jdbcTemplate操作"><a href="#2-Spring的jdbcTemplate操作" class="headerlink" title="2.Spring的jdbcTemplate操作"></a>2.Spring的jdbcTemplate操作</h4><p>  1)Spring框架一站式框架(针对JavaEE的三层，每一层都有解决技术)<br>  2)在DAO层，使用jdbcTemplate</p>
<h4 id="3-Spring对不同的持久化层技术都进行了封装"><a href="#3-Spring对不同的持久化层技术都进行了封装" class="headerlink" title="3.Spring对不同的持久化层技术都进行了封装"></a>3.Spring对不同的持久化层技术都进行了封装</h4><p>  1)jdbcTemplate对jdbc进行封装</p>
<h4 id="4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"><a href="#4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作" class="headerlink" title="4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"></a>4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作</h4><pre><code>添加
  1)导入jdbcTemplate使用的jar包(spring-jdbc-4.2.4.RELEASE.jar spring-tx-4.2.4.RELEASE.jar)
  2)创建对象，设置数据库信息(注意配置数据库的驱动)
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  3)创建jdbcTemplate对象，设置数据源
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  4)调用jdbcTemplate对象里面的方法实现操作
    1.创建sql语句
    String sql=&quot;insert into user values(?,?)&quot;;
    jdbcTemplate.update(sql,&quot;lucy&quot;,&quot;123&quot;);//调用模板中的update方法

修改
  1)设置数据库的信息
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  2)创建jdbcTemplate对象
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  3)调用jdbcTemplate对象里面的update()方法实现操作
  String sql=&quot;update user set password=? where username=?&quot;;//根据用户名修改密码
  int rows=jdbcTemplate.update(sql,&quot;1234&quot;,&quot;lucy&quot;);
  System.out.println(rows);//输出结果为1，修改成功


删除
   1)设置数据库的信息
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  2)创建jdbcTemplate对象
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  3)调用update()方法实现删除
  String sql=&quot;delete from user where username=?&quot;;
  int rows=jdbcTemplate.update(sql,&quot;lucy&quot;);
  System.out.println(rows);


查询
   1.使用jdbcTemplate实现查询操作



   2.查询的具体操作
     1)查询返回某一个值(数据库中有多少条记录)
       1.设置数据库信息

       2.创建jdbcTemplate对象

       3.调用方法得到记录数

     String sql=&quot;select count(*) from user&quot;;
       4.调用jdbcTemplate的方法
     int count=jdbcTemplate.queryForObject(sql,Integer.class);

     第一个参数，sql：返回sql语句
     第二个参数，requiredType：返回类型的class


     注意：jdbc底层实现程序
    public class testJDBC(){
    Connection conn=null;
    PreparedStatement psmt=null;
    ResultSet rs=null;
        //1.加载驱动
    try{
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.创建连接
        conn=DriverManager.getConnection(&quot;jdbc:mysql:///spring_day03&quot;,&quot;root&quot;,&quot;root&quot;);
        //3.编写sql语句
        String sql=&quot;select *from user where username=?&quot;;
        //4.预编译sql
        psmt=connt.prepareStatement(sql);
        //5.设置参数值
        psmt.setString(1,&quot;lucy&quot;);
        //6.执行sql
        rs=psmt.executeQuery();
        //7.遍历结果集
        while(rs.next()){
            //得到返回结果集
            String username=rs.getString(&quot;username&quot;);
            String password=rs.getString(&quot;password&quot;);
            //创建一个实体类，将username与password放到实体类中去
            //创建实体类的对象
            User user=new User();
            user.setUsername(username);
            user.setPassword(password);
            //输出user
            System.out.println(user);
        }
    }catch(ClassNotFoundException e){
        e.printStackTrace();
        }finally{
        try{
            rs.close();
            psmt.close();
            conn.close();
        }catch(SQLException e){
            e.printStackTrace();
            }

        }
    }


     2)查询返回对象

    1)在方法里面操作，设置数据库信息
    DriverManagerDataSource dataSource=new DriverManagerDataSource();
      dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
      dataSource.setUsername(&quot;root&quot;);
      dataSource.setPassword(&quot;root&quot;);

      2)创建jdbcTemplate对象
      JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

    3)写sql语句，根据username查询
    String sql=&quot;select *from user where username=?&quot;;

    4)调用jdbcTemplate的方法实现
    jdbcTemplate.queryForObject(String sql,RowMapper&lt;T&gt;rowMapper,Object...args)

    User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),&quot;lucy&quot;)
        第一个参数：sql语句
        第二个参数：RowMapper，接口，类似于dbutils里面的接口，需要自己写类实现接口，自己实现数据封装
        第三个参数：可变参数

    注意：在Java里面可以有多个class，但是只能有一个public

    写RowMapper类

    class MyRowMapper implements RowMapper&lt;User&gt;{
            @Override
            public User mapRow(ResultSet rs,int num) throws SQLException{
                //1.从结果集里面得到数据
                String username=rs.getString(&quot;username&quot;);
                String password=rs.getString(&quot;password&quot;);
                //2.将得到的数据封装到对象里面
                User user = new User();
                user.setUsername(username);
                user.setPassword(password);
                return user;
            }
        }

    5)输出user
    System.out.println(user);


     3)查询返回list集合

    query(String sql,RowMapper&lt;T&gt; rowMapper,Object...args):List&lt;T&gt;
       1)sql语句
       2)RowMapper接口，自己写类实现数据封装
       3)可变参数

       1)设置数据库信息
    DriverManagerDataSource dataSource=new DriverManagerDataSource();
      dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
      dataSource.setUsername(&quot;root&quot;);
      dataSource.setPassword(&quot;root&quot;);

      2)创建jdbcTemplate对象
      JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

    3)写sql语句
    String sql = &quot;select * from user&quot;;

    4)调用jdbcTemplate的方法实现
    List&lt;User&gt; list=jdbcTemplate.query(sql,new MyRowMapper());
    System.out.println(list);

    //MyRowMapper()实现与上面的一样
</code></pre><blockquote>
<p>注意：增、删、修都是使用update()方法，而查询使用的query()方法</p>
</blockquote>
<hr>
<h2 id="Spring配置连接池和dao使用jdbcTemplate"><a href="#Spring配置连接池和dao使用jdbcTemplate" class="headerlink" title="Spring配置连接池和dao使用jdbcTemplate"></a>Spring配置连接池和dao使用jdbcTemplate</h2><pre><code>1.Spring配置连接池(c3p0)
  1)导入jar包(c3p0连接池jar包c3p0-0.0.2.1.jar   mchange-commons-java-0.2.3.4.jar)

  2)创建Spring配置文件，配置连接池
1)将程序在配置文件中进行配置

&lt;!--配置c3p0连接池--&gt;
//创建连接池对象
&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3po.ComboPooledDataSource&quot;&gt;
     &lt;!--注入属性值--&gt;
     &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day03&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;


  注意：设置c3p0连接池的信息(原始方式)
    ComboPooledDataSource dataSource=new ComboPooledDataSource();
    dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUrl(&quot;jdbc:mysql:///spring_day03&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;root&quot;);


2.dao使用jdbcTemplate

1)创建Service和dao对象，在service里面注入dao对象
&lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt;&lt;/bean&gt;
     &lt;!--注入dao对象--&gt;
     &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;

2)创建jdbcTemplate对象，将模板对象注入到dao里面
//得到JdbcTemplate对象
private JdbcTemplate jdbcTemplate;
public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
    this.jdbcTemplate=jdbcTemplate;
}
&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt;
     &lt;!--注入jdbcTemplate对象--&gt;
     &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

3)在jdbcTemplate对象里面注入dataSource
private DataSource dataSource;
private SQLExceptionTranslator exceptionTranslator;
private boolean lazyInit=true;

public void setDataSource(DataSource dataSource){
    this.dataSource=dataSource;
}

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;!--将dataSource传递到模板对象里面--&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>案例：Service调用DAO，然后DAO调用jdbcTemplate，最后jdbcTemplate调用dataSource</p>
<pre><code>UserService.java

public class UserServie{
    private UserDao userDao;
    public void setUserDao(UserDao userDao){
        this.userDao=userDao;
        }
    public void add(){
        userDao.add();
        }
    }

UserDao.java

public class UserDao{
    //得到JdbcTemplate对象
    private JdbcTemplate jdbcTemplate;
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate=jdbcTemplate;
        }
    //添加操作
    public void add(){
        //创建jdbcTemplate对象
        //JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
        String sql=&quot;insert into user values(?,?)&quot;;
        jdbcTemplate.update(sql,&quot;李磊&quot;,&quot;123&quot;);
        }
    }
</code></pre><p>测试类：</p>
<blockquote>
<p>扩展</p>
<blockquote>
<p>Spring JDBCTemplate 方法详解</p>
</blockquote>
</blockquote>
<pre><code>1.JDBCTemplate 主要提供以下五类方法：
    1.execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句。

    2.update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句。batchUpdate方法用于执行批处理相关语句。

    3.query方法及queryForXXX方法：用于执行查询相关语句。

    4.call方法：用于执行存储过程、函数相关语句。

2.JDBCTemplate 类支持的回调类

    1.预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句

        1.PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement

        2.CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement

    2.预编译语句设置回调：用于给预编译语句相应参数设值

        1.PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值

        2.BatchPreparedStatementSetter：；类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小

    3.自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作

        1.ConnectionCallback：通过回调获取JdbcTemplate提供的Connection，用户可在该Connection执行任何数量的操作

        2.StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作

        3.PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作

        4.CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作

    4.结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式

        1.RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。

        2.RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSetrs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。

        3.ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集。

3.使用方法
</code></pre><blockquote>
<p>1.预编译语句以及存储过程创建回调、自定义功能回调使用</p>
</blockquote>
<p>首先使用<code>PreparedStatementCreator</code>创建一个预编译语句，其次由<code>JdbcTemplate</code>通过<code>PreparedStatementCallback</code>回调传回，由用户决定如何执行该<code>PreparedStatement</code>。此处我们使用的是<code>execute</code>方法。</p>
<blockquote>
<p>2.预编译语句设值回调使用</p>
</blockquote>
<p>通过<code>JdbcTemplate</code>的<code>int update(String sql, PreparedStatementSetterpss)</code> 执行预编译<code>sql</code>，其中<code>sql</code>参数为<code>insert into test(name) values (?)</code>，该<code>sql</code> 有一个占位符需要在执行前设值。<code>PreparedStatementSetter</code> 实现就是为了设值，使用 <code>setValues(PreparedStatementpstmt)</code>回调方法设值相应的占位符位置的值。 <code>JdbcTemplate</code>也提供一种更简单的方式<code>update(String sql, Object... args)</code>来实现设值，所以只要当使用该种方式不满足需求时才应使用<code>PreparedStatementSetter</code>。</p>
<blockquote>
<p>结果集处理回调</p>
</blockquote>
<p><code>RowMapper</code>接口提供<code>mapRow(ResultSet rs, int rowNum)</code>方法将结果集的每一行转换为一个<code>Map</code>，当然可以转换为其他类，如表的对象画形式。</p>
<p><code>RowCallbackHandler</code>接口也提供方法<code>processRow(ResultSet rs)</code>，能将结果集的行转换为需要的形式。</p>
<p><code>ResultSetExtractor</code>使用回调方法<code>extractData(ResultSet rs)</code>提供给用户整个结果集，让用户决定如何处理该结果集。</p>
<blockquote>
<p>注意：我们可以使用JdbcTemplate提供更简单的queryForXXX方法，来简化开发。</p>
</blockquote>
<pre><code>//1.查询一行数据并返回int型结果  
jdbcTemplate.queryForInt(&quot;select count(*) from test&quot;);  

//2. 查询一行数据并将该行数据转换为Map返回  
jdbcTemplate.queryForMap(&quot;select * from test where name=&apos;name5&apos;&quot;);  

//3.查询一行任何类型的数据，最后一个参数指定返回结果类型  
jdbcTemplate.queryForObject(&quot;select count(*) from test&quot;, Integer.class);  

//4.查询一批数据，默认将每行数据转换为Map       
jdbcTemplate.queryForList(&quot;select * from test&quot;);  

//5.只查询一列数据列表，列类型是String类型，列名字是name  
jdbcTemplate.queryForList(&quot;select name from test where name=?&quot;, new Object[]{&quot;name5&quot;}, String.class);  

//6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上  
SqlRowSet rs = jdbcTemplate.queryForRowSet(&quot;select * from test&quot;);  
</code></pre><blockquote>
<p>总结：JDBCTemplate 提供很多方法，这其中的规律便是：第一种提供回调接口让用户决定做什么。第二种是比较简单方法(如：queryForXxx)，用于比较简单的操作。</p>
</blockquote>
<hr>
<pre><code>4.JDBCTemplate 的基本使用步骤

    1.JDBC模板依赖连接池来获取数据的连接，所以需要先构建连接池
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);

    2.创建JDBC模板
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //或者使用构造方法
        jdbcTemplate.setDataSource(dataSource);
</code></pre><blockquote>
<p>注意：1.配置JDBCTemplate的三种方式：1.在自定义的DAO实现类注入一个DataSource引用来完成JdbcTemplate的实例化，即从外部注入DataSource到DAO中，然后实例化jdbctemplate，然后将DataSource设置到jdbcTemplate对象中。2…….</p>
</blockquote>
<pre><code>3.sql语句
    //查询的sql语句
    String sql = &quot;select count(*)  from user&quot;;
    Long num = (long) jdbcTemplate.queryForObject(sql, Long.class);
    System.out.println(num);
</code></pre><blockquote>
<p>注意：Spring学习中，在new对象的时候我们应该想到IOC，在使用set方法时应该想到DI，在要切面时应该想到AOP，所以有一引用链：</p>
</blockquote>
<pre><code>1. 我们需要有DataSource，DataSource的属性可以通过注入数据库的一些配置属性添加

2. 我要有JdbcTemplate，而Template依赖与DataSource，我要以ref的方式为我的JdbcTemplate注入引用

3. 有了JdbcTemplate之后，我要有Dao，此时我应该在Dao添加一个JdbcTemplate的成员，然后以ref的方式将JdbcTemplate引入到Dao中

4. 我在Action或者是Servlet中都会调用的是Serivce，所以，我在Serivce中要添加一个Dao作为成员，然后由ref在注入Dao到Service中

DataSource --&gt; JdbcTemplate --&gt; Dao --&gt; Service --&gt; Action/Servlet

&quot;--&gt;&quot;表示将左边的对象注入到右边的对象当中

5.JDBCTemplate 的CRUD方法

    //插入程序用的是update方法，查询用的是query方法。
    //首先定义一个sql语句
    String  sql = &quot;insert into user (username,password) values(?,?)&quot;;
    //然后使用jdbctemplate方法插入数据
    jdbcTemplate.update(sql, user.getUsername(), user.getPassword());
</code></pre><blockquote>
<p>注意：<code>jdbcTemplate.update</code>适用于<code>insert/update/delete</code>操作。<br>其中：第一个参数为执行的sql。 第二个参数为参数数据 第三个参数为参数类型。</p>
</blockquote>
<pre><code>//删除
String sql = &quot;delete from user where username= ?&quot;;
jdbcTemplate.update(sql, &quot;小王&quot;);

//修改
String sql = &quot;update user set username=? where username= ?&quot;;
jdbcTemplate.update(sql,  user.getUsername() + &quot;_new&quot;, user.getUsername());

//查询
//在最开始使用比较基础的持久化工具(DBUtils)时，会针对查询结果给我们提供一些封装的接口和类，但是JdbcTemplate只给我们提供接口，并没有可用的类，所以需要我们自己实现类来进行封装。

//1.查询表的记录数
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
String sql = &quot;select count(*) from user&quot;;
Long row = jdbcTemplate.queryForObject(sql, Long.class);
System.out.println(&quot;查询出来的记录数为：&quot; + row);

//2.查询返回对象
//获得jdbcTemplate对象
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
String sql = &quot;select username, password from user where username = ?&quot;;
// 设定参数
Object[] object = {&quot;mary_new&quot;};
// 进行查询
User user = jdbcTemplate.queryForObject(sql, object,  new UserMapper());
System.out.println(user);
//注意：除此之外还需要实现结构RowMapper来新建一个映射类，且此java类应该与具体的sql语句对应。
...
    public class UserMapper implements RowMapper&lt;User&gt;{
       @Override
       public User mapRow(ResultSet resultSet, int rows) throws SQLException {
           User user = new User();
           user.setUsername(resultSet.getString(1));
           user.setPassword(resultSet.getString(2));

           return user;
       }
       ....

//3.查询并返回list集合
...
    // 获得jdbcTemplate对象
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);

    // sql语句
    String sql = &quot;select * from user&quot;;
    List&lt;User&gt; users = jdbcTemplate.query(sql, new UserMapper());

    for(User u: users) {
      System.out.println(u);
    }
    ...
</code></pre><hr>
<pre><code>6.JdbcTemplate.queryForList()方法中不同的参数：
    1.String sql;//查询用的sql语句
    2.Object[] args;//sql语句中的参数
    3.int[] argTypes;//sql语句中参数的数据类型
    4.Class elementType;//list装载结果的元数据类型
</code></pre><hr>
<h2 id="Spring的是事务管理"><a href="#Spring的是事务管理" class="headerlink" title="Spring的是事务管理"></a>Spring的是事务管理</h2><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><pre><code>1.事务是一组操作的执行单元，相对于数据库操作来说，事务管理的是一组SQL指令(增删改)，事务的一致性要求这个事务内的操作必须全部执行成功，如果在此过程出现差错，如一条sql语句没有执行成功，那么这一组操作都将全部回滚。
</code></pre><p>这里可以用四个词来解释事务：<br>    A（atomic 原子性）：发生就是全部都发生，不发生全都不发生<br>    C（consistent 一致性）：数据应该不被破坏<br>    I（isolate 隔离性）：用户间操作不相混淆<br>    D（durable 持久性）：永久保存，如保存到数据库中等</p>
<h4 id="Spring事务管理api"><a href="#Spring事务管理api" class="headerlink" title="Spring事务管理api"></a>Spring事务管理api</h4><pre><code>1.spring事务管理的两种方式
1)编程式事务管理(不用)
2)声明式事务管理
      1.基于xml配置文件实现
  2.基于注解方式实现
</code></pre><h4 id="Spring事务管理高层抽象主要包括三个接口"><a href="#Spring事务管理高层抽象主要包括三个接口" class="headerlink" title="Spring事务管理高层抽象主要包括三个接口"></a>Spring事务管理高层抽象主要包括三个接口</h4><pre><code>1.事务管理器：PlatformTransactionManager
1)Spring针对不同的DAO层框架都提供了不同的实现类
2)无论是使用基于xml配置文件方式实现事务管理还是使用基于注解方式实现事务管理，首先都需要配置事务管理器
</code></pre><p>案例：</p>
<pre><code>搭建转账环境

1.创建数据库表，添加数据(创建基本的用户信息(用户名、密码))
2.创建service类和dao类，完成注入关系

&lt;bean id=&quot;orderService&quot; class=&quot;cn.itcast.service.OrderService&quot;&gt;
    &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;ordersDao&quot; class=&quot;cn.itcast.dao.OrdersDao&quot;&gt;
    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

  注意：service层又叫做业务逻辑层，dao层单纯对数据库做操作，在dao层不添加业务
</code></pre><blockquote>
<p>注意：在bean.xml文件配置时候是service中注入dao，dao中注入模板，模板中注入dataSource</p>
</blockquote>
<pre><code>2.事务定义信息(隔离、传播、超时、只读)：TransactionDefinition

3.事务具体运行状态：TransactionStatus
</code></pre><hr>
<h4 id="1-声明式事务管理-xml配置"><a href="#1-声明式事务管理-xml配置" class="headerlink" title="1.声明式事务管理(xml配置)"></a>1.声明式事务管理(xml配置)</h4><pre><code>1.配置文件的方式使用aop思想配置

  1.配置事务管理器
  &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;
  2.配置事务的增强
  &lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;&quot; propagation=&quot;&quot;/&gt;//指定运行事务的匹配规则 propagation：
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  3.配置切面
  &lt;aop:config&gt;
    //1.切入点
    &lt;aop:pointcut expression=&quot;&quot; id=&quot;&quot;/&gt;
    //2.切面
    &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;//表示的意思是将哪个增强(advice-ref)用到哪一个切面(pointcut-ref)上面
  &lt;/aop:config&gt;

2.
</code></pre><h4 id="2-声明式事务管理-注解"><a href="#2-声明式事务管理-注解" class="headerlink" title="2.声明式事务管理(注解)"></a>2.声明式事务管理(注解)</h4><pre><code>1.配置事务管理器
  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframwork.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
  &lt;/bean&gt;

2.配置事务注解
  &lt;tx:annnotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

3.在要使用事务的方法所在类上面添加注释

  @Transactional
  public class OrdersService{
    private OrdersDao ordersDao;
    public void setOrdersDao(OrdersDao ordersDao){

        }
        //调用dao的方法，业务逻辑层写转账业务等
        //要使用到的业务逻辑
    public void accountMoney(){

        }    
    }
</code></pre><hr>
<blockquote>
<blockquote>
<p>扩展：</p>
</blockquote>
</blockquote>
<pre><code>1.常用注解：
1.@Transactional 事务注解，标注当前类时表示类中所有方法都进行事务处理。
  @Transactional public class TestServiceBean implements TestService {}
注意：1.@Transactional 只能被应用到public方法上,对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.

2.POJO类与VO类
    vo：1.表示viewObject 只负责封装页面传递过来的数据 2.valueObject 页面与页面之间的传递时保存值的对象。

    区别1：1.POJO是持久层所使用的，是用来封装原始数据的，而VO则主要用来在视图层活动，两个JavaBean所使用的范围不同。假如我们从数据库取出来的原始数据，我们可以通过业务层将数据进行封装，再通过VO发到页面上去。

    过程：我们获得的时候，数据是原始数据，然后通过业务层进行判断，将其所对应的参数放到VO里。即POJO里的属性主要是用来给数据库用的，而VO里的属性是纯用户显示的。
    区别2：1.POJO类，是不继承任何类(继承Object类)，不实现任何接口的，只有属性和set/get方法。

    2.VO类，实际返回给用户的视图对象，将某个指定页面&lt;组件&gt;的所有数据封装起来。
      如：用户发出请求(可能是填写表单)，表单的数据在展示层被匹配为VO。

    3.PO类，每个数据基本上都对象数据库中的某个字段，一般需要实现序列化接口，也有些时候继承一些类
</code></pre><hr>
<h2 id="SSH框架整合-Struts2-hibernate-spring4-x"><a href="#SSH框架整合-Struts2-hibernate-spring4-x" class="headerlink" title="SSH框架整合(Struts2 hibernate spring4.x)"></a>SSH框架整合(Struts2 hibernate spring4.x)</h2><pre><code>回顾SSH框架知识点
</code></pre><h4 id="Hibernate框架"><a href="#Hibernate框架" class="headerlink" title="Hibernate框架"></a>Hibernate框架</h4><pre><code>1.Hibernate核心配置文件
  - 如果单纯使用Hibernate框架，核心配置文件名称hibernate.cfg.xml和位置在src下面这是固定的
  - Hibernate和Spring进行整合的时候，hibernate核心配置文件的名称和位置是没有固定要求的


  1)ORM思想(对象关系映射 实体类与数据表之间的映射关系)
</code></pre><h4 id="Struts2框架"><a href="#Struts2框架" class="headerlink" title="Struts2框架"></a>Struts2框架</h4><pre><code>1.Action操作
  1)action创建的三种方式
    继承类 ActionSupport

  2)配置action访问路径
    - 创建struts2.xml配置文件，这个配置文件名和位置固定在src下面

  3)配置访问action的多个方法
    - 使用通配符方式配置

  4)在action获取表单提交数据
    - 获取request对象
      --  使用ServletActionContext类获取
    - 属性封装
    - 模型驱动(重点)
    - 表达式封装

  5)在action操作域对象
    - 使用ServletActionContext获取域对象

  6)配置struts2的过滤器


2.值栈
  1)向值栈放数据
- set方法
- push方法
- 定义变量，生成get方法

  2)从值栈获取数据
- 在JSP中使用struts2标签+ognl获取
- &lt;s:property&gt;
- &lt;s:iterator&gt;


3.拦截器
  1)aop和责任链模式
  2)自定义拦截器
    - 继承MethodFilterInterceptor
    - 重写类里面的方法
    - 配置拦截器和action关联
</code></pre><h4 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h4><pre><code>1.spring核心配置文件
  1)名称和位置没有固定要求
  2)在spring核心配置文件中引入schema约束

2.创建对象
  1)xml配置方式 &lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;/&gt;
  2)注解方式，四个注解

3.注入属性
  1)xml配置方式
  2)注解方式，两个注解

4.使用ServletContext对象和监听器实现
  1)在服务器启动时候，加载spring配置文件，创建连接
  2)配置spring的监听器
  3)指定spring配置文件位置
</code></pre><h2 id="SSH整合的思想"><a href="#SSH整合的思想" class="headerlink" title="SSH整合的思想"></a>SSH整合的思想</h2><pre><code>Web层：struts2框架 调用service层

Service层：Spring框架 调用DAO层

Dao层：Hibernate框架 对数据库进行crud操作
</code></pre><blockquote>
<p>注意：框架的之间的整合往往是两个框架之间的整合</p>
</blockquote>
<pre><code>1.struts2框架与Spring框架的整合
  - 将struts2的action对象创建交给Spring来进行管理
    &lt;bean id=&quot;&quot; class=&quot;&quot; acope=&quot;protype&quot;&gt;

2.Spring框架与Hibernate框架之间的整合
  - 将hibernate核心配置文件里面的数据库配置，直接写在Spring配置文件中

  - 在第一次访问的时候会很慢，是因为在第一次访问的时候要创建sessionFactory对象
    -- 解决方案：将sessionFactory对象创建交给Spring来管理

  - 在服务器启动的时候创建sessionFactory对象
</code></pre><h2 id="整合Struts2与Spring框架"><a href="#整合Struts2与Spring框架" class="headerlink" title="整合Struts2与Spring框架"></a>整合Struts2与Spring框架</h2><pre><code>将Struts2的action交给Spring管理
实现过程
1.导入Struts2的jar包
</code></pre><hr>
<h4 id="SSH框架搭建和整合-struts2-spring4-hibernate5"><a href="#SSH框架搭建和整合-struts2-spring4-hibernate5" class="headerlink" title="SSH框架搭建和整合(struts2/spring4/hibernate5)"></a>SSH框架搭建和整合(struts2/spring4/hibernate5)</h4><pre><code>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层），以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。
</code></pre><blockquote>
<p>总结：<br>    在SSH框架中使用Struts2框架作为系统的整体基础架构，负责MVC的分离。<br>    在Struts框架的模型(model)部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring做支持，支持struts和hibernate。</p>
</blockquote>
<pre><code>具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring做支持，支持struts和hibernate。
其实ssh框架最主要的本质是：“高内聚、低耦合”。
</code></pre><hr>
<h2 id="Spring-项目开发经验"><a href="#Spring-项目开发经验" class="headerlink" title="Spring 项目开发经验"></a>Spring 项目开发经验</h2><h4 id="1-spring-使用-HandlerExceptionResolver-实现全局异常捕获"><a href="#1-spring-使用-HandlerExceptionResolver-实现全局异常捕获" class="headerlink" title="1.spring 使用 HandlerExceptionResolver 实现全局异常捕获"></a>1.spring 使用 HandlerExceptionResolver 实现全局异常捕获</h4><p>首先实现的功能，我们在项目实现的过程中，项目会发生异常，但是我们并没有捕获这些异常，所以会经常出现bug等。在我们没有配置捕获全局异常时，容器会自动打印错误信息。但是如果我们在web.xml中配置，就会拦截错误，然后跳转到响应的处理错误页面。</p>
<pre><code>&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;/500.jsp&lt;/location&gt;
&lt;/error-page&gt;
//以上表示在web.xml中配置错误拦截，然后跳转到指定的错误处理界面
</code></pre><p>但是现在我们在项目中通过实现Spring的HandlerExceptionResolver接口是实现所有的异常的捕获。</p>
<ul>
<li><p>方式一(通过实现HandlerExceptionResolver接口)使用步骤：</p>
<p>  1.新建GlobalExceptionResolver</p>
<pre><code>@Component
//使用spring 利用 HandlerExceptionResolver实现全局异常捕获
public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {
    private static Logger LOG = Logger.getLogger(GlobalHandleExceptionResolver.class);
    private static  final int USER_EXCEPTION_CODE = 1;
    private static  final int OTHER_EXCEPTION_CODE =2;

    //编写自己需要的类
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,
                                          Object handle, Exception ex){
        ModelAndView mv = new ModelAndView(&quot;error&quot;);
        if(ex instanceof  UserException){
            mv.addObject(&quot;message&quot;, ex.getMessage());
            mv.addObject(&quot;code&quot;,USER_EXCEPTION_CODE);
            LOG.error(&quot;用户异常:&quot; +ex.getMessage(),ex);
        }else{
            mv.addObject(&quot;message&quot;,&quot;未知异常&quot;);
            mv.addObject(&quot;code&quot;,OTHER_EXCEPTION_CODE);
            LOG.error(&quot;未知异常:&quot;+ ex.getMessage(),ex);
        }
        return mv;
    }
}
</code></pre><p>  2.在spring配置文件中配置新建的类</p>
<pre><code>&lt;!--全局异常捕捉 --&gt;
&lt;bean class=&quot;com.ssm.exception.GlobalExceptionResolver&quot; /&gt;
</code></pre><p>  3.根据需求编写自己需要处理的方法</p>
<blockquote>
<p>注意：在开发的过程中如果返回null，这样的话这个类如同不起作用。如果我们想返回错误页面，那么直接在ModleAndView里面写好即可。</p>
</blockquote>
<p>  ModelAndView modelAndView = new ModelAndView();<br>  modelAndView.setViewName(“error”);<br>  return modelAndView;</p>
</li>
<li><p>方式二(通过使用注解)使用步骤：</p>
<p>  1.创建GlobalExceptionResolver</p>
<pre><code>//通过使用ControllerAdvice和ExceptionHandler这两个注解实现全局的异常捕获
@ControllerAdvice
public class GlobalExceptionResolver {
    //这里的ServiceException是自定义的异常
    @ExceptionHandler(value = ServiceException.class)
    public @ResponseBody String serviceCommonExceptionHandler(ServiceException e) {
        //对捕获的异常进行处理并打印日志等，之后返回json数据，方式与Controller相同
        return &quot;{&apos;code&apos;:-1}&quot;;
    }

    @ExceptionHandler(value = Exception.class)
    public ModelAndView exceptionHandler() {
        //当然也可以直接返回ModelAndView等类型，然后跳转相应的错误页面，这都根据实际的需要进行使用
        return new ModelAndView();
    }
}

//自定义异常：
public class ServiceException extends RuntimeException{
    //...
}
</code></pre><blockquote>
<p>注意：spring会根据@ExceptionHandler的value值进行匹配，如果我们项目中的一些异常没有被捕获，那么这里就会处理一些没有捕获的异常。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="2-Spring-MVC-之-HandlerMethodArgumentResolver"><a href="#2-Spring-MVC-之-HandlerMethodArgumentResolver" class="headerlink" title="2.Spring MVC 之 HandlerMethodArgumentResolver"></a>2.Spring MVC 之 HandlerMethodArgumentResolver</h4><p>简言之，HandlerMethodArgumentResolver = HandlerMethod + Argument(参数) + Resolver(解析器),其实就是HandlerMethod方法的解析器, 将 HttpServletRequest(header + body 中的内容)解析为HandlerMethod方法的参数。</p>
<pre><code>//判断 HandlerMethodArgumentResolver 是否支持 MethodParameter(PS: 一般都是通过 参数上面的注解|参数的类型)
public interface HandlerMethodArgumentResolver {
    //判断是否支持要转换的参数类型
    boolean supportsParameter(MethodParameter var1);
    //当支持后进行相应的转换
    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;
}
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
