<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="BangjinHu'Blog" />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="微信公众号：iProgrammer_ing">
<meta property="og:type" content="website">
<meta property="og:title" content="BangjinHu&#39;s Blog">
<meta property="og:url" content="http://bangjinhu.github.io/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="微信公众号：iProgrammer_ing">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BangjinHu&#39;s Blog">
<meta name="twitter:description" content="微信公众号：iProgrammer_ing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/"/>





  <title>BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/微电子集成电路工程坊 - 开发记录文档/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/微电子集成电路工程坊 - 开发记录文档/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:33:04+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-02T19:40:30+08:00">
                2019-09-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  125
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="flexpaper-openOffice-SwfTools"><a href="#flexpaper-openOffice-SwfTools" class="headerlink" title="flexpaper + openOffice + SwfTools"></a>flexpaper + openOffice + SwfTools</h4><p>1.flexpaper 不支持中文路径，在fb编译器中二次编译之后不支持中文路径，采用数据库中英文路径与中文路径对应的方式解决。</p>
<p>2.在竞赛信息修改的时候，文件修改没有支持，后期加上</p>
<p>3.在系统设置里面加上每个设备的预约数量上限，以设备名称查找已预约设备数量。还有每个实验室的预约数量上限。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Spring技术栈构建前后台团购网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Spring技术栈构建前后台团购网站/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:33:04+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-08T16:59:23+08:00">
                2019-09-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  37
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring技术栈构建前后台团购网站"><a href="#Spring技术栈构建前后台团购网站" class="headerlink" title="Spring技术栈构建前后台团购网站"></a>Spring技术栈构建前后台团购网站</h2><h4 id="lombak插件"><a href="#lombak插件" class="headerlink" title="lombak插件"></a>lombak插件</h4><h4 id="分包发布（Web-Controller-Service-…）"><a href="#分包发布（Web-Controller-Service-…）" class="headerlink" title="分包发布（Web/Controller | Service/…）"></a>分包发布（Web/Controller | Service/…）</h4><h4 id="FreeMarker-Macro"><a href="#FreeMarker-Macro" class="headerlink" title="FreeMarker | Macro"></a>FreeMarker | Macro</h4><h4 id="Sitemesh"><a href="#Sitemesh" class="headerlink" title="Sitemesh"></a>Sitemesh</h4><h4 id="缓存（Redis）"><a href="#缓存（Redis）" class="headerlink" title="缓存（Redis）"></a>缓存（Redis）</h4><h4 id="Mybatis工具类"><a href="#Mybatis工具类" class="headerlink" title="Mybatis工具类"></a>Mybatis工具类</h4><h4 id="地区选择"><a href="#地区选择" class="headerlink" title="地区选择"></a>地区选择</h4>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/以太网/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/以太网/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:53+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-12-17T10:42:03+08:00">
                2019-12-17
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  71
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p>以太网前端有一个叫做前导码的部分（由0|1数字交替组合而成，表示一个以太网帧的开始）。</p>
<p>帧尾最后出现的是FCS，用它可以检测帧是否有损坏。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java 虚拟工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java 虚拟工具/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:10+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-07T16:04:32+08:00">
                2019-11-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-visulVM"><a href="#Java-visulVM" class="headerlink" title="Java visulVM"></a>Java visulVM</h2><p>这是一款Java自带的监控工具。</p>
<h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/高效并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/高效并发/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:10+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-01-04T15:39:44+08:00">
                2020-01-04
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,728
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h2><p>[TOC]</p>
<h3 id="第十二章-Java内存模型与线程"><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h3><p>多任务处理的原因是因为CPU运算速度与计算机的存储、通信子系统的差距太大，大量的时间都花费在磁盘IO、网络通信以及数据库的访问上面。</p>
<p>衡量一个服务性能的高低好坏，每秒事务处理数（TPS）是最重要的指标之一，代表每秒内服务端平均能响应的请求总数。</p>
<h4 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h4><p>Java虚拟机规范中试图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p><strong>12.3.1 主内存与工作内存</strong><br></p>
<p>Java内存模型的主要目标就是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。</p>
<p><strong>12.3.2 内存间交互操作</strong><br></p>
<p>关于主内存与工作内存之间具体的交互协议，一个变量如何从主内存拷贝到工作内存，相反操作等，Java内存模型定义8种操作完成。</p>
<pre><code>1.lock（锁定）：作用于主内存变量。
2.unlock（解锁）：作用于主内存变量。
3.read（读取）：作用于主内存。
4.load（载入）：作用于工作内存变量。
...
</code></pre><p><strong>12.3.3 对于volatile型变量的特殊规则</strong><br></p>
<p>关键字volatile是Java虚拟机提供的最轻量级的同步机制，但是很多情况下程序员使用synchronized来进行同步。因为不理解的缘故。</p>
<p>当一个变量定义为volatile之后，其具备两种特性：</p>
<pre><code>1.保证此变量对所有线程的可见性，可见性表示当一个线程修改变量值的时候，其它线程立刻得知修改后的新值。
</code></pre><blockquote>
<p>提示：普通变量不能做到上面的，它需要通过主内存来完成。如果线程A修改一个普通变量的值，然后主内存进行回写，另外一个线程B在A完成回写之后再从主内存进行读取操作，新的变量才会对线程B可见。</p>
</blockquote>
<blockquote>
<p>提示：JMM实现让volatile修饰变量让其它内存立刻可见的思路在于：==当写一个volatile变量时，JMM会将该线程对应的工作内存中的共享变量值刷新到主内存中==，==当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量==。volatile变量正是通过这种写-读方式实现对其他线程可见（但其内存语义实现则是通过内存屏障）。</p>
</blockquote>
<blockquote>
<p>注意：volatitle变量在各个线程的工作内存中不存在一致性问题。Java里面运算不是原子操作，==导致volatitle变量的运算在并发下一样是不安全的==。</p>
</blockquote>
<pre><code>2.volatile禁止指令重排优化，由于 编译器和处理器 都能执行指令重排优化。普通变量仅仅能保证该方法在执行过程中得到正确的结果，但是不能保证程序代码的执行顺序。

如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。
总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。
</code></pre><blockquote>
<p>内存屏障(内存栅栏)：是一个CPU指令，作用有两个：1.保证特定操作的执行顺序。2.保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</p>
</blockquote>
<blockquote>
<p>提示：使用volatile的优势：在某些情况下，volatile同步机制的性能要优于锁（synchronized关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。volatile变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
</blockquote>
<blockquote>
<p>提示：指令重排序，指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应的电路单元处理，但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保证程序能得出正确的执行结果。</p>
</blockquote>
<p><strong>12.3.4 对于long和double型变量的特殊规则</strong><br></p>
<p>因为Java内存模型要求lock unlock read load assign use store write这8个操作都具有原子性，但是对于64位的数据类型（long和double）在模型中特定一条宽松的规定：允许虚拟机将没有被volatile修饰的 64位 数据的读写操作划分为 两次32位 的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定。</p>
<p>因为Java内存模型虽然允许不将long和double变量的读写实现成原子操作，但是允许虚拟机选择将这些操作实现为具有原子性的操作。</p>
<p><strong>12.3.5 原子性、可见性与有序性</strong><br></p>
<pre><code>1.原子性：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write；在synchronized块之间的操作也具备原子性。

2.可见性：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了volatile之外，Java还有synchronized和final关键字能实现可见性。

3.有序性：如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）。如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序现象和工作内存与主内存同步延迟）。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。
</code></pre><p><strong>12.3.6 先行发生原则</strong><br></p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>面是Java内存模型下一些天然的先行发生关系：</p>
<pre><code>程序次序规则

管程锁定规则

volatile变量规则

线程启动规则

线程终止规则

线程中断规则

对象终结规则

传递性
</code></pre><p>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
<h4 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h4><p><strong>12.4.1 线程的实现</strong><br></p>
<p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度。Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。</p>
<p>实现线程有三种方式：</p>
<pre><code>1.使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）。

2.使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）。

3.使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。）
</code></pre><p><strong>12.4.2 Java线程调度</strong><br></p>
<p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p>
<pre><code>1.协同式调度多线程系统：线程的执行时间由线程本身来控制，线程执行完之后要通过通知系统切换到另一个线程上。

    优势：实现简单。

2.抢占式线程调度：线程由系统来分配执行时间，线程的切换不由线程本身来决定。
</code></pre><p>Java线程优先级</p>
<pre><code>...
</code></pre><p><strong>12.4.3 状态转换</strong><br></p>
<p>Java语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。</p>
<h3 id="第十三章-线程安全与锁优化"><a href="#第十三章-线程安全与锁优化" class="headerlink" title="第十三章 线程安全与锁优化"></a>第十三章 线程安全与锁优化</h3><h4 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h4><h4 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h4><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
<p><strong>13.2.1 Java语言中的线程安全</strong><br></p>
<p>我们可以将Java语言中各种操作共享的数据分为5类：</p>
<pre><code>1.不可变：不可变带来的安全性是最简单和最纯粹的，如final的基本数据类型。如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如：String类的substring、replace方法。Number类型的大部分子类都符合不可变要求的类型，但是AtomicInteger和AtomicLong则并非不可变的。

2.绝对线程安全：Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。比如java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了。

3.相对线程安全：通常意义上所讲的线程安全就是相对相对线程安全，其需要保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要额外的保障措施，但对于特定顺序的连续调用需要额外的同步手段保证调用的正确性。

4.线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况。

5.线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java语言中很少出现。

    5.1 线程对立的例子：

        Thread类的suspend()方法和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程，如果并发进行的话无论调用是否进行同步，目标线程都会有死锁的风险。
</code></pre><p><strong>13.2.2 线程安全的实现方法</strong><br></p>
<p>虚拟机提供的同步和锁机制在线程安全中实现起到重要的作用。</p>
<pre><code>1.互斥同步（阻塞同步）

    同步：表示在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个或一些线程使用。

    互斥：是实现同步的一种手段，临界区 | 互斥量 | 信号量都是主要的互斥实现方法。
</code></pre><blockquote>
<p>提示：在Java中最基本的互斥同步手段就是 synchronized 关键字（该关键字经过编译之后生成了monitorenter和monitorexit两个字节码指令）。</p>
</blockquote>
<p>除了synchronized关键字之外，我们还能使用java.util.concurrent包的重入锁(ReentrantLock)来实现同步，在基本用法中，synchronized关键字和ReentrantLock很像。相比synchronized关键字ReentrantLock增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。</p>
<p>互斥同步属于一种悲观的并发策略，认为如果不做正确的同步措施就会发生问题，所以无论共享数据是否真的会出现竞争，其都要加锁。</p>
<pre><code>2.非阻塞同步

    互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略。

    随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步。

    Java并发包的整数原子类，其中的compareAndSet和getAndIncrement等方法都使用了Unsafe类的CAS操作。

3.无同步方案

    要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码。
</code></pre><h4 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h4><p><strong>13.3.1 自旋锁和自适应自旋</strong><br></p>
<p>互斥同步对性能最大的影响是阻塞的实现，挂起线程 和 恢复线程 的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。</p>
<p>另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<blockquote>
<p>提示：为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁。</p>
</blockquote>
<p>在JDK 1.6已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源。在JDK 1.6中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p><strong>13.3.2 锁消除</strong><br></p>
<p>锁清除表示虚拟机 即时编译器  在运行时对一些程序要求同步，但是被检测到不可能存在共享数据竞争的锁进行清除。</p>
<blockquote>
<p>提示：锁清除的判断依据来源于 逃逸分析 的数据支持(如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其它线程访问到，那就可以将它们当做栈上的数据处理，认为它们是线程私有化的，同步加锁自然无需进行)。</p>
</blockquote>
<p><strong>13.3.3 锁粗化</strong><br></p>
<p>原则上总是推荐将同步块的作用范围限制得尽量小，只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p><strong>13.3.4 轻量级锁</strong><br></p>
<p>它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot虚拟机的对象头分为两部分信息</p>
<pre><code>1.第1部分用于存储对象自身的运行时数据（如哈希码、GC分代年龄等），这部分称为mark word，是实现轻量级锁和偏向锁的关键。

2.第2部分用于存储指定方法区对象类型数据的指针。如果对象是数组，还会有一个部分存储数据的长度。
</code></pre><p><strong>13.3.5 偏向锁</strong><br></p>
<p>偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能（在没有实际竞争的情况下，还能够针对部分场景继续优化）。</p>
<p>如果不仅仅没有竞争，自始至终使用锁的线程都只有一个，那么维护轻量级锁都是浪费的。偏向锁的目的是：减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗，轻量级锁每次申请 | 释放锁都至少需要一次 CAS，但是偏向锁只有初始化时需要使用一次CAS。</p>
<p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下将整个同步都消除掉，连CAS操作都不做。</p>
<p>偏向锁表示会偏向第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其它线程获取，那持有偏向锁的线程将永远不需要再进行同步。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/走近Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/走近Java/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:10+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-07T08:38:37+08:00">
                2019-08-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/虚拟机执行子系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/虚拟机执行子系统/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:10+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-01-04T16:36:20+08:00">
                2020-01-04
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,526
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><p>[TOC]</p>
<h3 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h3><p>程序编译的结果从本地机器码转变为字节码。</p>
<blockquote>
<p>提示：实现语言无关性的基础仍然是虚拟机和字节码存储格式。Class文件中包含了Java虚拟机指令集和符号表以及若干其它辅助信息。</p>
</blockquote>
<h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p>将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p>
<h4 id="6-2-无关性基石"><a href="#6-2-无关性基石" class="headerlink" title="6.2 无关性基石"></a>6.2 无关性基石</h4><pre><code>1.Java刚诞生的口号：一次编写，到处运行（Write Once, Run Anywhere）。

2.实现虚拟机的语言无关性的基础是虚拟机和字节码存储格式，Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成Class文件，从而在虚拟机上运行。
</code></pre><h4 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3 Class类文件的结构"></a>6.3 Class类文件的结构</h4><blockquote>
<p>注意：任何一个Class文件都对应着唯一一个类或接口的定义信息。但相反地，类或接口并不一定都得定义在文件里（比如类或接口也可以通过类加载器直接生成）。</p>
</blockquote>
<p>Class文件是以一组8位字节为基础单位的二进制流，中间没有分隔符。</p>
<p>Class文件中字节序为Big-Endian，最高位字节在地址最低位、最低位字节在地址最高位<br>Class文件中只有2种数据类型：无符号数和表。</p>
<pre><code>1.无符号数：属于基本类型。

2.表：是由多个无符号数或者其它表作为数据项构成的复合数据类型。
</code></pre><blockquote>
<p>提示：无论是无符号数还是表，当需要描述同一类型但数量不定的多个线程时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式。这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
</blockquote>
<blockquote>
<p>提示：Class的结构被完全限定的，不能有任何违背官方规定的操作。</p>
</blockquote>
<p><strong>6.3.1 魔数和Class文件版本</strong><br></p>
<p>每个Class文件的头四个字节称为魔数，用于确定这个文件是否为一个能被虚拟机接受的Class文件。紧接着魔数的4个字节存储的是Class文件的版本号，分为次版本号和主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后的版本的Class文件。</p>
<p><strong>6.3.2 常量池</strong><br></p>
<p>常量池在主次版本之后，可以理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型。常量池的容量计数是从1开始的，0用于描述“不引用任何一个常量池项目”。</p>
<p>常量池中主要存放两大类常量：字面量和符号引用。</p>
<pre><code>1.字面量：接近Java的常量概念。如：文本字符串 | 声明为final的常量值等。

2.符号引用：符号则引用则属于编译原理方面概念。包括：

    2.1 类和接口的全限定名
    2.2 字段的名称和描述符
    2.3 方法的名称和描述符
</code></pre><p>常量池中每一项常量都是一个表，JDK1.7中一共有14种常量类型。</p>
<pre><code>...
</code></pre><p><strong>6.3.3 访问标志</strong><br>        </p>
<p>访问标志用于标示一些类或接口的访问信息，如Class是类还是接口，是否是public，是否定义完为abstract等。如果是类的话，是否被声明为final等。</p>
<p><strong>6.3.4 类索引、父类索引和接口索引集合</strong><br></p>
<p>这三项用于确定类的继承关系，类索引用于确定类的全限定名。父类索引用于确定类的父类的全限定名。接口索引集合用来描述类实现了哪些接口，并按照implements语句的顺序排列。</p>
<p><strong>6.3.5 字段表集合</strong><br></p>
<p>字段表用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量，但是不包括在方法内部声明的局部变量。</p>
<p>字段包括字段修饰符（用标志位描述，和类的访问标志类似），字段的简单名称，字段和方法的描述符以及属性表集合。</p>
<pre><code>1.简单名称是指没有类型和参数修饰的方法或者字段名称。

2.描述符用于描述字段的数据类型，方法的参数列表和返回值。

3.全限定名。如：类的全限定名
</code></pre><p>字段表集合不会列出从超类或父接口中继承而来的字段，但可能列出原本Java程序中不存在的字段，如：内部类指向外部类的实例的字段。</p>
<p><strong>6.3.6 方法表集合</strong><br></p>
<p>方法表集合和字段表集合类似，包括了方法的访问标志、名称索引、描述符索引和属性表集合<br>方法里的Java代码通过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p>
<p>如果父类的方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。但有可能会出现由编译器自动添加的方法，如类构造器“<clinit>”方法和实例构造器“<init>”方法。</init></clinit></p>
<p>Java语言中要重载一个方法，除了要有相同的简单名称之外，还要求必须有与原方法不同的特征签名。特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合。由于返回值不包含在特征签名中，所以Java语言里无法仅仅依靠返回值不同来对已有的方法进行重载。</p>
<p><strong>6.3.7 属性表集合</strong><br></p>
<p>属性表不要求具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略不认识的属性</p>
<p>1.Code属性</p>
<pre><code>Java程序方法体中的代码通过编译器编译成字节码指令后存储在Code属性内
max_stack代表了操作数栈深度的最大值，虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。
</code></pre><blockquote>
<p>提示：Slot是虚拟机为局部变量分配内存所使用的最小单位，局部变量表中的Slot可以重用<br>虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令。</p>
</blockquote>
<pre><code>通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。这样就实现了在任何实例方法里面都能通过this关键字访问到此方法所属的对象。

异常表是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。
</code></pre><p>2.Exceptions属性</p>
<pre><code>Exceptions属性的作用是列举出方法描述时在throws关键字后面列举的异常。
</code></pre><p>3.LineNumberTable属性</p>
<pre><code>用于描述Java源码行号和字节码行号(字节码的偏移量)之间的对应关系。
</code></pre><p>可以在Javac中分别使用-g:none和-g:lines来取消或要求生成这项信息；如果关闭，当抛出异常时，堆栈中将不会显示出错的行号。</p>
<p>4.LocalVariableTable属性</p>
<pre><code>描述栈帧中局部变量中的变量与Java源码中定义的变量之间的关系。
</code></pre><p>可以在Javac中分别使用-g:none和-g:vars来取消或要求生成这项信息。如果关闭，所有参数的名称都将消失，IDE将会使用诸如arg0、arg1之类的占位符代替原油的参数名。</p>
<p>5.ConstantValue属性</p>
<pre><code>用于通知虚拟机自动为静态变量赋值，只有类变量(被static关键字修饰的变量)才可以使用这项属性。
</code></pre><p>虚拟机对非static类型的变量的赋值是在实例构造器<init>方法中进行；而对于类变量则有2种方式，在类构造器<clinit>方法中或者使用ConstantValue属性。</clinit></init></p>
<blockquote>
<p>提示：ConstantValue属性值只能限于基本类型和String。</p>
</blockquote>
<p>6.Signure属性</p>
<pre><code>用于记录泛型签名中包含类型变量或参数化类型的类、接口、初始化方法或成员的泛型签名信息。
</code></pre><p>Java语言的泛型采用的是擦除法实现的伪泛型，在字节码(code属性)中，泛型信息编译(类型变量、参数化类型)之后都通通被擦除掉。</p>
<blockquote>
<p>提示：Java的反射API获取的泛型类型的最终数据源就是来自Signure属性。</p>
</blockquote>
<h4 id="6-4-字节码指令"><a href="#6-4-字节码指令" class="headerlink" title="6.4 字节码指令"></a>6.4 字节码指令</h4><p>Java采用面向操作数栈而不是寄存器的架构。</p>
<p>字节码指令集由于限制了虚拟机操作码的长度为一个字节，所以指令集的字节码总数不可能超过256条。</p>
<p>编译器在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型的数据，将boolean和char类型的数据零扩展为相应的int类型数据。</p>
<p>虚拟机规范规定在处理整型数据时，只有除法指令和求余指令中当出现除数为零时会导致虚拟机抛出ArithmeticException异常。</p>
<p>Java虚拟机在进行浮点数运算时会采用最接近数舍入模式，把浮点数转换整数时，Java虚拟机使用IEEE 754标准的向零舍入模式；多疑浮点数运算不能用于精确计算。</p>
<p>Java虚拟机处理浮点数运算时，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作没有明确的数学定义的话，将会使用NaN表示。所有使用NaN值作为操作数的算法操作，结果都会返回NaN。</p>
<p>在对long类型的数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较采用无信号比较方式。</p>
<p>Java虚拟机直接支持小范围类型向大范围类型的安全转换，比如int到float，而处理窄化类型转化可能会导致结果产生不同的正负号、不同数量级的情况，很可能会导致数值的精度丢失。</p>
<p>Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出的运行时异常<br>各种数据类型的比较最后都会转化为int类型的比较操作。</p>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，2种同步结构都是使用管程(Monitor)来支持。Java虚拟机的指令集中有 monitorenter 和 monitorexit 2条指令来支持synchronized关键字的语义。</p>
<h3 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h3><p>虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机最直接使用的Java类型的过程就是虚拟机的类加载机制。</p>
<h4 id="7-1-类加载特性"><a href="#7-1-类加载特性" class="headerlink" title="7.1 类加载特性"></a>7.1 类加载特性</h4><p>在Java中，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提高灵活性，Java中天生可以动态扩展语言特性就是依赖运行期动态加载和动态连接实现。</p>
<h4 id="7-2-类加载过程"><a href="#7-2-类加载过程" class="headerlink" title="7.2 类加载过程"></a>7.2 类加载过程</h4><p>类的加载过程，从类被加载到虚拟机内存开始，到卸载出内存为止，其整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。</p>
<p><strong>7.2.1 加载</strong><br></p>
<p>加载是类加载过程的一个阶段，在加载阶段需要完成：</p>
<pre><code>1.通过一个类的全限定名来获取定义此类的二进制字节流。

2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据接口。

3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
</code></pre><p><strong>7.2.2 验证</strong><br></p>
<p>验证是连接阶段的第一步，这一阶段的主要目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。</p>
<p>从整体上看，验证阶段大致上会完成4个阶段的校验工作：文件格式、元数据、字节码、符号引用。</p>
<p>1.文件格式验证</p>
<pre><code>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
</code></pre><p>可能包括的验证点：1.是否以魔数0xCAFEBABE开头。2.主次版本号是否在当前虚拟机处理范围之内。3.常量池的常量中是否有不被支持的常量类型。4.指向常量的各种索引值中是否有指向不存在常量或不符合类型的常量。5. …</p>
<p>2.元数据验证</p>
<pre><code>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。
</code></pre><p>可能包括验证点：1.这个类是否有父类。2.这个类的父类是否继承了不允许被继承的类。3. …</p>
<p>3.字节码验证</p>
<pre><code>该阶段的验证主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。在第二阶段对元数据信息中的数据类型做完检查之后，这个阶段将对类的方法进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
</code></pre><p>4.符号引用验证</p>
<pre><code>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。
</code></pre><p>可能验证的内容有：1.符号引用中通过字符串描述的全限定名是否能找到对应的类。2.在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段。…</p>
<p><strong>7.2.3 准备</strong><br></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值阶段，变量所使用的内存都将在方法区中进行分配。</p>
<blockquote>
<p>提示：此时进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将在对象实例化时随着对象一起分配在Java堆中。</p>
</blockquote>
<p><strong>7.2.4 解析</strong><br></p>
<p>该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用和直接引用的关联：</p>
<p>1.概念</p>
<pre><code>1. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

2. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。
</code></pre><blockquote>
<p>注意：虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前采取解析。</p>
</blockquote>
<p>2.对解析结果进行缓存</p>
<p>同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功。同样的，如果第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p>
<p>3.解析动作的目标</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限制符7类符号引用进行。前面四种引用的解析过程，对于后面三种，与JDK1.7新增的动态语言支持息息相关，由于java语言是一门静态类型语言，因此没有介绍invokedynamic指令的语义之前，没有办法将他们和现在的java语言对应上。</p>
<p><strong>7.2.5 初始化</strong><br></p>
<p>类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码（或者说是字节码）。</p>
<h4 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h4><p>类加载器，表示将“通过一个类的全限定名来获取描述此类的二进制字节流”动作放在Java虚拟机外面去实现，从而使得应用程序能够自己觉得如何获取所需要的类。</p>
<p><strong>7.4.1 类与类加载器</strong><br></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p>
<p><strong>7.4.2 类加载器</strong><br></p>
<p>从Java虚拟机的角度分为两种不同的类加载器：启动类加载器（Bootstrap ClassLoader）和其他类加载器。</p>
<pre><code>1.启动类加载器，使用C++语言实现，是虚拟机自身的一部分。

2.其余的类加载器都由Java语言实现，独立于虚拟机之外，并且全都继承自java.lang.ClassLoader类。（这里只限于HotSpot虚拟机）。
</code></pre><p>从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p>
<p>1.启动类加载器（Bootstrap ClassLoader）</p>
<p>这个类加载器负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</p>
<p>2.扩展类加载器（Extension ClassLoader）</p>
<p>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p>3.应用程序类加载器（Application ClassLoader）</p>
<p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>
<p><strong>7.4.3 双亲委派机制</strong><br></p>
<p>双亲委派机制模型：要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。</p>
<blockquote>
<p>双亲委派模型的工作过程：1.如果一个类加载器收到了类加载的请求，先将这个请求委派给父类加载器去完成（所以所有的加载请求最终都会传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</p>
</blockquote>
<p>使用双亲委派模型来组织类加载器之间的关系，显而易见的优势：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p><strong>7.4.4 破坏双亲委派模型</strong><br></p>
<p>1.第一次被破坏</p>
<p>1.第二次被破坏</p>
<p>1.第三次被破坏</p>
<h3 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h3><h4 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h4><p>==执行引擎是Java虚拟机最核心的组成部件之一==。虚拟机的执行引擎由自己实现，所以可以自行定制指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<p>从外观上看，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本节将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p>
<h4 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h4><p>栈帧是用于==支持虚拟机方法调用和方法执行的数据结构==，它是虚拟机运行时数据区中虚拟机栈的栈元素。</p>
<p>栈帧存储了方法的==局部变量表、操作数栈、动态连接和方法返回地址==等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<blockquote>
<p>提示：执行引擎运行所有字节码指令都只针对当前栈帧进行操作。</p>
</blockquote>
<p><strong>8.2.1 局部变量表</strong><br></p>
<p>局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表的容量以变量槽（Variable Slot）为最小单位。 一个Slot可以存放一个32位以内（boolean、byte、char、short、int、float、reference和returnAddress）的数据类型，reference类型表示一个对象实例的引用，returnAddress已经很少见了，可以忽略。</p>
<p>对于64位的数据类型（Java语言中明确的64位数据类型只有long和double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>虚拟机通过==索引定位的方式使用局部变量表==，索引值的范围从0开始至局部变量表最大的Slot数量。访问的是32位数据类型的变量，索引n就代表了使用第n个Slot,==如果是64位数据类型，就代表会同时使用n和n+1这两个Slot==。</p>
<p>为了节省栈帧空间，局部变量Slot可以重用，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。如果当前字节码PC计数器的值超出了某个变量的作用域，那么这个变量的Slot就可以交给其他变量使用。这样的设计会带来一些额外的副作用，比如：在某些情况下，Slot的复用会直接影响到系统的收集行为。</p>
<p><strong>8.2.2 操作数栈</strong><br></p>
<p>操作数栈又称为操作栈，它是一个后入先出栈。当一个方法执行开始时，这个方法的操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是 出栈/入栈操作。</p>
<p>在概念模型中，一个活动线程中两个栈帧是相互独立的。但大多数虚拟机实现都会做一些优化处理：让下一个栈帧的部分操作数栈与上一个栈帧的部分局部变量表重叠在一起，这样的好处是方法调用时可以共享一部分数据，而无须进行额外的参数复制传递。</p>
<p><strong>8.2.3 动态连接</strong><br></p>
<p>每个==栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用==，持有这个引用是为了支持方法调用过程中的动态连接；</p>
<p>字节码中方法调用指令是以常量池中的指向方法的符号引用为参数的，有一部分符号引用会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为 静态解析，另外一部分在每次的运行期间转化为直接引用，这部分称为动态连接。</p>
<p><strong>8.2.4 方法返回地址</strong><br></p>
<p>当一个方法执行之后，只有两种方式可以退出这个方法。</p>
<pre><code>1.执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。

2.另外一种是在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理（即本方法异常处理表中没有匹配的异常处理器），就会导致方法退出，这种退出方式称为异常完成出口。
</code></pre><blockquote>
<p>注意：这种退出方式不会给上层调用者产生任何返回值。</p>
</blockquote>
<p><code>无论采用何种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行</code>，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p>
<p>一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<p><strong>8.2.5 附加信息</strong><br></p>
<p>虚拟机规范允许虚拟机实现向栈帧中添加一些自定义的附加信息，例如与调试相关的信息等。</p>
<h4 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h4><p>方法调用并不等同于方法的执行，方法调用阶段唯一的任务就是确定被调用方法的版本(调用哪一个方法)，不涉及方法内部的具体运行过程，在程序运行时进行方法调用是最普遍频繁的操作。</p>
<blockquote>
<p>提示：Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。</p>
</blockquote>
<p><strong>8.3.1 解析</strong><br></p>
<p>“编译期可知，运行期不可变”的方法（静态方法和私有方法），在类加载的解析阶段，会将其符号引用转化为直接引用（入口地址）。这类方法的调用称为“解析（Resolution）”。</p>
<p>在Java虚拟机中提供了5条方法调用字节码指令：</p>
<pre><code>1.invokestatic:调用静态方法

2.invokespecial:调用实例构造器方法、私有方法、父类方法

3.invokevirtual:调用所有的虚方法

4.invokeinterface:调用接口方法，会在运行时在确定一个实现此接口的对象

5.invokedynamic:先在运行时动态解析出点限定符所引用的方法，然后再执行该方法，在此之前的4条调用命令的分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
</code></pre><p><strong>8.3.2 分派</strong><br></p>
<p>分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟中是如何实现的。</p>
<p>1.静态分派</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派发生在编译阶段。静态分派最典型的应用就是方法重载。</p>
<pre><code>package Demo.controller;

public class staticDispatch {
    static abstract class Human{}

    static class man extends Human{}

    static class woman extends Human{}

    public void sayhello(Human guy){
        System.out.println(&quot;human guy&quot;);
    }

    public void sayhello(man guy){
        System.out.println(&quot;man guy&quot;);
    }

    public void sayhello(woman guy){
        System.out.println(&quot;woman guy&quot;);
    }

    public static void main(String[] args) {
        Human man = new man();
        Human woman = new woman();
        staticDispatch staticDispatch = new staticDispatch();
        staticDispatch.sayhello(man);

        staticDispatch.sayhello(woman);
    }
}
</code></pre><blockquote>
<p>总结：Human man = new Man();其中的Human称为变量的静态类型，man称为变量的实际类型。那么两者的区别在于：静态类型在编译期可知，而实际类型到运行期才能确定。在重载时通过参数的静态类型而不是实际类型作为判定依据，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。</p>
</blockquote>
<p>所以选择了sayhello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p>
<p>2.动态分派</p>
<p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。最典型的应用就是方法重写。</p>
<p>3.单分派和多分派</p>
<p>方法的接收者、方法的参数都可以称为方法的宗量。根据分批基于多少种宗量，可以将分派划分为单分派和多分派。单分派是根据一个宗量对目标方法进行选择的，多分派是根据多于一个的宗量对目标方法进行选择的。</p>
<p>Java在进行静态分派时，选择目标方法要依据两点：一是变量的静态类型是哪个类型，二是方法参数是什么类型。因为要根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
<p>运行时阶段的动态分派过程，由于编译器已经确定了目标方法的签名（包括方法参数），运行时虚拟机只需要确定方法的接收者的实际类型，就可以分派。因为是根据一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<blockquote>
<p>注：到JDK1.7时，Java语言还是静态多分派、动态单分派的语言，未来有可能支持动态多分派。</p>
</blockquote>
<p>4.虚拟机动态分派的实现</p>
<p>由于动态分派是非常频繁的动作，而动态分派在方法版本选择过程中又需要在方法元数据中搜索合适的目标方法，虚拟机实现出于性能的考虑，通常不直接进行如此频繁的搜索，而是采用优化方法。</p>
<p>其中一种“稳定优化”手段是：在类的方法区中建立一个虚方法表（Virtual Method Table, 也称vtable, 与此对应，也存在接口方法表——Interface Method Table，也称itable）。使用虚方法表索引来代替元数据查找以提高性能。其原理与C++的虚函数表类似。</p>
<p>虚方法表中存放的是各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类中该方法相同，都指向父类的实现入口。虚方法表一般在类加载的连接阶段进行初始化。</p>
<p><strong>8.3.3 动态类型语言支持</strong><br></p>
<p>JDK新增加了invokedynamic指令来是实现“动态类型语言”。</p>
<p>静态语言和动态语言的区别：</p>
<pre><code>静态语言（强类型语言）： 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。  例如：C++、Java、Delphi、C#等。

动态语言（弱类型语言） ： 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。  例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

强类型定义语言 ： 强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。

弱类型定义语言 ： 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
</code></pre><h4 id="8-4-基于栈的字节码解释执行引擎"><a href="#8-4-基于栈的字节码解释执行引擎" class="headerlink" title="8.4 基于栈的字节码解释执行引擎"></a>8.4 基于栈的字节码解释执行引擎</h4><p>虚拟机如何调用方法的内容已经讲解完毕，现在我们来探讨虚拟机是如何执行方法中的字节码指令。</p>
<p><strong>8.4.1 解释执行</strong><br></p>
<p>Java语言经常被人们定位为“解释执行”语言，在Java初生的JDK1.0时代，这种定义还比较准确的，但当主流的虚拟机中都包含了即时编译后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出来了直接生成本地代码的编译器[如何GCJ（GNU Compiler for the Java）]，而C/C++也出现了通过解释器执行的版本（如CINT），这时候再笼统的说“解释执行”，对于整个Java语言来说就成了几乎没有任何意义的概念，只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。</p>
<p>Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译就是半独立实现的，</p>
<p><strong>8.4.2 基于栈的指令集和基于寄存器的指令集</strong><br></p>
<p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），依赖操作数栈进行工作。与之相对应的另一套常用的指令集架构是基于寄存器的指令集， 依赖寄存器进行工作。</p>
<p>基于栈的指令集主要的优点就是可移植，寄存器是由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。</p>
<p>栈架构的指令集还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单等。<br>栈架构指令集的主要缺点是执行速度相对来说会稍微慢一些。</p>
<h3 id="第九章-类加载及执行子系统的案例实战"><a href="#第九章-类加载及执行子系统的案例实战" class="headerlink" title="第九章 类加载及执行子系统的案例实战"></a>第九章 类加载及执行子系统的案例实战</h3><h4 id="9-1-Tomcat：正统的类加载架构"><a href="#9-1-Tomcat：正统的类加载架构" class="headerlink" title="9.1 Tomcat：正统的类加载架构"></a>9.1 Tomcat：正统的类加载架构</h4>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/类加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/类加载/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:10+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-09T20:19:39+08:00">
                2019-11-09
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,794
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>[toc]</p>
<p>在Java程序中，类型的加载、连接和初始化过程都是在程序运行期间完成的。提供了更大的灵活性，增加了更多的功能。</p>
<h3 id="Java-虚拟机与程序的生命周期"><a href="#Java-虚拟机与程序的生命周期" class="headerlink" title="Java 虚拟机与程序的生命周期"></a>Java 虚拟机与程序的生命周期</h3><p>在如下几种情况下，Java虚拟机将结束生命周期：</p>
<pre><code>1. 执行了System.exit()方法

2. 程序正常执行结束

3. 程序在执行过程中遇到异常或错误而异常终止

4. 由于操作系统出现错误而导致Java虚拟机进程终止
</code></pre><h3 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h3><pre><code>1. 加载：查找并加载类的二进制数据（就是将二进制形式的Java类型读入Java虚拟机中）

2. 连接：

    1. 验证：确保被加载的类的正确性

    2. 准备：为类的静态变量分配内存、并将其初始化为默认值（为类变量分配内存，设置默认值。但是到达初始化之前，类变量都没有初始化为真正的初始值。）

    3. 解析：将类中的符号引用转换为直接引用（解析过程是在类型的常量池中寻找类、接口、字段和方法的符号引用，将这些符号引用替换为直接引用的过程。）

3. 初始化：为类的静态变量赋予正确的初始值（为类的变量赋予正确的初始值）

    类的初始化步骤：

        1. 假如这个类还没有被加载和连接，那就先进行加载和连接

        2. 假如类存在直接父类，并且这个父类还没有被初始化，那么就先初始化直接父类

        3. 假如类中存在初始化语句，那就依次执行这些初始化语句

4. 类的实例化：

    1. 为新的对象分配内存
    2. 为实例变量赋予默认值
    3. 为实例变量赋予正确初始值。

    Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为&lt;init&gt;。针对源程序中每一个类的构造方法，Java编译器都产生一个&lt;init&gt;方法。
</code></pre><h4 id="Java对类的使用方式"><a href="#Java对类的使用方式" class="headerlink" title="Java对类的使用方式"></a>Java对类的使用方式</h4><p>Java程序对类的使用方式有两种：主动使用与被动使用。所有Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才 初始化 它们。</p>
<pre><code>1. 主动使用

    1. 创建类的实例
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值
    3. 调用类的静态方法
    4. 反射
    5. 初始化一个类的子类
    6. Java虚拟机启动时被标明为启动类的类
    7. 动态语言支持
</code></pre><blockquote>
<p>提示：调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
</blockquote>
<pre><code>2. 被动使用

    除了上面的七种主动使用方式之外，其它方式不会导致类被初始化
</code></pre><blockquote>
<p>提示：所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化它们。</p>
</blockquote>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类的加载指将类.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范没有说明Class对象位于哪里，hospot将其放在方法区内）封装类在方法区内的数据结构。</p>
<p>类的加载的最终产品是位于内存中的Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<blockquote>
<p>类加载器是用来将类加载到Java虚拟机中，在jdk1.2之后采用双亲委托机制，该机制能够更好的保证Java平台的安全。在此机制中，出Java虚拟机自带的根类加载器之外，其余的类加载器都有且只有一个父类加载器。当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，如果父类加载器能加载，则由父类加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p>
</blockquote>
<h5 id="加载-class文件方式"><a href="#加载-class文件方式" class="headerlink" title="加载.class文件方式"></a>加载.class文件方式</h5><pre><code>1. 从本地系统中直接加载

2. 通过网路下载.class文件

3. 从zip等归档文件中加载

4. 将Java源文件动态编译为.class文件

...
</code></pre><blockquote>
<p>提示：对于静态字段来说，只要直接定义了该字段的类才会被初始化。当一个类在初始化时，要求其父类全部都已经初始化完成。</p>
</blockquote>
<pre><code>-XX:+TraceClassLoading：用于追踪类的加载信息并打印出来。

-XX:+&lt;option&gt;，表示开启option选项
-XX:-&lt;option&gt;，表示关闭option选项
-XX:&lt;option&gt;=&lt;value&gt;，表示将option选项值设置为value
</code></pre><p>由上面的命令可以在控制台得到即使static中没有被初始化，但是在Java中已经被加载出来过的。</p>
<p>常量在编译阶段会被存入到调用这个常量方法所在类的常量池中。本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</p>
<blockquote>
<p>提示：助记符：</p>
</blockquote>
<blockquote>
<blockquote>
<p>ldc表示将int，float或是String类型的常量值从常量池中推送至栈顶。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>bipush表示将单字节（-128-127）的常量推送至栈顶。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>sipush表示将一个短整型的常量值（-32768-32767）推送至栈顶。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>iconst_1表示将int类型1推送至栈顶。（iconst_1 - iconst_5）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>anewarry表示创建一个引用类型的（如类、接口、数组）数组，并将其引用值压入栈顶</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>newarray表示创建一个指定的原始类型（如int float char等）的数组，并将其引用值压入栈顶。</p>
</blockquote>
</blockquote>
<p>当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，会导致这个被初始化。</p>
<p>对于数组实例来说，其类型是由JVM在运行期间动态生成的，表示 [运行类的类型 这种形式。动态生成的类型，其父类类型是Object。对于数组来说，JavaDoc经常将构成数组的元素的Component，实际就是数组降低一个维度后的类型。</p>
<blockquote>
<p>提示：当一个数组类的类型是原生类型时，表示该类的类加载器是没有的（null）。</p>
</blockquote>
<p>当一个接口在初始化时，并不要求其父接口都完成初始化。只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。</p>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ol>
<li>在初始化一个类时，并不会先初始化它所实现的接口。</li>
<li>在初始化一个接口时，并不会先初始化它的父接口。</li>
</ol>
<p>所以一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时才会导致该接口的初始化。</p>
<h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><p>只有当程序访问的 静态变量 或 静态方法 确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。</p>
<p>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<h4 id="两种类型的类加载器"><a href="#两种类型的类加载器" class="headerlink" title="两种类型的类加载器"></a>两种类型的类加载器</h4><p>类加载器并不需要等到某个类被“首次主动使用”时在加载它。</p>
<p>1.JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误。（LinkageError错误）。2. 如果这个类一直没有被使用，那么类加载器就不会报错错误。</p>
<p>在类被加载之后，就进入连接阶段，该阶段是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p>
<blockquote>
<p>类的验证内容：1. 类文件的结构检查。 2. 语义检查。 3. 字节码检查。 4. 二进制兼容性验证。</p>
</blockquote>
<h5 id="1-Java虚拟机自带的加载器"><a href="#1-Java虚拟机自带的加载器" class="headerlink" title="1. Java虚拟机自带的加载器"></a>1. Java虚拟机自带的加载器</h5><p>由上到下的类加载器：</p>
<pre><code>1. 根类加载器（Bootstrap）

    该加载器没有父加载器，它负责加载虚拟机的核心类库，如：java.lnag.*等。根类加载器从系统属性 sun.boot.class.path 所指定的目录中加载类库。该加载器的实现依赖底层操作系统，是虚拟机实现的一部分，并没有继承java.lang.ClassLoader类。

        $JAVA_HOME中jre/lib/rt.jar里所有的.class，是由c++实现，不是classloader的子类。

2. 扩展类加载器（Extension）

    它的父加载器是根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库。或者从jdk的安装目录的 jre\lib\ext子目录（扩展目录）下加载类库。如果用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载。该加载器是java.lang.ClassLoader类的子类。

        负责加载Java平台的扩展功能的jar包。包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。

3. 系统（应用）类加载器（System）

    或称为应用类加载器，它的父加载器是扩展类加载器。它从环境变量 classpath或者系统属性 java.class.path 所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。该加载器是 java.lang.ClassLoader 类的子类。

        负责加载classpath中指定的jar包及目录中class。
</code></pre><h5 id="2-用户自定义的类加载器"><a href="#2-用户自定义的类加载器" class="headerlink" title="2. 用户自定义的类加载器"></a>2. 用户自定义的类加载器</h5><pre><code>1. java.lang.ClassLoader的子类

    所有用户自定义的类加载器都应该继承该类。

2. 用户可以定制类的加载方式
</code></pre><h5 id="当前类加载器（Current-ClassLoader）"><a href="#当前类加载器（Current-ClassLoader）" class="headerlink" title="当前类加载器（Current ClassLoader）"></a>当前类加载器（Current ClassLoader）</h5><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其它类（指的是所依赖的类），如果ClassX引用了ClassY，那么ClassX的类加载器就会去加载ClassY（前提是ClassY尚未被加载）。</p>
<h5 id="线程上下文加载器（Context-ClassLoader）"><a href="#线程上下文加载器（Context-ClassLoader）" class="headerlink" title="线程上下文加载器（Context ClassLoader）"></a>线程上下文加载器（Context ClassLoader）</h5><p>线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器。</p>
<p>如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类和资源。</p>
<h5 id="线程上下文类加载器的重要性"><a href="#线程上下文类加载器的重要性" class="headerlink" title="线程上下文类加载器的重要性"></a>线程上下文类加载器的重要性</h5><pre><code>SPI（Service Provider Interface） - 服务提供接口
</code></pre><p>父ClassLoader可以使用当前线程Thread.currentThread().getContextLoader()所指定的ClassLoader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其它没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。</p>
<blockquote>
<p>提示：线程上下文类加载器就是当前线程的Current ClassLoader。</p>
</blockquote>
<p>在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的，而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包（厂商提供），Java的启动类加载器是不会加载其它来源的jar的，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>
<blockquote>
<p>提示：线程上下文类加载器的一般使用模式（获取-使用-还原）。</p>
</blockquote>
<pre><code>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

try{
    Thread.currentThread().setContextClassLoader(targetTccl);
    myMethod();
}finally{
    Thread.currentThread().setContextClassLoader(classLoader);
}
</code></pre><p>在myMethod里面则调用了Thread.currentThread().getContextClassLoader()，获取当前线程的上下文类加载器做某些事情。</p>
<p>如果一个类由类加载器A加载，那这个类的依赖类也是由相同的类加载器加载的（如果该依赖类之前没有被加载过的话）。</p>
<blockquote>
<p>提示：ContextClassLoader的作用就是为了破坏Java的类加载委托机制。</p>
</blockquote>
<p>当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。</p>
<h4 id="类加载器的双亲委托机制"><a href="#类加载器的双亲委托机制" class="headerlink" title="类加载器的双亲委托机制"></a>类加载器的双亲委托机制</h4><p>在双亲委托机制中，各个加载器按照父子关系形成了树形结构（逻辑意义上的树形结构），除了根类加载器之外，其余的类加载器都有且只有一个父加载器。</p>
<pre><code>1. 自底向上检查类是否已经加载

2. 自顶向下尝试加载类

public Test16(String classLoaderName) {
    super();//将系统类加载器当做该类加载器的父加载器
    this.classLoaderName = classLoaderName;
}

public Test16(ClassLoader parent, String classLoaderName) {
    super(parent);//显示指定该类加载器的父加载器
    this.classLoaderName = classLoaderName;
}
</code></pre><p>如果有一个类加载器能够成功加载到我们的Test类，那么称此类加载器是定义类加载器，而所有能够成功返回Class对象引用的类加载器（包括定义类加载器）都称为初始类加载器。</p>
<h5 id="类加载器双亲委托模型的优点"><a href="#类加载器双亲委托模型的优点" class="headerlink" title="类加载器双亲委托模型的优点"></a>类加载器双亲委托模型的优点</h5><pre><code>1. 可以确保Java核心类库的类型安全：所有的Java应用都至少会引用java.lang.Object类，也就是在运行期，java.lang.Object这个类会被加载到Java虚拟机中。如果这个加载过程是由Java应用自己的类加载器所完成，那么很可能就会在JVM中存在很多版本的java.lang.Object类，而且这些类之间还是不兼容的，互相不可见的（正是命名空间在发挥作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了Java应用所使用的都是同一个版本的Java核心类库，它们之间是相互兼容的。

2. 可以确保Java核心类库所提供的类不会被自定义的类所替代。

3. 不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要不同的类加载器来加载它们即可。不同的类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。
</code></pre><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成的。</p>
<p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</p>
<p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p>
<h5 id="关于命名空间的说明"><a href="#关于命名空间的说明" class="headerlink" title="关于命名空间的说明"></a>关于命名空间的说明</h5><pre><code>1. 子加载器所加载的类能够访问父加载器所加载的类。

2. 父加载器所加载的类无法访问子加载器所加载的类。
</code></pre><h5 id="不同类加载器命名空间关系"><a href="#不同类加载器命名空间关系" class="headerlink" title="不同类加载器命名空间关系"></a>不同类加载器命名空间关系</h5><p>同一个命名空间内的类是相互可见的，子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类。如：系统类加载器加载的类能看见根类加载器加载的类。</p>
<p>由父加载器加载的类不能看见子加载器加载的类。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类互相不可见。</p>
<p>在运行期，一个Java类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器（defining loader）所共同决定的。如果同样名字（即相同的完全限定名）的类是由两个不同的加载器所加载的，那么这些类就是不同的，即便.class文件的字节码完全一样，并且从相同的位置加载。</p>
<p>内建于JVM中的启动类加载器会加载 java.lang.ClassLoader以及其它的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫作启动类加载器（Bootstrap）。</p>
<blockquote>
<p>提示：启动类加载器并不是Java类，而其它的加载器则都是Java类。启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。所有类加载器（除了启动类加载器）都被实现为Java类，不过，总归要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。</p>
</blockquote>
<h4 id="获得ClassLoader的途径"><a href="#获得ClassLoader的途径" class="headerlink" title="获得ClassLoader的途径"></a>获得ClassLoader的途径</h4><ol>
<li>获取当前类的ClassLoader -&gt; clazz.getClassLoader();</li>
<li>获取当前线程上下文的ClassLoader -&gt; Thread.currentThread().getContextClassLoader();</li>
<li>获取系统的ClassLoader -&gt; ClassLoader.getSystemClassLoader();</li>
<li>获取调用者的ClassLoader -&gt; DriverManager.getCallerClassLoader();</li>
</ol>
<h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>当类被加载、连接和初始化后，它的生命周期开始，当代表该类的class对象不再被引用，即不可触及时，class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。</p>
<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>
<p>由Java虚拟机自带的类加载器所加载的类在虚拟机的生命周期中，始终不会被卸载。而由用户自定义的类加载器可以被卸载。</p>
<h4 id="Laucher-加载类加载器"><a href="#Laucher-加载类加载器" class="headerlink" title="Laucher 加载类加载器"></a>Laucher 加载类加载器</h4><p>源码分析</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/程序编译与代码优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/程序编译与代码优化/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:10+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-01-04T15:48:04+08:00">
                2020-01-04
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  99
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h2><p>[TOC]</p>
<h3 id="第10章-早期（编译器）优化"><a href="#第10章-早期（编译器）优化" class="headerlink" title="第10章 早期（编译器）优化"></a>第10章 早期（编译器）优化</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>javac 这类编译器对代码的运行效率没有任何优化措施。</p>
<h4 id="Javac-编译器"><a href="#Javac-编译器" class="headerlink" title="Javac 编译器"></a>Javac 编译器</h4><p>它本身是一个Java语言编写的程序。</p>
<h3 id="第11章-晚期（运行期）优化"><a href="#第11章-晚期（运行期）优化" class="headerlink" title="第11章 晚期（运行期）优化"></a>第11章 晚期（运行期）优化</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>即时编译器（JIT编译器），不是虚拟机必需的部分，Java虚拟机规范</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第14章 Spring MVC工作机制和设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第14章 Spring MVC工作机制和设计模式/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T07:32:01+08:00">
                2020-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-10-21T19:30:20+08:00">
                2019-10-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  21
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第14章-Spring-MVC工作机制和设计模式"><a href="#第14章-Spring-MVC工作机制和设计模式" class="headerlink" title="第14章 Spring MVC工作机制和设计模式"></a>第14章 Spring MVC工作机制和设计模式</h2><p>[TOC]</p>
<h3 id="Spring-MVC总体设计"><a href="#Spring-MVC总体设计" class="headerlink" title="Spring MVC总体设计"></a>Spring MVC总体设计</h3>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">242</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.avantv.cn" target="_blank" title="AVANTV">
                      
                        <i class="fa fa-fw fa-user"></i>AVANTV</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">465.0k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
