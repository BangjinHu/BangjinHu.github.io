<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="spring," />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="注意：所有文章除特别说明外，转载请注明出处. Spring - FDSpring提供一种方法管理你的业务对象，主要有两个功能为我们的业务对象管理提供便捷  1.DI 依赖注入 2.AOP 面向切面编程  1.Java Bean每一个实现Bean的规范才可以由Spring来接管，而Bean的规范是： 1.必须是个共有类  2.有无参构造函数  3.用公有方法暴露内部成员属性(setter/gett">
<meta name="keywords" content="spring">
<meta property="og:type" content="article">
<meta property="og:title" content="spring">
<meta property="og:url" content="http://bangjinhu.github.io/undefined/Spring/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="注意：所有文章除特别说明外，转载请注明出处. Spring - FDSpring提供一种方法管理你的业务对象，主要有两个功能为我们的业务对象管理提供便捷  1.DI 依赖注入 2.AOP 面向切面编程  1.Java Bean每一个实现Bean的规范才可以由Spring来接管，而Bean的规范是： 1.必须是个共有类  2.有无参构造函数  3.用公有方法暴露内部成员属性(setter/gett">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-20T07:04:21.072Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring">
<meta name="twitter:description" content="注意：所有文章除特别说明外，转载请注明出处. Spring - FDSpring提供一种方法管理你的业务对象，主要有两个功能为我们的业务对象管理提供便捷  1.DI 依赖注入 2.AOP 面向切面编程  1.Java Bean每一个实现Bean的规范才可以由Spring来接管，而Bean的规范是： 1.必须是个共有类  2.有无参构造函数  3.用公有方法暴露内部成员属性(setter/gett">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/undefined/Spring/"/>





  <title>spring | BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">spring</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T09:22:26+08:00">
                2018-06-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-09-20T15:04:21+08:00">
                2018-09-20
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Spring-FD"><a href="#Spring-FD" class="headerlink" title="Spring - FD"></a>Spring - FD</h1><p>Spring提供一种方法管理你的业务对象，主要有两个功能为我们的业务对象管理提供便捷</p>
<ul>
<li>1.DI 依赖注入</li>
<li>2.AOP 面向切面编程</li>
</ul>
<h4 id="1-Java-Bean"><a href="#1-Java-Bean" class="headerlink" title="1.Java Bean"></a>1.Java Bean</h4><p>每一个实现Bean的规范才可以由Spring来接管，而Bean的规范是：</p>
<pre><code>1.必须是个共有类 
2.有无参构造函数 
3.用公有方法暴露内部成员属性(setter/getter) 实现了这样的规范的类才叫做JavaBean(一种可重用组件)
</code></pre><h4 id="2-DI-依赖注入"><a href="#2-DI-依赖注入" class="headerlink" title="2.DI-依赖注入"></a>2.DI-依赖注入</h4><p> 简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p>
<h4 id="3-AOP-面向切面对象"><a href="#3-AOP-面向切面对象" class="headerlink" title="3.AOP-面向切面对象"></a>3.AOP-面向切面对象</h4><p>在执行某个操作前后需要输出日志，但是如果是手工加代码会非常吃力，维护也非常艰难，所以这就需要面向切面编程</p>
<a id="more"></a>
<hr>
<h2 id="Spring框架的主要内容"><a href="#Spring框架的主要内容" class="headerlink" title="Spring框架的主要内容"></a>Spring框架的主要内容</h2><h4 id="1-Spring框架运行环境"><a href="#1-Spring框架运行环境" class="headerlink" title="1.Spring框架运行环境"></a>1.Spring框架运行环境</h4><pre><code>Data Access/Integration：JDBC ORM OXM JMS Transaction 
Web：WebSocket Servlet Web Portlet
Core Container：Beans Core Context SpEL

AOP Aspects Instrumentation Messaging

Test


Test：Spring支持Junit单元测试
</code></pre><blockquote>
<p>核心容器(IOC)：Bean(Bean工厂/创建对象)、Core(一切的基础)、Context(上下文)、SpEL(Spring的表达式语言)</p>
</blockquote>
<blockquote>
<p>AOP：AOP、Aspects</p>
</blockquote>
<blockquote>
<p>数据访问的支持:JDBC、ORM、Transaction、JMS(Java邮件服务)</p>
</blockquote>
<blockquote>
<p>Web的支持：Spring MVC</p>
</blockquote>
<hr>
<h4 id="2-Ioc-Inversion-of-control-控制反转"><a href="#2-Ioc-Inversion-of-control-控制反转" class="headerlink" title="2.Ioc(Inversion of control)控制反转"></a>2.Ioc(Inversion of control)控制反转</h4><p>这是一种设计思想，在Java开发中，Ioc意味着将你设计好的对象交给容器控制管理，不像传统的在对象内部直接控制。</p>
<p>解释：在传统的Java程序设计中，在对象内部通过new进行创建对象，是程序主动去创建依赖对象，Ioc专门有一个容器来创建这些对象，即由Ioc容器来控制对象的创建。Ioc容器控制了对象，主要控制了外部资源的获取。</p>
<hr>
<h4 id="3-DI-Dependency-Injection-依赖注入"><a href="#3-DI-Dependency-Injection-依赖注入" class="headerlink" title="3.DI(Dependency Injection)依赖注入"></a>3.DI(Dependency Injection)依赖注入</h4><p>组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>解释：应用程序依赖于Ioc容器。应用程序需要Ioc容器来提供对象需要的外部资源。Ioc容器注入应用程序某个对象，应用程序依赖的对象。注入某个对象所需要的外部资源(对象、资源、常量数据)。</p>
<blockquote>
<p>一般项目开发的模块：</p>
</blockquote>
<pre><code>注意：
    DAO层、Service层、Controller层和View层详解
    1.DAO层
      主要做数据持久层的工作，负责与数据库进行联络的一些任务封装在此。
        1)设计DAO层的接口
        2)在Spring配置文件中定义此接口的实现类
        3)在模块中调用此接口来进行数据业务的处理，不需要关心此接口的具体实现类是哪个类
        注意：DAO层的数据源配置以及有关数据库连接的参数都在Spring的配置文件中进行配置

    2.Service层
      此层主要负责业务模块的逻辑应用设计
        1)首先设计接口，再设计其实现类，最后再在配置文件中配置其实现的关联，从而在应用中调用service接口来进行业务处理。
        2)service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用业务逻辑的独立性和重复利用性。

    3.Controller层
      此层负责具体的业务模块流程的控制，在此层要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行

    4.View层
      View层与控制层结合比较紧密，View层主要负责网页前台的JSP页面的表示
</code></pre><blockquote>
<p>1.首先给出Ioc(控制反转)思想程序：</p>
</blockquote>
<pre><code>1.定义DAO接口UserDao
2.定义DAO接口实现类UserDaoMysqlImpl和UserDaoOracleImpl
3.定义Service层接口UserService，实现具体的业务
4.定义Service接口的实现类UserServiceImpl,Service层的业务实现，具体要调用到已定义的Dao层的接口
</code></pre><blockquote>
<blockquote>
<p>注意：控制反转(Ioc)的设计思想，我们不需要应用程序本身来创建对象，而是将创建对象的任务交付给Ioc容器</p>
</blockquote>
</blockquote>
<hr>
<h1 id="Spring-SD"><a href="#Spring-SD" class="headerlink" title="Spring - SD"></a>Spring - SD</h1><hr>
<h2 id="Spring的bean管理-xml方式"><a href="#Spring的bean管理-xml方式" class="headerlink" title="Spring的bean管理(xml方式)"></a>Spring的bean管理(xml方式)</h2><pre><code>对象创建的细节：
  1.对象创建的时间
   1)scope=&quot;prototype&quot;(默认值) 在用到对象时才创建 (多例 action对象)
   2)scope=&quot;singleton&quot; 在启动(容器初始化之前)就已经创建了对象，整个web应用只有一个单例(dao/service/工具类)
  2.是否延迟创建
   1)lazy-init=&quot;false&quot;(默认值) 不延迟创建，即在启动时就创建
   2)lazy-init=&quot;true&quot; 延迟初始化，在用到对象的时候才创建
</code></pre><h2 id="Bean实例化的方式"><a href="#Bean实例化的方式" class="headerlink" title="Bean实例化的方式"></a>Bean实例化的方式</h2><pre><code>1.在Spring里面通过配置文件创建对象

2.Bean实例化三种方式实现(创建对象的几种方式)

  1)使用类的无参数构造创建(重点)
    &lt;bean id=&quot;user&quot; class=&quot;cn.itcase.ioc.User&quot;&gt;&lt;/bean&gt;
    注意：如果类里面没有无参数构造，会出现异常，所以一般要在类里面有有参构造的前提下重写无参构造方法

  2)带参构造创建
    &lt;bean id=&quot;user2&quot; class=&quot;cn.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; type=&quot;int&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;Jack&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

  3)使用静态工厂创建
    创建静态方法，返回类对象
        &lt;!-- # 3.2 工厂类： 静态方法 --&gt;
    &lt;!-- 
        class 指定的就是工厂类型
        factory-method  一定是工厂里面的“静态方法”
     --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;cn.ObjectFactory&quot; factory-method=&quot;getStaticInstance&quot;&gt;&lt;/bean&gt;

  4)使用实例工厂创建
    创建不是静态的方法，返回类对象
        &lt;!-- 3. 工厂类创建对象 --&gt;
    &lt;!-- # 3.1 工厂类，实例方法 --&gt;
    &lt;!-- 先创建工厂 --&gt;
    &lt;bean id=&quot;factory&quot; class=&quot;cn.ObjectFactory&quot;&gt;&lt;/bean&gt;
    &lt;!-- 在创建user对象，用factory方的实例方法 --&gt;
    &lt;bean id=&quot;user4&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;
</code></pre><blockquote>
<p>注意：</p>
</blockquote>
<pre><code>Spring管理Bean

Spring容器通常理解为BeanFactory或者ApplicationContext 

在Spring的Ioc容器能够帮助我们创建对象，对象交给Spring管理之后我们不用手动去new对象
</code></pre><h2 id="对象依赖关系"><a href="#对象依赖关系" class="headerlink" title="对象依赖关系"></a>对象依赖关系</h2><pre><code>Spring常用的几种注入方式：
    1.通过构造器

    2.通过set方法给属性注入值(最常用)
</code></pre><hr>
<h2 id="Servlet监听器"><a href="#Servlet监听器" class="headerlink" title="Servlet监听器"></a>Servlet监听器</h2><p>定义：监听器就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p>
<p>在Servlet规范中定义了多种类型的监听器，它们用于监听的事件源分别为 ServletContext, HttpSession 和 ServletRequest 这三个域对象。</p>
<pre><code>1.监听ServletContext域对象的创建和销毁
  ServletContextListener接口用于监听ServletContext对象的创建与销毁事件
      创建：服务器启动针对每一个web应用创建servletcontext
    销毁：服务器关闭前先关闭代表每一个web应用的servletContext

2.编写Servlet监听器
  1.实现一个特定的接口，并且针对相应的动作覆盖接口中相应的方法
  2.servlet监听器注册是由web容器负责，我们只需要在web.xml文件中使用&lt;listener&gt;标签配置好监听器，web容器就会自动将监听器注册到事件源中
  3.一个web.xml文件中可以配置多个servlet事件监听器，web服务器按照它们的web.xml文件中的注册顺序来加载和注册这些servlet监听器

3.监听HttpSession域对象创建与销毁
  HttpSessionListener接口用于监听HttpSession的创建和销毁
    创建：调用sessionCreated(HttpSessionEvent se)方法
    销毁：sessionDestroyed (HttpSessionEvent se)方法

4.监听HttpRequest域对象创建与销毁

    创建：用户的每一次访问都会创建一个request
    销毁：当前访问结束，request对象就会销毁
</code></pre><blockquote>
<p>注意：session域对象在每一次访问时被创建，而如果用户的session在30分钟内没有使用，服务器就会销毁session，在web.xml中也可以配置session的失效时间</p>
</blockquote>
<hr>
<h2 id="Spring注解注入详解"><a href="#Spring注解注入详解" class="headerlink" title="Spring注解注入详解"></a>Spring注解注入详解</h2><h4 id="1-Resource注解"><a href="#1-Resource注解" class="headerlink" title="1.@Resource注解"></a>1.@Resource注解</h4><p>这一注解是JSR-250标准注解，推荐使用其代替Spring专有的@Autowired注解，@Resource的作用相当于@Autowired，只不过@Autowired按 byType 自动注入，而@Resource默认按 byName 自动注入罢了。</p>
<p>@Resource有两个比较重要的属性，分别是name与type，Spring注解的name属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType<br>自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</p>
<h4 id="2-Component注解"><a href="#2-Component注解" class="headerlink" title="2.@Component注解"></a>2.@Component注解</h4><p>在对应的类上加上一个@Component注解就定义该类是Bean </p>
<h4 id="3-Scope注解"><a href="#3-Scope注解" class="headerlink" title="3.@Scope注解"></a>3.@Scope注解</h4><p>在使用XML定义bean的时候，有些时候需要通过bean的scope属性来定义一个bean的作用范围</p>
<hr>
<h2 id="Spring-Ioc快速入门"><a href="#Spring-Ioc快速入门" class="headerlink" title="Spring Ioc快速入门"></a>Spring Ioc快速入门</h2><p>  1.下载Spring的开发包</p>
<p>  2.了解Spring的目录结构 1)docs：Spring的开发文档 2)libs：Spring的开发包 3)schema：约束文档</p>
<p>  3.创建一个项目引入jar包</p>
<p>  4.引入Spring的配置文件</p>
<p>  5.编写测试类</p>
<p>IOC：控制反转，将Bean创建反转给Spring容器<br>DI：依赖注入，在Spring创建这个类的过程中，将这个类的依赖的属性注入，设置属性值</p>
<p>两者之间的关系：依赖注入不能单独存在，需要在Ioc的基础上完成操作</p>
<p>Ioc与DI之间的区别</p>
<ul>
<li></li>
</ul>
<p>Spring的工厂类</p>
<p>  1.ApplicationContext</p>
<pre><code>- ClassPathXmlApplicationContext：解析类路径下的XML
- FileSystemXmlApplicationContext：解析本地磁盘上的XML
</code></pre><p>注意：BeanFactory和ApplicationContext都是Spring中的工厂，BeanFactory是Spring的老版的工厂类(第一次调用getBean方法的时候实例化类)<br>      ApplicationContext是Spring的新版本的工厂类(在加载核心配置文件的时候，将所有的类实例化)</p>
<p>Spring的Bean管理(基于XML方式)</p>
<pre><code>1.Spring实例化Bean方式

  无参构造方式(最常用)
   &lt;!-- 无参数构造方法方式 --&gt;
   //引入Spring的配置文件(1.引入约束 2.编写标签)
   &lt;bean id=&quot;bean1&quot; class=&quot;cn.augmentum.spring.demo3.Bean1&quot;&gt;&lt;/bean&gt;
   //编写测试类
   @Test
   /**
    * 无参数构造
    */
   public void demo1() {
       // 加载核心配置文件:
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
               &quot;applicationContext.xml&quot;);
       Bean1 bean1 = (Bean1) applicationContext.getBean(&quot;bean1&quot;);//getBean()是用来获取applicationContext.xml文件里bean的
       System.out.println(bean1);
   }

  静态工厂实例化方式

  Bean2的静态工厂:

  public class Bean2Factory {
     public static Bean2 getBean2(){
         return new Bean2();
    }
  }

 配置文件:
   &lt;!-- 静态工厂实例化方式 --&gt;
   &lt;bean id=&quot;bean2&quot; class=&quot;cn.augmentum.spring.demo3.Bean2Factory&quot; factory-method=&quot;getBean2&quot;/&gt;

 代码:
   @Test
   /**
    * 静态工厂实例化
    */
   public void demo2() {
       // 加载核心配置文件:
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
               &quot;applicationContext.xml&quot;);
       Bean2 bean2 = (Bean2) applicationContext.getBean(&quot;bean2&quot;);
       System.out.println(bean2);
   }


 实例工厂:
 public class Bean3Factory {

    public Bean3 getBean3(){
       System.out.println(&quot;实例工厂执行了...&quot;);
       return new Bean3();
    }
 }

 配置文件:
   &lt;!-- 实例工厂实例化方式 --&gt;
   &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.spring.demo3.Bean3Factory&quot;/&gt;
   &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;/&gt;

 代码:
   @Test
   /**
    * 实例工厂实例化
    */
   public void demo3() {
       // 加载核心配置文件:
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
               &quot;applicationContext.xml&quot;);
       Bean3 bean3 = (Bean3) applicationContext.getBean(&quot;bean3&quot;);
       System.out.println(bean3);
   }
</code></pre><h2 id="Spring的Bean的常用配置"><a href="#Spring的Bean的常用配置" class="headerlink" title="Spring的Bean的常用配置"></a>Spring的Bean的常用配置</h2><h4 id="1-标签的id和name属性"><a href="#1-标签的id和name属性" class="headerlink" title="1.标签的id和name属性"></a>1.<bean>标签的id和name属性</bean></h4><pre><code>id与name的区别：
  id：使用xml约束中id约束，不可以出现特殊字符
  name：出现特殊字符，如果使用name没有id，那么name可以作为id使用
</code></pre><h4 id="2-上生命周期的配置"><a href="#2-上生命周期的配置" class="headerlink" title="2.上生命周期的配置"></a>2.<bean>上生命周期的配置</bean></h4><pre><code>@Test
    /**
     * Bean的生命周期的相关配置:
     *     * init-method
     *     * destory-method :只能针对单例对象有效.必须在工厂关闭之后才会销毁对象.
     */
    public void demo1(){
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        EmployeeService employeeService = (EmployeeService) applicationContext
                .getBean(&quot;employeeService&quot;);
        employeeService.save();
        applicationContext.close();
    }
</code></pre><h4 id="3-上的作用范围的配置"><a href="#3-上的作用范围的配置" class="headerlink" title="3.上的作用范围的配置:"></a>3.<bean>上的作用范围的配置:</bean></h4><pre><code>scope属性:

 - singleton :单例的(默认)
 - prototype :多例的
 - request :WEB项目中,创建一个对象,保存到request域中
 - session :WEB项目中,创建一个对象,保存到session域中
 - globalsession :WEB项目中,特殊环境.分布式开发环境.如果没有分布式环境,相当于session
</code></pre><h4 id="4-Bean的生命周期"><a href="#4-Bean的生命周期" class="headerlink" title="4.Bean的生命周期"></a>4.Bean的生命周期</h4><hr>
<h2 id="Spring属性注入"><a href="#Spring属性注入" class="headerlink" title="Spring属性注入"></a>Spring属性注入</h2><p>属性注入：创建对象的时候，向类里面属性设置值，这一过程就是属性注入</p>
<pre><code> 1.有参构造方法的属性注入
    &lt;bean id=&quot;car&quot; class=&quot;cn.augmentum.spring.demo6.Car&quot;&gt;//创建类，然后在类中添加属性值
　　   &lt;constructor-arg name=&quot;name&quot; value=&quot;宝马&quot;/&gt;
　     &lt;constructor-arg name=&quot;price&quot; value=&quot;1000000&quot;/&gt;
    &lt;/bean&gt;

    //第一种 有参构造注入属性值(一般情况下的属性赋值方式)
    public class User{
        private String name;
        public User(String name){
            this.name=name;
        }
    }
    User user=new User(&quot;lucy&quot;);

 2.set方法的属性注入

   &lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot;&gt;//1.创建car2对象
　    &lt;property name=&quot;name&quot; value=&quot;奇瑞QQ&quot;/&gt;//2.属性注入(对象中属性的值的设定) name属性值：类里面定义的属性名称 value属性：设置具体的值
　　  &lt;property name=&quot;price&quot; value=&quot;30000&quot;/&gt;
   &lt;/bean&gt;  

    //第二种 使用set方法注入属性值(在一般情况下使用的属性赋值方式)
     public class User{
        private String name;
        public void setName(String name){
            this.name=name;
        }
    }
    User user=new User();
    user.setName(&quot;张三&quot;);

 //第三种 使用接口方式注入
 public interface Dao{
     public void delete(String name);
    }

 public class DaoImpl implements Dao{
    private String name;
    public void delete(String name){
        this.name=name;
        }
    }

注意：在spring框架中只支持前面两种方式
      1)set方法注入(重点)
      2)有参数构造注入

 3.Spring的2.5支持p名称空间注入

   p名称空间语法

    普通属性：p:name=&quot;&quot;
    对象类型属性：p:name-ref=&quot;&quot;

 4.p名称空间的使用

   1.引入p名称空间

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   2.p名称空间的注入

&lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot; p:name=&quot;长安奔奔&quot; p:price=&quot;25000&quot;/&gt;
&lt;bean id=&quot;employee&quot; class=&quot;cn.augmentum.spring.demo6.Employee&quot; p:name=&quot;马凤&quot; p:car2-ref=&quot;car2&quot;/&gt;  ref：表示引用其他bean对象    

 5.Spring3.0的SpEL的属性注入
   SpEL语法：#{SpEL}

1.属性配置
 &lt;bean id=&quot;carInfo&quot; class=&quot;cn.augmentum.spring.demo6.CarInfo&quot;&gt;
 &lt;/bean&gt;

2.属性注入
 &lt;!-- SpEL的方式的属性注入 --&gt;
&lt;bean id=&quot;car2&quot; class=&quot;cn.augmentum.spring.demo6.Car2&quot;&gt;
　　&lt;property name=&quot;name&quot; value=&quot;#{carInfo.carName}&quot;/&gt;
　　&lt;property name=&quot;price&quot; value=&quot;#{carInfo.calculatorPrice()}&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;employee&quot; class=&quot;cn.augmentum.spring.demo6.Employee&quot;&gt;
　 &lt;property name=&quot;name&quot; value=&quot;涛哥&quot;/&gt;
　 &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt;
&lt;/bean&gt;

 6.Spring中数组或集合的复杂类型属性注入(在创建好类之后便要创建类的对象，此时创建对象的操作交给Spring容器，然后注入对象的属性值)

   1.注入复杂属性值，首先创建类型对象
    &lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt;
        //2.然后在创建的对象中注入属性值
        &lt;property name=&quot;arrs&quot;&gt;//加入的属性名称
　　            &lt;list&gt;
　　　　            &lt;value&gt;老马&lt;/value&gt;
　　　　            &lt;value&gt;马凤&lt;/value&gt;
　 　　             &lt;value&gt;马如花&lt;/value&gt;
　　            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;



&lt;!--List集合的属性的注入:--&gt;
&lt;property name=&quot;list&quot;&gt;
　　&lt;list&gt;
　　　　&lt;value&gt;马芙蓉&lt;/value&gt;
　　　　&lt;value&gt;马大帅&lt;/value&gt;
　　　　&lt;value&gt;马大彪&lt;/value&gt;
　　&lt;/list&gt;
&lt;/property&gt;

&lt;!--Set集合的属性的注入:--&gt;
&lt;property name=&quot;set&quot;&gt;
　　&lt;set&gt;
　　　　&lt;value&gt;马云&lt;/value&gt;
　　　　&lt;value&gt;马化腾&lt;/value&gt;
　　　　&lt;value&gt;马大哈&lt;/value&gt;
　　&lt;/set&gt;
&lt;/property&gt;

&lt;!--Map集合的属性的注入:--&gt;
&lt;property name=&quot;map&quot;&gt;
　　&lt;map&gt;
　　　　&lt;entry key=&quot;aaa&quot; value=&quot;刘能&quot;/&gt;
　　　　&lt;entry key=&quot;bbb&quot; value=&quot;赵四&quot;/&gt;
　　　  &lt;entry key=&quot;ccc&quot; value=&quot;王五&quot;/&gt;
　 &lt;/map&gt;
&lt;/property&gt;

&lt;!--Properties的属性的注入:--&gt;
&lt;property name=&quot;properties&quot;&gt;
　　&lt;props&gt;
　　　　&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
　　　　&lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;
　　&lt;/props&gt;
&lt;/property&gt;


 7.Spring中的分配置文件进行开发
   1.加载配置文件时候加载多个配置文件

   2.总配置文件中引入其他配置文件
</code></pre><h4 id="2-注入对象类型属性-重点"><a href="#2-注入对象类型属性-重点" class="headerlink" title="2.注入对象类型属性(重点)"></a>2.注入对象类型属性(重点)</h4><pre><code>1.创建service类和dao类
  1)在service得到dao对象

2.具体实现过程
    1)在service里面将dao作为类型属性
    2)生成dao类型属性的set方法

    public class UserService{
        //1.定义dao类型属性
        private UserDao userDao;
        //2.生成set方法
        public void setUserDao(UserDao userDao){
            this.userDao=userDao;
        }

    }

 3)配置文件中注入关系

    1.配置service和dao对象
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt;&lt;/bean&gt;

    2.注入dao对象 name属性值，service类里面属性名称，现在不要写value属性，因为刚写的是字符串，现在是对象，写ref属性，dao配置bean标签中id值
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
</code></pre><h4 id="3-Bean标签常用属性"><a href="#3-Bean标签常用属性" class="headerlink" title="3.Bean标签常用属性"></a>3.Bean标签常用属性</h4><pre><code>1)id属性：为后面查找类起的名称，id属性值名称任意命名，id属性值不能包含特殊字符，根据id值得到配置对象
2)class属性：创建对象所在的类的全路径
3)name属性：功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊字符
4)scope属性：
  - singleton :单例的(默认) 创建的实例是一个对象
  - prototype :多例的 创建的实例是多个对象
  - request :WEB项目中,创建一个对象,保存到request域中
  - session :WEB项目中,创建一个对象,保存到session域中
  - globalsession :WEB项目中,特殊环境.分布式开发环境.如果没有分布式环境,相当于session
</code></pre><h2 id="Spring整合Web项目原理"><a href="#Spring整合Web项目原理" class="headerlink" title="Spring整合Web项目原理"></a>Spring整合Web项目原理</h2><pre><code>1.加载Spring核心配置文件，根据配置创建对象
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
    //1)new对象,虽然这一过程功能可以实现，但是实现效率很低

2.提高这一过程实现效率的思想：将加载配置文件和创建对象的过程在服务器启动的过程完后

3.上述思想实现原理

    1)ServletContext对象
    2)监听器

    3)具体使用
      - 在服务器启动的使用，会为每个项目创建一个ServletContext对象
      - 在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候被创建
      - 使用监听器监听到ServletContext对象创建的时候
        --加载Spring配置文件，将配置文件配置对象创建
        --将创建出来的对象放到ServletContext域对象里面(setAttribute方法)
      - 获取对象的时候，到ServletContext域之中得到(getAttribute方法)
</code></pre><hr>
<h1 id="Spring-TD"><a href="#Spring-TD" class="headerlink" title="Spring - TD"></a>Spring - TD</h1><h2 id="Spring的Bean管理-注解"><a href="#Spring的Bean管理-注解" class="headerlink" title="Spring的Bean管理(注解)"></a>Spring的Bean管理(注解)</h2><blockquote>
<p>注解(程序里面的图书特殊标记，使用注解可以完成功能 写法：@注解名称(属性名称=属性值)) &gt;&gt;注解可以使用在类上面、方法上面以及属性上面</p>
</blockquote>
<h4 id="1-Spring注解开发准备"><a href="#1-Spring注解开发准备" class="headerlink" title="1.Spring注解开发准备"></a>1.Spring注解开发准备</h4><pre><code>1.导入jar包
 1.导入基本的jar包
 2.导入aop的jar包
2.创建类、创建方法

3.创建Spring配置文件，引入约束
 1.在刚开始做Ioc基本功能的时候，引入的约束是beans
 2.但是在做Spring的Ioc注解开发的时候需要引入新的约束(../spring-context.xsd)

4.开启注解扫描(到包里面扫描类、方法、属性上面是否有注解)
 &lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt;
 //另外一个开启扫描注解配置程序
 &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;//这只会扫描属性上面的注解
</code></pre><h4 id="2-注解创建对象"><a href="#2-注解创建对象" class="headerlink" title="2.注解创建对象"></a>2.注解创建对象</h4><pre><code>1.在创建对象的类上面使用注解实现
    @ Component(value=&quot;user&quot;) // &lt;bean id=&quot;user&quot; class=&quot;&quot;/&gt;
    public class User{
        //...
        }

2.创建对象有四个注解

    下面三个的让标注类的用途清晰，在后续Spring版本中对其增强
    @ Controller ：web层
    @ Service ：业务层
    @ Repository ：持久层
    @ Component 和上面的三个注解等效


3.创建对象单实例还是多实例
    @ Scope(value=&quot;prototype&quot;)
</code></pre><h4 id="3-注解注入属性"><a href="#3-注解注入属性" class="headerlink" title="3.注解注入属性"></a>3.注解注入属性</h4><pre><code>注入属性注解：
    1.@Autowired 
    2.@Resource 

1.@Autowired 
  创建service类，创建dao类，在service类中得到dao对象
  1)使用注解创建dao类与service类的对象
    @Service(value=&quot;userService&quot;)
    public class UserService{
        //...
        }

    @Component(value=&quot;userService&quot;)
    public class UserService{
        //...
        }

  2)得到dao对象(在service类里面定义dao类型属性)
    - 1.定义dao类型属性，在dao属性上面使用注解完成对象注入
    @Autowired(自动装配)
    private UserDao userDao;
    //使用注解方式的时候不需要使用set方法注入属性值

2.@Resource 
  name属性值写注解创建dao对象value值
  @Resource(name=&quot;userDao&quot;)
  private UserDao userDao;



配置文件和注解混合使用

  1.创建对象操作使用配置文件方式实现
    &lt;bean id=&quot;bookService&quot; class=&quot;cn.itcast&quot;&gt;&lt;/bean&gt;    
  2.注入属性的操作使用注解方式实现
    //得到类的对象，使用注解的方式
    @Resource(name=&quot;bookDao&quot;)
    private BookDao bookDao;

    @Resource(name=&quot;ordersDao&quot;)
    private OrdersDao ordersDao;


3.多种装配Bean方式的比较

  1.基于xml配置(适用于Bean来自第三方、使用其他命名空间)
    bean定义：&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;
    bean名称：通过id或name指定
    bean属性注入：&lt;property&gt;或者p命名空间
    生命过程/bean作用范围：init-method/destory-method 范围：scope属性

  2.基于注解配置（Bean的实现类由用户自己开发）
    bean定义：
    @Component(@Repository)
    @Service
    @Controller

    bean名称：@Component(&quot;person&quot;)

    bean属性注入：@Autowired 按类型注入
          @Qualifier 按名称注入

    生命过程：

  3.基于Java类配置
    bean注入：在方法内部编写注入代码逻辑
</code></pre><hr>
<h2 id="AOP-面向切面-方面-编程"><a href="#AOP-面向切面-方面-编程" class="headerlink" title="AOP(面向切面(方面)编程)"></a>AOP(面向切面(方面)编程)</h2><p>动态代理实现的过程</p>
<h4 id="1-AOP概念"><a href="#1-AOP概念" class="headerlink" title="1.AOP概念"></a>1.AOP概念</h4><ul>
<li>1)面向切面编程，扩展功能不修改源程序实现  </li>
<li>2)AOP采取横向抽取机制，取代了传统纵向继承体系(纵向抽取机制：一个类文件继承另一个类文件的机制)重复性代码</li>
</ul>
<h4 id="2-AOP原理"><a href="#2-AOP原理" class="headerlink" title="2.AOP原理"></a>2.AOP原理</h4><p>AOP(横向抽取机制) 底层使用动态代理方式实现(实现过程)</p>
<h4 id="3-AOP底层使用动态代理实现"><a href="#3-AOP底层使用动态代理实现" class="headerlink" title="3.AOP底层使用动态代理实现"></a>3.AOP底层使用动态代理实现</h4><ul>
<li>第一种情况，有接口的情况，使用动态代理创建接口实现类代理对象</li>
<li>第二种情况，没有接口的情况，使用动态代理创建类的子类代理对象</li>
</ul>
<blockquote>
<p>第一种情况：</p>
</blockquote>
<pre><code>public interface Dao{
    public void add();
}

public class DaoImpl implements Dao{
    public void add(){
        //添加实现逻辑
    }
}
</code></pre><blockquote>
<p>注意：使用动态代理方式，创建接口实现类代理对象 (创建和DaoImpl类平级的对象 这个对象不是真正的对象，是一个代理对象，实现和DaoImpl相同的功能)</p>
</blockquote>
<blockquote>
<p>第二种情况：</p>
</blockquote>
<pre><code>public class User{
    public void add(){

    }
}
</code></pre><p>动态代理实现(使用cglib动态代理，针对没有接口的情况)</p>
<ul>
<li>创建User类的子类的代理对象</li>
<li>在子类里面调用父类的方法完成增强</li>
</ul>
<h4 id="4-AOP操作术语"><a href="#4-AOP操作术语" class="headerlink" title="4.AOP操作术语"></a>4.AOP操作术语</h4><ul>
<li><p>横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
</li>
<li><p>PointCut(切入点)：在类里面可以有很多方法被增强，比如实际操作中，只是增强了类里面的add()方法和update()方法，实际增强的方法就称为切入点</p>
</li>
<li><p>JoinPoint(连接点)：类里面的哪些方法可以被增强，这些方法就成为连接点，所以这些连接点指的是方法</p>
</li>
<li><p>Advice(通知/增强)：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能就称为增强</p>
<p>前置通知：在方法之前执行<br>后置通知：在方法之后执行<br>异常通知：方法出现异常执行<br>最终通知：在后置之后执行<br>环绕通知：在方法之前和之后执行</p>
</li>
<li><p>Aspect(切面)：将增强应用到具体方法上面，这一过程称为切面(将增强应用到切入点的过程就称为切面) 对横切关注点的抽象</p>
</li>
</ul>
<blockquote>
<p>切面：简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
</blockquote>
<blockquote>
<blockquote>
<p>使用横切系统，AOP把软件系统分为两个部分：核心关注点(业务处理的主要流程)和横切关注点。</p>
</blockquote>
</blockquote>
<hr>
<h4 id="5-代理"><a href="#5-代理" class="headerlink" title="5.代理"></a>5.代理</h4><pre><code>1.JDK动态代理

2.使用cglib生成代理
  对于不使用接口的业务类，无法使用jdk动态代理，而cglib采用非常底层字节码技术，可以为一个类创建子类，解决无接口代理问题

3.关于intercept拦截方法
     /**
     * @param obj CGlib根据指定父类生成的代理对象
     * @param method 拦截的方法
     * @param args 拦截方法的参数数组
     * @param proxy 方法的代理对象，用于执行父类的方法
     * @return
    */
    public Object intercept(Object obj, Method method, Object[] args,
           MethodProxy proxy) throws Throwable {
        ... ...
    }
</code></pre><blockquote>
<p>注意：最新版本Spring已经将CGLib开发类引入spring-core-3.2.0.RELEASE.jar</p>
</blockquote>
<blockquote>
<p>总结：Spring AOP底层就是通过JDK动态代理或CGLIB动态代理技术为目标Bean执行横向织入</p>
</blockquote>
<pre><code>1.若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。
2.若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。

  程序中应该优先对接口创建代理，便于程序解耦维护

  标记为final的方法，不能被代理，因为无法进行覆盖

JDK动态代理，是针对接口生成子类，接口中方法不能使用final修饰
CGLib 是针对目标类生产子类，因此类或方法不能是final的

  Spring只支持方法连接点，不提供属性连接
</code></pre><hr>
<h1 id="Spring的AOP操作-FOD"><a href="#Spring的AOP操作-FOD" class="headerlink" title="Spring的AOP操作 - FOD"></a>Spring的AOP操作 - FOD</h1><p>  1.在Spring里面进行AOP操作，使用aspectj实现<br>    AspectJ：面向切面的框架，不是Spring的一部分，与Spring一起做AOP开发</p>
<p>  2.使用aspectj实现AOP有两种方式<br>    1)基于aspectj的xml配置<br>    2)基于aspectj的注解方式</p>
<h4 id="AOP操作准备"><a href="#AOP操作准备" class="headerlink" title="AOP操作准备"></a>AOP操作准备</h4><p>   1.除了导入基本的jar包之外，还需要导入aop相关的jar包<br>   2.创建一个Spring的核心配置文件，导入aop约束</p>
<h4 id="使用表达式配置切入点"><a href="#使用表达式配置切入点" class="headerlink" title="使用表达式配置切入点"></a>使用表达式配置切入点</h4><p>  1.切入点，实际增强的方法<br>  2.常用表达式<br>    execution</p>
<pre><code>1)execution(*cn.itcast.aop.Book.add(..))
2)execution(*cn.itcast.aop.Book.*(..))
3)execution(**.*(..))
4)匹配所有save开头的方法execution(*save*(..))
</code></pre><h4 id="使用AOP方式操作步骤"><a href="#使用AOP方式操作步骤" class="headerlink" title="使用AOP方式操作步骤"></a>使用AOP方式操作步骤</h4><pre><code>1.配置两个类的对象
&lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;myBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;

2.配置aop操作(1.配置切入点(使用表达式的方式) 2.配置切面(将增强用到方法上面去)  expression：上面所诉表达式 id：名字)
&lt;aop:config&gt;
    &lt;aop:pointcut expression=&quot;&quot; id=&quot;&quot;/&gt;
    &lt;aop:aspect ref=&quot;增强的对象&quot;&gt;
    //配置增强类型
    &lt;aop:before method=&quot;增强类里面所使用的方法&quot; pointcut-ref=&quot;切入点的引用&quot;/&gt;    
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><h2 id="log4j介绍"><a href="#log4j介绍" class="headerlink" title="log4j介绍"></a>log4j介绍</h2><p>1.通过log4j可以看到程序运行过程中更详细的信息(加载的配置文件、日志文件)</p>
<pre><code>log4j使用步骤：
1.导入log4j的jar包
2.复制log4j的配置文件，复制到src下面
  log4j.propertises(配置文件)

3.设置日志的级别
  log4j.rootLogger=info,stdout
    1)info：看到基本的信息
    2)debug：看到更详细的信息
</code></pre><h2 id="Spring整合Web项目演示"><a href="#Spring整合Web项目演示" class="headerlink" title="Spring整合Web项目演示"></a>Spring整合Web项目演示</h2><pre><code>1.演示问题
1.action调用service，service里面调用dao方式，每次访问action的时候都会加载配置文件
2.解决方案
  1)在服务器启动的时候，创建对象加载配置文件
  2)底层使用监听器、ServletContext对象

3.在Spring里面不需要我们自己写代码实现，框架已经帮我们封装好了
  1)封装了一个监听器，只需要配置好监听器就行了
  2)配置监听器之前需要导入Spring整合web项目的jar包
  3)指定加载配置文件的位置

    指定Spring配置文件的位置
    &lt;context-param&gt;
        &lt;param-name&gt;..&lt;/param-name&gt;
        &lt;param-value&gt;...&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre><hr>
<h2 id="基于aspectj的注解aop"><a href="#基于aspectj的注解aop" class="headerlink" title="基于aspectj的注解aop"></a>基于aspectj的注解aop</h2><h4 id="1-使用注解方式实现aop操作"><a href="#1-使用注解方式实现aop操作" class="headerlink" title="1.使用注解方式实现aop操作"></a>1.使用注解方式实现aop操作</h4><pre><code>1.首先引入aop编程的相关jar包
2.然后在bean.xml文件中引入aop名称空间
3.其次在bean.xml文件中开启aop扫描&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;
4.然后开启aop注解方式，默认是false &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
5.开始写一个切面类
  1.@Component：加入IOC容器 @Aspect：指定当前类为切面类 
  2.在类里面指定切入点表达式，拦截那些方法，即为那些类生成代理对象(@Pointcut(&quot;execution(* com.bie.aop.UserDao.*(..))&quot;))
    注意：在类里面可以开启前置增强(@Before(&quot;pointCut()&quot;)) 开启后置增强(@After(&quot;pointCut()&quot;))
6.在写好切面类之后写执行目标对象方法(接口/接口实现类)以及最后的测试类
</code></pre><blockquote>
<p>注意：如果目标对象是有实现接口，spring会自动选择”jdk代理(动态代理)”动态代理标识：<code>class com.sun.proxy.$Proxy10</code> 如果对象没有实现接口，spring会自动调用”cglib代理”</p>
</blockquote>
<pre><code>1)创建对象
  &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;//创建Book对象，被增强类
  &lt;bean id=&quot;MyBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;//创建增强类MyBook对象
2)在Spring核心配置文件中开启aop操作
  &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt;
3)在增强类上面使用注解方式来完成增强配置
  @Aspect
  public class MyBook{
      //在方法上面使用注解完成增强配置
      @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;)
      public void before(){
          System.out.println(&quot;before.......&quot;);
      }
  }
</code></pre><h4 id="2-Spring的jdbcTemplate操作"><a href="#2-Spring的jdbcTemplate操作" class="headerlink" title="2.Spring的jdbcTemplate操作"></a>2.Spring的jdbcTemplate操作</h4><p>  1)Spring框架一站式框架(针对JavaEE的三层，每一层都有解决技术)<br>  2)在DAO层，使用jdbcTemplate</p>
<h4 id="3-Spring对不同的持久化层技术都进行了封装"><a href="#3-Spring对不同的持久化层技术都进行了封装" class="headerlink" title="3.Spring对不同的持久化层技术都进行了封装"></a>3.Spring对不同的持久化层技术都进行了封装</h4><p>  1)jdbcTemplate对jdbc进行封装</p>
<h4 id="4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"><a href="#4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作" class="headerlink" title="4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"></a>4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作</h4><pre><code>添加
  1)导入jdbcTemplate使用的jar包(spring-jdbc-4.2.4.RELEASE.jar spring-tx-4.2.4.RELEASE.jar)
  2)创建对象，设置数据库信息(注意配置数据库的驱动)
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  3)创建jdbcTemplate对象，设置数据源
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  4)调用jdbcTemplate对象里面的方法实现操作
    1.创建sql语句
    String sql=&quot;insert into user values(?,?)&quot;;
    jdbcTemplate.update(sql,&quot;lucy&quot;,&quot;123&quot;);//调用模板中的update方法

修改
  1)设置数据库的信息
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  2)创建jdbcTemplate对象
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  3)调用jdbcTemplate对象里面的update()方法实现操作
  String sql=&quot;update user set password=? where username=?&quot;;//根据用户名修改密码
  int rows=jdbcTemplate.update(sql,&quot;1234&quot;,&quot;lucy&quot;);
  System.out.println(rows);//输出结果为1，修改成功


删除
   1)设置数据库的信息
  DriverManagerDataSource dataSource=new DriverManagerDataSource();
  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
  dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
  dataSource.setUsername(&quot;root&quot;);
  dataSource.setPassword(&quot;root&quot;);

  2)创建jdbcTemplate对象
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

  3)调用update()方法实现删除
  String sql=&quot;delete from user where username=?&quot;;
  int rows=jdbcTemplate.update(sql,&quot;lucy&quot;);
  System.out.println(rows);


查询
   1.使用jdbcTemplate实现查询操作



   2.查询的具体操作
     1)查询返回某一个值(数据库中有多少条记录)
       1.设置数据库信息

       2.创建jdbcTemplate对象

       3.调用方法得到记录数

     String sql=&quot;select count(*) from user&quot;;
       4.调用jdbcTemplate的方法
     int count=jdbcTemplate.queryForObject(sql,Integer.class);

     第一个参数，sql：返回sql语句
     第二个参数，requiredType：返回类型的class


     注意：jdbc底层实现程序
    public class testJDBC(){
    Connection conn=null;
    PreparedStatement psmt=null;
    ResultSet rs=null;
        //1.加载驱动
    try{
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.创建连接
        conn=DriverManager.getConnection(&quot;jdbc:mysql:///spring_day03&quot;,&quot;root&quot;,&quot;root&quot;);
        //3.编写sql语句
        String sql=&quot;select *from user where username=?&quot;;
        //4.预编译sql
        psmt=connt.prepareStatement(sql);
        //5.设置参数值
        psmt.setString(1,&quot;lucy&quot;);
        //6.执行sql
        rs=psmt.executeQuery();
        //7.遍历结果集
        while(rs.next()){
            //得到返回结果集
            String username=rs.getString(&quot;username&quot;);
            String password=rs.getString(&quot;password&quot;);
            //创建一个实体类，将username与password放到实体类中去
            //创建实体类的对象
            User user=new User();
            user.setUsername(username);
            user.setPassword(password);
            //输出user
            System.out.println(user);
        }
    }catch(ClassNotFoundException e){
        e.printStackTrace();
        }finally{
        try{
            rs.close();
            psmt.close();
            conn.close();
        }catch(SQLException e){
            e.printStackTrace();
            }

        }
    }


     2)查询返回对象

    1)在方法里面操作，设置数据库信息
    DriverManagerDataSource dataSource=new DriverManagerDataSource();
      dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
      dataSource.setUsername(&quot;root&quot;);
      dataSource.setPassword(&quot;root&quot;);

      2)创建jdbcTemplate对象
      JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

    3)写sql语句，根据username查询
    String sql=&quot;select *from user where username=?&quot;;

    4)调用jdbcTemplate的方法实现
    jdbcTemplate.queryForObject(String sql,RowMapper&lt;T&gt;rowMapper,Object...args)

    User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),&quot;lucy&quot;)
        第一个参数：sql语句
        第二个参数：RowMapper，接口，类似于dbutils里面的接口，需要自己写类实现接口，自己实现数据封装
        第三个参数：可变参数

    注意：在Java里面可以有多个class，但是只能有一个public

    写RowMapper类

    class MyRowMapper implements RowMapper&lt;User&gt;{
            @Override
            public User mapRow(ResultSet rs,int num) throws SQLException{
                //1.从结果集里面得到数据
                String username=rs.getString(&quot;username&quot;);
                String password=rs.getString(&quot;password&quot;);
                //2.将得到的数据封装到对象里面
                User user = new User();
                user.setUsername(username);
                user.setPassword(password);
                return user;
            }
        }

    5)输出user
    System.out.println(user);


     3)查询返回list集合

    query(String sql,RowMapper&lt;T&gt; rowMapper,Object...args):List&lt;T&gt;
       1)sql语句
       2)RowMapper接口，自己写类实现数据封装
       3)可变参数

       1)设置数据库信息
    DriverManagerDataSource dataSource=new DriverManagerDataSource();
      dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      dataSource.setUrl(&quot;jdbc:myql:///spring_day_03&quot;);
      dataSource.setUsername(&quot;root&quot;);
      dataSource.setPassword(&quot;root&quot;);

      2)创建jdbcTemplate对象
      JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);

    3)写sql语句
    String sql = &quot;select * from user&quot;;

    4)调用jdbcTemplate的方法实现
    List&lt;User&gt; list=jdbcTemplate.query(sql,new MyRowMapper());
    System.out.println(list);

    //MyRowMapper()实现与上面的一样
</code></pre><blockquote>
<p>注意：增、删、修都是使用update()方法，而查询使用的query()方法</p>
</blockquote>
<hr>
<h2 id="Spring配置连接池和dao使用jdbcTemplate"><a href="#Spring配置连接池和dao使用jdbcTemplate" class="headerlink" title="Spring配置连接池和dao使用jdbcTemplate"></a>Spring配置连接池和dao使用jdbcTemplate</h2><pre><code>1.Spring配置连接池(c3p0)
  1)导入jar包(c3p0连接池jar包c3p0-0.0.2.1.jar   mchange-commons-java-0.2.3.4.jar)

  2)创建Spring配置文件，配置连接池
1)将程序在配置文件中进行配置

&lt;!--配置c3p0连接池--&gt;
//创建连接池对象
&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3po.ComboPooledDataSource&quot;&gt;
     &lt;!--注入属性值--&gt;
     &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day03&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;


  注意：设置c3p0连接池的信息(原始方式)
    ComboPooledDataSource dataSource=new ComboPooledDataSource();
    dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUrl(&quot;jdbc:mysql:///spring_day03&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;root&quot;);


2.dao使用jdbcTemplate

1)创建Service和dao对象，在service里面注入dao对象
&lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt;&lt;/bean&gt;
     &lt;!--注入dao对象--&gt;
     &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;

2)创建jdbcTemplate对象，将模板对象注入到dao里面
//得到JdbcTemplate对象
private JdbcTemplate jdbcTemplate;
public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
    this.jdbcTemplate=jdbcTemplate;
}
&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt;
     &lt;!--注入jdbcTemplate对象--&gt;
     &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

3)在jdbcTemplate对象里面注入dataSource
private DataSource dataSource;
private SQLExceptionTranslator exceptionTranslator;
private boolean lazyInit=true;

public void setDataSource(DataSource dataSource){
    this.dataSource=dataSource;
}

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;!--将dataSource传递到模板对象里面--&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>案例：Service调用DAO，然后DAO调用jdbcTemplate，最后jdbcTemplate调用dataSource</p>
<pre><code>UserService.java

public class UserServie{
    private UserDao userDao;
    public void setUserDao(UserDao userDao){
        this.userDao=userDao;
        }
    public void add(){
        userDao.add();
        }
    }

UserDao.java

public class UserDao{
    //得到JdbcTemplate对象
    private JdbcTemplate jdbcTemplate;
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate=jdbcTemplate;
        }
    //添加操作
    public void add(){
        //创建jdbcTemplate对象
        //JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
        String sql=&quot;insert into user values(?,?)&quot;;
        jdbcTemplate.update(sql,&quot;李磊&quot;,&quot;123&quot;);
        }
    }
</code></pre><p>测试类：</p>
<blockquote>
<p>扩展</p>
<blockquote>
<p>Spring JDBCTemplate 方法详解</p>
</blockquote>
</blockquote>
<pre><code>1.JDBCTemplate 主要提供以下五类方法：
    1.execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句。

    2.update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句。batchUpdate方法用于执行批处理相关语句。

    3.query方法及queryForXXX方法：用于执行查询相关语句。

    4.call方法：用于执行存储过程、函数相关语句。

2.JDBCTemplate 类支持的回调类

    1.预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句

        1.PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement

        2.CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement

    2.预编译语句设置回调：用于给预编译语句相应参数设值

        1.PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值

        2.BatchPreparedStatementSetter：；类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小

    3.自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作

        1.ConnectionCallback：通过回调获取JdbcTemplate提供的Connection，用户可在该Connection执行任何数量的操作

        2.StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作

        3.PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作

        4.CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作

    4.结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式

        1.RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。

        2.RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSetrs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。

        3.ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集。

3.使用方法
</code></pre><blockquote>
<p>1.预编译语句以及存储过程创建回调、自定义功能回调使用</p>
</blockquote>
<p>首先使用<code>PreparedStatementCreator</code>创建一个预编译语句，其次由<code>JdbcTemplate</code>通过<code>PreparedStatementCallback</code>回调传回，由用户决定如何执行该<code>PreparedStatement</code>。此处我们使用的是<code>execute</code>方法。</p>
<blockquote>
<p>2.预编译语句设值回调使用</p>
</blockquote>
<p>通过<code>JdbcTemplate</code>的<code>int update(String sql, PreparedStatementSetterpss)</code> 执行预编译<code>sql</code>，其中<code>sql</code>参数为<code>insert into test(name) values (?)</code>，该<code>sql</code> 有一个占位符需要在执行前设值。<code>PreparedStatementSetter</code> 实现就是为了设值，使用 <code>setValues(PreparedStatementpstmt)</code>回调方法设值相应的占位符位置的值。 <code>JdbcTemplate</code>也提供一种更简单的方式<code>update(String sql, Object... args)</code>来实现设值，所以只要当使用该种方式不满足需求时才应使用<code>PreparedStatementSetter</code>。</p>
<blockquote>
<p>结果集处理回调</p>
</blockquote>
<p><code>RowMapper</code>接口提供<code>mapRow(ResultSet rs, int rowNum)</code>方法将结果集的每一行转换为一个<code>Map</code>，当然可以转换为其他类，如表的对象画形式。</p>
<p><code>RowCallbackHandler</code>接口也提供方法<code>processRow(ResultSet rs)</code>，能将结果集的行转换为需要的形式。</p>
<p><code>ResultSetExtractor</code>使用回调方法<code>extractData(ResultSet rs)</code>提供给用户整个结果集，让用户决定如何处理该结果集。</p>
<blockquote>
<p>注意：我们可以使用JdbcTemplate提供更简单的queryForXXX方法，来简化开发。</p>
</blockquote>
<pre><code>//1.查询一行数据并返回int型结果  
jdbcTemplate.queryForInt(&quot;select count(*) from test&quot;);  

//2. 查询一行数据并将该行数据转换为Map返回  
jdbcTemplate.queryForMap(&quot;select * from test where name=&apos;name5&apos;&quot;);  

//3.查询一行任何类型的数据，最后一个参数指定返回结果类型  
jdbcTemplate.queryForObject(&quot;select count(*) from test&quot;, Integer.class);  

//4.查询一批数据，默认将每行数据转换为Map       
jdbcTemplate.queryForList(&quot;select * from test&quot;);  

//5.只查询一列数据列表，列类型是String类型，列名字是name  
jdbcTemplate.queryForList(&quot;select name from test where name=?&quot;, new Object[]{&quot;name5&quot;}, String.class);  

//6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上  
SqlRowSet rs = jdbcTemplate.queryForRowSet(&quot;select * from test&quot;);  
</code></pre><blockquote>
<p>总结：JDBCTemplate 提供很多方法，这其中的规律便是：第一种提供回调接口让用户决定做什么。第二种是比较简单方法(如：queryForXxx)，用于比较简单的操作。</p>
</blockquote>
<hr>
<pre><code>4.JDBCTemplate 的基本使用步骤

    1.JDBC模板依赖连接池来获取数据的连接，所以需要先构建连接池
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);

    2.创建JDBC模板
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //或者使用构造方法
        jdbcTemplate.setDataSource(dataSource);
</code></pre><blockquote>
<p>注意：1.配置JDBCTemplate的三种方式：1.在自定义的DAO实现类注入一个DataSource引用来完成JdbcTemplate的实例化，即从外部注入DataSource到DAO中，然后实例化jdbctemplate，然后将DataSource设置到jdbcTemplate对象中。2…….</p>
</blockquote>
<pre><code>3.sql语句
    //查询的sql语句
    String sql = &quot;select count(*)  from user&quot;;
    Long num = (long) jdbcTemplate.queryForObject(sql, Long.class);
    System.out.println(num);
</code></pre><blockquote>
<p>注意：Spring学习中，在new对象的时候我们应该想到IOC，在使用set方法时应该想到DI，在要切面时应该想到AOP，所以有一引用链：</p>
</blockquote>
<pre><code>1. 我们需要有DataSource，DataSource的属性可以通过注入数据库的一些配置属性添加

2. 我要有JdbcTemplate，而Template依赖与DataSource，我要以ref的方式为我的JdbcTemplate注入引用

3. 有了JdbcTemplate之后，我要有Dao，此时我应该在Dao添加一个JdbcTemplate的成员，然后以ref的方式将JdbcTemplate引入到Dao中

4. 我在Action或者是Servlet中都会调用的是Serivce，所以，我在Serivce中要添加一个Dao作为成员，然后由ref在注入Dao到Service中

DataSource --&gt; JdbcTemplate --&gt; Dao --&gt; Service --&gt; Action/Servlet

&quot;--&gt;&quot;表示将左边的对象注入到右边的对象当中

5.JDBCTemplate 的CRUD方法

    //插入程序用的是update方法，查询用的是query方法。
    //首先定义一个sql语句
    String  sql = &quot;insert into user (username,password) values(?,?)&quot;;
    //然后使用jdbctemplate方法插入数据
    jdbcTemplate.update(sql, user.getUsername(), user.getPassword());
</code></pre><blockquote>
<p>注意：<code>jdbcTemplate.update</code>适用于<code>insert/update/delete</code>操作。<br>其中：第一个参数为执行的sql。 第二个参数为参数数据 第三个参数为参数类型。</p>
</blockquote>
<pre><code>//删除
String sql = &quot;delete from user where username= ?&quot;;
jdbcTemplate.update(sql, &quot;小王&quot;);

//修改
String sql = &quot;update user set username=? where username= ?&quot;;
jdbcTemplate.update(sql,  user.getUsername() + &quot;_new&quot;, user.getUsername());

//查询
//在最开始使用比较基础的持久化工具(DBUtils)时，会针对查询结果给我们提供一些封装的接口和类，但是JdbcTemplate只给我们提供接口，并没有可用的类，所以需要我们自己实现类来进行封装。

//1.查询表的记录数
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
String sql = &quot;select count(*) from user&quot;;
Long row = jdbcTemplate.queryForObject(sql, Long.class);
System.out.println(&quot;查询出来的记录数为：&quot; + row);

//2.查询返回对象
//获得jdbcTemplate对象
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
String sql = &quot;select username, password from user where username = ?&quot;;
// 设定参数
Object[] object = {&quot;mary_new&quot;};
// 进行查询
User user = jdbcTemplate.queryForObject(sql, object,  new UserMapper());
System.out.println(user);
//注意：除此之外还需要实现结构RowMapper来新建一个映射类，且此java类应该与具体的sql语句对应。
...
    public class UserMapper implements RowMapper&lt;User&gt;{
       @Override
       public User mapRow(ResultSet resultSet, int rows) throws SQLException {
           User user = new User();
           user.setUsername(resultSet.getString(1));
           user.setPassword(resultSet.getString(2));

           return user;
       }
       ....

//3.查询并返回list集合
...
    // 获得jdbcTemplate对象
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);

    // sql语句
    String sql = &quot;select * from user&quot;;
    List&lt;User&gt; users = jdbcTemplate.query(sql, new UserMapper());

    for(User u: users) {
      System.out.println(u);
    }
    ...
</code></pre><hr>
<pre><code>6.JdbcTemplate.queryForList()方法中不同的参数：
    1.String sql;//查询用的sql语句
    2.Object[] args;//sql语句中的参数
    3.int[] argTypes;//sql语句中参数的数据类型
    4.Class elementType;//list装载结果的元数据类型
</code></pre><hr>
<h2 id="Spring的是事务管理"><a href="#Spring的是事务管理" class="headerlink" title="Spring的是事务管理"></a>Spring的是事务管理</h2><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><pre><code>1.事务是一组操作的执行单元，相对于数据库操作来说，事务管理的是一组SQL指令(增删改)，事务的一致性要求这个事务内的操作必须全部执行成功，如果在此过程出现差错，如一条sql语句没有执行成功，那么这一组操作都将全部回滚。
</code></pre><p>这里可以用四个词来解释事务：<br>    A（atomic 原子性）：发生就是全部都发生，不发生全都不发生<br>    C（consistent 一致性）：数据应该不被破坏<br>    I（isolate 隔离性）：用户间操作不相混淆<br>    D（durable 持久性）：永久保存，如保存到数据库中等</p>
<h4 id="Spring事务管理api"><a href="#Spring事务管理api" class="headerlink" title="Spring事务管理api"></a>Spring事务管理api</h4><pre><code>1.spring事务管理的两种方式
1)编程式事务管理(不用)
2)声明式事务管理
      1.基于xml配置文件实现
  2.基于注解方式实现
</code></pre><h4 id="Spring事务管理高层抽象主要包括三个接口"><a href="#Spring事务管理高层抽象主要包括三个接口" class="headerlink" title="Spring事务管理高层抽象主要包括三个接口"></a>Spring事务管理高层抽象主要包括三个接口</h4><pre><code>1.事务管理器：PlatformTransactionManager
1)Spring针对不同的DAO层框架都提供了不同的实现类
2)无论是使用基于xml配置文件方式实现事务管理还是使用基于注解方式实现事务管理，首先都需要配置事务管理器
</code></pre><p>案例：</p>
<pre><code>搭建转账环境

1.创建数据库表，添加数据(创建基本的用户信息(用户名、密码))
2.创建service类和dao类，完成注入关系

&lt;bean id=&quot;orderService&quot; class=&quot;cn.itcast.service.OrderService&quot;&gt;
    &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;ordersDao&quot; class=&quot;cn.itcast.dao.OrdersDao&quot;&gt;
    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

  注意：service层又叫做业务逻辑层，dao层单纯对数据库做操作，在dao层不添加业务
</code></pre><blockquote>
<p>注意：在bean.xml文件配置时候是service中注入dao，dao中注入模板，模板中注入dataSource</p>
</blockquote>
<pre><code>2.事务定义信息(隔离、传播、超时、只读)：TransactionDefinition

3.事务具体运行状态：TransactionStatus
</code></pre><hr>
<h4 id="1-声明式事务管理-xml配置"><a href="#1-声明式事务管理-xml配置" class="headerlink" title="1.声明式事务管理(xml配置)"></a>1.声明式事务管理(xml配置)</h4><pre><code>1.配置文件的方式使用aop思想配置

  1.配置事务管理器
  &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;
  2.配置事务的增强
  &lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;&quot; propagation=&quot;&quot;/&gt;//指定运行事务的匹配规则 propagation：
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  3.配置切面
  &lt;aop:config&gt;
    //1.切入点
    &lt;aop:pointcut expression=&quot;&quot; id=&quot;&quot;/&gt;
    //2.切面
    &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;//表示的意思是将哪个增强(advice-ref)用到哪一个切面(pointcut-ref)上面
  &lt;/aop:config&gt;

2.
</code></pre><h4 id="2-声明式事务管理-注解"><a href="#2-声明式事务管理-注解" class="headerlink" title="2.声明式事务管理(注解)"></a>2.声明式事务管理(注解)</h4><pre><code>1.配置事务管理器
  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframwork.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
  &lt;/bean&gt;

2.配置事务注解
  &lt;tx:annnotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

3.在要使用事务的方法所在类上面添加注释

  @Transactional
  public class OrdersService{
    private OrdersDao ordersDao;
    public void setOrdersDao(OrdersDao ordersDao){

        }
        //调用dao的方法，业务逻辑层写转账业务等
        //要使用到的业务逻辑
    public void accountMoney(){

        }    
    }
</code></pre><hr>
<blockquote>
<blockquote>
<p>扩展：</p>
</blockquote>
</blockquote>
<pre><code>1.常用注解：
1.@Transactional 事务注解，标注当前类时表示类中所有方法都进行事务处理。
  @Transactional public class TestServiceBean implements TestService {}
注意：1.@Transactional 只能被应用到public方法上,对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.

2.POJO类与VO类
    vo：1.表示viewObject 只负责封装页面传递过来的数据 2.valueObject 页面与页面之间的传递时保存值的对象。

    区别1：1.POJO是持久层所使用的，是用来封装原始数据的，而VO则主要用来在视图层活动，两个JavaBean所使用的范围不同。假如我们从数据库取出来的原始数据，我们可以通过业务层将数据进行封装，再通过VO发到页面上去。

    过程：我们获得的时候，数据是原始数据，然后通过业务层进行判断，将其所对应的参数放到VO里。即POJO里的属性主要是用来给数据库用的，而VO里的属性是纯用户显示的。
    区别2：1.POJO类，是不继承任何类(继承Object类)，不实现任何接口的，只有属性和set/get方法。

    2.VO类，实际返回给用户的视图对象，将某个指定页面&lt;组件&gt;的所有数据封装起来。
      如：用户发出请求(可能是填写表单)，表单的数据在展示层被匹配为VO。

    3.PO类，每个数据基本上都对象数据库中的某个字段，一般需要实现序列化接口，也有些时候继承一些类
</code></pre><hr>
<h2 id="SSH框架整合-Struts2-hibernate-spring4-x"><a href="#SSH框架整合-Struts2-hibernate-spring4-x" class="headerlink" title="SSH框架整合(Struts2 hibernate spring4.x)"></a>SSH框架整合(Struts2 hibernate spring4.x)</h2><pre><code>回顾SSH框架知识点
</code></pre><h4 id="Hibernate框架"><a href="#Hibernate框架" class="headerlink" title="Hibernate框架"></a>Hibernate框架</h4><pre><code>1.Hibernate核心配置文件
  - 如果单纯使用Hibernate框架，核心配置文件名称hibernate.cfg.xml和位置在src下面这是固定的
  - Hibernate和Spring进行整合的时候，hibernate核心配置文件的名称和位置是没有固定要求的


  1)ORM思想(对象关系映射 实体类与数据表之间的映射关系)
</code></pre><h4 id="Struts2框架"><a href="#Struts2框架" class="headerlink" title="Struts2框架"></a>Struts2框架</h4><pre><code>1.Action操作
  1)action创建的三种方式
    继承类 ActionSupport

  2)配置action访问路径
    - 创建struts2.xml配置文件，这个配置文件名和位置固定在src下面

  3)配置访问action的多个方法
    - 使用通配符方式配置

  4)在action获取表单提交数据
    - 获取request对象
      --  使用ServletActionContext类获取
    - 属性封装
    - 模型驱动(重点)
    - 表达式封装

  5)在action操作域对象
    - 使用ServletActionContext获取域对象

  6)配置struts2的过滤器


2.值栈
  1)向值栈放数据
- set方法
- push方法
- 定义变量，生成get方法

  2)从值栈获取数据
- 在JSP中使用struts2标签+ognl获取
- &lt;s:property&gt;
- &lt;s:iterator&gt;


3.拦截器
  1)aop和责任链模式
  2)自定义拦截器
    - 继承MethodFilterInterceptor
    - 重写类里面的方法
    - 配置拦截器和action关联
</code></pre><h4 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h4><pre><code>1.spring核心配置文件
  1)名称和位置没有固定要求
  2)在spring核心配置文件中引入schema约束

2.创建对象
  1)xml配置方式 &lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;/&gt;
  2)注解方式，四个注解

3.注入属性
  1)xml配置方式
  2)注解方式，两个注解

4.使用ServletContext对象和监听器实现
  1)在服务器启动时候，加载spring配置文件，创建连接
  2)配置spring的监听器
  3)指定spring配置文件位置
</code></pre><h2 id="SSH整合的思想"><a href="#SSH整合的思想" class="headerlink" title="SSH整合的思想"></a>SSH整合的思想</h2><pre><code>Web层：struts2框架 调用service层

Service层：Spring框架 调用DAO层

Dao层：Hibernate框架 对数据库进行crud操作
</code></pre><blockquote>
<p>注意：框架的之间的整合往往是两个框架之间的整合</p>
</blockquote>
<pre><code>1.struts2框架与Spring框架的整合
  - 将struts2的action对象创建交给Spring来进行管理
    &lt;bean id=&quot;&quot; class=&quot;&quot; acope=&quot;protype&quot;&gt;

2.Spring框架与Hibernate框架之间的整合
  - 将hibernate核心配置文件里面的数据库配置，直接写在Spring配置文件中

  - 在第一次访问的时候会很慢，是因为在第一次访问的时候要创建sessionFactory对象
    -- 解决方案：将sessionFactory对象创建交给Spring来管理

  - 在服务器启动的时候创建sessionFactory对象
</code></pre><h2 id="整合Struts2与Spring框架"><a href="#整合Struts2与Spring框架" class="headerlink" title="整合Struts2与Spring框架"></a>整合Struts2与Spring框架</h2><pre><code>将Struts2的action交给Spring管理
实现过程
1.导入Struts2的jar包
</code></pre><hr>
<h4 id="SSH框架搭建和整合-struts2-spring4-hibernate5"><a href="#SSH框架搭建和整合-struts2-spring4-hibernate5" class="headerlink" title="SSH框架搭建和整合(struts2/spring4/hibernate5)"></a>SSH框架搭建和整合(struts2/spring4/hibernate5)</h4><pre><code>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层），以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。
</code></pre><blockquote>
<p>总结：<br>    在SSH框架中使用Struts2框架作为系统的整体基础架构，负责MVC的分离。<br>    在Struts框架的模型(model)部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring做支持，支持struts和hibernate。</p>
</blockquote>
<pre><code>具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring做支持，支持struts和hibernate。
其实ssh框架最主要的本质是：“高内聚、低耦合”。
</code></pre><hr>
<h2 id="Spring-项目开发经验"><a href="#Spring-项目开发经验" class="headerlink" title="Spring 项目开发经验"></a>Spring 项目开发经验</h2><h4 id="1-spring-使用-HandlerExceptionResolver-实现全局异常捕获"><a href="#1-spring-使用-HandlerExceptionResolver-实现全局异常捕获" class="headerlink" title="1.spring 使用 HandlerExceptionResolver 实现全局异常捕获"></a>1.spring 使用 HandlerExceptionResolver 实现全局异常捕获</h4><p>首先实现的功能，我们在项目实现的过程中，项目会发生异常，但是我们并没有捕获这些异常，所以会经常出现bug等。在我们没有配置捕获全局异常时，容器会自动打印错误信息。但是如果我们在web.xml中配置，就会拦截错误，然后跳转到响应的处理错误页面。</p>
<pre><code>&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;/500.jsp&lt;/location&gt;
&lt;/error-page&gt;
//以上表示在web.xml中配置错误拦截，然后跳转到指定的错误处理界面
</code></pre><p>但是现在我们在项目中通过实现Spring的HandlerExceptionResolver接口是实现所有的异常的捕获。</p>
<ul>
<li><p>方式一(通过实现HandlerExceptionResolver接口)使用步骤：</p>
<p>  1.新建GlobalExceptionResolver</p>
<pre><code>@Component
//使用spring 利用 HandlerExceptionResolver实现全局异常捕获
public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {
    private static Logger LOG = Logger.getLogger(GlobalHandleExceptionResolver.class);
    private static  final int USER_EXCEPTION_CODE = 1;
    private static  final int OTHER_EXCEPTION_CODE =2;

    //编写自己需要的类
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,
                                          Object handle, Exception ex){
        ModelAndView mv = new ModelAndView(&quot;error&quot;);
        if(ex instanceof  UserException){
            mv.addObject(&quot;message&quot;, ex.getMessage());
            mv.addObject(&quot;code&quot;,USER_EXCEPTION_CODE);
            LOG.error(&quot;用户异常:&quot; +ex.getMessage(),ex);
        }else{
            mv.addObject(&quot;message&quot;,&quot;未知异常&quot;);
            mv.addObject(&quot;code&quot;,OTHER_EXCEPTION_CODE);
            LOG.error(&quot;未知异常:&quot;+ ex.getMessage(),ex);
        }
        return mv;
    }
}
</code></pre><p>  2.在spring配置文件中配置新建的类</p>
<pre><code>&lt;!--全局异常捕捉 --&gt;
&lt;bean class=&quot;com.ssm.exception.GlobalExceptionResolver&quot; /&gt;
</code></pre><p>  3.根据需求编写自己需要处理的方法</p>
<blockquote>
<p>注意：在开发的过程中如果返回null，这样的话这个类如同不起作用。如果我们想返回错误页面，那么直接在ModleAndView里面写好即可。</p>
</blockquote>
<p>  ModelAndView modelAndView = new ModelAndView();<br>  modelAndView.setViewName(“error”);<br>  return modelAndView;</p>
</li>
<li><p>方式二(通过使用注解)使用步骤：</p>
<p>  1.创建GlobalExceptionResolver</p>
<pre><code>//通过使用ControllerAdvice和ExceptionHandler这两个注解实现全局的异常捕获
@ControllerAdvice
public class GlobalExceptionResolver {
    //这里的ServiceException是自定义的异常
    @ExceptionHandler(value = ServiceException.class)
    public @ResponseBody String serviceCommonExceptionHandler(ServiceException e) {
        //对捕获的异常进行处理并打印日志等，之后返回json数据，方式与Controller相同
        return &quot;{&apos;code&apos;:-1}&quot;;
    }

    @ExceptionHandler(value = Exception.class)
    public ModelAndView exceptionHandler() {
        //当然也可以直接返回ModelAndView等类型，然后跳转相应的错误页面，这都根据实际的需要进行使用
        return new ModelAndView();
    }
}

//自定义异常：
public class ServiceException extends RuntimeException{
    //...
}
</code></pre><blockquote>
<p>注意：spring会根据@ExceptionHandler的value值进行匹配，如果我们项目中的一些异常没有被捕获，那么这里就会处理一些没有捕获的异常。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="2-Spring-MVC-之-HandlerMethodArgumentResolver"><a href="#2-Spring-MVC-之-HandlerMethodArgumentResolver" class="headerlink" title="2.Spring MVC 之 HandlerMethodArgumentResolver"></a>2.Spring MVC 之 HandlerMethodArgumentResolver</h4><p>简言之，HandlerMethodArgumentResolver = HandlerMethod + Argument(参数) + Resolver(解析器),其实就是HandlerMethod方法的解析器, 将 HttpServletRequest(header + body 中的内容)解析为HandlerMethod方法的参数。</p>
<pre><code>//判断 HandlerMethodArgumentResolver 是否支持 MethodParameter(PS: 一般都是通过 参数上面的注解|参数的类型)
public interface HandlerMethodArgumentResolver {
    //判断是否支持要转换的参数类型
    boolean supportsParameter(MethodParameter var1);
    //当支持后进行相应的转换
    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;
}
</code></pre>
      
    </div>
    
    
    
    
    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>spring</a></p>
  <p><span>文章作者:</span>Bangjin-Hu</a></p>
  <p><span>发布时间:</span>2018年06月05日 - 09:22:26</p>
  <p><span>最后更新:</span>2018年09月20日 - 15:04:21</p>
  <p><span>原始链接:</span><a href="/undefined/Spring/" title="spring">http://bangjinhu.github.io/undefined/Spring/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://bangjinhu.github.io/undefined/Spring/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

      
    </div>
    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="Bangjin-Hu wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎扫码关注微信公众号，订阅我的微信公众号.</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持是我创作的动力.</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat-reward-img.jpg" alt="Bangjin-Hu 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay-reward-img.jpg" alt="Bangjin-Hu 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Bangjin-Hu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://bangjinhu.github.io/undefined/Spring/" title="spring">http://bangjinhu.github.io/undefined/Spring/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/spring/" rel="tag"><i class="fa fa-tag"></i> spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/undefined/项目开发经验/" rel="prev" title="Java程序开发项目经验">
                Java程序开发项目经验 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-FD"><span class="nav-text">Spring - FD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Java-Bean"><span class="nav-text">1.Java Bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-DI-依赖注入"><span class="nav-text">2.DI-依赖注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-AOP-面向切面对象"><span class="nav-text">3.AOP-面向切面对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring框架的主要内容"><span class="nav-text">Spring框架的主要内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Spring框架运行环境"><span class="nav-text">1.Spring框架运行环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Ioc-Inversion-of-control-控制反转"><span class="nav-text">2.Ioc(Inversion of control)控制反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-DI-Dependency-Injection-依赖注入"><span class="nav-text">3.DI(Dependency Injection)依赖注入</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-SD"><span class="nav-text">Spring - SD</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的bean管理-xml方式"><span class="nav-text">Spring的bean管理(xml方式)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean实例化的方式"><span class="nav-text">Bean实例化的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象依赖关系"><span class="nav-text">对象依赖关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet监听器"><span class="nav-text">Servlet监听器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring注解注入详解"><span class="nav-text">Spring注解注入详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Resource注解"><span class="nav-text">1.@Resource注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Component注解"><span class="nav-text">2.@Component注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Scope注解"><span class="nav-text">3.@Scope注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Ioc快速入门"><span class="nav-text">Spring Ioc快速入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的Bean的常用配置"><span class="nav-text">Spring的Bean的常用配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-标签的id和name属性"><span class="nav-text">1.标签的id和name属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-上生命周期的配置"><span class="nav-text">2.上生命周期的配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-上的作用范围的配置"><span class="nav-text">3.上的作用范围的配置:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Bean的生命周期"><span class="nav-text">4.Bean的生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring属性注入"><span class="nav-text">Spring属性注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-注入对象类型属性-重点"><span class="nav-text">2.注入对象类型属性(重点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Bean标签常用属性"><span class="nav-text">3.Bean标签常用属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring整合Web项目原理"><span class="nav-text">Spring整合Web项目原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-TD"><span class="nav-text">Spring - TD</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的Bean管理-注解"><span class="nav-text">Spring的Bean管理(注解)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Spring注解开发准备"><span class="nav-text">1.Spring注解开发准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-注解创建对象"><span class="nav-text">2.注解创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-注解注入属性"><span class="nav-text">3.注解注入属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-面向切面-方面-编程"><span class="nav-text">AOP(面向切面(方面)编程)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-AOP概念"><span class="nav-text">1.AOP概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-AOP原理"><span class="nav-text">2.AOP原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-AOP底层使用动态代理实现"><span class="nav-text">3.AOP底层使用动态代理实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-AOP操作术语"><span class="nav-text">4.AOP操作术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-代理"><span class="nav-text">5.代理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring的AOP操作-FOD"><span class="nav-text">Spring的AOP操作 - FOD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP操作准备"><span class="nav-text">AOP操作准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用表达式配置切入点"><span class="nav-text">使用表达式配置切入点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用AOP方式操作步骤"><span class="nav-text">使用AOP方式操作步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#log4j介绍"><span class="nav-text">log4j介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring整合Web项目演示"><span class="nav-text">Spring整合Web项目演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于aspectj的注解aop"><span class="nav-text">基于aspectj的注解aop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-使用注解方式实现aop操作"><span class="nav-text">1.使用注解方式实现aop操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Spring的jdbcTemplate操作"><span class="nav-text">2.Spring的jdbcTemplate操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Spring对不同的持久化层技术都进行了封装"><span class="nav-text">3.Spring对不同的持久化层技术都进行了封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作"><span class="nav-text">4.jdbcTemplate的使用和dbutils使用和相似，对数据库进行crud操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring配置连接池和dao使用jdbcTemplate"><span class="nav-text">Spring配置连接池和dao使用jdbcTemplate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的是事务管理"><span class="nav-text">Spring的是事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事务概念"><span class="nav-text">事务概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring事务管理api"><span class="nav-text">Spring事务管理api</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring事务管理高层抽象主要包括三个接口"><span class="nav-text">Spring事务管理高层抽象主要包括三个接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-声明式事务管理-xml配置"><span class="nav-text">1.声明式事务管理(xml配置)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-声明式事务管理-注解"><span class="nav-text">2.声明式事务管理(注解)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSH框架整合-Struts2-hibernate-spring4-x"><span class="nav-text">SSH框架整合(Struts2 hibernate spring4.x)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hibernate框架"><span class="nav-text">Hibernate框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struts2框架"><span class="nav-text">Struts2框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring框架"><span class="nav-text">Spring框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSH整合的思想"><span class="nav-text">SSH整合的思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整合Struts2与Spring框架"><span class="nav-text">整合Struts2与Spring框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SSH框架搭建和整合-struts2-spring4-hibernate5"><span class="nav-text">SSH框架搭建和整合(struts2/spring4/hibernate5)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-项目开发经验"><span class="nav-text">Spring 项目开发经验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-spring-使用-HandlerExceptionResolver-实现全局异常捕获"><span class="nav-text">1.spring 使用 HandlerExceptionResolver 实现全局异常捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Spring-MVC-之-HandlerMethodArgumentResolver"><span class="nav-text">2.Spring MVC 之 HandlerMethodArgumentResolver</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count"></span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
