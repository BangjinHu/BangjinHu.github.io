<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="Servlet," />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="注意：所有文章除特别说明外，转载请注明出处. Servlet 开发步骤：   编写一个java类，实现servlet接口 把开发好的java类部署到web服务器  API文档  Servlet API Documentation  生命周期相关方法(life-cycle methods)Servlet的生命周期通过java.servlet.Servlet接口中的init()、service()、">
<meta name="keywords" content="Servlet">
<meta property="og:type" content="article">
<meta property="og:title" content="Servlet">
<meta property="og:url" content="http://bangjinhu.github.io/undefined/Servlet/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="注意：所有文章除特别说明外，转载请注明出处. Servlet 开发步骤：   编写一个java类，实现servlet接口 把开发好的java类部署到web服务器  API文档  Servlet API Documentation  生命周期相关方法(life-cycle methods)Servlet的生命周期通过java.servlet.Servlet接口中的init()、service()、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-29T02:48:38.350Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Servlet">
<meta name="twitter:description" content="注意：所有文章除特别说明外，转载请注明出处. Servlet 开发步骤：   编写一个java类，实现servlet接口 把开发好的java类部署到web服务器  API文档  Servlet API Documentation  生命周期相关方法(life-cycle methods)Servlet的生命周期通过java.servlet.Servlet接口中的init()、service()、">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/undefined/Servlet/"/>





  <title>Servlet | BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Servlet</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:48:38+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13,715
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  56
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p>开发步骤：</p>
</blockquote>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器</li>
</ul>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html" target="_blank" rel="noopener">Servlet API Documentation</a></p>
</blockquote>
<h4 id="生命周期相关方法-life-cycle-methods"><a href="#生命周期相关方法-life-cycle-methods" class="headerlink" title="生命周期相关方法(life-cycle methods)"></a>生命周期相关方法(life-cycle methods)</h4><p>Servlet的生命周期通过<code>java.servlet.Servlet</code>接口中的<code>init()</code>、<code>service()</code>、和<code>destroy()</code>方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。（见文末【参考链接】）</p>
<h4 id="手动编写第一个servlet"><a href="#手动编写第一个servlet" class="headerlink" title="手动编写第一个servlet"></a>手动编写第一个servlet</h4><p>1.在tomcat中新建一个web应用<code>hello</code>，在web应用中新建一个<code>WEB-INF/classes</code>目录</p>
<p>2.在<code>classes</code>目录新建一个<code>FirstServlet</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span><span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"hello servlet!!!"</span>.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编译，<code>javac -cp %CATALINA_HOME%/lib/servlet-api.jar  -d . FirstServlet.java</code>,命令行手动编译参考<a href="http://www.iitshare.com/under-the-cmd-compile-the-java.html" target="_blank" rel="noopener">这里</a></p>
<p>4.在<code>WEB-INF</code>目录中新建一个<code>web.xml</code>文件，配置servlet的对外访问路径</p>
<p>5.启动tomcat访问</p>
<h4 id="servlet的调用过程和生命周期"><a href="#servlet的调用过程和生命周期" class="headerlink" title="servlet的调用过程和生命周期"></a>servlet的调用过程和生命周期</h4><p>时序图 -&gt; servlet的调用过程和生命周期</p>
<h4 id="servlet的开发细节"><a href="#servlet的开发细节" class="headerlink" title="servlet的开发细节"></a>servlet的开发细节</h4><ul>
<li><strong>标签</strong>:<code>&lt;servlet&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，<code>&lt;servlet-mapping&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code></li>
<li><strong>映射</strong>:<code>web.xml</code>中一个<code>&lt;servlet&gt;</code>可对应多个<code>&lt;servlet-mapping&gt;</code></li>
<li><p><strong>通配符</strong>:<code>&lt;servlet-mapping&gt;</code>的<code>&lt;url-pattern&gt;</code>可以使用通配符，两种固定格式：<code>*.扩展名</code>；以<code>/</code>开头，以<code>/*</code>结尾</p>
</li>
<li><p><strong>对象</strong>:servlet由servlet引擎调用，不能独立运行。客户端多次请求，服务器只创建一个servlet实例，之后驻留内存中继续服务直至web容器退出才销毁它。</p>
</li>
<li><strong>请求</strong>:服务器针对客户端的每一次请求都会创建新的<code>request</code>和<code>response</code>对象(它们的生命周期很短)，传给<code>service</code>方法。</li>
<li><strong>加载</strong>:servlet实例的创建和<code>init</code>方法的调用是在第一次请求时，而非服务器启动时，除非在<code>&lt;servlet&gt;</code>标签配置<code>&lt;load-on-start-up&gt;</code>,数字越小优先级越高</li>
<li><strong>缺省</strong>:映射路径为正斜杠<code>/</code>，则为当前web应用的缺省servlet,不匹配的都交给缺省</li>
<li><strong>线程安全</strong>:访问同一资源会引发线程安全问题; <code>SingleThreadModel</code>标记接口(已弃用)</li>
<li><strong>ServletConfig</strong>:在<code>&lt;servlet&gt;</code>标签配置<code>&lt;init-param&gt;</code>，通过<code>getServletConfig</code>方法获得配置。可配置输出字符集，读哪个配置文件等等。</li>
<li><strong>ServletContext</strong>:代表当前web应用，含有一些web应用全局性方法，实现web资源共享、servlet转发等。通过<code>ServletConfig.getServletContext</code>方法获得，在<code>&lt;context-param&gt;</code>标签配置。</li>
</ul>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>API:<a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/ServletContext.html" target="_blank" rel="noopener">Interface ServletContext</a></p>
<p><strong>概念</strong><br></p>
<p>一个web应用所有servlet共享同一个ServletContext对象，可实现数据共享。ServletContext被称为context<strong>域</strong>对象。</p>
<p>域：作用范围 context域：整个应用程序范围。</p>
<p>ServletContext域：</p>
<ol>
<li>这是一个容器</li>
<li>说明了这个容器的作用范围，也就是应用程序范围</li>
</ol>
<p>转发:客户机一次请求；重定向：客户机两次请求</p>
<p>作用</p>
<ul>
<li>获取web应用的初始化参数</li>
<li>实现servlet转发</li>
<li>利用ServletContext对象读取资源文件<ul>
<li>获得文件路径</li>
<li>读取资源文件的三种方式</li>
<li>.properties文件（属性文件）</li>
</ul>
</li>
</ul>
<p>配置文件：properties文件和xml文件；数据有关系使用xml文件，没有关系则使用properties文件。</p>
<p>1.通过<code>ServletContext</code>的<code>getResourceAsStream</code>方法，读取properties文件</p>
<p>模板代码(注意文件位置不同写路径会不同)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/org/iot/servlet/db.properties"</span>);</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();<span class="comment">//map</span></span><br><span class="line">properties.load(in);</span><br></pre></td></tr></table></figure>
<p>2.通过<code>servletContext</code>的<code>getRealPath</code>方法得到资源的绝对路径，再通过传统方式(<code>FileInputStream</code>)读取</p>
<p>3.通过类装载器去读，<code>ClassLoader</code>的<code>getResourceAsStream</code>(如果读取资源文件的程序不是servlet)，文件不能太大。<strong>只装载一次</strong>，所以如要读到更新后的数据，通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据（用<code>getResource</code>得到path，再用<code>FileInputStream</code>）</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://blog.csdn.net/evankaka/article/details/46673051" target="_blank" rel="noopener">servlet和Jsp生命周期解读</a></p>
</blockquote>
<hr>
<p>Servlet </p>
<pre><code>1.Servlet程序编写  生命周期
2.ServletAPI Request Response 
3.Cookie 和 Session 
</code></pre><p>1.理论<br>    Servlet 用来开发 动态web资源</p>
<pre><code>静态web资源 ： 固定数据文件
动态web资源 ： 通过程序动态生成数据文件 

注意：Servlet技术基于Request-Response编程模型  HTTP协议也是基于请求响应 模型。Servlet技术 用来 开发基于HTTP web 应用程序 

接触 JavaEE API 程序接口和已经实现接口类的使用 JavaEE：Java Platform, Enterprise Edition 缩写 
</code></pre><p>2.Servlet快速入门<br>    1.创建web project<br>    2.编写 class 继承 HttpServlet<br>    3.在web.xml 配置Servlet程序虚拟访问路径<br>      用户在浏览器上通过这个路径访问编写Servlet程序</p>
<pre><code>4.覆盖doGet或者doPost方法进行输出 (表示输出函数是doPost/doGet方法)

总结：Servlet 动态生成网页文件 
</code></pre><p>3.Servlet执行过程</p>
<pre><code>1.用户在客户端发起url请求 ： http://localhost/day05/hello   web.xml /hello 映射 HelloServlet程序

  在servlet写好之后，通过在web.xml文件中配置相应路径响应的servlet，然后将其映射过去。

2.用户提交请求时，get方式提交 执行 HelloServlet的 doGet 方法   post方式提交 执行 HelloServlet的 doPost 方法 

  用户在前台提交表单的方式 method=&quot;post/get&quot; 对应在servlet中执行相应的doPost/doPost方法
</code></pre><p>4.Servlet程序在编写和运行时，需要 javaee 类库 （API支持）</p>
<pre><code>* 在学习javase  List 需要 import java.util.List  需要 jre/lib/rt.jar 
* MyEclipse 自动导入 javaee5 liberary  存在 javaee.jar  提供 Servlet 需要类 API支持 （开发环境使Servlet程序正常编译）
* Serlvet程序运行tomcat环境中 没有javaee.jar , 在 tomcat/lib/servlet-api.jar 提供Servlet程序运行需要 类API 支持 （运行环境需要的）
</code></pre><p>5.手动编写Servlet运行</p>
<pre><code>1.在webapps 新建 day05test目录   此为虚拟应用
2.在day05test 新建 WEB-INF/classes
3.将编写Servlet的java源码文件 放入 classes ，在 WEB-INF 配置web.xml 
4.编译Servlet的 java程序 

// 通过 -classpath 指定 Servlet需要jar 包
javac -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java
//生成Servlet package结构    
javac -d . -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java
</code></pre><p>6.Servlet运行原理分析</p>
<pre><code>编写Servlet程序没有 main函数，tomcat调用Servlet程序执行

通过myeclipse向导创建 Servlet   在创建Servlet程序的同时，生成 web.xml 配置

* 生成Servlet信息非常复杂，想生成 Servlet 内容整洁一些，精简一些的话就修改Servlet模板 
    1、myeclipse工具   安装目录 common / plugins
    com.genuitec.eclipse.wizards_8.5.0.me201003052220.jar
    2、解压缩 templates/Servlet.java  这个就是Servlet模板 
</code></pre><p>7.通过API Servlet继承关系<br>    Servlet接口<br>    实现类 ： GenericServlet<br>    子类 HttpServlet 编写Servlet 继承HttpServlet </p>
<pre><code>* 编写Servlet 间接 实现 Servlet 接口  （简化开发）

Servlet接口 提出，为了解决基于请求-响应模型数据处理 （并没有涉及与HTTP协议相关 API）
GenericServlet 实现接口 通用Servlet 也没有提供与 HTTP协议相关 API 
HttpServlet 引入与 协议相关 API 
</code></pre><p>8.Servlet生命周期 </p>
<pre><code>init(ServletConfig config)  初始化 
service(ServletRequest req, ServletResponse res)  提供服务方法
destroy()  销毁 

1、tomcat服务器启动时，没有创建Servlet对象

2、第一次访问时，tomcat构造Servlet对象，调用 init，执行service 

3、从第二次以后访问 tomcat 不会从新创建Servlet对象，也不会调用init   每一次访问都会调用service

4、当服务器重启或正常关闭时 调用destroy （正常关闭 shutdown.bat）

注意：Servlet对象是tomcat创建的，每次请求调用Servlet中service方法，tomcat服务器会在每次调用Servlet的service方法时，为该方法创建Request对象和Response对象

* 在 JavaEE API 中没有Request和Response实现类   实现类由Servlet服务器提供的，tomcat提供实现类 weblogic 提供实现类 


service方法 和 HttpServlet doGet/doPost 关系区别（必须阅读HttpServlet源代码） 

在HttpServlet代码实现中，根据请求方式不同 调用相应doXXX方法 get方式请求  doGet  post方式   doPost 

配置Servlet随tomcat服务器启动时 进行初始化   &lt;load-on-startup &gt;(web.xml中配置)  *&lt;load-on-startup &gt; 参数可以是一个数字 0-9 代表服务器加载优先级 0 最高 

例如：在tomcat启动时，想通过Servlet加载一些框架配置文件 配置随服务器启动 （struts1 ）

结论：
    1、编写Servlet 继承HttpServlet
    2、编写Servlet 不需要覆盖service方法，只需要覆盖doGet和doPost 方法

    Servlet初始化时覆盖init() ，无需覆盖init(config) ？？ 
    * init(Config) 调用 init() 

注意：当doGet和doPost代码逻辑相同时，可以相互调用，简化编程
</code></pre><p>9.一个Servlet可以配置多个 url-pattern (web.xml)</p>
<pre><code>URL 配置格式 三种：
    1、完全路径匹配  (以/开始 ) 例如：/hello /init 
        * 当前工程没有被正确发布，访问该工程所有静态资源、动态资源而发生404错误  表示工程启动时出错了 
        * 查看错误时 分析错误
            1) 单一错误 ： 从上到下 查看第一行你自己写的代码 （有的错误与代码无关，查看错误信息）
            2）复合错误 Caused by ---- 查看最后一个Caused by 
            * Invalid &lt;url-pattern&gt; init2 in servlet mapping 

    2、目录匹配 (以/开始) 例如：/*  /abc/* 
        / 代表网站根目录 

    3、扩展名 (不能以/开始) 例如：*.do *.action 
        典型错误 /*.do 

    优先级：完全匹配 &gt; 目录匹配 &gt; 扩展名匹配 
</code></pre><p>10.路径问题：编写九九乘法表</p>
<pre><code>1、需要用户在客户端输入一个数字
2、Servlet接收客户输入数字 打印对应乘法表 
</code></pre><p>例如：在chengfabiao.html 通过 action 访问 ChengfabiaoServlet  路径可以用绝对路径和相对路径 </p>
<pre><code>1.相对路径：相对当前网页地址 路径  例如 chengfabiao  ./chengfabiao  ../chengfabiao
    例如： http://localhost/day05/chengfabiao.html  提交 action=&quot;chengfabiao&quot; 

* 将url最后地址换成相对路径 
结果： http://localhost/day05/chengfabiao    服务器端 /chengfabiao

    例如： http://localhost/day05/aaa/chengfabiao.html 提交 action=&quot;chengfabiao&quot;
    结果： http://localhost/day05/aaa/chengfabiao    服务器 /chengfabiao 
        * /aaa/chengfabiao 与服务器 /chengfabiao 不匹配 出现404 

    http://localhost/day05/aaa/chengfabiao.html 提供 action=&quot;../chengfabiao&quot; 
    结果：http://localhost/day05/aaa/../chengfabiao   ..和/aaa抵消 http://localhost/day05/chengfabiao 可以匹配服务器 /chengfabiao

结论：如果用相对路径提交请求，考虑当前路径， 当前访问服务器资源路径不同   相对路径写法不同

绝对路径 解决相对路径，会根据当前地址改变问题。 
例如： /day05/chengfabiao 、http://localhost/day05/chengfabiao

绝对路径 以/开始 /访问服务器根目录 
例如： 客户端访问服务器，不管当前路径是什么   / 服务器根目录 http://localhost/day05   找到虚拟目录day05工程  /day05/chengfabiao  找到 day05工程下配置 虚拟路径/chengfabiao

结论： 客户端路径 /工程虚拟目录/servlet虚拟路径 例如：/day05/chengfabiao
服务器端 配置web.xml 不需要写工程虚拟目录  只要直接写/servlet虚拟路径  例如：/chengfabiao 
</code></pre><hr>
<h4 id="掌握Servlet程序编写"><a href="#掌握Servlet程序编写" class="headerlink" title="掌握Servlet程序编写"></a>掌握Servlet程序编写</h4><pre><code>通过路径 访问Servlet 程序
    * Servlet 生命周期

    init 程序初始化
    service 程序业务层
    destroy 程序销毁    
</code></pre><p>1.学习init方法  init(ServletConfig)  通过ServletConfig 获得Servlet初始化参数</p>
<p>  1、创建一个Servlet</p>
<p>  2、在 web.xml 中 <servlet> 标签内通过 <init-param> 标签为Servlet配置初始化参数<br>    <init-param><br>        <param-name>itcast</param-name><br>        <param-value>传智播客</param-value><br>    </init-param></init-param></servlet></p>
<p>  3、在Servlet程序中通过ServletConfig对象获得itcast对应数据<br>    getInitParameter —— 通过name获得value<br>    getInitParameterNames  —– 获得所有name </p>
<ul>
<li><p>思考 ：如何在 doGet 或 doPost 方法中获得 Servlet 初始化参数？ </p>
<p>1.将ServletConfig对象保存实例成员变量<br>2.GenericServlet 已经将 ServletConfig 保存成员变量，在子类中通过 getServletConfig() 方法获得初始化参数</p>
<p>结论：子类Servlet不需要覆盖 init(ServletConfig) 只需要通过GenericServlet中 getServletConfig() 获得ServletConfig对象<br>应用：在init-param 指定配置文件位置和名称，配置Servlet随服务器启动创建 load-on-startup  </p>
</li>
<li><p>ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得 每个Servlet程序都对应一个ServletConfig对象 </p>
</li>
<li><p>ServletContext 是Servlet上下文对象，每一个工程都会创建单独ServletContext对象，这个对象代表当前web工程，操作ServletContext，必须通过 ServletConfig 获得对象 </p>
<p>应用：</p>
<pre><code>1、 获得整个web应用初始化参数
2、 实现全局数据共享
3、 实现服务器端转发功能
4、 读取web工程资源文件
</code></pre></li>
</ul>
<hr>
<p>1.获取WEB应用的初始化参数 和 ServletConfig 对象不同 </p>
<ul>
<li>ServletConfig对象配置参数，只对配置Servlet有效，如果配置参数，所有Servlet都可以访问 通过ServletContext<br><context-param></context-param></li>
</ul>
<p>2.通过 ServletContext 在多个Servlet间 共享数据<br>    案例：在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1 </p>
<pre><code>    在CountServlet 初始化过程中，向ServletContext 保存访问次数 方法：ServletContext  setAttribute 

    每次访问次数 +1  数据存放ServletContext中 所有Servlet都可以获得该数据

* 在ServletContext中保存数据，所有Servlet都可以访问 
</code></pre><p>3.通过 ServletContext 完成服务器程序转发 </p>
<pre><code>什么是转发？ 转发和重定向区别 ？
getRequestDispatcher(java.lang.String path)  完成转发

使用转发还是重定向？ 转发性能好于重定向，请求次数好 

案例：统计字母次数
    request.getParameter(&quot;content&quot;) 获得form 提交内容 content 就是 textarea name属性
</code></pre><p>4.利用ServletContext对象读取资源文件</p>
<pre><code>1.使用java application 读取文件，读取当前工程下所有文件  使用相对路径读取文件

2.使用Servlet读取文件 只能读取WebRoot下所有文件  必须使用绝对磁盘路径读取文件 

3.通过站点根目录绝对路径 获得磁盘绝对路径 getServletContext().getRealPath(“/WEB-INF/info.txt”)

注意：因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，通过Class类对象读取该目录下文件 
    String filename3 = c.getResource(&quot;/a1.txt&quot;).getFile();  表示： / 代表 /WEB-INF/classes 

结论：在WEB工程中，必须将文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx  getServletContext().getRealPath(&quot;/xxx&quot;);   /代表WebRoot 
如果读取文件恰好位于 WEB-INF/classes 通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径   / 代表 /WEB-INF/classes 
</code></pre><p>注意：<br>    缺省Servlet 功能：处理其他Servlet都不处理请求<br>    tomcat/conf/web.xml  org.apache.catalina.servlets.DefaultServlet 作为缺省Servlet </p>
<pre><code>总结：
    1、编写Servlet HelloServlet
    2、修改Servlet模板 
    3、Servlet生命周期 理论重点掌握
    4、Servlet url三种写法 完全、目录、扩展名
    5、路径问题：绝对路径   案例 九九乘法表
           将web.xml 配置路径复制到网页 在路径前 /工程名
    6、ServletConfig 和ServletContext 读取初始化参数区别 ？
    7、ServletContext数据共享案例   统计访问次数
    8、ServletContext转发案例   统计字母出现次数
    9、读取web工程中资源文件   绝对路径
        在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx   getServletContext().getRealPath(&quot;/xxx&quot;);  /代表WebRoot 
        如果读取文件 恰好位于 WEB-INF/classes   通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes 
    10、缺省Servlet 了解功能将静态资源数据内容读取写给客户端 
</code></pre><hr>
<h4 id="HttpServletResponse-HttpServletRequest-关键：了解HTTP协议"><a href="#HttpServletResponse-HttpServletRequest-关键：了解HTTP协议" class="headerlink" title="HttpServletResponse HttpServletRequest(关键：了解HTTP协议)"></a>HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</h4><p>Web服务器(TOMCAT)收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象和代表响应的response对象。所以获取客户端提交的数据，只需要找到request对象即可，然后如果需要向容器输出数据，只需要找response对象即可。</p>
<p><strong>1.HttpServletResponse</strong><br></p>
<pre><code>1.响应行 setStatus(int sc);//设置相应状态码 HTTP/1.1 200
2.响应头 setHeader(String name,String value);//设置响应头信息 
      请求重定向 sendRedirect(String location);

  浏览器使用的码表(告知)
    response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

  告知客户端不缓存
    response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
    response.setDataHeader(&quot;expires&quot;,0);
3.相应正文
    setCharacterEncoding(String charset);//告知服务器使用什么编码
    setContentType(String type);
</code></pre><p><strong>2.HttpServletRequest</strong><br></p>
<pre><code>1.请求行
  Get方式 URL链接：http://localhost:8080/day09/servlet/req1?username=zs  协议：http/1.1

    getMethod(); 获得请求方式
    getRequestURL();返回客户端发出请求时的完整URL。
    getRequestURI(); 返回请求行中的资源名部分。
    getContextPath(); 当前应用的虚拟目录 /day09_01_request
    getQueryString() ; 返回请求行中的参数部分。

2.请求消息头

  String getHeader(String name)  根据头名称得到头信息值
  Enumeration   getHeaderNames()  得到所有头信息name
  Enumeration   getHeaders(String name)  根据头名称得到相同名称头信息值

3.请求正文

获取表单数据相关的方法
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  getParameter(name) 根据表单中name属性的名，获取value属性的值方法 
  getParameterValues（String name）专为复选框提供的方法
  getParameterNames() 得到表单提交的所有name的方法 
  getParameterMap 到表单提交的所有值的方法   //做框架用，非常实用
  getInputStream  以字节流的方式得到所有表单数据

扩展：
    操作非表单数据相关的方法(request是一个域对象)
        void setAttribute(String name, Object value);
        Object getAttribute(String name);
        void removeAttribute(String name);

    请求转发相关方法

        //得到请求转发或请求包含的协助对象
        RequestDispatcher getRequestDispatcher(String path)
        forward(ServletRequest request, ServletResponse response) //转发的方法
        include(ServletRequest request, ServletResponse response) //请求包含

    请求编码相关方法

        //解决post方式编码
        request.setCharacterEncoding(&quot;UTF-8&quot;); //告诉服务器客户端什么编码,只能处理post请求方式

        //解决get方式编码
        String name = new String(name.getBytes(“iso-8859-1”),”UTF-8”);
</code></pre><hr>
<h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2><p>两条主线<br>    1、HTTP协议<br>    2、Servlet生命周期 </p>
<p>1.init()方法中参数 ServletConfig 对象的使用</p>
<p>  通过 ServletConfig 获得 ServletContext 对象来使用</p>
<p>2.service()方法 含有两个参数对象 ServletRequest ServletResponse </p>
<p>  在实际开发Servlet过程中不需要覆盖service,HttpServlet 根据请求方式自动调用 doGet 或者 doPost doGet和doPost参数 HttpServletRequest 和 HttpServletResponse </p>
<hr>
<p>3.HttpServletRequest HttpServletResponse (学习重点)</p>
<p>  客户端每次请求都会创建request对象和response对象 作用：被传递service / doGet / doPost </p>
<p>  1.HttpServletRequest 封装客户端相关信息，服务器Servlet程序可以 通过request对象 操作客户端信息<br>  2.HttpServletResponse 封装服务器向客户端发送响应数据信息，Servlet程序 通过response对象 向客户端发送响应</p>
<p>4.Response常用的API</p>
<pre><code>1.setStatus 设置响应行 当中 状态码
2.setHeader 设置响应头信息
3.getOutputStream 获得字节流 ---- 输出响应体内容
4.getWriter 获得字符流 ---- 输出响应体内容
</code></pre><p>注意：</p>
<ul>
<li>HttpServletResponse 继承 ServletResponse 接口 ，ServletResponse 并没有提供与HTTP协议相关API ，HttpServletResponse 添加了与协议相关 API</li>
<li>JavaEE API 中并没有提供 HttpServletResponse 实现类 —- 实现类由tomcat服务器提供的</li>
</ul>
<p>5.服务器常用状态码 ： 200 302 304 404 500 </p>
<pre><code>200 请求处理成功
302 客户端重定向
304 客户端访问资源没有被修改，客户端访问本地缓存
404 访问资源不存在
500 服务器内部出错
</code></pre><p>6.案例：</p>
<pre><code>1.通过302 + Location 头信息实现页面重定向效果 
    response.setStatus(302);
    response.setHeader(&quot;Location&quot;, &quot;/day06/welcome.html&quot;); // 相对路径 和 绝对路径

注意：* / 由客户端定向服务器，代表客户端 / , 必须添加工程虚拟目录 

   头信息存在多个值

    Accept-Encoding: gzip, deflate --- key:value1,value2 
    response.addHeader 用于设置响应头有多个值 ------ 不常用 
重点：setHeader 

在Response API 中提供sendRedirect ---- 完成302+Location重定向效果 
例如： response.sendRedirect(&quot;/day06/welcome.html&quot;);

2.登陆重定向


3.自动刷新网页 

* 登陆成功，5秒后自动跳转XX页面 
原理：通过refresh 头信息 
格式 -----   refresh: 时间;url=跳转路径
例如： refresh:3;url=http://www.itcast.cn -------- 3秒后自动跳转http://www.itcast.cn 网站 

注意：* HTML 页面中存在一类非常特殊标签 &lt;meta&gt; ，&lt;meta&gt; 起到设置头信息作用 
&lt;meta content=&quot;3;url=/day06/response/demo3/result.html&quot; http-equiv=&quot;refresh&quot;&gt; ---- 完成自动跳转 

4.通过response头信息设置 浏览器禁止缓存

原理：和禁用缓存相关头信息 三个 
Cache-Control:no-cache
Expires:Thu, 01 Dec 1994 16:00:00 GMT  ----- setDateHeader(&quot;expires&quot;,-1);
Pragma : no-cache

IE 工具---Internet选项 ---常规 --- 设置 --- 查看文件
对于Servlet生成HTML页面，经常需要改变，禁止Servlet动态程序缓存 
注意：* 设置Expires时，通常 setDateHeader 为过期时间设置一个毫秒值，生成HTTP响应时，会自动转换日期字符串表示 
</code></pre><p>通过response 生成 客户端响应体，通过字节流和字符流两种输出方式 </p>
<pre><code>* 哪些情况用字节流？ 哪些情况用字符流 ？ 
    文件拷贝 ---- 字节流 
    分析文件内容 --- 字符流 （中文操作 字符流）

5.输出中文信息

对中文信息进行编码 
response.setCharacterEncoding(&quot;utf-8&quot;);
response.setContentType(&quot;text/html;charset=utf-8&quot;); 

setCharacterEncodig 和 setContentType 区别 ？

结论：开发中只需要使用setContentType 就可以了
</code></pre><blockquote>
<p>注意：<br>    1、getOutputStream和getWriter 不能同时使用<br>    2、必须在getOutputStream和getWriter 之前 设置响应 编码<br>    3、getOutputStream和getWriter 输出内容 是 HTTP响应体<br>    4、getOutputStream和getWriter 存在缓冲区的 ，在service方法结束时，自动关闭流，flush缓冲区内容</p>
</blockquote>
<pre><code>6.文件下载
第一种：通过超链接 完成文件下载 
* 如果浏览器可以识别该文件格式，直接打开，只有链接文件浏览器不识别文件格式，才会实现下载 

第二种：通过Servlet程序实现下载 
原理：通过Servlet读取目标程序，将资源返回客户端
通过程序下载文件 设置两个头信息 Content-Type Content-Disposition 
response.setContentType(getServletContext().getMimeType(filename));  ---- 设置文件类型 
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+ filename); ---- 设置文件以附件形式下载（对于浏览器识别格式文件）

7.验证码输出案例 
Java图形API 生成验证码图片 ----- 了解 
为什么需要验证码 ？防止有人通过程序恶意攻击网站 
验证码为什么是图片 ？为什么雪花或者干扰线？  
常用验证码 ： 字母和数字 

验证码旋转效果 
rotate(double theta, double x, double y)  ----- 参数 theta 旋转弧度 
2PI 弧度 = 360 角度 

-30 ---- 30 角度 

验证码看不清楚，点击切换验证码 ---- 编写JavaScript程序 
方法一：设置验证码图片不缓存
方法二：每次访问使url 不同 ----- url?new Date().getTime() 当前时间 
</code></pre><hr>
<p>HttpServletRequest 分为四个部分</p>
<pre><code>HttpServletRequest 想比 ServletRequest 添加与协议相关 API

1、获取客户机信息
    URI和URL区别
    url:http://localhost/day06/request1  --- 完整
    uri:/day06/request1  ---- 部分

    URI 包含 URL的 ，URL 一定完成路径，URI可以相对路径 
    http://localhost/day06/request1 是一个URL 同时也是 URI
    ./hello  /day06/request1 ---- 都是URI 不是URL 

获得ip ： request.getRemoteAddr();

获得当前访问资源路径 ： request.getRequestURI().substring(request.getContextPath().length());


2、获取请求头信息
    getHeader 获得头信息的值，转换一个字符串
    getHeaders 获得头信息值 ，获得Enumeration
    getHeaderNames 获得所有头信息名称  返回 Enumeration

    * 掌握getHeader使用，遍历Enumeration 获得所有头信息

    编写防盗链程序，存在合法referer不是盗链，否则控制目标资源无法访问 ！
    * 通过URL 绕过盗链判断

3、获取请求参数

    请求参数：指用户通过请求提交服务器一些数据

        &lt;a href=&quot;url?xxx=xxx&quot; &gt;
        &lt;form method=&quot;get&quot;&gt;
        &lt;form method=&quot;post&quot;&gt;

    如：/day06/request4?name=zhangsan&amp;city=beijing  这一路径中包括两个参数的 name 和 city 

request常用API四个

    getParameter
    getParameterValues
    getParameterNames
    getParameterMap 

非空校验
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {} //短路 

乱码问题
    post方法：request.setCharacterEncoding(&quot;客户端编码集&quot;);

    get乱码手动解决
        username = URLEncoder.encode(username, &quot;ISO-8859-1&quot;);// 用ISO编码
        username = URLDecoder.decode(username, &quot;utf-8&quot;); // 用utf-8解码
        简化上面写法 ： username = new String(username.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);

get乱码 配置tomcat默认解码字符集
    在tomcat/conf/server.xml 
    Connector中 添加一个属性 URIEncoding=&quot;utf-8&quot;

结论：开发时，尽量不要修改tomcat默认解码集 ，提交请求请尽量使用post ，如果非要使用get ，手动编码

问题：http://localhost/day06/servlet?username=zhangsan+lisi
在服务器端 通过 request.getParameter(&quot;username&quot;) 结果是 ？？？ ----- zhangsan lisi 


4、利用请求域传递对象
    HttpServletRequest 和 ServletContext 类似 都是数据域对象 ， 以Map方式保持数据

    区分：存活时间不同 

    ServletContext对象 服务器启动对象创建，服务器停止对象销毁
    ServletRequest对象 当产生一次请求时 创建，当响应结束后，对象销毁 

    通过request转发请求，request保存数据进行Servlet之间传递 ---- 应用？
    Servlet进行数据处理 --- 生成结果 --- 转发结果给JSP显示 
</code></pre><p>注意：</p>
<pre><code>1、在使用forward之前 不能将响应内容传输到客户端
    情况一 response输出流执行flush 
    情况二 同一个Servlet不能连续使用forward 和 redirect
2、在执行forward 和 redirect时，清除之前写入响应流数据 
3、ServletContext进行转发 路径必须/开始，request进行转发路径可以使用相对路径 

转发和重定向区别
    1、转发一次请求、一次响应 重定向 两次请求 两次响应
    2、转发只能跳转站内程序，重定向定向任何站点 
    3、转发 URL地址不变 ，重定向URL地址改变 
    4、转发 对客户端不可见，重定向对客户端可见 
    5、转发共享同一个Request中数据，重定向两次请求，不同Request对象，不能共享Request数据 
</code></pre><ul>
<li>request.setAttribute 必须和 request.getRequestDispatcher().forward 一起使用 </li>
</ul>
<p>RequestDispatcher 的 include 方法 用来做页面布局 —— &lt;%@include%&gt; <a href="jsp:include" target="_blank" rel="noopener">jsp:include</a><br>将页面公共部分抽取出来，通过include 引用到页面中 —- 更加方便维护 </p>
<hr>
<p>总结：<br>    1、Response 四个必须 API setStatus setHeader getOutputStream getWriter<br>    setStatus 状态码<br>    setHeader 头信息<br>    getOutputStream getWriter  响应体</p>
<pre><code>2、重定向 302 + Location ---- 简写 sendRedirect 
案例 用户登录重定向 

3、refresh自动刷新网页 
&lt;meta&gt; 标签使用 

4、禁用浏览器缓存 三个头字段 

5、响应中文乱码 ---- 都使用setContentType

6、文件下载 超链接和Servlet程序 
    Servlet程序 设置两个头字段 Content-Type Content-Disposition

7、验证码程序 （写完整存档）
    * 验证码点击切换 两种方法 

8、request请求行相关API getRequestURI getContextPath getRemoteAddr getMethod  
    思考：获得访问资源路径 

9、request头信息获得（不重要） ---- 掌握防盗链案例

10、获得请求参数 乱码解决 get 、post  （超级重要）

11、转发共享request数据 、include进行页面布局 ---- 了解即可
</code></pre><hr>
<p>POST编码与GET编码</p>
<p>1.POST编码<br>  &lt;%@page pageEncoding=”UTF-8”%&gt; 浏览器当前是什么编码就以什么编码提交<br>  Servlet：因为客户端没有告诉服务器，请求正文的编码，于是服务器默认用ISO-8859-1进行编码，从而出现乱码<br>  解决方法：告诉服务器请求正文的数据应该使用的编码是什么(request.setCharacterEncoding(“UTF-8”);)</p>
<p>2.GET编码<br>  &lt;%@page pageEncoding=”UTF-8”%&gt; 浏览器当前是什么编码就以什么编码提交<br>  Servlet：URL地址后的参数服务器默认用ISO-8859-1进行编码，这样会产生乱码<br>  解决方法：如果依照POST的解决乱码的方法，结果是无效的。需要拿到原始的二进制数据，然后用UTF-8进行重新编码</p>
<p>  byte b[] = name.getBytes(“ISO-8859-1”);//1010101<br>  String name = new String(b,”UTF-8”);//解决</p>
<hr>
<p>Request Response对象解决乱码的应用</p>
<pre><code>1.服务器解决乱码
response.setContentType(&quot;text/html;charset=gbk&quot;);
2.浏览器解决乱码
request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre><hr>
<p>Servlet技术</p>
<pre><code>1、Servlet程序编写 ----- 生命周期
2、ServletAPI Request Response 
3、Cookie 和 Session 
</code></pre><p>注意：Servlet 用来 动态web资源 开发<br>    静态web资源 ： 固定数据文件<br>    动态web资源 ： 通过程序动态生成数据文件 </p>
<pre><code>Servlet技术基于Request-Response编程模型 ---- HTTP协议也是基于请求响应 模型 
* Servlet技术 用来 开发基于HTTP web 应用程序 

接触 JavaEE API ------ 程序 接口 和 已经实现接口 类的 使用 
JavaEE ---- Java Platform, Enterprise Edition  缩写 
</code></pre><hr>
<p>Servlet快速入门<br>    1、创建web project<br>    2、编写 class 继承 HttpServlet<br>    3、在web.xml 配置 Servlet程序 虚拟访问路径 </p>
<pre><code>    * 用户在浏览器上通过这个路径 访问编写Servlet程序 
4、覆盖doGet或者doPost方法 进行输出 

* Servlet 动态生成 网页文件 

执行过程
    1、用户在客户端发起url请求 ： http://localhost/day05/hello ----- web.xml /hello 映射 HelloServlet程序
    2、用户提交请求时，get方式提交 执行 HelloServlet的 doGet方法 post方式提交 执行 HelloServlet的doPost 方法 

Servlet程序在编写和运行时，需要javaee 类库 （API支持）
    * 在学习javase  List 需要 import java.util.List  需要 jre/lib/rt.jar 
    * MyEclipse 自动导入 javaee5 liberary  存在 javaee.jar  提供 Servlet 需要类 API支持 （开发环境使Servlet程序正常编译）
    * Serlvet程序运行tomcat环境中 没有javaee.jar , 在 tomcat/lib/servlet-api.jar 提供Servlet程序运行需要 类API 支持 （运行环境需要的）

手动编写Servlet运行
    1、在webapps 新建 day05test目录 --- 虚拟应用
    2、在day05test 新建 WEB-INF/classes
    3、将编写Servlet的java源码文件 放入 classes ，在 WEB-INF 配置web.xml 
    4、编译Servlet的 java程序 

设置classpath路径
    javac -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java  // 通过 -classpath 指定 Servlet需要jar 包

生成Servlet package结构 
    javac -d . -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java


Servlet运行原理分析
    编写Servlet程序没有 main函数 ---- tomcat调用Servlet程序执行

    通过myeclipse向导 创建Servlet ---- 创建Servlet程序，生成web.xml 配置 
        * 生成Servlet信息非常复杂，想生成Servlet 内容整洁一些，精简一些 ------ 修改Servlet模板 
        1、myeclipse工具 ---- 安装目录 common / plugins
            com.genuitec.eclipse.wizards_8.5.0.me201003052220.jar

        2、解压缩 templates/Servlet.java --- 这个就是Servlet模板 

通过API Servlet继承关系 
    Servlet接口 ---- 实现类 ： GenericServlet ------ 子类 HttpServlet  ------ 编写Servlet 继承HttpServlet 
        * 编写Servlet 间接 实现 Servlet 接口  （简化开发）
    Servlet接口 提出，为了解决基于请求-响应模型数据处理 （并没有涉及与HTTP协议相关 API）
    GenericServlet 实现接口 通用Servlet 也没有提供与 HTTP协议相关 API 
    HttpServlet 引入与 协议相关 API 
</code></pre><hr>
<p>Servlet生命周期 </p>
<pre><code>1.init(ServletConfig config)  初始化 
2.service(ServletRequest req, ServletResponse res)  提供服务方法
3.destroy()  销毁 

1、tomcat服务器启动时，没有创建Servlet对象

//默认第一次请求时创建servlet实例，应用存在实例就存在，在实例被卸载，实例就销毁
2、第一次访问时，tomcat构造Servlet对象，调用 init，执行service 

3、从第二次以后访问 tomcat 不会从新创建Servlet对象，也不会调用init  每一次访问都会调用service 
4、当服务器重启或正常关闭时 调用destroy （正常关闭 shutdown.bat）

Servlet对象是tomcat创建的，每次请求调用Servlet中service方法，tomcat服务器会在每次调用Servlet的service方法时，为该方法创建Request对象和Response对象 
* 在 JavaEE API 中没有Request和Response实现类   实现类由Servlet服务器提供的，tomcat提供实现类 weblogic 提供实现类 

service方法 和 HttpServlet doGet/doPost 关系区别？ 必须阅读HttpServlet源代码 
在HttpServlet代码实现中，根据请求方式不同 调用相应doXXX方法 get方式请求 --- doGet  post方式 --- doPost 

配置Servlet随tomcat服务器启动时 进行初始化   &lt;load-on-startup &gt;
*&lt;load-on-startup &gt; 参数可以是一个数字 0-9 代表服务器加载优先级 0 最高 
例如：在tomcat启动时，想通过Servlet加载一些框架配置文件 配置随服务器启动 （struts1 ）
</code></pre><p>结论：<br>    1、编写Servlet 继承HttpServlet<br>    2、编写Servlet 不需要覆盖service方法，只需要覆盖doGet和doPost 方法</p>
<pre><code>Servlet初始化时覆盖init() ，无需覆盖init(config) ？？ 
* init(Config) 调用 init() 

当doGet和doPost代码逻辑相同时，可以相互调用，简化编程
</code></pre><hr>
<p>Servlet的三种创建方式</p>
<pre><code>1.实现javax.servlet.Servlet接口

2.实现javax.servlet.GenericServlet类(适配器模式)

3.继承javax.servlet.http.HttpServlet类(模板方法设计模式) 这种方式是开发中常用的方法

public class ServletDemo extends HttpServlet{
    protected void doGet(HttpServletRequest req,HttpServleResponse resp) throws ServletException,IOExcption{
        System.out.println(&quot;get方法实现&quot;);
        }
    protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException,IOException{
        System.out.println(&quot;doPost方法实现&quot;);
        }
    }
</code></pre><hr>
<pre><code>web.xml映射细节

    1.配置多个映射路径（配置多个&lt;servlet-mapping&gt;）：

        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;

    2.通配符*代表任意字符串

        1.url-pattern: *.do  以*.字符串的请求都可以访问   注：不要加/ (扩展名匹配)
        2.url-pattern: /*  任意字符串都可以访问 (绝对匹配)
        3.url-pattern：/action/* 以/action开头的请求都可以访问 (开头匹配)

    注意：如果url-pattern的值是/，表示执行默认映射。所有资源都是servlet
</code></pre><hr>
<p>一个Servlet可以配置多个url-pattern </p>
<p>URL 配置格式 三种：<br>    1、完全路径匹配  (以/开始 ) 例如：/hello /init </p>
<pre><code>    * 当前工程没有被正确发布，访问该工程所有静态资源、动态资源 发生404 ----- 工程启动时出错了 
    * 查看错误时 分析错误
1) 单一错误 ： 从上到下 查看第一行你自己写代码 （有的错误与代码无关，查看错误信息）
2）复合错误 Caused by ---- 查看最后一个Caused by 
* Invalid &lt;url-pattern&gt; init2 in servlet mapping 

2、目录匹配 (以/开始) 例如：/*  /abc/* 
/ 代表网站根目录 

3、扩展名 (不能以/开始) 例如：*.do *.action 
典型错误 /*.do 

优先级：完全匹配&gt;目录匹配 &gt; 扩展名匹配 
</code></pre><p>路径问题：编写九九乘法表<br>    1、需要用户在客户端输入一个数字<br>    2、Servlet接收客户输入数字 打印对应乘法表 </p>
<pre><code>在chengfabiao.html 通过 action 访问 ChengfabiaoServlet  路径可以用绝对路径和相对路径 

相对路径：相对当前网页地址 路径  例如 chengfabiao  ./chengfabiao ../chengfabiao
例如： http://localhost/day05/chengfabiao.html  提交 action=&quot;chengfabiao&quot;

* 将url最后地址换成相对路径 
结果： http://localhost/day05/chengfabiao  ----- 服务器端 /chengfabiao

例如： http://localhost/day05/aaa/chengfabiao.html 提交 action=&quot;chengfabiao&quot;
结果： http://localhost/day05/aaa/chengfabiao  ----- 服务器 /chengfabiao 
* /aaa/chengfabiao 与服务器 /chengfabiao 不匹配 出现404 

http://localhost/day05/aaa/chengfabiao.html 提供 action=&quot;../chengfabiao&quot; 
结果：http://localhost/day05/aaa/../chengfabiao ---- &gt; ..和/aaa抵消 http://localhost/day05/chengfabiao 可以匹配服务器 /chengfabiao

结论：如果用相对路径提交请求，考虑当前路径， 当前访问服务器资源路径不同 ---- 相对路径写法不同

绝对路径 解决相对路径，会根据当前地址改变问题。 例如： /day05/chengfabiao 、http://localhost/day05/chengfabiao
绝对路径 以/开始 /访问服务器根目录 
例如： 客户端访问服务器，不管当前路径是什么 --- / 服务器根目录 http://localhost
/day05 --- 找到虚拟目录day05工程  /day05/chengfabiao --- 找到 day05工程下配置 虚拟路径/chengfabiao

结论： 客户端路径 /工程虚拟目录/servlet虚拟路径 例如：/day05/chengfabiao
服务器端 配置web.xml 不需要写工程虚拟目录  只要直接写/servlet虚拟路径  例如：/chengfabiao 
</code></pre><hr>
<p>掌握Servlet程序编写</p>
<pre><code>通过路径 访问Servlet 程序
</code></pre><ul>
<li><p>Servlet 生命周期</p>
<p>  init<br>  service<br>  destroy </p>
</li>
</ul>
<p>学习init方法   init(ServletConfig)   通过ServletConfig 获得Servlet初始化参数</p>
<pre><code>1、创建一个Servlet
2、在web.xml 中 &lt;servlet&gt; 标签内 通过 &lt;init-param&gt; 标签 为Servlet配置初始化参数
        &lt;init-param&gt;
            &lt;param-name&gt;itcast&lt;/param-name&gt;
            &lt;param-value&gt;传智播客&lt;/param-value&gt;
        &lt;/init-param&gt;

3、在Servlet程序中通过ServletConfig对象 获得itcast对应数据 
    getInitParameter   通过name获得value
    getInitParameterNames  获得所有name 

  Servlet获取配置信息

    ServletConfig作用：

        1.获取servlet配置信息
        2.获取ServletContext对象 ServletContext对象代表整个应用，且一个应用应用只有一个ServletContext对象 作用：在一定范围之内使得多个Servlet共享数据

* 思考 ：如何在doGet 或 doPost 方法中 获得 Servlet初始化参数 
    1.将ServletConfig对象保存实例成员变量 
    2.GenericServlet 已经将ServletConfig 保存成员变量   在子类中通过 getServletConfig方法 获得 初始化参数

结论：子类Servlet不需要覆盖 init(ServletConfig) , 只需要通过GenericServlet中 getServletConfig() 获得ServletConfig对象 

应用：在init-param 指定配置文件位置和名称，配置Servlet随服务器启动创建 load-on-startup  

* ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得   每个Servlet程序都对应一个ServletConfig对象 

ServletContext 是Servlet上下文对象 
    每一个工程 对会创建 单独ServletContext对象，这个对象代表当前web工程 
    操作ServletContext 必须通过ServletConfig 获得对象 
</code></pre><p>应用：<br>    1、 获得整个web应用初始化参数<br>    2、 实现全局数据共享<br>    3、 实现服务器端转发功能<br>    4、 读取web工程资源文件</p>
<pre><code>1、获取WEB应用的初始化参数 和 ServletConfig 对象不同 
* ServletConfig对象 配置参数，只对配置Servlet有效，如果配置参数，所有Servlet都可以访问 通过ServletContext
    &lt;context-param&gt;

2、通过ServletContext 在多个Servlet间 共享数据 
    在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1 
    在CountServlet 初始化过程中，向ServletContext 保存访问次数   0    ServletContext  setAttribute 

      每次访问次数 +1  数据存放ServletContext中  所有Servlet都可以获得该数据

    * 在ServletContext中保存数据，所有Servlet都可以访问 

3、通过ServletContext 完成服务器程序转发 
    什么是转发？ 转发和重定向区别 ？
    getRequestDispatcher(java.lang.String path)   完成转发

    使用转发还是重定向？   转发性能好于重定向，请求次数好 

    统计字母次数
    request.getParameter(&quot;content&quot;) 获得form 提交内容 content 就是 textarea name属性

4、利用ServletContext对象读取资源文件

    使用java application 读取文件，读取当前工程下所有文件    使用相对路径读取文件
    使用Servlet读取文件 只能读取WebRoot下所有文件    必须使用绝对磁盘路径读取文件 

    通过站点根目录绝对路径 获得磁盘绝对路径   getServletContext().getRealPath(“/WEB-INF/info.txt”)

    * 因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，通过Class类对象读取 该目录下文件 
    String filename3 = c.getResource(&quot;/a1.txt&quot;).getFile();    / 代表 /WEB-INF/classes 

结论：在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx     getServletContext().getRealPath(&quot;/xxx&quot;);  /代表WebRoot 
      如果读取文件 恰好位于 WEB-INF/classes   通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes 


    缺省Servlet 功能：处理其他Servlet都不处理请求 
    tomcat/conf/web.xml  org.apache.catalina.servlets.DefaultServlet 作为缺省Servlet 
</code></pre><p>总结：<br>    1、编写Servlet HelloServlet<br>    2、修改Servlet模板<br>    3、Servlet生命周期 理论重点掌握<br>    4、Servlet url三种写法 完全、目录、扩展名<br>    5、路径问题：绝对路径      案例 九九乘法表<br>        将web.xml 配置路径复制到网页 在路径前 /工程名<br>    6、ServletConfig 和ServletContext 读取初始化参数区别 ？<br>    7、ServletContext数据共享案例      统计访问次数<br>    8、ServletContext转发案例   统计字母出现次数<br>    9、读取web工程中资源文件    绝对路径<br>        在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx    getServletContext().getRealPath(“/xxx”);  /代表WebRoot<br>        如果读取文件 恰好位于 WEB-INF/classes    通过 类名.class.getResource(“/文件名”).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes<br>    10、缺省Servlet 了解功能将静态资源数据内容读取写给客户端 </p>
<hr>
<h4 id="Servlet-基本训练"><a href="#Servlet-基本训练" class="headerlink" title="Servlet 基本训练"></a>Servlet 基本训练</h4><pre><code>1.在Servlet中实现请求转发

    在Servlet中实现页面转发，使用的是RequestDispatcher对象的 forward（）方法。可以在Servlet中通过 forward（）方法将当前的请求转发到其他web组件（Servlet、JSP、HTML）。

2.在Servlet中处理表单提交的数据

    Java Web的核心组件Servlet的主要功能就是处理客户端的表单请求数据，然后再Servlet中首先对这些数据进行验证，然后可能会封装到JavaBean。
    接下来调用数据库的业务逻辑方法将数据保存或者进行其他操作，最后Servlet控制将响应结果返回到客户端。

    注意：在实际开发中，Servlet处理完表单数据之后，通常会根据表单数据更新数据库，最后再由Servlet进行控制转发

3.在Servlet中实现页面重定向

    实现页面重定向主要应用在HttpServletResponse对象的sendRedirect()方法

4.动态生成HTML文档

5.在Servlet中向客户端写cookie信息
</code></pre><hr>
<p>HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</p>
<pre><code>Web服务器(TOMCAT)收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。
所以既然response/request对象代表请求和响应，那么获取客户端提交过来的数据只需要找request对象就可以，然后向容器输出数据，只需要找response对象就可以了。
</code></pre><p>1.HttpServletResponse(该对象代表服务器的响应 此对象中封装了向客户端发送数据、发送响应头、发送响应状态码的方法)</p>
<pre><code>1.响应行 setStatus(int sc);//设置相应状态码 HTTP/1.1 200
2.相应头 setHeader(String name,String value);//设置响应头信息 
      请求重定向 sendRedirect(String location);

  浏览器使用的码表(告知)
    response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

  告知客户端不缓存
    response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
    response.setDataHeader(&quot;expires&quot;,0);
3.相应正文
    setCharacterEncoding(String charset);//告知服务器使用什么编码
    setContentType(String type);

扩展：response常见应用

    向客户端输出中文数据：response.getOutputStream().write(“中国”.getBytes()));//以默认编码发送数据

    注意：当浏览器中出现乱码，通过以下方法：response.setContentType(&quot;text/html;charset=UTF-8&quot;); 解决
    总结：程序以什么编码输出就需要告诉客户端以什么编码显示

    response细节：

        1.getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。
        2.getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。  会抛异常。
        3.Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 
        4.Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。 
</code></pre><p>2.HttpServletRequest(代表客户端的请求，当客户端通过HTTP协议访问服务器时，Http请求头中的所有信息都封装到这对象，开发人员通过此对象的方法获取客户的这些信息)</p>
<pre><code>1.请求行
  Get方式 URL链接：http://localhost:8080/day09/servlet/req1?username=zs  协议：http/1.1

    getMethod(); 获得请求方式
    getRequestURL();返回客户端发出请求时的完整URL。
    getRequestURI(); 返回请求行中的资源名部分。
    getContextPath(); 当前应用的虚拟目录 /day09_01_request
    getQueryString() ; 返回请求行中的参数部分。

2.请求消息头

  String getHeader(String name)  根据头名称得到头信息值
  Enumeration   getHeaderNames()  得到所有头信息name
  Enumeration   getHeaders(String name)  根据头名称得到相同名称头信息值

3.请求正文

获取表单数据相关的方法
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  getParameter(name) 根据表单中name属性的名，获取value属性的值方法 
  getParameterValues（String name）专业为复选框取取提供的方法
  getParameterNames() 得到表单提交的所有name的方法 
  getParameterMap 到表单提交的所有值的方法   //做框架用，非常实用
  getInputStream  以字节流的方式得到所有表单数据

扩展：
    操作非表单数据相关的方法(request是一个域对象)
        void setAttribute(String name, Object value);
        Object getAttribute(String name);
        void removeAttribute(String name);

    请求转发相关方法

        //得到请求转发或请求包含的协助对象
        RequestDispatcher getRequestDispatcher(String path)
        forward(ServletRequest request, ServletResponse response) //转发的方法
        include(ServletRequest request, ServletResponse response) //请求包含

    请求编码相关方法

        //解决post方式编码
        request.setCharacterEncoding(&quot;UTF-8&quot;); //告诉服务器客户端什么编码,只能处理post请求方式

        //解决get方式编码
        String name = new String(name.getBytes(“iso-8859-1”),”UTF-8”);
</code></pre><hr>
<p>一、什么Servlet？</p>
<pre><code>servlet 是运行在 Web 服务器中的小型 Java 程序（即：服务器端的小应用程序）。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。
</code></pre><p>1.1、编写一个servlet程序：<br>a、写一个java类，实现servlet接口</p>
<pre><code>public class ServletDemo implements Servlet{
    //接收用户请求，并作出响应
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        response.getWriter().write(&quot;hello ServletDemo&quot;);
    }
}
</code></pre><p>b、修改web.xml文件，给servlet提供一个可访问的URI地址</p>
<pre><code>&lt;!--创建Servlet实例--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servletDemo的实现类&lt;/servlet-class&gt;
&lt;/sevlet&gt;

&lt;!--给servlet提供(映射)一个可以访问的URI地址--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>c、部署应用到tomcat服务器</p>
<p>d、测试：<a href="http://locahost:8080/day08_servlet/demo1" target="_blank" rel="noopener">http://locahost:8080/day08_servlet/demo1</a></p>
<p>二、执行过程</p>
<pre><code>1.首先在浏览器输入地址，然后地址转到Tomcat找到servlet应用
2.然后在servlet应用中找到相应的访问的demo
3.在找到对应的demo之后实例化后调用初始化方法
4.然后再次调用service方法
5.最后将信息响应给客户端并调用distory方法
</code></pre><p>三、Servlet生命周期（重要）<br>    实例化–&gt;初始化–&gt;服务-&gt;销毁<br>出生：（实例化–&gt;初始化）第一次访问Servlet就出生（默认情况下）<br>活着：（服务）应用活着，servlet就活着<br>死亡：（销毁）应用卸载了servlet就销毁。</p>
<pre><code>//默认第一次请求，创建Servlet实例，当应用存在那么实例就存在，应用卸载，相应的实例就销毁
public class ServletDemo implements Servlet{
    //生命周期的方法：实例化对象
    //第一次被访问时调用
    public ServletDemo(){
        System.out.println(&quot;ServletDemo被调用&quot;);
    }
    //生命周期的方法：初始化方法
    //第一次被访问时调用
    public void init(ServletConfig config) throws ServletException{
        System.out.println(&quot;init方法被调用&quot;);
    }
    //生命周期方法：服务方法
    //接受用户请求，并做出相应
    //每次请求都被调用
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;service方法被调用&quot;);
    }
    //生命周期的方法：销毁
    //当应用被卸载时调用
    public void destroy(){
        System.out.println(&quot;destroy被调用&quot;);
    }
}
</code></pre><p>小知识：<br>如何让servlet在服务器启动时就创建。</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servletDemo的实现类&lt;/servlet-class&gt;
    &lt;!--使得当前servlet在服务器启动时创建--&gt;
    &lt;load-on-startup&gt;2&lt;/load-no-startup&gt;
&lt;/sevlet&gt;
</code></pre><p>四、Servlet的三种创建方式<br>4.1、实现javax.servlet.Servlet接口（参见：编写一个servlet程序：）</p>
<p>4.2、继承javax.servet.GenericServlet类(适配器模式)</p>
<pre><code>public class ServletDemo extends GenericServlet{
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;servletDemo&quot;);
    }
}
</code></pre><p>4.3、继承javax.servlet.http.HttpServlet类（模板方法设计模式）<br>(开发中常用方式)</p>
<pre><code>//不要重写父类的service方法
public class ServletDemo extends HttpServlet{
    protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;servletDemo doGet方法被调用&quot;);
    }
    protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{

    }
}
</code></pre><p>Servlet –&gt; GenericServlet –&gt; HttpServlet  (继承HttpServlet)<br>曾祖父     爷爷        爸爸     孙子</p>
<p>小技巧：使生成的servlet更清新一些<br>找到：MyEclipse\Common\plugins目录<br>把com.genuitec.eclipse.wizards_9.0.0.me201108091322.jar复制到上面目录<br>servet映射细节：<br>servet映射细节1：</p>
<pre><code>&lt;!--配置多个映射路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo3&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>servet映射细节2: 通配符<em> 代表任意字符串<br>url-pattern: </em>.do  以<em>.字符串的请求都可以访问 注：不要加/<br>url-pattern: /</em>  任意字符串都可以访问<br>url-pattern： /action/* 以/action开头的请求都可以访问<br>匹配规则：<br>优先级：从高到低<br>绝对匹配–&gt;  /开头匹配 –&gt; 扩展名方式匹配</p>
<p>如果url-pattern的值是/，表示执行默认映射。所有资源都是servlet</p>
<p>五、Servlet的线程安全<br>单实例：每次访问多线程<br>解决线程安全问题的最佳办法，不要写全局变量，而写局部变量。</p>
<p>六、Servlet获取配置信息<br>ServletConfig的使用<br>作用1：可以获取servlet配置信息<br>方式1：</p>
<pre><code>private ServletConfig config;
//使用初始化方法回复到ServletConfig对象，此对象由服务器创建
public void init(ServletConfig config) throws ServletException{
    this.config = config;
}

public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{
    String value = config.getInitParameter(&quot;encoding&quot;);//根据配置文件中的名，得到值
    System.out.println(value);
}
</code></pre><p>方式2：</p>
<pre><code>//通过使用继承父类的方法得到ServletConfig对象
String value = this.getServletConfig().getInitParameter(&quot;encoding&quot;);
System.out.println(value);
</code></pre><p>方式3：</p>
<pre><code>String value = this.getInitParameter(&quot;encoding&quot;);
System.out.println(value);
</code></pre><p>作用2：可以获得ServletContext对象</p>
<p>七、ServletContext（重要）<br>ServletContext: 代表的是整个应用。一个应用只有一个ServletContext对象。单实例。<br>作用：<br>域对象：在一定范围内（当前应用），使多个Servlet共享数据。<br>常用方法：<br>void setAttribute(String name,object value);//向ServletContext对象的map中添加数据<br>Object getAttribute(String name);//从ServletContext对象的map中取数据<br>void rmoveAttribute(String name);//根据name去移除数据</p>
<p>获取全局配置信息：</p>
<p>修改web.xml文件：</p>
<pre><code>&lt;!--配置当前应用的全局信息--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>String getInitParameter(String name) //根据配置文件中的key得到value</p>
<pre><code>//获取全局配置信息
String encoding = sc.getInitParameter(&quot;encoding&quot;);
System.out.println(encoding);
</code></pre><p>获取资源路径：<br>String  getRealPath(String path);//根据资源名称得到资源的绝对路径.<br>可以得到当前应用任何位置的任何资源。</p>
<p>实现Servlet的转发。</p>
<p> RequestDispatcher  getRequestDispatcher(String path) ;//参数表示要跳转到哪去</p>
<hr>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h4 id="题目1-在Servlet中实现请求转发"><a href="#题目1-在Servlet中实现请求转发" class="headerlink" title="题目1 在Servlet中实现请求转发"></a>题目1 在Servlet中实现请求转发</h4><pre><code>1.index.jsp
&lt;form action=&quot;forward&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

   2.forwardServlet.java
   public class ForwardServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);//设置请求的字符编码格式
        String name = request.getParameter(&quot;name&quot;);    //获得请求表单中的用户名
        String pwd = request.getParameter(&quot;pwd&quot;);//获得请求表单的密码
        if ((name != null &amp;&amp; !name.equals(&quot;&quot;))&amp;&amp; (pwd != null &amp;&amp; !pwd.equals(&quot;&quot;))) {
            if (name.equals(&quot;zhaoyanliang&quot;) &amp;&amp; pwd.equals(&quot;123&quot;)) {
                request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request,response);    //使用RequestDispatcher对象将页面请求转发到success.jsp页
            } else {
                request.getRequestDispatcher(&quot;error.jsp&quot;).forward(request,response);
            }
        }else {

        }
    }
}

3.web.xml
&lt;servlet&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;cn.itcast.servlet.ForwardServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/forward&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><hr>
<h4 id="题目2-在Servlet中处理表单提交的数据"><a href="#题目2-在Servlet中处理表单提交的数据" class="headerlink" title="题目2 在Servlet中处理表单提交的数据"></a>题目2 在Servlet中处理表单提交的数据</h4><pre><code>1.index.jsp
&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;性别：&lt;/td&gt;
               &lt;td&gt;
                   &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; /&gt;男
                   &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女
               &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;年龄：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;Email：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;
                   &lt;input type=&quot;submit&quot; value=&quot;注 册&quot; /&gt;
                   &lt;input type=&quot;reset&quot; value=&quot;重 置&quot; /&gt;
               &lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.LoginServlet.java
public class LoginServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;GBK&quot;);            //设置请求的字符编码格式
        String name = request.getParameter(&quot;name&quot;);        //获得用户名
        String pwd = request.getParameter(&quot;pwd&quot;);        //获得密码
        String sex = request.getParameter(&quot;sex&quot;);        //获得性别
        String age = request.getParameter(&quot;age&quot;);        //获得年龄
        String email = request.getParameter(&quot;email&quot;);    //获得Email
        request.getRequestDispatcher(&quot;logininfo.jsp&quot;).forward(request, response);
    }
}

3.logininfo.jsp
&lt;table align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;用户名：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;name&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;密码：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;pwd&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;性别：&lt;/td&gt;
        &lt;td&gt;
            &lt;%=request.getParameter(&quot;sex&quot;)%&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;年龄：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;age&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Email：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;email&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
   &lt;/table&gt;
</code></pre><hr>
<h4 id="题目3-在Servlet中实现页面重定向"><a href="#题目3-在Servlet中实现页面重定向" class="headerlink" title="题目3 在Servlet中实现页面重定向"></a>题目3 在Servlet中实现页面重定向</h4><pre><code>1.index.jsp
&lt;form action=&quot;redirect&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.RedirectServlet.java
public class RedirectServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);        //设置请求数据的字符编码格式
        String name = request.getParameter(&quot;name&quot;); //获得请求表单中的用户名
        String pwd = request.getParameter(&quot;pwd&quot;);    //获得请求表单中的密码
        if((name!=null&amp;&amp;!name.equals(&quot;&quot;))&amp;&amp;(pwd!=null&amp;&amp;!pwd.equals(&quot;&quot;))){
            if(name.equals(&quot;mr&quot;)&amp;&amp;pwd.equals(&quot;123&quot;)){
                //使用SendRedirect()方法将页面重定向到success.jsp
                response.sendRedirect(&quot;success.jsp&quot;);
            }else{
                //使用SendRedirect()方法将页面重定向到error.jsp
                response.sendRedirect(&quot;error.jsp&quot;);
            }
        }
    }
}
</code></pre><hr>
<h4 id="题目4-动态生成HTML文档"><a href="#题目4-动态生成HTML文档" class="headerlink" title="题目4 动态生成HTML文档"></a>题目4 动态生成HTML文档</h4><pre><code>public class ServletHTML extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        //设置响应的字符集格式为UTF-8
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        //设置响应正文的MIME类型
        response.setContentType(&quot;text/html&quot;);
        //返回一个PrintWriter对象，Servlet使用它来输出字符串形式的正文数据
        PrintWriter out = response.getWriter();
        //以下为输出的HTML正文数据
        out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;&quot;);
        out.println(&quot;&lt;HTML&gt;&quot;);
        out.println(&quot;&lt;HEAD&gt;&lt;TITLE&gt;动态生成HTML文档&lt;/TITLE&gt;&quot;);
        out.println(&quot;&lt;link rel=;stylesheet&apos; type=&apos;text/css&apos; href=&apos;css/style.css&apos;&gt;&quot;);
        out.println(&quot;&lt;/HEAD&gt;&quot;);
        out.println(&quot;&lt;BODY&gt;&quot;);
        out.println(&quot;&lt;table border=&apos;1&apos; align=&apos;center&apos;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&lt;td&gt;动态生成HTMl文档&lt;/td&gt;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&lt;td&gt;表格&lt;/td&gt;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;/BODY&gt;&quot;);
        out.println(&quot;&lt;/HTML&gt;&quot;);
        out.flush();
        out.close();
    }

}
</code></pre><hr>
<h4 id="题目5-在Servlet中向客户端写Cookie信息"><a href="#题目5-在Servlet中向客户端写Cookie信息" class="headerlink" title="题目5 在Servlet中向客户端写Cookie信息"></a>题目5 在Servlet中向客户端写Cookie信息</h4><pre><code>1.index.jsp
&lt;form action=&quot;cookieservlet&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;
               &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
               &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.CookieServlet.java
public class CookieServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);
        String name = request.getParameter(&quot;name&quot;);            // 获取用户名
        //创建一个Cookie对象，并将用户名保存到Cookie对象中
        Cookie nameCookie = new Cookie(&quot;userName&quot;, name);
        //设置Cookie过期之前的时间，单位为秒
        nameCookie.setMaxAge(60);
        //通过response的addCookie()方法将此Cookie对象保存到客户端浏览器的Cookie中
        response.addCookie(nameCookie);
        request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request, response);
    }
}

3.在index.jsp中读取所有客户端的Cookie，通过循环Cookie数组找到保存用户名的Cookie
&lt;%
      String userName=null;//用于保存从cookie中读取出的用户名
      Cookie cookieArr[] = request.getCookies();//获取客户端的所有Cookie
      if(cookieArr!=null&amp;&amp;cookieArr.length&gt;0){
          for(Cookie c:cookieArr){
              if(c.getName().equals(&quot;userName&quot;)){ //如果Cookie中有一个名为
                                                           userName的Cookie
                  userName =c.getValue();            //获得此cookie的值 
              }
          }
      }
%&gt;   

4.将获取到的用户名Cookie的值赋值给用户名文本框
&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&lt;%if(userName!=null){out.print(userName);}%&gt;&quot;/&gt;
</code></pre><blockquote>
<p>注意：在创建Cookie对象时，由于不可以直接将中文字符作为Cookie的值，因此在将中文字符保存到Cookie对象之前，应该使用java.net.URLEncoder类的encode()方法对中文字符进行编码。在获取该Cookie对象中的值时，需要使用java.net.URLDecoder类的decode()方法对已经编码过的字符进行解码，还原字符串的初始值。</p>
</blockquote>
<hr>

      
    </div>
    
    
    
    
    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Servlet</a></p>
  <p><span>文章作者:</span>Bangjin-Hu</a></p>
  <p><span>发布时间:</span>2019年10月15日 - 09:22:26</p>
  <p><span>最后更新:</span>2020年03月29日 - 10:48:38</p>
  <p><span>原始链接:</span><a href="/undefined/Servlet/" title="Servlet">http://bangjinhu.github.io/undefined/Servlet/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://bangjinhu.github.io/undefined/Servlet/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

      
    </div>
    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="Bangjin-Hu wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎扫码关注微信公众号，订阅我的微信公众号.</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持是我创作的动力.</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat-reward-img.jpg" alt="Bangjin-Hu 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay-reward-img.jpg" alt="Bangjin-Hu 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Bangjin-Hu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://bangjinhu.github.io/undefined/Servlet/" title="Servlet">http://bangjinhu.github.io/undefined/Servlet/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Servlet/" rel="tag"><i class="fa fa-tag"></i> Servlet</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/undefined/Java 核心技术36讲 重点/" rel="next" title="Java核心技术36讲">
                <i class="fa fa-chevron-left"></i> Java核心技术36讲
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/undefined/Redis/" rel="prev" title="Redis">
                Redis <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">242</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.avantv.cn" target="_blank" title="AVANTV">
                      
                        <i class="fa fa-fw fa-user"></i>AVANTV</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet"><span class="nav-text">Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期相关方法-life-cycle-methods"><span class="nav-text">生命周期相关方法(life-cycle methods)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手动编写第一个servlet"><span class="nav-text">手动编写第一个servlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#servlet的调用过程和生命周期"><span class="nav-text">servlet的调用过程和生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#servlet的开发细节"><span class="nav-text">servlet的开发细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServletContext"><span class="nav-text">ServletContext</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-text">参考链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#掌握Servlet程序编写"><span class="nav-text">掌握Servlet程序编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpServletResponse-HttpServletRequest-关键：了解HTTP协议"><span class="nav-text">HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet技术"><span class="nav-text">Servlet技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet-基本训练"><span class="nav-text">Servlet 基本训练</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#案例："><span class="nav-text">案例：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目1-在Servlet中实现请求转发"><span class="nav-text">题目1 在Servlet中实现请求转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目2-在Servlet中处理表单提交的数据"><span class="nav-text">题目2 在Servlet中处理表单提交的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目3-在Servlet中实现页面重定向"><span class="nav-text">题目3 在Servlet中实现页面重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目4-动态生成HTML文档"><span class="nav-text">题目4 动态生成HTML文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目5-在Servlet中向客户端写Cookie信息"><span class="nav-text">题目5 在Servlet中向客户端写Cookie信息</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">465.0k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
