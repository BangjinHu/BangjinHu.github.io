<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java集合," />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="注意：所有文章除特别说明外，转载请注明出处. HashMap源码解析[TOC] 1. 默认属性">
<meta name="keywords" content="Java集合">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码解析">
<meta property="og:url" content="http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="注意：所有文章除特别说明外，转载请注明出处. HashMap源码解析[TOC] 1. 默认属性">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://bangjinhu.github.io/undefined/Java集合框架%20HashMap源码解析/images/1.png">
<meta property="og:updated_time" content="2020-03-30T00:12:02.802Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap源码解析">
<meta name="twitter:description" content="注意：所有文章除特别说明外，转载请注明出处. HashMap源码解析[TOC] 1. 默认属性">
<meta name="twitter:image" content="http://bangjinhu.github.io/undefined/Java集合框架%20HashMap源码解析/images/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/"/>





  <title>HashMap源码解析 | BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">HashMap源码解析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-30T08:12:02+08:00">
                2020-03-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java集合/" itemprop="url" rel="index">
                    <span itemprop="name">Java集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,843
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h2><p>[TOC]</p>
<h3 id="1-默认属性"><a href="#1-默认属性" class="headerlink" title="1. 默认属性"></a>1. 默认属性</h3><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">//默认初始容量 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大值 2^30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认扩容因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//转为红黑树的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;<span class="comment">//由树转换为链表的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//默认的树存在的最小数组长度 此长度最少是TREEIFY_THRESHOLD的四倍（注释之中说的很清楚）</span></span><br></pre></td></tr></table></figure>
<h3 id="2-put方法"><a href="#2-put方法" class="headerlink" title="2. put方法"></a>2. put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//hashcode是32位的，无符号右移16位，那生成的就是16位0加原高位的16位值， 就是对半了，异或计算也就变成</span></span><br><span class="line"><span class="comment">//了高16位和低16位进行异或，原高16位不变。这么干主要用于当hashmap 数组比较小的时候所有二进制都参与运</span></span><br><span class="line"><span class="comment">//算了，防止hash冲突太大，</span></span><br></pre></td></tr></table></figure>
<h4 id="putval-添加-方法"><a href="#putval-添加-方法" class="headerlink" title="==putval(添加)方法=="></a>==putval(添加)方法==</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果存储元素的table为空，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">///这里的resize  是初始化的时候调用 后面会讲</span></span><br><span class="line">            n = (tab = resize()).length;    <span class="comment">// 获取默认长度（16）</span></span><br><span class="line">    	<span class="comment">//p = tab[i = (n - 1) &amp; hash] 获取要插入的元素在hash桶中的位置</span></span><br><span class="line">        <span class="comment">// 如果根据hash值获取的结点为空（这个位置没有节点）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)      <span class="comment">// 此处 &amp; 代替了 %（效率更高）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//则直接新建一个结点</span></span><br><span class="line">        <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果有节点</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果新插入的结点和table中p结点的hash值，key值相同的话</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;<span class="comment">//则进行覆盖</span></span><br><span class="line">            <span class="comment">// 如果是红黑树结点的话，进行红黑树插入（上次分享了红黑树）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//定位到这个hash桶了 但是这里面是链表（没有进行过树化）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 如果p节点的next为空 直接在后面插入(代表这个单链表只有一个头部结点)</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//插入完成之后再次判断是否要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">//转换为红黑树</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">////如果下一个节点e 不为null 并且这个链表中的节点就是你要找的节点 终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 及时更新p 保证p是最后一个</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果存在这个映射就覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 判断是否允许覆盖，并且value是否为空、</span></span><br><span class="line">                <span class="comment">//onlyIfAbsent 如果为true，不更改现有值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);     <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 执行到这里，说明是增加了新的元素，而不是替换了老的元素，所以相关计数需要累加</span></span><br><span class="line">        ++modCount;     <span class="comment">// 更改操作次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)     <span class="comment">// 大于临界值</span></span><br><span class="line">            <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">            <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">            resize();  </span><br><span class="line">        <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回空</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="PUT方法的流程："><a href="#PUT方法的流程：" class="headerlink" title="==PUT方法的流程：=="></a>==PUT方法的流程：==</h5><ul>
<li><strong>1、如果未被初始化，则初始化</strong></li>
<li><strong>2、根据KEY求Hash值，然后计算下标。</strong></li>
<li><strong>3、如果没有碰撞直接放入bucket中。</strong></li>
<li><strong>4、如果碰撞了，则以链表的方式连接到后面。</strong></li>
<li><strong>5、如果链表长度大于 8，则调转换为红黑树的方法</strong></li>
<li><strong>6、如果树节点个数低于 6，则调转换链表的方法</strong></li>
<li><strong>7、如果节点已经存在则直接替换</strong></li>
<li><strong>8、如果超过了阈值，则进行扩容</strong></li>
</ul>
<h4 id="resize-扩容-方法"><a href="#resize-扩容-方法" class="headerlink" title="resize(扩容)方法"></a>resize(扩容)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化或者扩容之后元素调整</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧元素数组的各种信息</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//如果你是新创建的话 表的大小就是0 否则就是原来的大小</span></span><br><span class="line">        <span class="comment">//第一次是为0的 代表 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;就是16</span></span><br><span class="line">        <span class="comment">// 老的扩容阀值设置</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新数组的长度及扩容的临界值（都初始化为0）</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;   <span class="comment">// 如果原table不为空</span></span><br><span class="line">            <span class="comment">// 如果数组元素个数大于等于限定的最大容量（2的30次方）</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 扩容阀值设置为int最大值（2的31次方 -1 ），因为oldCap再乘2就溢出了</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//直接返回</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）newCap = oldCap &lt;&lt; 1 相当于*2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//并且旧的容量大于默认的初始化大小16</span></span><br><span class="line">                <span class="comment">// 新的扩容阈值 = 旧的扩容阈值 * 2 </span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">            newCap = oldThr;<span class="comment">//如果旧的扩容本来就大于0，那么新的容量就是旧的扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// threshold（旧的扩容）为0，则使用默认值</span></span><br><span class="line">            <span class="comment">// 能运行到这里的话，说明是调用无参构造函数创建的该map，并且第一次添加元素</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//16 </span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//0.75*16=12</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  <span class="comment">// 如果阈值值还为0，则设置临界值</span></span><br><span class="line">            <span class="comment">//计算得到新的阙值</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//新的阙值 =  如果新的容量&lt;最大的容量 并且 新的阈值&lt;最大的容量 ，那么新的阙值 = 计算的             //否则=最大int</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr; <span class="comment">//阙值 = 新的阙值(更新阈值)</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    		<span class="comment">////创建一个新的哈希数组桶 大小为新的容量</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;   <span class="comment">// 调整数组大小之后，需要调整红黑树或者链表的指向</span></span><br><span class="line">            <span class="comment">//遍历旧的hash桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//如果旧的hash桶的元素不为null  e为旧的hash桶的元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;<span class="comment">//旧的hash桶设置为null(主要为了使得数组可被回收)</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果你是一个元素</span></span><br><span class="line">                        <span class="comment">//那么在新的hash桶中给你安排一个位置  </span></span><br><span class="line">                        <span class="comment">//位置是你的hash值 &amp; 新的桶的容量-1（再次分配位置） </span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 	<span class="comment">//如果你不只一个元素并且是TreeNode</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//调用split方法</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//如果你是普通的链表</span></span><br><span class="line">                        <span class="comment">// 链表调整</span></span><br><span class="line">                        <span class="comment">// 按命名来翻译的话，应该叫低位首尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 按命名来翻译的话，应该叫高位首尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//以上的低位指的是新数组的 0 到 oldCap-1 、高位指定的是oldCap 到 newCap - 1</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//看是否需要进行位置变化 新增位的值 不需要变化就放在原来的位置</span></span><br><span class="line">                            <span class="comment">//如果hash值和老的长度做与运算，结果为0，那么该hash值再和新数组的长度取摸的话值也不会放生变化，所以该元素的在新数组的位置和在老数组的位置是相同的，所以该元素可以放置在低位链表中。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// 如果没有尾，说明链表为空</span></span><br><span class="line">                                    loHead = e;<span class="comment">// 链表为空时，头节点指向该元素</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 如果有尾，那么链表不为空，把该元素挂到链表的最后。</span></span><br><span class="line">                                    loTail.next = e; </span><br><span class="line">                                loTail = e;<span class="comment">// 把尾节点设置为当前元素</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果与运算结果不为0，说明hash值大于老数组长度（例如hash值为17）</span></span><br><span class="line">                            <span class="comment">// 此时该元素应该放置到新数组的高位位置上</span></span><br><span class="line">                            <span class="comment">//例：老数组长度16，那么新数组长度为32，hash为17的应该放置在数组的第17个位置上，也就是下标为16，那么下标为16已经属于高位了，低位是[0-15]，高位是[16-31]</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//需要变化 就构建高位放置的链表</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">// 如果没有尾，说明链表为空</span></span><br><span class="line">                                    hiHead = e;<span class="comment">// 链表为空时，头节点指向该元素</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 如果有尾，那么链表不为空，把该元素挂到链表的最后</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;<span class="comment">// 把尾节点设置为当前元素</span></span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">// 低位的元素组成的链表还是放置在原来的位置</span></span><br><span class="line">                            </span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;<span class="comment">//赋值 （原来位置</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高位的元素组成的链表放置的位置只是在原有位置上偏移了老数组的长度个位置</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             <span class="comment">// 销毁实例，等待GC回收</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// 例：hash为 17 在老数组放置在0下标，在新数组放置在16下标；                                   //hash为 18 在老数组放置在1下标，在新数组放置在17下标； </span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新的数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 总结一下</span></span><br><span class="line"><span class="comment"> *  1、如果你是新创建的话 旧的表的大小就是0 否则就是原来的大小</span></span><br><span class="line"><span class="comment"> *  2、 如果原table不为空且数组元素个数大于等于限定的最大容量（2的30次方），扩容阀值设置为int最大值</span></span><br><span class="line"><span class="comment"> *    直接返回。</span></span><br><span class="line"><span class="comment"> *  3、新的表的大小等于旧的乘2,如果其大小小于最大容量，并且旧的容量大于默认的初始化大小16，</span></span><br><span class="line"><span class="comment"> *     新的扩容阈值 = 旧的扩容阈值 * 2 </span></span><br><span class="line"><span class="comment"> *  4、如果是是调用无参构造函数创建的该map，并且第一次添加元素，给附上初始值16</span></span><br><span class="line"><span class="comment"> *  5、如果阈值值还为0，则设置临界值：新的阙值 =  如果新的容量&lt;最大的容量 并且 新的阈值&lt;最大的容量</span></span><br><span class="line"><span class="comment"> *     那么新的阙值 = 计算的  否则=最大int</span></span><br><span class="line"><span class="comment"> *  6、创建一个新的哈希数组桶 大小为新的容量，然后遍历旧的哈希桶</span></span><br><span class="line"><span class="comment"> *  7、如果旧的hash桶的元素不为null，旧的hash桶设置为null(主要为了使得数组可被回收)这里已经用e接收了</span></span><br><span class="line"><span class="comment"> *  8、如果你是一个元素，那么在新的hash桶中给你安排一个位置，</span></span><br><span class="line"><span class="comment"> *	   位置是你的hash值 &amp; 新的桶的容量-1（再次分配位置）</span></span><br><span class="line"><span class="comment"> *  9、如果你不只一个元素并且是TreeNode,那么调用split方法，进行树的修剪</span></span><br><span class="line"><span class="comment"> *  10、如果你是一个普通链表，且(e.hash &amp; oldCap) == 0，则挂到低位链，否则挂到高位链</span></span><br><span class="line"><span class="comment"> *  11、如果链表上存在元素，则尾插。</span></span><br><span class="line"><span class="comment"> *  12、把老数组赋空，便于GC回收。</span></span><br><span class="line"><span class="comment"> *  13、高位的元素组成的链表放置的位置只是在原有位置上偏移了老数组的长度个位置</span></span><br><span class="line"><span class="comment"> 		例：hash为 17 在老数组放置在0下标，在新数组放置在16下标；                                   	//hash为 18 在老数组放置在1下标，在新数组放置在17下标； </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="split-红黑树修剪-方法"><a href="#split-红黑树修剪-方法" class="headerlink" title="split(红黑树修剪)方法"></a><strong>split</strong>(红黑树修剪)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">上述方法在resize()过程中被调用 </span><br><span class="line">和链表的修剪差不多（再次操作看看是否要再次保留红黑树）</span><br><span class="line">目的是将树的数据重新散列到数组中</span><br><span class="line"><span class="comment">//被调用的代码 split(当前hash表，新的哈希桶，要分割的元素的下标，旧的容量) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;<span class="comment">//这里的this :    e = oldTab[j] 上下文中的代码</span></span><br><span class="line">            </span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//低位的头和低位的尾</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//高位的头和高位的尾</span></span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>; <span class="comment">//地位和高位的2个计数器</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;<span class="comment">//获取下一个节点</span></span><br><span class="line">                e.next = <span class="keyword">null</span>;<span class="comment">//设置为null</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果 e.hash 与 原来旧的容量 &amp; 为 0 说明不需要进行移动位置  </span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;<span class="comment">//将e 复制给头</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//如果尾巴不为null 尾巴的next 为 e</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;<span class="comment">//将e 作为新的尾巴</span></span><br><span class="line">                    ++lc;<span class="comment">//次数 + 1 </span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)<span class="comment">//否则需要移动位置</span></span><br><span class="line">                        hiHead = e;<span class="comment">//高位的链表和低位一样</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123; <span class="comment">//如果有链表</span></span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<span class="comment">//如果长度 &lt;= 6  </span></span><br><span class="line">                <span class="comment">//取消树化 将这个树里面的链表结构变成普通的链表结构</span></span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead; <span class="comment">//否则将地位复制给原来的下标</span></span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);<span class="comment">//进行树化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);<span class="comment">//进行了移位 位置偏移 下标 + 原来的容器大小</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="untreeify-非树化-方法"><a href="#untreeify-非树化-方法" class="headerlink" title="untreeify(非树化)方法"></a>untreeify(非树化)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果链表的长度 &lt;= UNTREEIFY_THRESHOLD(<span class="number">6</span>) 就进行非树化，否则就进行树化。</span><br><span class="line">这里的非树化就是将TreeNode转换成Node</span><br><span class="line">		<span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">            <span class="comment">//将q转换成普通的Nod return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span></span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p; <span class="comment">//头为p</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;<span class="comment">//返回这个链表</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeifyBin-树化-方法"><a href="#treeifyBin-树化-方法" class="headerlink" title="treeifyBin(树化)方法"></a>treeifyBin(树化)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">treeifyBin方法，应该可以解释为：把容器里的元素变成树结构   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tab：元素数组，</span></span><br><span class="line"><span class="comment"> * hash：hash值（要增加的键值对的key的hash值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果元素数组为空 或者 数组长度小于 树结构化的最小限制</span></span><br><span class="line"><span class="comment">     * MIN_TREEIFY_CAPACITY 默认值64，对于这个值可以理解为：如果元素数组长度小于这个值，没有必要去进行结构转换</span></span><br><span class="line"><span class="comment">     * 当一个数组位置上集中了多个键值对，那是因为这些key的hash值和数组长度取模之后结果相同。（并不是因为这些key的hash值相同）</span></span><br><span class="line"><span class="comment">     * 因为hash值相同的概率不高，所以可以通过扩容的方式，来使得最终这些key的hash值在和新的数组长度取模之后，拆分到多个数组位置上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize(); <span class="comment">// 扩容，可参见resize方法解析</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果元素数组长度已经大于等于了 MIN_TREEIFY_CAPACITY，那么就有必要进行结构转换了</span></span><br><span class="line">    <span class="comment">// 根据hash值和数组长度进行取模运算后，得到链表的首节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">// 定义首、尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// 将该节点转换为 树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">// 如果尾节点为空，说明还没有根节点</span></span><br><span class="line">                hd = p; <span class="comment">// 首节点（根节点）指向 当前节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 尾节点不为空，以下两行是一个双向链表结构</span></span><br><span class="line">                p.prev = tl; <span class="comment">// 当前树节点的 前一个节点指向 尾节点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 尾节点的 后一个节点指向 当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p; <span class="comment">// 把当前节点设为尾节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 继续遍历链表</span></span><br><span class="line">        <span class="comment">// 到目前为止 也只是把Node对象转换成了TreeNode对象，把单向链表转换成了双向链表</span></span><br><span class="line">        <span class="comment">// 把转换后的双向链表，替换原来位置上的单向链表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">//此处单独解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeify-打头树化-方法"><a href="#treeify-打头树化-方法" class="headerlink" title="treeify(打头树化)方法"></a>treeify(打头树化)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为HashMap的元素数组,</span></span><br><span class="line"><span class="comment"> * treeify方法是TreeNode类的一个实例方法，通过TreeNode对象调用，实现该对象打头的链表转换为树结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; <span class="comment">// 定义树的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123; <span class="comment">// 遍历链表，x指向当前节点、next指向下一个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>; <span class="comment">// 设置当前节点的左右节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果还没有根节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>; <span class="comment">// 当前节点的父节点设为空</span></span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">// 当前节点的红色属性设为false（把当前节点设为黑色）</span></span><br><span class="line">            root = x; <span class="comment">// 根节点指向到当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果已经存在根节点了</span></span><br><span class="line">            K k = x.key; <span class="comment">// 取得当前链表节点的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash; <span class="comment">// 取得当前链表节点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 定义key所属的Class</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span></span><br><span class="line">                <span class="comment">// GOTO1</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph; <span class="comment">// dir 标识方向（左右）、ph标识当前树节点的hash值</span></span><br><span class="line">                K pk = p.key; <span class="comment">// 当前树节点的key</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前树节点hash值 大于 当前链表节点的hash值</span></span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识当前链表节点会放到当前树节点的左侧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>; <span class="comment">// 右侧</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果两个节点的key的hash值相等，那么还要通过其他方式再进行比较</span></span><br><span class="line"><span class="comment">                 * 如果当前链表节点的key实现了comparable接口，并且当前树节点和链表节点是相同Class的实例，那么通过comparable的方式再比较两者。</span></span><br><span class="line"><span class="comment">                 * 如果还是相等，最后再通过tieBreakOrder比较一次</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 保存当前树节点</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果dir 小于等于0 ： 当前链表节点一定放置在当前树节点的左侧，但不一定是该树节点的左孩子，也可能是左孩子的右孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果dir 大于0 ： 当前链表节点一定放置在当前树节点的右侧，但不一定是该树节点的右孩子，也可能是右孩子的左孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩子 为 起始节点  再从GOTO1 处开始 重新寻找自己（当前链表节点）的位置</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂载到当前树节点的左或者右侧了。</span></span><br><span class="line"><span class="comment">                 * 挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点进行处理了。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 当前链表节点 作为 当前树节点的子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 作为左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// 作为右孩子</span></span><br><span class="line">                    root = balanceInsertion(root, x); <span class="comment">// 重新平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把所有的链表节点都遍历完之后，最终构造出来的树可能经历多个平衡操作，根节点目前到底是链表的哪一个节点是不确定的</span></span><br><span class="line">    <span class="comment">// 因为我们要基于树来做查找，所以就应该把 tab[N] 得到的对象一定根节点对象，而目前只是链表的第一个节点对象，所以要做相应的处理。</span></span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">// 单独解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="moveRootToFront-保证根节点-方法"><a href="#moveRootToFront-保证根节点-方法" class="headerlink" title="moveRootToFront(保证根节点)方法"></a>moveRootToFront(保证根节点)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把红黑树的根节点设为  其所在的数组槽 的第一个元素</span></span><br><span class="line"><span class="comment"> * 首先明确：TreeNode既是一个红黑树结构，也是一个双链表结构</span></span><br><span class="line"><span class="comment"> * 这个方法里做的事情，就是保证树的根节点一定也要成为链表的首节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// 根节点不为空 并且 HashMap的元素数组不为空</span></span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash; <span class="comment">// 根据根节点的Hash值 和 HashMap的元素数组长度  取得根节点在数组中的位置</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; <span class="comment">// 首先取得该位置上的第一个节点对象</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123; <span class="comment">// 如果该节点对象 与 根节点对象 不同</span></span><br><span class="line">            Node&lt;K,V&gt; rn; <span class="comment">// 定义根节点的后一个节点</span></span><br><span class="line">            tab[index] = root; <span class="comment">// 把元素数组index位置的元素替换为根节点对象</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">// 获取根节点对象的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">// 如果后节点不为空 </span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp; <span class="comment">// root后节点的前节点  指向到 root的前节点，相当于把root从链表中摘除</span></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>) <span class="comment">// 如果root的前节点不为空</span></span><br><span class="line">                rp.next = rn; <span class="comment">// root前节点的后节点 指向到 root的后节点</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 如果数组该位置上原来的元素不为空</span></span><br><span class="line">                first.prev = root; <span class="comment">// 这个原有的元素的 前节点 指向到 root，相当于root目前位于链表的首位</span></span><br><span class="line">            root.next = first; <span class="comment">// 原来的第一个节点现在作为root的下一个节点，变成了第二个节点</span></span><br><span class="line">            root.prev = <span class="keyword">null</span>; <span class="comment">// 首节点没有前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这一步是防御性的编程</span></span><br><span class="line"><span class="comment">         * 校验TreeNode对象是否满足红黑树和双链表的特性</span></span><br><span class="line"><span class="comment">         * 如果这个方法校验不通过：可能是因为用户编程失误，破坏了结构（例如：并发场景下）；也可能是TreeNode的实现有问题（这个是理论上的以防万一）；</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="putTreeVal-树的添加节点-方法"><a href="#putTreeVal-树的添加节点-方法" class="headerlink" title="putTreeVal(树的添加节点)方法"></a>putTreeVal(树的添加节点)方法</h4><p>​    当同一个位置上链表中的元素达到8个的时候，就会再将这些元素构建成一个红黑树（参见：treeifyBin方法分析），同时把==原来的单链表结构变成了双链表结构==，也就是这些==元素即维持着红黑树的结构又维持着双链表的结构==。当第9个相同hash值的键值对put过来时，发现该位置已经是一个树节点了，那么就会调用putTreeVal方法，将这个新的值设置到指定的key上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当存在hash碰撞的时候，且元素数量大于8个时候，就会以红黑树的方式将这些元素组织起来</span></span><br><span class="line"><span class="comment"> * map 当前节点所在的HashMap对象</span></span><br><span class="line"><span class="comment"> * tab 当前HashMap对象的元素数组</span></span><br><span class="line"><span class="comment"> * h   指定key的hash值</span></span><br><span class="line"><span class="comment"> * k   指定key</span></span><br><span class="line"><span class="comment"> * v   指定key上要写入的值</span></span><br><span class="line"><span class="comment"> * 返回：指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 定义k的Class对象</span></span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>; <span class="comment">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>; <span class="comment">// 父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点开始遍历，没有终止条件，只能从内部退出</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk; <span class="comment">// 声明方向、当前节点hash值、当前节点的键对象</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前节点hash 大于 指定key的hash值</span></span><br><span class="line">            dir = -<span class="number">1</span>; <span class="comment">// 要添加的元素应该放置在当前节点的左侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">// 如果当前节点hash 小于 指定key的hash值</span></span><br><span class="line">            dir = <span class="number">1</span>; <span class="comment">// 要添加的元素应该放置在当前节点的右侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">// 如果当前节点的键对象 和 指定key对象相同</span></span><br><span class="line">            <span class="keyword">return</span> p; <span class="comment">// 那么就返回当前节点对象，在外层方法会对v进行写入</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class="line"><span class="comment">             * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点</span></span><br><span class="line"><span class="comment">             * 如果得到了键的equals相等的的节点就返回</span></span><br><span class="line"><span class="comment">             * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123; <span class="comment">// 如果还没有比对过当前节点的所有子节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch; <span class="comment">// 定义要返回的节点、和子节点</span></span><br><span class="line">                searched = <span class="keyword">true</span>; <span class="comment">// 标识已经遍历过一次了</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了</span></span><br><span class="line"><span class="comment">                 * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了</span></span><br><span class="line"><span class="comment">                 * find 方法内部还会有递归调用。参见：find方法解析</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q; <span class="comment">// 找到了指定key键对应的</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点</span></span><br><span class="line">            dir = tieBreakOrder(k, pk); <span class="comment">// 再比较一下当前节点键和指定key键的大小</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 定义xp指向当前节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果dir小于等于0，那么看当前节点的左节点是否为空，如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">        * 如果dir大于等于0，那么看当前节点的右节点是否为空，如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">        * 如果以上两条当中有一个子节点不为空，这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next; <span class="comment">// 获取当前节点的next节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); <span class="comment">// 创建一个新的树节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;  <span class="comment">// 左孩子指向到这个新的树节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x; <span class="comment">// 右孩子指向到这个新的树节点</span></span><br><span class="line">            xp.next = x; <span class="comment">// 链表中的next节点指向到这个新的树节点</span></span><br><span class="line">            x.parent = x.prev = xp; <span class="comment">// 这个新的树节点的父节点、前节点均设置为 当前的树节点</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>) <span class="comment">// 如果原来的next节点不为空</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x; <span class="comment">// 那么原来的next节点的前节点指向到新的树节点</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));<span class="comment">// 重新平衡，以及新的根节点置顶</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回空，意味着产生了一个新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="balanceInsertion-树的平衡-方法"><a href="#balanceInsertion-树的平衡-方法" class="headerlink" title="balanceInsertion(树的平衡)方法"></a>balanceInsertion(树的平衡)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">红黑树插入节点后，需要重新平衡</span><br><span class="line"> root 当前根节点</span><br><span class="line"> x 新插入的节点</span><br><span class="line"> 返回重新平衡后的根节点</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>; <span class="comment">// 新插入的节点标为红色</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这一步即定义了变量，又开起了循环，循环没有控制条件，只能从内部跳出</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点、xpp：爷爷节点、xppl：左叔叔节点、xppr：右叔叔节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// L1</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 父节点不为空</span></span><br><span class="line">        <span class="comment">// 如果父节点为黑色 或者 【（父节点为红色 但是 爷爷节点为空） -&gt; 这种情况何时出现？】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) <span class="comment">// L2</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">// 如果父节点是爷爷节点的左孩子  // L3</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">// 如果右叔叔不为空 并且 为红色  // L3_1</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>; <span class="comment">// 右叔叔置为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 运行到这里之后，就又会进行下一轮的循环了，将爷爷节点当做处理的起始节点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果右叔叔为空 或者 为黑色 // L3_2</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">// 如果当前节点是父节点的右孩子 // L3_2_1</span></span><br><span class="line">                    root = rotateLeft(root, x = xp); <span class="comment">// 父节点左旋，见下文左旋方法解析</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// 获取爷爷节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果父节点不为空 // L3_2_2</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点 置为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; <span class="comment">// 爷爷节点不为空</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为 红色</span></span><br><span class="line">                        root = rotateRight(root, xpp);  <span class="comment">//爷爷节点右旋，见下文右旋方法解析</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果父节点是爷爷节点的右孩子 // L4</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123; <span class="comment">// 如果左叔叔是红色 // L4_1</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>; <span class="comment">// 左叔叔置为 黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 运行到这里之后，就又会进行下一轮的循环了，将爷爷节点当做处理的起始节点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果左叔叔为空或者是黑色 // L4_2</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">// 如果当前节点是个左孩子 // L4_2_1</span></span><br><span class="line">                    root = rotateRight(root, x = xp); <span class="comment">// 针对父节点做右旋，见下文右旋方法解析</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// 获取爷爷节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果父节点不为空 // L4_2_4</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; <span class="comment">//如果爷爷节点不为空</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为红色</span></span><br><span class="line">                        root = rotateLeft(root, xpp); <span class="comment">// 针对爷爷节点做左旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点左旋</span></span><br><span class="line"><span class="comment"> * root 根节点</span></span><br><span class="line"><span class="comment"> * p 要左旋的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123; <span class="comment">// 要左旋的节点以及要左旋的节点的右孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>) <span class="comment">// 要左旋的节点的右孩子的左节点 赋给 要左旋的节点的右孩子 节点为：rl</span></span><br><span class="line">            rl.parent = p; <span class="comment">// 设置rl和要左旋的节点的父子关系【之前只是爹认了孩子，孩子还没有答应，这一步孩子也认了爹】</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要左旋的节点的右孩子的父节点  指向 要左旋的节点的父节点，相当于右孩子提升了一层，</span></span><br><span class="line">        <span class="comment">// 此时如果父节点为空， 说明r 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>) </span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) <span class="comment">// 如果父节点不为空 并且 要左旋的节点是个左孩子</span></span><br><span class="line">            pp.left = r; <span class="comment">// 设置r和父节点的父子关系【之前只是孩子认了爹，爹还没有答应，这一步爹也认了孩子】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 要左旋的节点是个右孩子</span></span><br><span class="line">            pp.right = r; </span><br><span class="line">        r.left = p; <span class="comment">// 要左旋的节点  作为 他的右孩子的左节点</span></span><br><span class="line">        p.parent = r; <span class="comment">// 要左旋的节点的右孩子  作为  他的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点右旋</span></span><br><span class="line"><span class="comment"> * root 根节点</span></span><br><span class="line"><span class="comment"> * p 要右旋的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123; <span class="comment">// 要右旋的节点不为空以及要右旋的节点的左孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>) <span class="comment">// 要右旋的节点的左孩子的右节点 赋给 要右旋节点的左孩子 节点为：lr</span></span><br><span class="line">            lr.parent = p; <span class="comment">// 设置lr和要右旋的节点的父子关系【之前只是爹认了孩子，孩子还没有答应，这一步孩子也认了爹】</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要右旋的节点的左孩子的父节点  指向 要右旋的节点的父节点，相当于左孩子提升了一层，</span></span><br><span class="line">        <span class="comment">// 此时如果父节点为空， 说明l 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>) </span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p) <span class="comment">// 如果父节点不为空 并且 要右旋的节点是个右孩子</span></span><br><span class="line">            pp.right = l; <span class="comment">// 设置l和父节点的父子关系【之前只是孩子认了爹，爹还没有答应，这一步爹也认了孩子】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 要右旋的节点是个左孩子</span></span><br><span class="line">            pp.left = l; <span class="comment">// 同上</span></span><br><span class="line">        l.right = p; <span class="comment">// 要右旋的节点 作为 他左孩子的右节点</span></span><br><span class="line">        p.parent = l; <span class="comment">// 要右旋的节点的父节点 指向 他的左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>​     ConcurrentHashMap是Java并发包中提供的一个<strong>线程安全且高效</strong>的HashMap实现。<strong>==ConcurrentHashMap不允许key或value为null值==。</strong></p>
<h3 id="2-为什么HashMap用于多线程会出错？："><a href="#2-为什么HashMap用于多线程会出错？：" class="headerlink" title="2.为什么HashMap用于多线程会出错？："></a>2.为什么HashMap用于多线程会出错？：</h3><p>​             JDK1.7 的 HashMap在高并发环境下会形成<strong>环状链表</strong>，导致get操作时，进入死循环，所以，在并发环境中使用HashMap是非常危险的。</p>
<h3 id="3-为什么不用Hashtable？"><a href="#3-为什么不用Hashtable？" class="headerlink" title="3.为什么不用Hashtable？"></a>3.为什么不用Hashtable？</h3><p>​       HashTable线程安全的策略实现代价却太大了，简单粗暴，<strong>get/put</strong>所有相关操作都是synchronized<strong>的</strong>，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并<strong>发场景中性能就会非常差</strong>。</p>
<h3 id="4、ConcurrentHashMap-java7-中的实现方式"><a href="#4、ConcurrentHashMap-java7-中的实现方式" class="headerlink" title="4、ConcurrentHashMap java7 中的实现方式"></a>4、ConcurrentHashMap java7 中的实现方式</h3><p><img src="images/1.png" alt=""></p>
<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的==”分段锁”==思想。</p>
<h4 id="4-1-java7中的优缺点"><a href="#4-1-java7中的优缺点" class="headerlink" title="4.1 java7中的优缺点"></a>4.1 java7中的优缺点</h4><p>​    ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个==Segment==数组。每个段其实==就是一个小的Hashtable==，它们有自己的锁。==只要多个修改操作发生在不同的段上，它们就可以并发进行。（JDK7中是这样实现的）==</p>
<p>​    ==但是！！！==有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁.</p>
<p>​    所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</p>
<h3 id="ConcurrentHashMap-java8-中的实现"><a href="#ConcurrentHashMap-java8-中的实现" class="headerlink" title="ConcurrentHashMap java8 中的实现"></a>ConcurrentHashMap java8 中的实现</h3><h4 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h4><p>​    JDK8：ConcurrentHashMap在JDK8中进行了巨大改动，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用==CAS==算法。</p>
<h4 id="2、什么是volatille关键字？"><a href="#2、什么是volatille关键字？" class="headerlink" title="2、什么是volatille关键字？"></a>2、什么是volatille关键字？</h4><p>volatile是一种轻量级的同步机制，它主要有两个特性：</p>
<p>一是保证共享变量对所有线程的可见性；（==内存可见性==）</p>
<p>二是禁止指令重排序优化。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像<strong>num++这种复合操作（读写存）</strong>，volatile无法保证其原子性。</p>
<h4 id="3、重要属性"><a href="#3、重要属性" class="headerlink" title="==3、重要属性=="></a>==3、重要属性==</h4><h5 id="3-1-sizeCtl"><a href="#3-1-sizeCtl" class="headerlink" title="3.1 sizeCtl"></a>3.1 sizeCtl</h5><p>​    可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个==控制标识符==，在不同的地方有不同用途，而且它的<strong>取值不同，也代表不同的含义</strong>。</p>
<ul>
<li><strong>负数代表正在进行初始化或扩容操作</strong>         </li>
<li><strong>-1代表正在初始化</strong></li>
<li><strong>-N 表示有N-1个线程正在进行扩容操作</strong></li>
<li><strong>正数或0代表hash表还没有被初始化，</strong>这个数值表示初始化或下一次进行扩容的大小，==这一点类似于扩容阈值的概念==。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的</li>
</ul>
<h5 id="3-2初始化数组-initTable"><a href="#3-2初始化数组-initTable" class="headerlink" title="3.2初始化数组 initTable"></a>3.2初始化数组 initTable</h5><p>​    初始化方法主要应用了关键属性sizeCtl 如果这个值〈<strong>0，表示其他线程正在进行初始化，就放弃这个操作。</strong>在这也可以<strong>看出</strong>ConcurrentHashMap的==初始化只能由一个线程完成==。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p>
<h5 id="3-3-核心内容"><a href="#3-3-核心内容" class="headerlink" title="3.3 核心内容"></a>3.3 核心内容</h5><ul>
<li>forword （(transfer)扩容时标记，碰到这个标记直接跳过），==类似于大家一起搭积木==</li>
<li>Moved （在put时候碰到Moved ，则帮助其扩容 helptransfer）</li>
<li>sizeCtl</li>
<li>CAS</li>
<li>Volatile（val 和 next 都用了）</li>
<li>以上五点保证了 ConcurrentHashMap 的高并发情况下的线程安全问题</li>
<li>java7中只有1000多行代码，而在Java8中重新编写了现在有6000多行代码</li>
</ul>
<h4 id="PUT流程："><a href="#PUT流程：" class="headerlink" title="==PUT流程：=="></a>==PUT流程：==</h4><ul>
<li><strong>1、判断是否初始化过，没有则进行初始化。</strong></li>
<li><strong>2、通过Hash定位到数组的索引坐标，判断是否有Node 节点，</strong><ul>
<li><strong>如果没有则使用 CAS 进行添加，添加失败进入下次循环</strong></li>
</ul>
</li>
<li><strong>3、检查到内部在扩容，就帮助他一块扩容（Moved ）</strong></li>
<li><strong>4、如果 Node 节点存在，则使用 synchronized 锁住头结点，</strong><ul>
<li><strong>如果是链表结构就进行链表的添加操作</strong><ul>
<li><strong>如果是红黑树结构就进行红黑树的添加操作</strong></li>
<li><strong>5、判断链表的长度是否大于 8，如果大于就去转为树结构</strong></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    
    
    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>HashMap源码解析</a></p>
  <p><span>文章作者:</span>Bangjin-Hu</a></p>
  <p><span>发布时间:</span>2019年10月15日 - 09:22:26</p>
  <p><span>最后更新:</span>2020年03月30日 - 08:12:02</p>
  <p><span>原始链接:</span><a href="/undefined/Java集合框架 HashMap源码解析/" title="HashMap源码解析">http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

      
    </div>
    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="Bangjin-Hu wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎扫码关注微信公众号，订阅我的微信公众号.</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持是我创作的动力.</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat-reward-img.jpg" alt="Bangjin-Hu 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay-reward-img.jpg" alt="Bangjin-Hu 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Bangjin-Hu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/" title="HashMap源码解析">http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java集合/" rel="tag"><i class="fa fa-tag"></i> Java集合</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/undefined/Logback/" rel="next" title="Logback">
                <i class="fa fa-chevron-left"></i> Logback
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/undefined/Log4j/" rel="prev" title="Log4j">
                Log4j <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">212</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap源码解析"><span class="nav-text">HashMap源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-默认属性"><span class="nav-text">1. 默认属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-put方法"><span class="nav-text">2. put方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hash方法"><span class="nav-text">hash方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#putval-添加-方法"><span class="nav-text">==putval(添加)方法==</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PUT方法的流程："><span class="nav-text">==PUT方法的流程：==</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resize-扩容-方法"><span class="nav-text">resize(扩容)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#split-红黑树修剪-方法"><span class="nav-text">split(红黑树修剪)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#untreeify-非树化-方法"><span class="nav-text">untreeify(非树化)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#treeifyBin-树化-方法"><span class="nav-text">treeifyBin(树化)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#treeify-打头树化-方法"><span class="nav-text">treeify(打头树化)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#moveRootToFront-保证根节点-方法"><span class="nav-text">moveRootToFront(保证根节点)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#putTreeVal-树的添加节点-方法"><span class="nav-text">putTreeVal(树的添加节点)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#balanceInsertion-树的平衡-方法"><span class="nav-text">balanceInsertion(树的平衡)方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、简介"><span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-为什么HashMap用于多线程会出错？："><span class="nav-text">2.为什么HashMap用于多线程会出错？：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-为什么不用Hashtable？"><span class="nav-text">3.为什么不用Hashtable？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、ConcurrentHashMap-java7-中的实现方式"><span class="nav-text">4、ConcurrentHashMap java7 中的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-java7中的优缺点"><span class="nav-text">4.1 java7中的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-java8-中的实现"><span class="nav-text">ConcurrentHashMap java8 中的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、简介-1"><span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、什么是volatille关键字？"><span class="nav-text">2、什么是volatille关键字？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、重要属性"><span class="nav-text">==3、重要属性==</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-sizeCtl"><span class="nav-text">3.1 sizeCtl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2初始化数组-initTable"><span class="nav-text">3.2初始化数组 initTable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-核心内容"><span class="nav-text">3.3 核心内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUT流程："><span class="nav-text">==PUT流程：==</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">486.7k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
