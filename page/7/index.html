<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="BangjinHu'Blog" />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="微信公众号：iProgrammer_ing">
<meta property="og:type" content="website">
<meta property="og:title" content="BangjinHu&#39;s Blog">
<meta property="og:url" content="http://bangjinhu.github.io/page/7/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="微信公众号：iProgrammer_ing">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BangjinHu&#39;s Blog">
<meta name="twitter:description" content="微信公众号：iProgrammer_ing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/page/7/"/>





  <title>BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java 泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java 泛型/" itemprop="url">泛型</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:38:35+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,057
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型表示将集合中的一个元素限定为一个特定的类型。参数化类型，将类型由原来的具体的类型参数化，类似于方法中变量参数。在使用泛型类时，虽然传入了不同的泛型参数，但是并没有真正意义上生成不同的类型，传入不同的泛型实参的泛型类在内存上只有一个，没有真正意义上生成不同的类型，传入不同参数的泛型类在内存上只有一个，即还是原来的基本类型，在逻辑上可以理解成多个不同的泛型类型。</p>
<blockquote>
<p>提示：foreach()方法作为遍历集合中的所有元素的方法。</p>
</blockquote>
<blockquote>
<blockquote>
<p>总结：泛型类型在逻辑上可以看成多个不同的类型，但是在实际上都是相同的基本类型。</p>
</blockquote>
</blockquote>
<pre><code>ArrayList&lt;E&gt; -- 泛型类型
ArrayList -- 原始类型
E -- 类型参数
&lt;&gt; -- 读作&quot;typeof&quot;
ArrayList&lt;Integer&gt; -- 参数化的类型
Integer -- 实际类型参数
</code></pre><blockquote>
<p>注意：1.参数类类型与原始类型相互兼容。</p>
</blockquote>
<pre><code>ArrayList  collection1 = new ArrayList&lt;Integer&gt;();//通过,无warning
ArrayList&lt;Integer&gt; collection2 = new ArrayList();//通过,有warning
</code></pre><blockquote>
<p>注意：2.参数类型不考虑类型的继承关系。</p>
</blockquote>
<pre><code>ArrayList&lt;String&gt; collection3 = new ArrayList&lt;Object&gt;();//编译不通过
ArrayList&lt;Object&gt; collection4 = new ArrayList&lt;String&gt;();//编译不通过

ArrayList collection5 = new ArrayList&lt;Integer&gt;();
ArrayList&lt;String&gt; collection6 = collection5;//编译通过
</code></pre><blockquote>
<p>注意：ArrayList<string>像一种新的特殊的ArrayList类，但是实际上系统并没有为ArrayList<string>生成新的class文件，并且不会把ArrayList<string>当做一种新的类型来处理，所以不存在泛型类这一说。不管泛型的类型形参传入哪一种类型实参，对于Java而言，他们依然被当成同一个类型来处理，在内存中也占用一块内存空间，故而在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。</string></string></string></p>
</blockquote>
<pre><code>//下面程序错误，不能再静态变量声明中使用类型形参
public class R&lt;T&gt;{
    static T info;
    //不能再静态方法声明中使用类型形参
    public static void bar(T msg){

    }
}
</code></pre><h4 id="1-”-”通配符"><a href="#1-”-”通配符" class="headerlink" title="1.”?”通配符"></a>1.”?”通配符</h4><p>“?”通配符表示任意类型，使用”?”通配符可以引用各种参数化的类型，可以调用与参数化无关的方法(如：size()方法)，不能调用与参数化有关的方法(如：add()方法)。</p>
<blockquote>
<p>通配符的扩展：</p>
</blockquote>
<pre><code>1.限定通配符的上边界
ArrayList&lt;? extends Number &gt; collection1= new ArrayList&lt;Integer &gt;();//编译通过
ArrayList&lt;? extends Number &gt; collection2= new ArrayList&lt;String&gt;();//编译不通过

2.限定通配符的下边界
ArrayList&lt;? super Integer &gt; collection3= new ArrayList&lt;Number&gt;();//编译通过
ArrayList&lt;? super Integer &gt; collection4= new ArrayList&lt;String&gt;();//编译不通过
</code></pre><h4 id="2-自定义泛型方法"><a href="#2-自定义泛型方法" class="headerlink" title="2.自定义泛型方法"></a>2.自定义泛型方法</h4><p>Java的泛型基本上完全在编译器中实现，用于编译器执行类型检查和类型判断，然后生成普通的非泛型的字节码，这种实现技术为“擦除”(erasure)。</p>
<blockquote>
<p>注意：因为泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。</p>
</blockquote>
<blockquote>
<p>擦除实例：</p>
</blockquote>
<pre><code>public class GenericTest {
    public static void main(String[] args) {
        new GenericTest().testType();
    }

    public void testType(){
        ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;();

        System.out.println(collection1.getClass()==collection2.getClass());
        //两者class类型一样,即字节码一致

        System.out.println(collection2.getClass().getName());
        //class均为java.util.ArrayList,并无实际类型参数信息
    }
}
</code></pre><p>输出：</p>
<pre><code>true
java.util.ArrayList
</code></pre><blockquote>
<p>注意：使用反射可以跳过编译器，向某个泛型集合中注入其他类型数据。</p>
</blockquote>
<blockquote>
<p>注意：只有引用类型才能作为泛型方法的实际参数。如：</p>
</blockquote>
<pre><code>public class GenericTest {
    public static void main(String[] args) {
        swap(new String[]{&quot;111&quot;,&quot;222&quot;},0,1);//编译通过

        //swap(new int[]{1,2},0,1);
        //编译不通过,因为int不是引用类型

        swap(new Integer[]{1,2},0,1);//编译通过
    }

    /*交换数组a 的第i个和第j个元素*/
    public static &lt;T&gt; void swap(T[]a,int i,int j){
        T temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
</code></pre><blockquote>
<p>提示：基本类型有些时候可以作为实参，因为自动装箱与拆箱。如：</p>
</blockquote>
<pre><code>//该实例还表明当实参不一致时，T取交集，即第一个共同的父类。
public class GenericTest {
    public static void main(String[] args) {
        new GenericTest().testType();
        int a = biggerOne(3,5);
        //int 和 double,取交为Number
        Number b = biggerOne(3,5.5);
        //String和int 取交为Object
        Object c = biggerOne(&quot;1&quot;,2);
    }
    //从x,y中返回y
    public static &lt;T&gt; T biggerOne(T x,T y){
        return y;
    }
}
</code></pre><h4 id="3-类型参数推断"><a href="#3-类型参数推断" class="headerlink" title="3.类型参数推断"></a>3.类型参数推断</h4><p>编译器在判断泛型方法的实际类型参数的过程称之为类型推断。</p>
<pre><code>1.当某个 类型变量 只在整个 参数列表 的 所有参数 和 返回值 中的一处被应用，那么根据调用方法时该处的 实际应用类型 来确定。即 直接根据调用方法 时 传递的参数类型 或 返回值 来决定 泛型参数 的类型。

如：
    swap(new String[3],1,2) -&gt; static &lt;E&gt; void swap(E[]a,int i,int j);

2.当某个 类型变量 在整个 参数列表 的 所有参数 和 返回值 中的 多处被应用 ，如 调用方法 时这么多处的 实际应用类型 都对应 同一种类型 ，则 泛型参数的类型 就是 该类型 。

如：
    add(3,5) -&gt; static &lt;T&gt; T add(T a,T b);

3.当 某个类型变量 在整个 参数列表 的 所有参数 和 返回值 中的*多处被应用了，如果 调用方法 时这么多处的 实际应用类型 对应 不同的类型 ,且没有 返回值 ，则取多个参数中的 最大交集类型 ，即第一个公共父类。

如：
    fill(new Integer[3],3.5) -&gt; static &lt;T&gt; void fill(T a[],T v);

4.当某个 类型变量 在整个 参数列表 的 所有参数 和 返回值 中的 多处被应用 ，如果 调用方法 时这么多处的 实际应用类型 对应不同的 类型 ,且使用有 返回值 ，则优先考虑 返回值的类型 。

如：
    int x = add(3,3.5) -&gt; static &lt;T&gt; T add(T a,T b);

5.参数类型的类型推断具有传递性。

如：
    //该例推断的实际类型为Object，编译通过
    copy(new Integer[5],new String[5]) -&gt; static &lt;T&gt; void copy(T []a,T []b);

    //该例则根据参数化的ArrayList类实例将类型变量直接确定为String类型，编译报错
    copy(new ArrayList&lt;String&gt;,new Integer[5]) -&gt; static &lt;T&gt; void copy(Collection&lt;T&gt;a,T[]b);
</code></pre><h4 id="4-自定义泛型"><a href="#4-自定义泛型" class="headerlink" title="4.自定义泛型"></a>4.自定义泛型</h4><pre><code>如：
    public class GenericDao&lt;T&gt;{
        public void add(T x){
        }

        public T findById(int id){
            return null;
        }

        public void delete(T obj){
        }

        public void delete(int id){
        }

        public void update(T obj){
        }

        public T findByUserName(String name){
            return null;
        }

        public &lt;T&gt; Set&lt;T&gt; findByConditions(String where){
            return null;
        }

    }
</code></pre><blockquote>
<p>注意：当一个变量被声明为泛型时，只能被实例变量和方法调用(还有内嵌类型)，而不能被静态变量和静态方法调用。因为静态成员是被所参数化的类所共享的，所以静态成员不应该有类级别的类型参数。</p>
</blockquote>
<h4 id="5-泛型方法与泛型类的比较"><a href="#5-泛型方法与泛型类的比较" class="headerlink" title="5.泛型方法与泛型类的比较"></a>5.泛型方法与泛型类的比较</h4><pre><code>如：
    public class A&lt;T&gt;(){
        //泛型类的成员方法，该T受A后面的T的限制
        public T memberFunc(){
            return null;
        }
        //泛型方法，这里的T和和类A的T是不同的
        public static &lt;T&gt; T genericFunc(T a){
            return null;
        }
        public static void main(String[] args) {
            //编译不通过
            //Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);

            //编译通过
            Set&lt;Integer&gt; set=  A&lt;String&gt;().findByConditions(&quot;s&quot;);
        }
    }
</code></pre><blockquote>
<p>总结：从这个例子可以得到泛型方法中的T与类中的T是不相同的。</p>
</blockquote>
<h4 id="6-泛型与反射"><a href="#6-泛型与反射" class="headerlink" title="6.泛型与反射"></a>6.泛型与反射</h4><p><strong>1.通过反射获取泛型的实际类型参数</strong><br><br>将泛型变量当成方法的参数，利用method类的getGenericParameterTypes()方法来获取泛型的实际类型参数。</p>
<pre><code>如：
    public class GenericTest {
        public static void main(String[] args) throws Exception {
            getParamType();
        }

         /*利用反射获取方法参数的实际参数类型*/
        public static void getParamType() throws NoSuchMethodException{
            Method method = GenericTest.class.getMethod(&quot;applyMap&quot;,Map.class);
            //获取方法的泛型参数的类型
            Type[] types = method.getGenericParameterTypes();
            System.out.println(types[0]);
            //参数化的类型
            ParameterizedType pType  = (ParameterizedType)types[0];
            //原始类型
            System.out.println(pType.getRawType());
            //实际类型参数
            System.out.println(pType.getActualTypeArguments()[0]);
            System.out.println(pType.getActualTypeArguments()[1]);
        }

        /*供测试参数类型的方法*/
        public static void applyMap(Map&lt;Integer,String&gt; map){

        }

    }
</code></pre><p>output：</p>
<pre><code>java.util.Map&lt;java.lang.Integer, java.lang.String&gt;
interface java.util.Map
class java.lang.Integer
class java.lang.String
</code></pre><h4 id="7-泛型派生类"><a href="#7-泛型派生类" class="headerlink" title="7.泛型派生类"></a>7.泛型派生类</h4><p>当创建带泛型类型声明的接口、父类时，可以为该接口创建实现类，或从该父类派生子类，当使用这些接口和父类时，不能再包含类型形参。</p>
<pre><code>//定义类A继承Apple类，Apple类不能再跟类型形参
pulic class A extends Apple&lt;T&gt;{};//这样的定义方式是错误的

//如果想从Apple类派生一个子类,使用Apple类时为T形参传入一个String类型
public class A extends Apple&lt;String&gt;
</code></pre><hr>
<hr>
<blockquote>
<p>扩展：泛型</p>
</blockquote>
<pre><code>泛型的好处：
    1.将运行时的异常提前到编译阶段.
    2.避免了无谓的强制类型转换
</code></pre><blockquote>
<blockquote>
<p>注意：泛型是jdk1.5加的特性</p>
</blockquote>
</blockquote>
<p>泛型在集合中的常见应用：</p>
<blockquote>
<p>注意：泛型没有多态的概念，左右两边的数据类型必须要一致，或者只写一边的泛型类型。</p>
</blockquote>
<blockquote>
<blockquote>
<p>推荐使用：两边都写泛型</p>
</blockquote>
</blockquote>
<blockquote>
<p>自定义泛型：自定义泛型就是一个数据类型的占位符或者是一个数据类型的常量。</p>
</blockquote>
<p>在方法上自定义泛型：</p>
<pre><code>修饰符 &lt;声明自定义的泛型&gt;返回值类型 函数名(使用自定义的泛型){

    }
</code></pre><blockquote>
<blockquote>
<p>方法泛型注意事项：<br>    1.在方法上自定义泛型，这个自定义泛型的具体数据类型是在调用该方法时传入实参时确定具体的数据类型的。<br>    2.自定义泛型只要符合标识符的命名规则即可，但自定义泛型我们一般都习惯使用一个大写字母(E T)表示。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：在泛型中不能使用基本数据类型，如果需要使用基本数据类型，那么就使用基本数据类型对应的包装类型<br>如：</p>
</blockquote>
<pre><code>char(基本类型)-----&gt;Character(包装类型)
int------&gt;Integer
boolean--&gt;Boolean
</code></pre><blockquote>
<p>泛型类</p>
</blockquote>
<p>泛型类的自定义格式：</p>
<pre><code>class 类名&lt;声明自定义类型&gt;{

    }
</code></pre><blockquote>
<blockquote>
<p>泛型类要注意的事项：</p>
</blockquote>
</blockquote>
<pre><code>1.在类上自定义泛型的具体数据类型是在使用该类的时候创建对象时确定的。
2.如果一个类在类上已经声明了自定义类型，且如果使用该类创建对象的时候没有指定泛型的具体数据类型，那么默认为Object类型。
3.在类上自定义泛型不能作用于静态的方法，如果静态的方法需要使用自定义泛型，那么需要在方法上自己声明使用。
</code></pre><blockquote>
<p>泛型接口：</p>
</blockquote>
<p>泛型接口的定义格式：</p>
<pre><code>interface 接口名&lt;声明自定义类型&gt;{

}
</code></pre><p>泛型接口要注意的事项：<br>    1.接口上自定义的泛型的具体数据类型是在实现一个接口的时候指定的。<br>    2.在接口上自定义的泛型如果在实现接口的时候没有指定具体的数据类型，那么默认为Object类型</p>
<p>需求：目前实现一个接口的时候，不明确目前要操作的数据类型，需要等待创建接口实现类对象的时候时候才能指定泛型的具体数据类型。</p>
<p>如果要延长接口自定义泛型的具体数据类型，格式如下：</p>
<pre><code>public class Demo4&lt;T&gt; implements Dao&lt;T&gt;{

        }
</code></pre><p>泛型的上下限：</p>
<p>需求1：定义一个函数可以接收任意类型的集合对象，要求接收的集合对象只能存储Interger或者是Integer的父类类型数据。<br>需求2：定义一个函数可以接收任意类型的集合对象，要求接收的集合对象只能存储Number或者是Number子类类型数据。</p>
<p>泛型中的通配符：？ </p>
<pre><code>例：？ super Integer：表示只能存储Integer或者Integer父类元素 泛型的下限
    ？ extends Number：表示只能存储Number或者Number类型的子类数据 泛型的上限
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java 集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java 集合/" itemprop="url">集合</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:40:12+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java集合/" itemprop="url" rel="index">
                    <span itemprop="name">Java集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,900
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>[TOC]</p>
<blockquote>
<p>注意：Object类型的数组可以存储任意类型的数据。</p>
</blockquote>
<h4 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h4><p>集合是存储对象数据的容器。</p>
<p>1.集合比数组的优势：</p>
<pre><code>1.集合可以存储任意类型的数据，数组只能存储同一种数据类型的数据(Object类型的数组除外)。
2.集合的长度是会发生变化的，数组的长度是固定的。
</code></pre><p>2.集合类的继承体系：</p>
<pre><code>Collection：是所有单例集合的根接口，其有两个接口List/Set
Set：如果实现了Set接口的集合类，具备特点：无序、不可重复。
List：如果实现了List接口的集合类，具备的特点：有序、可重复。有序：集合的有序不是指自然顺序，而是指添加进去的顺序与元素出来的顺序一致。
</code></pre><blockquote>
<p>提示：Collection与Collections的区别在于Collection是一个集合接口，其提供了对集合对象进行操作的通用接口方法。实现接口类主要有List/Set，该接口的设计是为各种具体的集合提供最大化的统一操作方式。Collections是针对集合类的一个包装类，它提供了一系列静态方法以实现对各种集合的搜索、排序、线程安全化等操作。<br></p>
</blockquote>
<blockquote>
<blockquote>
<p>继承：1.父类定义完整的成员、静态成员、非静态成员、构造方法，静态变量和静态方法都可以通过子类名.父类静态成员的形式调用。2.所有的私有成员不能继承private修饰的成员。3.构造函数不能被继承。</p>
</blockquote>
</blockquote>
<p><strong>super关键字</strong><br><br>this关键字和super关键字很像，this关键字指向的是当前对象的调用，super关键字指向的是当前对象调用的父类。this/super关键字只能在有对象的前提下使用，不能在静态上下文使用。</p>
<blockquote>
<p>提示：子类的构造函数默认第一行会调用父类的无参构造函数。super();</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在子类构造函数第一行通过super关键字调用父类任何构造函数，如果显式调用父类的构造函数，编译器自动添加的调用父类无参数的构造就消失，构造函数的调用只能放在第一行，只能调用一次。super()和this()不能同时存在构造函数的第一行。</p>
</blockquote>
</blockquote>
<hr>
<p>Collection接口中的方法(因为接口Collection不可以直接实现，此时使用多态ArrayList)：</p>
<pre><code>增加：&lt;br&gt;
   1.add(E e)：添加成功返回true，添加失败返回false&lt;br&gt;
   2.addAll(Collection c)：把一个集合中的元素添加到另外一个集合中去。例：c2.add(&quot;王林&quot;);c.addAll(c2);//就是将c2的元素添加到c集合中去。

删除：&lt;br&gt;
   1.clear()：清空集合中的元素&lt;br&gt;
   2.remove(o)：指定集合中的元素删除，删除成功返回true，删除失败返回false&lt;br&gt;
   3.removeAll()：该方法是删除一个集合中与另一个集合的交集元素。c.removeAll(c2);//删除c集合中与c2集合中的交集元素，因为是c集合调用此方法。&lt;br&gt;
   4.retainAll()：保留c集合与c2的交集元素，其它的元素一并删除。c.retainAll(c2);//


查看：&lt;br&gt;
   size()：查看集合中元素的个数。c.size();//查看c集合中元素的个数

判断：&lt;br&gt;
   1.isEmpty()：该方法是判断集合是否为空&lt;br&gt;
   2.contains(Object o)：判断集合中是否存在指定的元素&lt;br&gt;
   3.containsAll(Collection c)：判断集合c中是否包含c2的所有元素。c.containsAll(c2);//

迭代：&lt;br&gt;
 遍历集合中的元素的方法：&lt;br&gt;
    方式一：使用toArray()方法 将c集合中的所有元素存储到一个Object数组中返回。&lt;br&gt;
    方式二：使用迭代器iterator()遍历，Iterator it=c.iterator();//返回一个迭代器&lt;br&gt;
   1.toArray()：将集合中的元素全部存储到一个Object数组中返回。

   2.iterator()：

迭代器的作用：用于抓取集合中的元素，就类似与抓娃娃机里面的那个爪子一样。iterator实际上返回的是iterator接口的实现类对象。

迭代器的方法：&lt;br&gt;
    1.hasNext()：问是否存在下一个元素，如果有元素则返回true，否则返回false。(当前指针是否有指向元素，如果有返回true，否则返回false)&lt;br&gt;
    2.next()：获取当前指针指向的元素并返回当前的元素，然后指针向下移动一个单位。&lt;br&gt;
    3.remove()：删除迭代器最后一次返回的元素。
</code></pre><blockquote>
<p>注意：从Object数组中取出的元素只能使用Object类型声明变量接收，如果需要其它的变量类型，需要强制转换。</p>
</blockquote>
<h4 id="2-List："><a href="#2-List：" class="headerlink" title="2.List："></a>2.List：</h4><p>List继承Collection接口，所以Collection中有的方法，在List接口中也适用。</p>
<p>List接口中特有的方法：</p>
<pre><code>1.添加：
    add(int index,E element)：将指定元素添加到集合中的指定索引值位置上。
    addAll(int index,Collection c)：将指定集合添加到另一集合中指定索引值的位置上。

2.获取：
    get(int index)：使用get方法遍历集合中的元素，即获取指定索引值位置的集合中的元素
    indexOf(Object o)：找出指定元素第一次出现在集合中的索引值
    lastIndexOf(Object o)：找出指定元素最后一次出现在集合中的索引值
    subList(fromIndex,toIndex)：指定开始与结束的索引值，截取集合中的元素(在Java中截取都是包头不包尾的，如果想要截取到指定长度的元素，应该将末尾值加1)

3.修改：
    set(int index,E element)：使用指定的元素替换指定索引值的元素
</code></pre><blockquote>
<p>注意：List接口中特有的方法具备的特点：操作的方法都存在索引值，同时只有List接口下面的集合类才具备索引值。其它接口类下面的集合类都没有索引值。</p>
</blockquote>
<pre><code>4.迭代：
    listIterator():该方法返回的是一个List接口中特有的迭代器

ListIterator接口中特有的方法：
    hasPrevious()：判断是否存在上一个元素
    previous()：获取上一个元素，即当前指针先向上移动一个单位，然后再取出当前指针指向的元素

    add(E e)：将当前元素插入到当前指针指向的位置上
    set(E e)：替代迭代器最后一次返回的元素
</code></pre><p>练习：使用三种方式遍历集合的元素</p>
<pre><code>1.使用get方法遍历
2.使用迭代器正序遍历
3.使用迭代器逆序遍历
</code></pre><hr>
<pre><code>package cn.itcast.collelction;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class demo4 {
    public static void main(String[] args){
        List list=new ArrayList();
        list.add(&quot;张三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        System.out.println(&quot;=======使用get方法遍历======&quot;);
        for(int i=0;i&lt;list.size();i++){
            System.out.println(list.get(i)+&quot;,&quot;);
        }
        System.out.println(&quot;========使用迭代其正序遍历======&quot;);
        ListIterator it=list.listIterator();//获取迭代器
        while(it.hasNext()){
            System.out.println(it.next()+&quot;,&quot;);
        }
        System.out.println(&quot;=========使用迭代逆序遍历=======&quot;);
        while(it.hasPrevious()){//hasPrevious()：判断是否存在上一个元素
            System.out.println(it.previous()+&quot;,&quot;);//previous()：获取上一个元素，即当前指针先向上移动一个单位，然后再取出当前指针指向的元素
        }

    }

}
</code></pre><p>迭代器：指专门取出集合元素的对象，但是此对象很特殊，不能直接创建对象(new)，该对象是以内部类的形式存在每个集合类的内部。因为每个容器都有取出元素的功能。即Iterator是一个对象，它的工作是遍历并选择序列中的对象，它提供一种访问一个容器(container)对象中的各个元素，而又不必暴露该对象内部细节的方法。所以通过迭代器，开发人员不需要了解容器底层的接口，就可以实现对容器的遍历。</p>
<blockquote>
<p>迭代器在遍历元素时注意事项：<br>    1.在迭代器(内存模型)迭代元素的过程中，不允许使用集合对象改变集合中的元素的个数，如果需要添加删除只能使用迭代器的方法进行操作。如果使用了集合对象改变集合中元素个数就会出现ConcurrentModificationException异常。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：1.使用容器iterator()方法返回一个Iterator，然后通过Iterator的next()方法返回第一个元素。2.使用Iterator的hasNext()方法判断容器中是否还有元素，如果有，可以使用next()方法获取下一个元素。3.可以通过remove()方法删除迭代器返回的元素。</p>
</blockquote>
</blockquote>
<h4 id="3-List的实现类"><a href="#3-List的实现类" class="headerlink" title="3.List的实现类"></a>3.List的实现类</h4><pre><code>1.ArrayList
    ArrayList特有的方法：
     1.ensureCapacity(int minCapacity) 该操作增加ArrayList容量
        2.trimToSize()
ArrayList底层维护了一个Object数组实现的(底层是Objec数组写的)，所谓动态的是它的大小可变。 特点：查询速度块，增删慢(因为此时如果ArrayList长度不够用的时候需要创建新的ArrayList对象，然后将原来的数据拷贝到新建的对象中，那么这一过程就非常的漫长)
</code></pre><p>ArrayList何时使用：根据数据特点，如果当前数据查询比较多，增删比较少的时候，那么就使用ArrayList存储这批数据。比如高校的图书馆，这时候查询的操作比较多，然后增删的操作比较少，此时可以使用ArrayList来操作。</p>
<p>笔试题目：使用ArrayList无参构造函数创建一个对象时，默认的容量是多少？如果长度不够使用时又自增增长多少？<br><br>答：ArrayList底层是维护了一个Object数组实现的，使用无参构造函数时，Object数组默认的容量是10，当长度不够用时，自动增长0.5倍。</p>
<pre><code>2.LinkedList
实现原理：使用链表数据结构实现的。特点：查询速度慢，增删快(因为内存地址不连续，所以查询的时候需要遍历集合完之后才能查询到相应的元素的位置)
LinkedList的特有方法：
    addFirst()：将元素添加到集合的首位置上
    addLast()：将元素添加到集合的末尾处
    getFirst()：获取集合中首位置的元素
    getLast()：获取集合中末尾的元素
    removeFirst()：删除集合中的首位置元素并返回
    removeLast()：删除集合中的末尾位置元素并返回

    descendingIterator()：

    push()：进栈
    pop()：出栈

    offer()：进队列
    poll()：出队列
</code></pre><p>机试题目：使用LinkedList实现堆栈数据结构的存储方式与队列的数据结构存储方式</p>
<pre><code>3.Vector(了解) 底层是维护了一个Object的数组实现的，实现与ArrayList一样，但是Vector是线程安全的，操作效率低。(已经被ArrayList取代)
</code></pre><p>笔试题：说出ArrayList与Vector的区别？<br><br>答：相同点：ArrayList与Vector底层都是使用了Object数组实现的。<br>    不同点：1.ArrayList是线程不同步的，操作效率高。Vector是线程同步的，操作效率低。<br>        2.ArrayList是JDK1.2出现的，Vector是jdk1.0出现的。</p>
<hr>
<blockquote>
<p>ArrayList/Vector/LinkedList之间的区别：ArrayList/Vector/LinkedList类均在java.util包中，均为可伸缩数组，即可以动态改变长度的数组。ArrayList和Vector是在内存中开辟一块连续的空间来存储的，由于数据存储是连续的，所以他们支持用序号(下标)来访问元素，同时索引数据的速度比较快，但是在插入元素时需要移动容器中的元素，所以对数据的插入操作执行比较慢。ArrayList与Vector最大的区别是synchronization(同步)的使用，没有一个ArrayList的方法是同步的，而Vector的大部分方法都是直接或间接同步的，所以Vector是线程安全的，而ArrayList是线程不安全的。LinkedList是采用双向列表来实现的，对数据的索引需要从列表头开始遍历，因此用于随机访问则效率低下，但是在插入元素时不需要对数据进行移动，所以插入效率较高。此外，LinkedList是非线程安全的容器。</p>
</blockquote>
<h4 id="4-Set接口"><a href="#4-Set接口" class="headerlink" title="4.Set接口"></a>4.Set接口</h4><p>Set接口实现的集合类特点：无序、不可重复 </p>
<pre><code>1.无序：元素添加的顺序与出来的顺序是不一样的 
2.不可重复：set集合里面的元素是不可重复的。
</code></pre><p>1.Set接口下面的特有方法</p>
<pre><code>Set接口下面的实现类：

1.HashSet：底层是使用哈希表来支持的，特点：存取速度快。
    实现原理：往HashSet添加元素的时候HashSet会先调用元素的hashCode()方法得到元素的哈希值，然后通过元素的哈希值经过移位运算，就可以算出该元素在哈希表中的存储位置。
          情况一：如果算出元素存储的位置目前没有存储元素，那么该元素可以直接存储到该位置。
          情况二：如果算出该元素的存储位置目前已经存在有元素，那么会调用该元素的equals()方法与该位置的元素再比较一次，如果equals方法返回的是true，那么该元素与此位置上的元素是重复的，不允许添加，反之可以直接添加。

    哈希表的特点：桶式结构(一个空间里面可以装多个元素)
注意：HashCode值在默认情况下是表示的内存地址，但是在引用类的时候类会重写hashCode()方法，所以hashCode值可能会相同。

2.TreeSet：如果元素具备自然顺序特性，那么就按照元素自然顺序的特性进行排序存储

    TreeSet注意事项：
        1.往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。
        2.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素的比较规则定义在compareTo(T o)方法中。
        3.如果在比较元素的时候，compareTo()方法返回的是0，那么该元素就被视为重复元素，不允许添加(注意：TreeSet与hashCode()、equals()方法是没有任何关系的)
        4.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类与没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个比较器。
        5.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口，在创建TreeSet对象的时候也传入了比较器，那么是以比较器的比较规则优先使用。

自定义比较器：自定义一个类实现Comparator接口，把元素与元素之间的比较规则定义在compare()方法即可。
    格式：
    class 类名 implements Comparator{

        }
</code></pre><p>推荐使用：比较器(comparator)<br>        TreeSet实现原理：<br>            底层是使用红黑树(二叉树)数据结构实现的。存储规则：左小右大</p>
<p>注意：TreeSet是可以对字符串进行排序的，因为字符串已经实现了Comparable接口。</p>
<p>字符串比较规则：<br>    情况一：可以找到不同字符，比较的就是对应位置上的字符。</p>
<pre><code>情况二：找不到对应不同的字符，比较的就是字符串的长度。
</code></pre><blockquote>
<p>注意：1.eclipse的快捷键：Ctrl+shift+/ 添加多行注释 Ctrl+shift+\ 取消多行注释</p>
</blockquote>
<h4 id="5-Map接口"><a href="#5-Map接口" class="headerlink" title="5.Map接口"></a>5.Map接口</h4><p>Map中的元素是两个对象，一个对象作为键，一个对象作为值。键是不可以重复的，但是值可以重复。Map与Collection在集合框架中属于并列的存在。Map存储的是键值对。Map接口，表示将键映射到值的对象，一个映射不能包含重复的键，每个键最多能映射到一个值。</p>
<pre><code>1.HashMap 采用哈希表实现，无序。底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。

    1.1 LinkedHashMap：该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率

2.TreeMap 可以对键进行排序，底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator 进行比较排序。return 0，来判断键的唯一性。

3.Hashtable 底层是哈希表数据结构，线程同步，不可以存入null键，null值。效率较低，被 HashMap 替代
</code></pre><p>案例：使用HashMap建立学生姓名与年龄之间的映射关系。</p>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class Demo {
    public static void main(String[] args) {
        //定义一个Map容器对象
        Map&lt;String,Integer&gt; map1 = new HashMap&lt;String,Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);
        //添加重复的键值(值不同)，会返回集合中原有(重复键)的值
        System.out.println(map1.put(&quot;jack&quot;,30));//20

        Map&lt;String,Integer&gt; map2 = new HashMap&lt;String,Integer&gt;();
        map2.put(&quot;Aaron&quot;,25);
        map2.put(&quot;Brian&quot;,35);
        System.out.println(&quot;map2:&quot;+map2);
        //从指定的映射中将所有映射关系复制到此映射中
        map1.putAll(map2);
        System.out.println(&quot;map1:&quot;+map1);

        //删除
        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);                
        // 指定key，返回删除的键值对映射的值。
        // remove() 该方法删除关联对象，指定key对象
        // clear() 清空集合对象
        System.out.println(&quot;value:&quot; + map1.remove(&quot;java&quot;));
        map1.clear();
        System.out.println(&quot;map1:&quot; + map1);

        //获取
        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);
        // V get(Object key) 通过指定的key对象获取value对象
        // int size() 获取容器的大小
        System.out.println(&quot;value:&quot; + map1.get(&quot;jack&quot;));
        System.out.println(&quot;map.size:&quot; + map1.size());

        //判断
        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
        map1.put(&quot;jack&quot;, 20);
        map1.put(&quot;rose&quot;, 18);
        map1.put(&quot;lucy&quot;, 17);
        map1.put(&quot;java&quot;, 25);
        System.out.println(map1);
        System.out.println(&quot;isEmpty:&quot; + map1.isEmpty());//长度为0返回true，否则返回false
        System.out.println(&quot;containskey:&quot; + map1.containsKey(&quot;jack&quot;));//判断集合中是否包含指定key
        System.out.println(&quot;containsvalues:&quot; + map1.containsValue(100));
    }
}
</code></pre><p><strong>5.1 HashMap</strong><br><br>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</p>
<pre><code>import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

public class Demo {
    public static void main(String[] args){
        HashMap&lt;Person,String&gt; hashMap = new HashMap&lt;Person,String&gt;();
        hashMap.put(new Person(&quot;jack&quot;,20),&quot;1001&quot;);
        hashMap.put(new Person(&quot;Aaron&quot;,20),&quot;1002&quot;);
        System.out.println(hashMap);
        System.out.println(hashmap.put(new Person(&quot;rose&quot;,18),&quot;10086&quot;));

        Set&lt;Entry&lt;Person,String&gt;&gt; entrySet = new hashMap.entrySet();
        Iterator&lt;Entry&lt;Person,String&gt;&gt; it = entrySet.iterator();

        while(it.hasNext()) {
            Entry&lt;Person,String&gt; next = it.next();
            Person key = next.getKey();
            String value = next.getValue();
            System.out.println(key+&quot;=&quot;+value);
        }
    }
}

class Person {
    private String name;
    private int age;

    Person() {}

    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    //set/get方法

    @Override
    public int hashCode(){
        return this.name.hashCode()+age*37;
    }

    @Override
    public String toString(){
        return &quot;PersonName:&quot;+this.name+&quot;age:&quot;+age;
    }
}
</code></pre><p><strong>5.2 TreeMap</strong><br></p>
<blockquote>
<p>注意：Set的元素不可重复，Map的键不可重复，如果存入重复元素如何处理?<br><br>    1.Set元素重复元素不能存入add方法返回false。<br>    2.Map的重复健将覆盖旧键，将旧值返回。</p>
</blockquote>
<h4 id="6-使用Lambda表达式遍历集合"><a href="#6-使用Lambda表达式遍历集合" class="headerlink" title="6.使用Lambda表达式遍历集合"></a>6.使用Lambda表达式遍历集合</h4><p>Java8 为Iterable接口新增方法forEach()，用来遍历集合中的元素。</p>
<blockquote>
<p>注意：Iterator必须依附Collection对象。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java 集合框架 - 面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java 集合框架 - 面试/" itemprop="url">Java集合框架</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:39:43+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java集合/" itemprop="url" rel="index">
                    <span itemprop="name">Java集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,816
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java集合框架-面试"><a href="#Java集合框架-面试" class="headerlink" title="Java集合框架 - 面试"></a>Java集合框架 - 面试</h2><p>[TOC]</p>
<h3 id="数据结构与算法-考试"><a href="#数据结构与算法-考试" class="headerlink" title="数据结构与算法 - 考试"></a>数据结构与算法 - 考试</h3><pre><code>1.数据结构

    1.数组和链表的区别

    2.链表的操作：翻转、链表环路检测、双向链表、循环链表等相关操作

    3.队列和栈的应用

    4.二叉树的遍历方式及其递归和非递归的实现

    5.红黑树的旋转（难）

2.算法

    1.内部排序：递归、交换（冒泡、快排）、选择、插入等

    2.外部排序：利用有限内幕才能配合海量的外部存储来处理超大数据集
</code></pre><h3 id="Java集合-List-Set"><a href="#Java集合-List-Set" class="headerlink" title="Java集合 - List | Set"></a>Java集合 - List | Set</h3><pre><code>1.Collection

    1.List

        1.特点

            1.有序

            2.可重复

            3.通过索引操作元素

        2.分类

            1.底层是数组，查询快，增删慢

                1.ArrayList 线程不安全，效率高

                2.Vector 线程安全，效率低

            2.底层是链表，查询慢，增删快

                1.LinkedList 线程不安全，效率高

    2.Set

        1.特点

            1.无序

            2.元素唯一

        2.分类

            1.底层是哈希表

                HashSet 保证元素唯一性

            2.底层是二叉树

                TreeSet 保证元素排序，自然顺序，让对象所属的类去实现Comparable接口，无参构造。比较接口Comparator，带参构造
</code></pre><h3 id="Java集合-Map"><a href="#Java集合-Map" class="headerlink" title="Java集合 - Map"></a>Java集合 - Map</h3><pre><code>1.HashMap | HashTable | ConccurentHashMap 区别

    1.HashMap

        1.在Java8之前采用 数组+链表 的方式实现HashMap，利用他们各自的优势实现

        2.在Java8之后采用 数组+链表+红黑树 的方式实现HashMap

        3.HashMap.put()方法逻辑（Java 8之后）

            1.如果HashMap未被初始化过，则初始化

            2.对key求hash值，然后再计算下标

            3.如果没有碰撞，直接放入桶中

            4.如果碰撞了，以链表的方式链接到后面

            5.如果链表长度超过阈值，就将链表转换成红黑树

            6.如果链表长度低于6，就将红黑树转回链表

            7.如果节点已经存在就替换旧值

            8.如果桶满了（容量16*加载因子0.75），就需要resize（扩容2倍后重排）

        4.减少碰撞

            1.扰动函数：促使元素位置分布均匀，减少碰撞几率

            2.使用final对象，并采用合适的equals和hashcode方法

        5.扩容问题

            1.多线程环境下，调整大小会存在条件竞争，容易造成死锁

            2.rehashing是比较耗时的过程

    2.线程安全的HashMap

        通过调用synchronizedMap(hashMap)方法让HashMap变成线程安全。

    3.如何优化Hashtable

        1.通过琐细粒度化，将整锁拆解成多个锁进行优化

    4.ConcurrentHashMap.put()方法逻辑

        1.判断Node[]数组是否初始化，没有则进行初始化操作

        2.通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头节点），添加失败则进入下一次循环。

        3.检查到内部正在扩容，将帮助其一起扩容

        4.如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）

            如果是Node（链表结构）则执行链表的添加操作

            如果是TreeNode（树型结构）则执行树添加操作

        5.判断链表长度已经达到临界值8（8是默认值），当节点数超过这个值需要将链表转换成树结构

        总结：比起Segment，锁的拆分更细

            1.首先使用无锁操作CAS插入头节点，失败则循环重试

            2.如果头节点已经存在，则尝试获取头节点的同步锁，再进行操作

    5.总结：三者的区别

        1.HashMap 线程不安全，底层是通过 数组+链表+红黑树实现

        2.Hashtable 线程安全，底层是通过锁住整个对象，然后由数组+链表实现

        3.ConccurentHashMap 线程安全，CAS+同步锁，数组+链表+红黑树

        4.HashMap的key、value均可为null，而其它两个类不支持
</code></pre><h4 id="HashMap-Hashtable-区别"><a href="#HashMap-Hashtable-区别" class="headerlink" title="HashMap | Hashtable 区别"></a>HashMap | Hashtable 区别</h4><h5 id="1-线程是否安全"><a href="#1-线程是否安全" class="headerlink" title="1. 线程是否安全"></a>1. 线程是否安全</h5><p>HashMap是非线程安全的，Hashtable是线程安全的。Hashtable内部的方法基本都经过synchronized修饰。</p>
<h5 id="2-效率"><a href="#2-效率" class="headerlink" title="2. 效率"></a>2. 效率</h5><p>因为线程安全的问题，HashMap要比Hashtable效率高一点，另外，Hashtable基本被淘汰。</p>
<h5 id="3-对null-key-和-null-value的支持"><a href="#3-对null-key-和-null-value的支持" class="headerlink" title="3. 对null key 和 null value的支持"></a>3. 对null key 和 null value的支持</h5><p>在HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null。但是在Hashtable中put进的键值只要有一个null，就直接抛NPE异常。</p>
<h5 id="4-初始容量大小和每次扩容大小的不同"><a href="#4-初始容量大小和每次扩容大小的不同" class="headerlink" title="4. 初始容量大小和每次扩容大小的不同"></a>4. 初始容量大小和每次扩容大小的不同</h5><pre><code>1. 创建时如果不指定容量初始值，Hashtable默认的初始大小为11，之后每次扩容变为原来的 2n+1。HashMap默认的初始化大小为16，之后每次扩容，容量变为原来的2倍。

2. 创建时如果给定了容量的初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩容到2的幂次方大小（HashMap中的tableSizeFor()方法保证），也就是说HashMap总是使用2的幂次方作为哈希表的大小。
</code></pre><h5 id="5-底层数据结构"><a href="#5-底层数据结构" class="headerlink" title="5. 底层数据结构"></a>5. 底层数据结构</h5><p>JDK 8以后的HashMap在解决哈希冲突时有变化，当链表长度大于阈值（默认8）时，将链表转化为红黑树，以减少搜索时间。而Hashtable没有这样的机制。</p>
<h4 id="HashMap-HashSet-区别"><a href="#HashMap-HashSet-区别" class="headerlink" title="HashMap | HashSet 区别"></a>HashMap | HashSet 区别</h4><p>我们知道，HashSet底层是基于HashMap实现。</p>
<h5 id="1-HashSet如果检验重复"><a href="#1-HashSet如果检验重复" class="headerlink" title="1. HashSet如果检验重复"></a>1. HashSet如果检验重复</h5><pre><code>1. HashSet 计算对象的hashcode值来判断对象加入的位置，同时与其他加入的对象的hashcode值比较。如果没有相符的hashcode值则假设对象没有重复出现。否则调用equals()方法检查hashcode值相等的对象是否真的相同，如果两者相同，则加入操作失败。
</code></pre><h5 id="2-hashcode-equals-相关规定"><a href="#2-hashcode-equals-相关规定" class="headerlink" title="2. hashcode() | equals() 相关规定"></a>2. hashcode() | equals() 相关规定</h5><pre><code>如果两个对象相等，则hashcode一定也是相同的

两个对象相等,对两个equals方法返回true

两个对象有相同的hashcode值，它们也不一定是相等的

综上，equals方法被覆盖过，则hashCode方法也必须被覆盖

hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
</code></pre><h5 id="3-equals-区别"><a href="#3-equals-区别" class="headerlink" title="3. == | equals() 区别"></a>3. == | equals() 区别</h5><pre><code>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同

==是指对内存地址进行比较，equals()是对字符串的内容进行比较

==指引用是否相同，equals()指的是值是否相同
</code></pre><h3 id="HashMap-底层实现"><a href="#HashMap-底层实现" class="headerlink" title="HashMap 底层实现"></a>HashMap 底层实现</h3><h4 id="1-JDK-1-8-previous"><a href="#1-JDK-1-8-previous" class="headerlink" title="1. JDK 1.8 previous"></a>1. JDK 1.8 previous</h4><p>JDK1.8 之前 HashMap 底层是 ==数组和链表== 结合在一起使用也就是 ==链表散列==。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<blockquote>
<p>JDK 8 的hash()方法</p>
</blockquote>
<pre><code>static final int hash(Object key) {
  int h;
  // key.hashCode()：返回散列值也就是hashcode
  // ^ ：按位异或
  // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<h4 id="2-JDK-1-8-next"><a href="#2-JDK-1-8-next" class="headerlink" title="2. JDK 1.8 next"></a>2. JDK 1.8 next</h4><p>在 JDK 1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认是8）时，将链表转换为红黑树，以减少搜索时间。</p>
<p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
<h4 id="3-HashMap-的长度为何是2的幂次方"><a href="#3-HashMap-的长度为何是2的幂次方" class="headerlink" title="3. HashMap 的长度为何是2的幂次方"></a>3. HashMap 的长度为何是2的幂次方</h4><p>为让HashMap存取高效，尽量减少碰撞，即就是尽量让数据均匀分布。Hash值得取值范围大概有40亿的映射空间，只要哈希函数映射得比较均匀松散，一般难以出现碰撞，但是一个40亿长度的数组，内存是放不下的，所以这个散列值不能直接拿来用，在我们用之前需要先对数组的长度取模运算，得到的余数才能用来作为要存放的位置（对应数组下标）。这个数组下标的计算方法时：(n - 1) &amp; hash。（n表示数组长度）。所以这也就是为啥HashMap的长度要是2的幂次方。</p>
<h4 id="4-HashMap多线程操作导致死循环问题"><a href="#4-HashMap多线程操作导致死循环问题" class="headerlink" title="4. HashMap多线程操作导致死循环问题"></a>4. HashMap多线程操作导致死循环问题</h4><p>这里主要原因是因为 在并发下的 rehash() 操作造成元素之间会形成一个循环链表。在JDK 1.8之后解决了这个问题，但是还是不建议在多线程环境下使用HashMap，因为在多线程环境下使用HashMap还是会存在其它问题，如：数据丢失等。在并发环境下推荐使用：ConcurrentHashMap。</p>
<h3 id="ConcurrentHashMap-Hashtable-区别"><a href="#ConcurrentHashMap-Hashtable-区别" class="headerlink" title="ConcurrentHashMap | Hashtable 区别"></a>ConcurrentHashMap | Hashtable 区别</h3><p>Hashtable 与 ConcurrentHashMap 的区别主要体现在实现线程安全的方式不同。</p>
<h4 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a>1. 底层数据结构</h4><p>JDK 1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK 1.8 采用的数据结构跟HashMap JDK 1.8 的结构一样 数组+链表/红黑二叉树 。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<h4 id="2-实现线程安全的方式"><a href="#2-实现线程安全的方式" class="headerlink" title="==2. 实现线程安全的方式=="></a>==2. 实现线程安全的方式==</h4><p>① ==在JDK1.7的时候，ConcurrentHashMap（分段锁）== 对整个桶数组进行了分割分段(Segment)，==每一把锁只锁容器其中一部分数据==，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK 1.8 的时候已经摒弃了Segment的概念，而是直接用 ==Node 数组+链表+红黑树== 的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p>
<p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<h4 id="3-ConcurrentHashMap-线程安全的具体实现方式（底层具体实现）"><a href="#3-ConcurrentHashMap-线程安全的具体实现方式（底层具体实现）" class="headerlink" title="3. ConcurrentHashMap 线程安全的具体实现方式（底层具体实现）"></a>3. ConcurrentHashMap 线程安全的具体实现方式（底层具体实现）</h4><h5 id="1-JDK-1-7"><a href="#1-JDK-1-7" class="headerlink" title="1. JDK 1.7"></a>1. JDK 1.7</h5><p>首先将数据分为一段一段的存储，然后将每一段数据陪一把锁，当一个线程占用锁访问其中一个段数据时，其它段数据也能被其它线程访问。</p>
<blockquote>
<p>提示：ConcurrentHashMap 是由 Segment数组结构 和HashEntry 数组结构构成。</p>
</blockquote>
<p>Segment 实现了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<h5 id="2-JDK-1-8"><a href="#2-JDK-1-8" class="headerlink" title="2. JDK 1.8"></a>2. JDK 1.8</h5><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS和synchronized 来保证并发安全。数据结构跟 HashMap 1.8 的结构类似，==数组+链表/红黑二叉树==。Java  8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）</p>
<p>==synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。==</p>
<h3 id="comparable-comparator-区别"><a href="#comparable-comparator-区别" class="headerlink" title="comparable() | comparator 区别"></a>comparable() | comparator 区别</h3><ul>
<li>comparable 接口实际上是出自 java.lang 包，它有一个 compareTo(Object obj) 方法用来排序。</li>
<li>comparator 接口实际上是出自 java.util 包，它有一个 compare(Object o1, Object o2) 方法用来排序。</li>
</ul>
<p>一般地，如果我们需要对一个集合自定义排序时，我们需要重写 compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式：1. 重写方法。2. 使用两个参数版的Collections.sort()。</p>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h5 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h5><pre><code>1. ArrayList：Object数组

2. Vector：Object数组

3. LinkedList：双向链表（JDK 1.6之前为循环链表，JDK 1.7取消循环）
</code></pre><h5 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h5><pre><code>1. HashSet（无序|唯一）：基于HashMap实现，底层采用HashMap来保存元素。

2. LinkedHashSet：继承了HashSet，并且其内部是通过LinkedHashMap来实现的。

3. TreeSet（有序|唯一）：红黑树（自平衡排序二叉树）。
</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><p>JDK 1.8 之前HashMap由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（拉链法解决冲突）。JDK 1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转为红黑树，以减少搜索时间。</p>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是==基于拉链式散列结构即由数组和链表或红黑树==组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
<h5 id="3-Hashtable"><a href="#3-Hashtable" class="headerlink" title="3. Hashtable"></a>3. Hashtable</h5><p>数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<h5 id="4-TreeMap"><a href="#4-TreeMap" class="headerlink" title="4. TreeMap"></a>4. TreeMap</h5><p>红黑树（自平衡排序二叉树）</p>
<h3 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h3><p>主要根据集合的特点选用，如我们需要根据键值获取到元素值时就选用Map接口下的集合。需要排序时选择TreeMap，不需要排序时选择HashMap，需要保证线程安全时选用ConcurrentHashMap。只需要存放元素值时，选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合如：TreeSet或HashSet，不需要就选择List接口的ArrayList或LinkedList，然后再根据实现这些接口的集合特点来选用。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java8 新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java8 新特性/" itemprop="url">Java8 新特性</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:41:44+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-8/" itemprop="url" rel="index">
                    <span itemprop="name">Java 8</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,192
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><h2 id="一、Lambda-表达式"><a href="#一、Lambda-表达式" class="headerlink" title="==一、Lambda 表达式=="></a>==<strong>一、Lambda 表达式</strong>==</h2><h3 id="1-Lambda-表达式使用前后对比"><a href="#1-Lambda-表达式使用前后对比" class="headerlink" title="1. Lambda 表达式使用前后对比"></a>1. Lambda 表达式使用前后对比</h3><h4 id="使用前："><a href="#使用前：" class="headerlink" title="使用前："></a>使用前：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"我爱北京天安门！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	r1.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">			System.out.println(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	con.accept(<span class="string">"熙熙攘攘"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用后："><a href="#使用后：" class="headerlink" title="使用后："></a>使用后：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一：	</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Runnable r2 = () -&gt; System.out.println(<span class="string">"我爱这三秦大地！"</span>);</span><br><span class="line">	r2.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Consumer&lt;String&gt; con2 = (String t) -&gt; System.out.println(t);</span><br><span class="line">	con2.accept(<span class="string">"多么美丽"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Lambda-表达式的基本语法"><a href="#2-Lambda-表达式的基本语法" class="headerlink" title="2.Lambda 表达式的基本语法"></a>2.Lambda 表达式的基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*   <span class="number">1</span>. 举例：</span><br><span class="line">*     (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">*  <span class="number">2</span>. 格式：</span><br><span class="line">*     -&gt; ：Lambda操作符 或 箭头操作符</span><br><span class="line">*     -&gt; 左边： Lambda形参列表（其实就是接口中的抽象方法的形参列表）</span><br><span class="line">*     -&gt; 右边： Lambda 体（其实就是重写的抽象方法的方法体）</span><br></pre></td></tr></table></figure>
<h3 id="3-Lambda-表达式的使用（6种情况）"><a href="#3-Lambda-表达式的使用（6种情况）" class="headerlink" title="3.Lambda 表达式的使用（6种情况）"></a>3.Lambda 表达式的使用（6种情况）</h3><h4 id="无参，无返回值。"><a href="#无参，无返回值。" class="headerlink" title="无参，无返回值。"></a>无参，无返回值。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"我爱北京天安门！"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   r1.run();</span><br><span class="line">   System.out.println(<span class="string">"*********************************"</span>);</span><br><span class="line">   </span><br><span class="line">   Runnable r2 = () -&gt; System.out.println(<span class="string">"我爱这三秦大地！"</span>);</span><br><span class="line">   r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="需要一个参数，无返回值。"><a href="#需要一个参数，无返回值。" class="headerlink" title="需要一个参数，无返回值。"></a>需要一个参数，无返回值。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   con.accept(<span class="string">"熙熙攘攘"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; con2 = (String t) -&gt; System.out.println(t);</span><br><span class="line">   con2.accept(<span class="string">"多么美丽"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型推断。"><a href="#类型推断。" class="headerlink" title="类型推断。"></a>类型推断。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Consumer&lt;String&gt; con = (String t) -&gt; System.out.println(t);</span><br><span class="line">   con.accept(<span class="string">"西安城墙"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"*********************"</span>);</span><br><span class="line">   <span class="comment">//类型推断</span></span><br><span class="line">   Consumer&lt;String&gt; con2 = (t) -&gt; System.out.println(t);</span><br><span class="line">   con2.accept(<span class="string">"威武雄壮"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda-若只需要一个参数，参数的小括号可以省略"><a href="#Lambda-若只需要一个参数，参数的小括号可以省略" class="headerlink" title="Lambda 若只需要一个参数，参数的小括号可以省略"></a>Lambda 若只需要一个参数，参数的小括号可以省略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Consumer&lt;String&gt; con = (String t) -&gt; System.out.println(t);</span><br><span class="line">   con.accept(<span class="string">"西安城墙"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"*********************"</span>);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; con1 = t -&gt; System.out.println(t);</span><br><span class="line">   con1.accept(<span class="string">"威武雄壮"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda-需要两个或者多个参数，多条执行语句，并且可以有返回值"><a href="#Lambda-需要两个或者多个参数，多条执行语句，并且可以有返回值" class="headerlink" title="Lambda 需要两个或者多个参数，多条执行语句，并且可以有返回值"></a>Lambda 需要两个或者多个参数，多条执行语句，并且可以有返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">   System.out.println(<span class="string">"******************************"</span>);</span><br><span class="line">   Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">      System.out.println(o1);</span><br><span class="line">      System.out.println(o2);</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当-lambda-体只有一条语句时，return-与大括号若有，都可以省略"><a href="#当-lambda-体只有一条语句时，return-与大括号若有，都可以省略" class="headerlink" title="当 lambda 体只有一条语句时，return 与大括号若有，都可以省略"></a>当 lambda 体只有一条语句时，return 与大括号若有，都可以省略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"***********************"</span>);</span><br><span class="line">   </span><br><span class="line">   Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">   System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h3><p>​    <strong>-&gt; 左边</strong>：Lambda 形参列表的参数类型可以省略（类型推断），如果形参列表只有一个参数，其一对() 也可以省略</p>
<p>​    <strong>-&gt; 右边</strong>： Lambda体 应该使用一对{} 包裹，如果只有一条执行语句（可能是return 语句），可以省略大括号以及 return 关键字</p>
<h3 id="5-Lambda-表达式的实质"><a href="#5-Lambda-表达式的实质" class="headerlink" title="5.Lambda 表达式的实质"></a>5.Lambda 表达式的实质</h3><p>==Lambda表达式的本质： 作为函数式接口的实例。==</p>
<h3 id="6-何时使用Lambda表达式："><a href="#6-何时使用Lambda表达式：" class="headerlink" title="6.何时使用Lambda表达式："></a>6.何时使用Lambda表达式：</h3><p><strong>当需要给一个函数式接口实例化的时候，可以使用Lambda表达式。</strong></p>
<p>以前可以通过匿名实现类表示的现在都可以用Lambda表达式来书写.</p>
<h3 id="7-常使用的Lambda表达式"><a href="#7-常使用的Lambda表达式" class="headerlink" title="7.常使用的Lambda表达式"></a>7.常使用的Lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的Lambda 表达式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 集合遍历</span></span><br><span class="line">   List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">   list.forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   list.forEach(t -&gt; System.out.print(t + <span class="string">" "</span>));</span><br><span class="line">   list.forEach(System.out :: println);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 集合排序</span></span><br><span class="line">   list.sort(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   list.sort((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">   list.sort(Integer :: compareTo);</span><br><span class="line">   <span class="comment">//开启线程</span></span><br><span class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"run"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"run1"</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、函数式接口"><a href="#二、函数式接口" class="headerlink" title="二、函数式接口"></a>二、函数式接口</h2><h3 id="1-什么是函数接口："><a href="#1-什么是函数接口：" class="headerlink" title="1.什么是函数接口："></a>1.什么是函数接口：</h3><p>​    <strong>如果一个接口只声明了一个抽象方法，那么这个接口就成为函数式接口</strong>，我们可以在接口上面使用@FunctionalInterface 这个注解，用来检查它是否是一个函数式接口</p>
<h3 id="2-Java内置四大核心函数式接口"><a href="#2-Java内置四大核心函数式接口" class="headerlink" title="2.Java内置四大核心函数式接口"></a>2.Java内置四大核心函数式接口</h3><p>消费型接口：Consumer<t>         void accept(T t)<br>供给型接口：Supplier<t>             T get()<br>函数型接口：Function&lt;T, R&gt;         R apply(T t)<br>断定型接口：Predicate<t>         boolean test(T t)</t></t></t></p>
<h3 id="3-何时使用函数式接口："><a href="#3-何时使用函数式接口：" class="headerlink" title="3.何时使用函数式接口："></a>3.何时使用函数式接口：</h3><p>如果我们的开发中需要定义一个函数式接口，首先看看在已有的JDK提供的函数式接口是否提供了能满足需求的函数式接口，如果有则直接使用即可。</p>
<h2 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h3><p>方法引用可以看做是 Lambda 表达式的深层次的表达，换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，<strong>也可以认为是 Lambda 表达式的一个语法糖。</strong></p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><p>​    当要传递给Lambda 体的操作，已经有实现的方法了，可以使用方法引用。</p>
<h3 id="3-格式"><a href="#3-格式" class="headerlink" title="3.格式"></a>3.格式</h3><p>​    类（对象） :: 方法名</p>
<h3 id="4-分为以下三种情况"><a href="#4-分为以下三种情况" class="headerlink" title="4.分为以下三种情况"></a>4.分为以下三种情况</h3><p>对象     ：：     非静态方法<br>类     ：：     静态方法</p>
<p>类     ：：     非静态方法</p>
<h3 id="5-要求"><a href="#5-要求" class="headerlink" title="5.要求"></a>5.要求</h3><p>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同。(针对 情况1 或者 情况2)</p>
<p><strong>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或者无参数）时： ClassName  :: methodName</strong></p>
<h3 id="6-使用建议"><a href="#6-使用建议" class="headerlink" title="6.使用建议"></a>6.使用建议</h3><p>如果给函数式接口提供实例，恰好满足我们的方法引用的要求，大家就可以考虑给我们的函数式接口提供实例，如果不熟悉方法引用，那么还可以使用 Lambda 表达式。</p>
<h3 id="7-使用举例："><a href="#7-使用举例：" class="headerlink" title="7.使用举例："></a>7.使用举例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//情况一： 对象 ：： 实例方法</span></span><br><span class="line">   <span class="comment">//Consumer 中的void accept(T t)</span></span><br><span class="line">   <span class="comment">//PrintStream 中的 void println (T t)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">      con1.accept(<span class="string">"西安"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"*********************"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//对象调用非静态方法</span></span><br><span class="line">      PrintStream ps = System.out;</span><br><span class="line">      Consumer&lt;String&gt; con2 = ps :: println;</span><br><span class="line">      con2.accept(<span class="string">"XiAn"</span>);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Employee emp = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Tom"</span>, <span class="number">23</span>, <span class="number">8000.00</span>);</span><br><span class="line">      Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">      System.out.println(sup1.get());</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"***********"</span>);</span><br><span class="line">      Supplier&lt;String&gt; sup2 = emp :: getName;</span><br><span class="line">      System.out.println(sup2.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//情况二： 类 ：： 静态方法</span></span><br><span class="line">   <span class="comment">//Comparator 中的int compare(T t1, T t2)</span></span><br><span class="line">   <span class="comment">//Integer 中的 int compare(T t1, T t2)</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);</span><br><span class="line">      System.out.println(com1.compare(<span class="number">12</span>, <span class="number">32</span>));</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">      Comparator&lt;Integer&gt; com2 = Integer :: compare;</span><br><span class="line">      System.out.println(com1.compare(<span class="number">12</span>, <span class="number">32</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Function 中的 R apply(T t)</span></span><br><span class="line">   <span class="comment">//Math 中的 round (Double d)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Function&lt;Double, Long&gt; func = <span class="keyword">new</span> Function&lt;Double, Long&gt;() &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Double t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.round(t);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      System.out.println(func.apply(<span class="number">1.2324</span>));</span><br><span class="line">      System.out.println(<span class="string">"**************************"</span>);</span><br><span class="line"></span><br><span class="line">      Function&lt;Double, Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">      System.out.println(func1.apply(<span class="number">1.2324</span>));</span><br><span class="line">      System.out.println(<span class="string">"**************************"</span>);</span><br><span class="line">      </span><br><span class="line">      Function&lt;Double, Long&gt; func2 = Math :: round;</span><br><span class="line">      System.out.println(func2.apply(<span class="number">1.243</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//情况三： 类 ：： 实例方法（有难度）</span></span><br><span class="line">   <span class="comment">//Comparator 中的int compare(T t1, T t2)</span></span><br><span class="line">   <span class="comment">//String 中的 int t1.compareTo(t2)</span></span><br><span class="line">   <span class="comment">// t1 作为调用者 调用 t2</span></span><br><span class="line">   <span class="meta">@Test</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">      System.out.println(com1.compare(<span class="string">"abc"</span>, <span class="string">"abd"</span>));</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"********************************"</span>);</span><br><span class="line">      Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">      System.out.println(com2.compare(<span class="string">"abc"</span>, <span class="string">"abd"</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      BiPredicate&lt;String,    String&gt; pre1 = (str1, str2) -&gt; str1.equals(str2);</span><br><span class="line">      System.out.println(pre1.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>));</span><br><span class="line">      BiPredicate&lt;String,    String&gt; pre2 = String :: equals;</span><br><span class="line">      System.out.println(pre2.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、构造器引用以及数组引用"><a href="#四、构造器引用以及数组引用" class="headerlink" title="四、构造器引用以及数组引用"></a>四、构造器引用以及数组引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器引用：</span></span><br><span class="line"><span class="comment">//Supplier 中的 T get()</span></span><br><span class="line"><span class="comment">//Employee 中的无参构造器： Employee()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">   System.out.println(sup1.get());</span><br><span class="line">   System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">   Supplier&lt;Employee&gt; sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">   System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function 中的 R apply (T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Function&lt;Integer, Employee&gt; func1 = id -&gt; <span class="keyword">new</span> Employee(id);</span><br><span class="line">   System.out.println(func1.apply(<span class="number">1001</span>));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">   Function&lt;Integer, Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">   System.out.println(func2.apply(<span class="number">1002</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组引用</span></span><br><span class="line"><span class="comment">//Function 中的 R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Function&lt;Integer , String[]&gt; function = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">   System.out.println(Arrays.toString(function.apply(<span class="number">3</span>)));</span><br><span class="line">   Function&lt;Integer , String[]&gt; function1 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">   System.out.println(Arrays.toString(function1.apply(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、Stream-API"><a href="#五、Stream-API" class="headerlink" title="==五、Stream API=="></a>==<strong>五、Stream API</strong>==</h2><h3 id="1-Stream-API-的理解"><a href="#1-Stream-API-的理解" class="headerlink" title="1.Stream API 的理解"></a>1.Stream API 的理解</h3><ul>
<li>Stream 关注的是对数据的运算，与CPU打交道。集合关注的是对数据的存储，与内存打交道。    </li>
<li>Java8 提供了一套api，使用这套api可以对内存中的数据进行过滤，排序，映射，规约等操作，类似于sql语句。</li>
</ul>
<h3 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2.注意点"></a>2.注意点</h3><p>①：Stream 自己不会存储元素<br>②：Stream 不会改变原对象，相反，他们会返回一个持有结果的新的Stream。<br>③：Stream 的操作时延迟执行的。这也就意味着他们会等到需要结果的时候才执行</p>
<h3 id="3-Stream的使用流程"><a href="#3-Stream的使用流程" class="headerlink" title="3.Stream的使用流程"></a>3.Stream的使用流程</h3><p>①：Stream 的实例化<br>②：一系列的中间操作（过滤，映射，规约等）<br>③：终止操作。</p>
<h3 id="4-使用流程的注意点"><a href="#4-使用流程的注意点" class="headerlink" title="4.使用流程的注意点"></a>4.使用流程的注意点</h3><p>4.1 一个中间操作链，对数据源的数据进行处理。<br>4.2 一旦执行终止操作，就执行中间操作链，之后，<strong>不会再被使用</strong></p>
<h3 id="5-步骤一：Stream的实例化"><a href="#5-步骤一：Stream的实例化" class="headerlink" title="5.步骤一：Stream的实例化"></a>5.步骤一：Stream的实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest1</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式一：通过集合</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">      Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//default Stream&lt;E&gt; parallelstream() : 返回一个并行流</span></span><br><span class="line">      Stream&lt;Employee&gt; parallelstream = employees.parallelStream();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式二：通过数组</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">      <span class="comment">//调用Arrays类中的 static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) 返回一个流</span></span><br><span class="line">      IntStream intStream = Arrays.stream(arr);</span><br><span class="line">      </span><br><span class="line">      Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Tyrone"</span>);</span><br><span class="line">      Employee e2 = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Monkey"</span>);</span><br><span class="line">      Employee[] emps = &#123;e1, e2&#125;;</span><br><span class="line">      Stream&lt;Employee&gt; stream1 = Arrays.stream(emps);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式三：通过Stream的of()</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建 Stream 方式四：创建无限流</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代</span></span><br><span class="line">      <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">      <span class="comment">// 遍历前十个偶数</span></span><br><span class="line">      Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//生成</span></span><br><span class="line">      <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate()</span></span><br><span class="line">      Stream.generate(Math :: random).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-步骤二：中间操作"><a href="#6-步骤二：中间操作" class="headerlink" title="6.步骤二：中间操作"></a>6.步骤二：中间操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 筛选与切片</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//filter ( Predicate p) —接收 Lambda ， 从流中排除某些元素</span></span><br><span class="line">      Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">      <span class="comment">//练习查询员工工资大于 7000的 员工信息</span></span><br><span class="line">      stream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out :: println);</span><br><span class="line">      System.out.println(<span class="string">"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line">      <span class="comment">//limit — 截断流，使其元素不超过给定数量 </span></span><br><span class="line">      <span class="comment">//这里一定要重新生成一个stream </span></span><br><span class="line">       list.stream().limit(<span class="number">3</span>).forEach(System.out :: println);</span><br><span class="line">       System.out.println(<span class="string">"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//skip—跳过元素，返回一个扔掉了前 n 个元素的流，若流中元素不足 n 个，则返回一个空流。 </span></span><br><span class="line">       list.stream().skip(<span class="number">3</span>).forEach(System.out :: println);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//distinct —筛选，通过流所生成的元素 hashcode 和 equals 去除重复元素。</span></span><br><span class="line">      list.stream().distinct();<span class="comment">//其实就是元素去重而已</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 2. 映射</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//map(function f) 接受一个函数作为参数 将元素转换成其他形式的提取信息</span></span><br><span class="line">      List&lt;String&gt; list = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">      list.stream().map(str -&gt;str.toUpperCase()).forEach(System.out :: println);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//练习1： 获取员工姓名长度大于3的员工的姓名</span></span><br><span class="line">      List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;String&gt; names = employees.stream().map(e -&gt; e.getName());</span><br><span class="line">        names.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习2：</span></span><br><span class="line">      Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest2::StringToStream);</span><br><span class="line">      streamStream.forEach(s -&gt; &#123;</span><br><span class="line">         s.forEach(System.out :: println);</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(<span class="string">"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//flatMap(Function f) ——接收一个函数作为参数，将流中的每个值都转换称为另外一个流，然后把所有的流连接成一个流。</span></span><br><span class="line">      <span class="comment">//适用于 Stream 套 Stream</span></span><br><span class="line">      Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest2::StringToStream);</span><br><span class="line">      characterStream.forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//将字符串中的多个字符添加到 list 之中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Stream&lt;Character&gt; <span class="title">StringToStream</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">      ArrayList list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(Character c : str.toCharArray() ) &#123;</span><br><span class="line">         list.add(c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list.stream();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//sorted() 自然排序</span></span><br><span class="line">      <span class="comment">//sorted(Comparator com) 定制排序</span></span><br><span class="line">      List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">343</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">76</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">5646</span>, <span class="number">44</span>, -<span class="number">12</span>, -<span class="number">56</span>);</span><br><span class="line">      list1.stream().sorted().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将会抛出异常</span></span><br><span class="line">      <span class="comment">//List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line">      <span class="comment">//employees.stream().sorted().forEach(System.out :: println);</span></span><br><span class="line">      <span class="comment">//定制排序</span></span><br><span class="line">      List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">      employees.stream().sorted((e1, e2) -&gt; &#123;</span><br><span class="line">          <span class="keyword">int</span> index = Integer.compare(e1.getAge(), e2.getAge());</span><br><span class="line">          <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(e1.getSalary(), e2.getSalary());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-步骤三：终止操作"><a href="#7-步骤三：终止操作" class="headerlink" title="7.步骤三：终止操作"></a>7.步骤三：终止操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest3</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 匹配与查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">//        检查是否匹配所有元素</span></span><br><span class="line">        <span class="comment">//练习 ： 是否所有的员工的年龄全大于 18 岁</span></span><br><span class="line">        System.out.println(employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>));</span><br><span class="line"><span class="comment">//        检查是否至少匹配一个元素</span></span><br><span class="line">        <span class="comment">//是否存在员工工资大于 10000 的</span></span><br><span class="line">        System.out.println(employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>));</span><br><span class="line"><span class="comment">//        检查是否没有匹配元素</span></span><br><span class="line">        <span class="comment">//是否存在员工姓 “小”</span></span><br><span class="line">        System.out.println(employees.stream().allMatch(e -&gt; e.getName().startsWith(<span class="string">"小"</span>)));</span><br><span class="line"><span class="comment">//        返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; first = employees.stream().findFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line"><span class="comment">//        返回任意一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; any = employees.parallelStream().findAny();</span><br><span class="line">        System.out.println(any);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">//        返回元素的个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//        返回流中的最大值(最大年龄)</span></span><br><span class="line">        Stream&lt;Double&gt; doubleStream = employees.stream().map(employee -&gt; employee.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; max = doubleStream.max(Double::compareTo);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        <span class="comment">//返回流中的最小值 （最小年龄的员工）</span></span><br><span class="line">        Optional&lt;Employee&gt; min = employees.stream().min((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()));</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//内部迭代</span></span><br><span class="line">        employees.stream().forEach(System.out :: println);</span><br><span class="line">        System.out.println(<span class="string">"=-============================================="</span>);</span><br><span class="line">        employees.forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 规约</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reduce() 可以将流中的元素反复结合起来，得到一个值，返回</span></span><br><span class="line">        <span class="comment">//练习 ： 计算 1 - 10 的和</span></span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        Integer sum = integers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reduce()</span></span><br><span class="line">        <span class="comment">//计算所有员工的工资的总和</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Double&gt; salary = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; sumMoney = salary.reduce((d1, d2) -&gt; d1 + d2);</span><br><span class="line"><span class="comment">//        Optional&lt;Double&gt; sumMoney = salary.reduce(Double :: sum);</span></span><br><span class="line">        System.out.println(sumMoney);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 收集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//collect() —— 将流转换为其他形式。接受一个Collector 接口的实现，用于给Stream</span></span><br><span class="line">        <span class="comment">//练习： 查找工资大于 6000 的员工， 结果返回一个 List 或 Set</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line">        employeeList.forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、Optional类的使用"><a href="#六、Optional类的使用" class="headerlink" title="六、Optional类的使用"></a>六、Optional类的使用</h2><h3 id="1-理解："><a href="#1-理解：" class="headerlink" title="1.理解："></a>1.理解：</h3><p>==<strong>为了解决空指针而生</strong>==</p>
<p>Optional<t> 类 是一个容器类，他可以保存类型T的值，代表这个值存在。或仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在Optional 可以更好地表达这个概念，<strong>而且可以避免空指针异常。</strong></t></p>
<h3 id="2-常用方法："><a href="#2-常用方法：" class="headerlink" title="2.常用方法："></a>2.常用方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个空的opti 对象, 里面的 value 为 null</span></span><br><span class="line">        Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">        <span class="keyword">if</span>(!op1.isPresent()) &#123; <span class="comment">//判断是否包含数据 （false 表示不包含）</span></span><br><span class="line">            System.out.println(<span class="string">"数据为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        <span class="comment">//如果封装到数据 value 为空 则 get 报错</span></span><br><span class="line">        <span class="comment">//System.out.println(op1.get());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="comment">//把对象封装进 Optional ， of(T t)方法要求 t 不能为空</span></span><br><span class="line">        <span class="comment">//* @param value the value to be present, which must be non-null</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">        <span class="comment">// get 通常与 of 搭配使用 用于 获取 内部的数据</span></span><br><span class="line">        System.out.println(op1.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String str  = "beijing";</span></span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// ofNullable( T t) : 封装数据 t 赋给 Optional， 不要求 t 非空</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">        <span class="comment">// orElse(T t) : 如果 Optional 内部的 value 为空，则返回 t，非空 返回 value</span></span><br><span class="line">        String str2 = op1.orElse(<span class="string">"shanghai"</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-典型练习："><a href="#3-典型练习：" class="headerlink" title="3.典型练习："></a>3.典型练习：</h3><p>总之 Optional 就是为了尽可能避免 空指针异常而出现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 Optional 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGirlName2</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line">    Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">    Boy boy1 = boyOptional.orElse(<span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">"琪琪"</span>)));</span><br><span class="line">    Girl girl = boy1.getGirl();</span><br><span class="line">    Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">    Girl girl1 = girlOptional.orElse(<span class="keyword">new</span> Girl(<span class="string">"小芳"</span>));</span><br><span class="line">    <span class="keyword">return</span> girl1.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java容器框架 - List集合与源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java容器框架 - List集合与源码分析/" itemprop="url">Java集合框架 - ArrayList与源码分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:32:43+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA-容器/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA 容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  513
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java集合框架-ArrayList与源码分析"><a href="#Java集合框架-ArrayList与源码分析" class="headerlink" title="Java集合框架 - ArrayList与源码分析"></a>Java集合框架 - ArrayList与源码分析</h2><pre><code>//ArrayList继承关系
java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractList&lt;E&gt;
               ↳     java.util.ArrayList&lt;E&gt;

public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}
</code></pre><p>ArrayList继承了AbstractList，实现了List。它是一个数组队列，相当于动态数组。提供了相关的添加、删除、修改和遍历等功能。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList实现了RandomAccess接口，即提供了随机访问功能。RandomAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号来快速获取元素对象，这就是快速随机访问。后面会比较List的“快速随机访问”和使用“Iterator迭代器访问”的效率。</p>
<p>ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>
<p>ArrayList实现了java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>
<blockquote>
<p>注意：和Vector不同，ArrayList中的操作是非线程安全的。所以建议在单线程中使用ArrayList，在多线程中选择Vector或者CopyOnWriteArrayList。</p>
</blockquote>
<blockquote>
<p>提示：1. ArrayList是基于动态数组实现的，在增删时候，需要数组的拷贝复制。</p>
<ol start="2">
<li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍。</li>
<li>删除元素时不会减少容量，若希望减少容量则调用trimToSize()。</li>
<li>它不是线程安全的。它能存放null值。</li>
</ol>
</blockquote>
<h3 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h3><p>Vector底层也是数组，与ArrayList最大的区别就是：同步（线程安全）。</p>
<p>在要求非同步的情况下，我们一般都是使用ArrayList来替代Vector的。</p>
<p>如果想要ArrayList实现同步，可以使用Collections的方法：</p>
<pre><code>List list = Collections.synchronizedList(new ArrayList(...));
</code></pre><p>就可以实现同步了。</p>
<p>还有另外的一个区别：ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector扩展1倍。</p>
<h3 id="LinkedList-解析"><a href="#LinkedList-解析" class="headerlink" title="LinkedList 解析"></a>LinkedList 解析</h3><p>LinkedList底层是双向链表，</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java底层知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java底层知识/" itemprop="url">Java底层知识</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:33:13+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,347
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java底层知识"><a href="#Java底层知识" class="headerlink" title="Java底层知识"></a>Java底层知识</h2><p>[TOC]</p>
<h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，将字节码转换成具体平台上的机器指令。</p>
<blockquote>
<p>提示：JVM不将源码直接解析成机器码去执行的原因是因为，如果直接解析成机器码执行，那么每次还需要重新检测语法、句法、语义，这样一来整体的性能就会受到影响。</p>
</blockquote>
<h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><pre><code>JVM的组成

    1.Class Loader 依据特定格式，加载.class文件到内存

    2.Execution Engine 对命令进行解析

    3.Runtime Data Area JVM内存空间结构模型

    4.Native Interface (本地接口) 作用是融合不同的开发语言的原生库为Java所用
</code></pre><h3 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code>类从编译到执行的过程

    1.编译器将xxx.java源文件编译成xxx.class字节码文件

    2.ClassLoader将字节码转换成JVM中的Class&lt;xxx&gt;对象

    3.JVM利用Class&lt;xxx&gt;对象实例化为xxx对象
</code></pre><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流，它是Java的核心组件，所有的Class都有ClassLoader进行加载，ClassLoader负责通过Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化等操作。</p>
<pre><code>ClassLoader的种类：

    1.BootStrapClassLoader 加载核心库java.*

    2.ExtClassLoader 加载扩展库javax.*

    3.AppClassLoader 加载程序所在目录

    4.自定义ClassLoader

        关键函数

            findClass

            defineClass
</code></pre><h3 id="ClassLoader双亲委派机制"><a href="#ClassLoader双亲委派机制" class="headerlink" title="ClassLoader双亲委派机制"></a>ClassLoader双亲委派机制</h3><pre><code>提示：使用双亲委派机制去加载类的原因：1.避免多份同样字节码的加载。2.
</code></pre><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><pre><code>1.隐式加载 new

2.显示加载 loadClass forName等

    类的装载过程

        1.加载 通过ClassLoader加载class文件字节码，生成Class对象

        2.链接

            1.校验 检查加载的class的正确性和安全性

            2.准备 为类变量分配存储空间并设置类变量初始值

            3.解析 JVM将常量池内的符号引用转换为直接引用

        3.初始化 执行类变量赋值和静态代码块
</code></pre><h4 id="loadClass-forName-的区别"><a href="#loadClass-forName-的区别" class="headerlink" title="loadClass | forName 的区别"></a>loadClass | forName 的区别</h4><pre><code>1.Class.forName得到的class是已经初始化完成的

2.Classloader.loadClass得到的class是还没有链接的
</code></pre><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><pre><code>1.当前线程所执行的字节码行号指示器（逻辑）

2.改变计数器的值来选取下一条需要执行的字节码指令

3.和线程是一对一的关系，即线程私有

4.对Java方法计数，如果是Native方法则计数器值为undefined

5.不会发生内存泄漏
</code></pre><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><pre><code>1.Java方法执行的内存模型

2.包含多个栈帧


    局部变量表：包含方法执行过程中的所有变量

    操作数栈：入栈、出栈、复制、变换、产生消费变量
</code></pre><h4 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h4><pre><code>1.JVM三大性能调优参数

    -Xms 

        规定每个线程虚拟机栈的大小 （堆栈）

    -Xmx

        堆的初始值

    -Xss

        堆能达到的最大值
</code></pre><h5 id="Java内存中堆和栈的区别（内存分配策略）"><a href="#Java内存中堆和栈的区别（内存分配策略）" class="headerlink" title="Java内存中堆和栈的区别（内存分配策略）"></a>Java内存中堆和栈的区别（内存分配策略）</h5><pre><code>1.静态存储：编译时确定每个数据目标在运行时的存储空间需求

2.栈式存储：数据区需求在编译时未知，运行时模块入口前确定

3.堆式存储：编译时或运行时模块入口都无法确定，动态分配

堆和栈的联系：

    1.引用对象、数组时，栈里定义变量保存堆中目标的首地址

        在栈内存中存的地址（指向对应堆内存空间），在堆内存中存的是new出来的对象实例和数组

    2.管理方式：栈自动释放，堆需要GC

    3.空间大小：栈空间大小比堆小

    4.碎片相关：栈产生的碎片远小于堆

    5.分配方式：栈支持静态和动态分配，而堆仅支持动态分配

    6.效率：栈的效率要比堆高
</code></pre><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><pre><code>1.可以作为GC Root的对象

    1.虚拟机栈中引用的对象（栈帧中的本地变量表）

    2.方法区中的常量引用的对象

    3.方法区中的类静态属性引用的对象

    4.本地方法栈中JNI(Native方法)的引用对象

    5.活跃线程的引用对象

2.垃圾回收算法（不再做笔记）

    1.标记-清除

    2.复制

        1.解决碎片化问题

        2.顺序分配内存，简单高效

        3.适用于对象存活率低的场景

    3.标记-整理

    4.分代收集

        1.GC分类：

            1.Minor GC

            2.Full GC

        2.年轻代：尽可能快速地收集掉那些生命周期短的对象

            1.Eden区

            2.两个Survivor区

        3.对象晋升到老年代

            1.经历一定Minor次数依然存活的对象

            2.Survivor区或Eden区中存放不下的对象

            3.新生成的大对象（-XX:+PretenuerSizeThreshold命令控制对象大小）

        4.常用性能调优参数

            1.-XX:SurvivorRatio：Eden和Survivor的比值，默认8:1

            2.-XX:NewRatio：老年代和年轻代内存大小的比值

            3.-XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值

        4.老年代：存放生命周期较长的对象

        5.触发Full GC的条件

            1.老年代空间不足

            2.永久代空间不足

            3.Minor GC晋升到老年代的平均大小大于老年代的剩余空间

            4.调用System.gc()

        6.stop-the-world

            1.JVM由于要执行GC而停止了应用程序的执行

            2.任何一种GC算法中都会发生

            3.多数GC优化都是通过减少stop-the-world发生的时间来提高性能优化

        7.safepoint

            1.分析过程中对象引用关系不会发生变化的点

            2.产生safepoint的地方：方法调用、循环跳转、异常跳转等

            3.安全点的数量要适中
</code></pre><h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h4><pre><code>1.JVM的运行模式

    1.Server 启动较慢，启动之后程序运行较快

    2.Client 相反地

    提示：可以利用 java -version 命令来查看JVM的运行模式

2.年轻代常见的垃圾收集器

    1.Serial收集器（命令 -XX:UseSerialGC 命令可以让JVM在年轻代处理垃圾回收，是复制算法）

        1.单线程收集，进行垃圾收集时，必须暂停所有工作线程

        2.简单高效，Client模式下默认的年轻代收集器

    2.ParNew收集器（命令 -XX:UseParNewGC 命令可以让JVM在年轻代处理垃圾回收，复制算法）

        1.多线程回收，其余行为特点和Serial收集器一样

        2.单核执行效率不如Serial，在多核执行才有优势

    3.Parallel Scavenge收集器（命令 -XX:+UseParallelGC 命令...，复制算法）

        1.吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

        2.比起关注用户线程停顿时间，更关注系统的吞吐量

        3.在多核下执行才有优势，Server模式下默认的年轻代收集器

3.老年代常用的垃圾收集器

    1.Serial Old收集器（命令 -XX:+UseSerialOldGC 命令...，标记-整理算法）

        1.单线程收集，进行垃圾收集时，必须暂停所有工作线程

        2.简单高效，Client模式下默认的老年代收集器

    2.Parallel Old收集器（命令 -XX:+UseParallelOldGC 命令...，标记-整理）

        1.多线程，吞吐量优先

    3.CMS收集器（命令 -XX:+UseConcMarkSweepGC 命令...，标记-清除）

        垃圾收集过程：

            1.初始标记：stop-the-world

            2.并发标记：并发追溯标记，程序不会停顿

            3.并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象

            4.重新标记：暂停虚拟机，扫描CMS堆中的剩余对象

            5.并发清理：清理垃圾对象，程序不会停顿

            6.并发重置：重置CMS收集器的数据结构


4.年轻代和老年代通用

    1.G1垃圾收集器（-XX:+UseG1GC 复制+标记-整理算法）

        Garbage First 收集器的特点：

            1.并发和并行

            2.分代收集

            3.空间整合

            4.可预测的停顿

            5.将整个Java堆内存划分为多个大小相等的Region

            6.年轻代和老年代不再物理隔离

            7.
</code></pre><h3 id="GC面试题"><a href="#GC面试题" class="headerlink" title="GC面试题"></a>GC面试题</h3><h4 id="1-Object的finalize-方法的作用是否与C-的析构函数作用相同"><a href="#1-Object的finalize-方法的作用是否与C-的析构函数作用相同" class="headerlink" title="1.Object的finalize()方法的作用是否与C++的析构函数作用相同"></a>1.Object的finalize()方法的作用是否与C++的析构函数作用相同</h4><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><pre><code>1.javap -c 对编译之后的.class文件作反汇编操作

2.javac 编译生成字节码 .class 文件

3.
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java集合框架 - Collection架构与源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java集合框架 - Collection架构与源码分析/" itemprop="url">Java集合框架 - Collection架构与源码分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:33:49+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java集合/" itemprop="url" rel="index">
                    <span itemprop="name">Java集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,244
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java集合框架-Collection架构与源码分析"><a href="#Java集合框架-Collection架构与源码分析" class="headerlink" title="Java集合框架 - Collection架构与源码分析"></a>Java集合框架 - Collection架构与源码分析</h2><p>Collection是一个接口，它主要的两个分支是List和Set。List和Set都是接口，它们继承与Collection。List是有序的队列，可以用重复的元素；而Set是数学概念中的集合，不能有重复的元素。List和Set都有它们各自的实现类。</p>
<p>我们抽象出AbstractCollection类来让其他类继承，该类实现类Collection中的绝大部分方法。AbstractList和AbstractSet都继承与AbstractCollection，具体的List实现类继承与AbstractList，而Set的实现类则继承与AbstractSet。</p>
<p>Collection中有个iterator()方法，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>//Collection定义
public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}
</code></pre><p>从Collection的定义可以看出，Collection是一个接口。是一个高度抽象出来的集合，包含了集合的基本操作：添加|删除|清空|遍历|是否为空|获取大小等。Collection接口的所有子类都必须实现2中构造函数：1.不带参数的构造函数。2.参数为Collection的构造函数。ps：带参数的构造函数可以用来转换Collection类型。</p>
<pre><code>// Collection的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void            clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]        toArray()
</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code>//List定义
public interface List&lt;E&gt; extends Collection&lt;E&gt; {}
</code></pre><p>从List定义可以得到，List接口继承Collection接口即List是集合的一种。List是有序的队列，List中的每一个元素都有一个索引，第一个元素的索引值为0，往后的元素的索引值依次+1.，List中允许有重复的元素。List继承Collection自然包含了Collection的所有接口，由于List是有序队列，所以它也有自己额外的API接口。</p>
<pre><code>// Collection的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void            clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]        toArray()
// 相比与Collection，List新增的API：
abstract void                add(int location, E object) //在指定位置添加元素
abstract boolean             addAll(int location, Collection&lt;? extends E&gt; collection) //在指定位置添加其他集合中的元素
abstract E                   get(int location) //获取指定位置的元素
abstract int                 indexOf(Object object) //获得指定元素的索引
abstract int                 lastIndexOf(Object object) //从右边的索引
abstract ListIterator&lt;E&gt;     listIterator(int location) //获得iterator
abstract ListIterator&lt;E&gt;     listIterator()
abstract E                   remove(int location) //删除指定位置的元素
abstract E                   set(int location, E object) //修改指定位置的元素
abstract List&lt;E&gt;             subList(int start, int end) //获取子list
</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>//Set的定义
public interface Set&lt;E&gt; extends Collection&lt;E&gt; {}
</code></pre><p>Set也继承与Collection接口，且里面不能有重复元素。关于API，Set与Collection的API完全一样，不再赘述。</p>
<h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h3><pre><code>//AbstractCollection的定义
public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}
</code></pre><p>AbstractCollection是一个抽象类，实现了Collection中除了iterator()和size()之外的所有方法。AbstractCollection的主要作用是方便其它类实现Collection。如：ArrayList | LinkedList等。它们如果想要实现Collection接口，通过继承AbstractCollection就已经实现大部分方法，再实现iterator()和size()方法即可。</p>
<pre><code>//AbtractCollection源码在这里省略是因为是实现上面的所有方法
</code></pre><h3 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h3><pre><code>//定义
public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}
</code></pre><p>从定义可以看出，AbstractList是一个继承AbstractCollection，并且实现了List接口的抽象类。它实现了List中除了size()、get(int location)之外的方法。</p>
<p>AbstractList的主要作用：它实现了List接口中的大部分函数，从而方便其它类继承List。另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()方法。</p>
<pre><code>//这里省略源码复制，后面对比看..
</code></pre><h3 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h3><pre><code>//定义
public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}
</code></pre><p>AbstractSet是一个继承与AbstractCollection，并且实现了Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，所以Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()外的方法。所以源码和AbstractCollection的一样。</p>
<pre><code>//源码省略...
</code></pre><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><pre><code>//定义
public interface Iterator&lt;E&gt; {}
</code></pre><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历其中的元素。Iterator提供的API接口包括：是否存在下一个元素，获取下一个元素和删除当前元素。</p>
<blockquote>
<p>注意：Iterator遍历Collection时，是fail-fast机制：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程A访问集合时，就会抛出CurrentModificationException异常，产生fail-fast事件。</p>
</blockquote>
<pre><code>// Iterator的API
abstract boolean hasNext()
abstract E next()
abstract void remove()
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java集合框架 HashMap源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java集合框架 HashMap源码解析/" itemprop="url">HashMap源码解析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:34:25+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java集合/" itemprop="url" rel="index">
                    <span itemprop="name">Java集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,843
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h2><p>[TOC]</p>
<h3 id="1-默认属性"><a href="#1-默认属性" class="headerlink" title="1. 默认属性"></a>1. 默认属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">//默认初始容量 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大值 2^30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认扩容因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//转为红黑树的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;<span class="comment">//由树转换为链表的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//默认的树存在的最小数组长度 此长度最少是TREEIFY_THRESHOLD的四倍（注释之中说的很清楚）</span></span><br></pre></td></tr></table></figure>
<h3 id="2-put方法"><a href="#2-put方法" class="headerlink" title="2. put方法"></a>2. put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//hashcode是32位的，无符号右移16位，那生成的就是16位0加原高位的16位值， 就是对半了，异或计算也就变成</span></span><br><span class="line"><span class="comment">//了高16位和低16位进行异或，原高16位不变。这么干主要用于当hashmap 数组比较小的时候所有二进制都参与运</span></span><br><span class="line"><span class="comment">//算了，防止hash冲突太大，</span></span><br></pre></td></tr></table></figure>
<h4 id="putval-添加-方法"><a href="#putval-添加-方法" class="headerlink" title="==putval(添加)方法=="></a>==putval(添加)方法==</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果存储元素的table为空，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">///这里的resize  是初始化的时候调用 后面会讲</span></span><br><span class="line">            n = (tab = resize()).length;    <span class="comment">// 获取默认长度（16）</span></span><br><span class="line">    	<span class="comment">//p = tab[i = (n - 1) &amp; hash] 获取要插入的元素在hash桶中的位置</span></span><br><span class="line">        <span class="comment">// 如果根据hash值获取的结点为空（这个位置没有节点）</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)      <span class="comment">// 此处 &amp; 代替了 %（效率更高）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//则直接新建一个结点</span></span><br><span class="line">        <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果有节点</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果新插入的结点和table中p结点的hash值，key值相同的话</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;<span class="comment">//则进行覆盖</span></span><br><span class="line">            <span class="comment">// 如果是红黑树结点的话，进行红黑树插入（上次分享了红黑树）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//定位到这个hash桶了 但是这里面是链表（没有进行过树化）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 如果p节点的next为空 直接在后面插入(代表这个单链表只有一个头部结点)</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//插入完成之后再次判断是否要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">//转换为红黑树</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">////如果下一个节点e 不为null 并且这个链表中的节点就是你要找的节点 终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 及时更新p 保证p是最后一个</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果存在这个映射就覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 判断是否允许覆盖，并且value是否为空、</span></span><br><span class="line">                <span class="comment">//onlyIfAbsent 如果为true，不更改现有值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);     <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 执行到这里，说明是增加了新的元素，而不是替换了老的元素，所以相关计数需要累加</span></span><br><span class="line">        ++modCount;     <span class="comment">// 更改操作次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)     <span class="comment">// 大于临界值</span></span><br><span class="line">            <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">            <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">            resize();  </span><br><span class="line">        <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回空</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="PUT方法的流程："><a href="#PUT方法的流程：" class="headerlink" title="==PUT方法的流程：=="></a>==PUT方法的流程：==</h5><ul>
<li><strong>1、如果未被初始化，则初始化</strong></li>
<li><strong>2、根据KEY求Hash值，然后计算下标。</strong></li>
<li><strong>3、如果没有碰撞直接放入bucket中。</strong></li>
<li><strong>4、如果碰撞了，则以链表的方式连接到后面。</strong></li>
<li><strong>5、如果链表长度大于 8，则调转换为红黑树的方法</strong></li>
<li><strong>6、如果树节点个数低于 6，则调转换链表的方法</strong></li>
<li><strong>7、如果节点已经存在则直接替换</strong></li>
<li><strong>8、如果超过了阈值，则进行扩容</strong></li>
</ul>
<h4 id="resize-扩容-方法"><a href="#resize-扩容-方法" class="headerlink" title="resize(扩容)方法"></a>resize(扩容)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化或者扩容之后元素调整</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧元素数组的各种信息</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//如果你是新创建的话 表的大小就是0 否则就是原来的大小</span></span><br><span class="line">        <span class="comment">//第一次是为0的 代表 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;就是16</span></span><br><span class="line">        <span class="comment">// 老的扩容阀值设置</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新数组的长度及扩容的临界值（都初始化为0）</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;   <span class="comment">// 如果原table不为空</span></span><br><span class="line">            <span class="comment">// 如果数组元素个数大于等于限定的最大容量（2的30次方）</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 扩容阀值设置为int最大值（2的31次方 -1 ），因为oldCap再乘2就溢出了</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//直接返回</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）newCap = oldCap &lt;&lt; 1 相当于*2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//并且旧的容量大于默认的初始化大小16</span></span><br><span class="line">                <span class="comment">// 新的扩容阈值 = 旧的扩容阈值 * 2 </span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">            newCap = oldThr;<span class="comment">//如果旧的扩容本来就大于0，那么新的容量就是旧的扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// threshold（旧的扩容）为0，则使用默认值</span></span><br><span class="line">            <span class="comment">// 能运行到这里的话，说明是调用无参构造函数创建的该map，并且第一次添加元素</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//16 </span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//0.75*16=12</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  <span class="comment">// 如果阈值值还为0，则设置临界值</span></span><br><span class="line">            <span class="comment">//计算得到新的阙值</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//新的阙值 =  如果新的容量&lt;最大的容量 并且 新的阈值&lt;最大的容量 ，那么新的阙值 = 计算的             //否则=最大int</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr; <span class="comment">//阙值 = 新的阙值(更新阈值)</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    		<span class="comment">////创建一个新的哈希数组桶 大小为新的容量</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;   <span class="comment">// 调整数组大小之后，需要调整红黑树或者链表的指向</span></span><br><span class="line">            <span class="comment">//遍历旧的hash桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//如果旧的hash桶的元素不为null  e为旧的hash桶的元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;<span class="comment">//旧的hash桶设置为null(主要为了使得数组可被回收)</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果你是一个元素</span></span><br><span class="line">                        <span class="comment">//那么在新的hash桶中给你安排一个位置  </span></span><br><span class="line">                        <span class="comment">//位置是你的hash值 &amp; 新的桶的容量-1（再次分配位置） </span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 	<span class="comment">//如果你不只一个元素并且是TreeNode</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//调用split方法</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//如果你是普通的链表</span></span><br><span class="line">                        <span class="comment">// 链表调整</span></span><br><span class="line">                        <span class="comment">// 按命名来翻译的话，应该叫低位首尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 按命名来翻译的话，应该叫高位首尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//以上的低位指的是新数组的 0 到 oldCap-1 、高位指定的是oldCap 到 newCap - 1</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//看是否需要进行位置变化 新增位的值 不需要变化就放在原来的位置</span></span><br><span class="line">                            <span class="comment">//如果hash值和老的长度做与运算，结果为0，那么该hash值再和新数组的长度取摸的话值也不会放生变化，所以该元素的在新数组的位置和在老数组的位置是相同的，所以该元素可以放置在低位链表中。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// 如果没有尾，说明链表为空</span></span><br><span class="line">                                    loHead = e;<span class="comment">// 链表为空时，头节点指向该元素</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 如果有尾，那么链表不为空，把该元素挂到链表的最后。</span></span><br><span class="line">                                    loTail.next = e; </span><br><span class="line">                                loTail = e;<span class="comment">// 把尾节点设置为当前元素</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果与运算结果不为0，说明hash值大于老数组长度（例如hash值为17）</span></span><br><span class="line">                            <span class="comment">// 此时该元素应该放置到新数组的高位位置上</span></span><br><span class="line">                            <span class="comment">//例：老数组长度16，那么新数组长度为32，hash为17的应该放置在数组的第17个位置上，也就是下标为16，那么下标为16已经属于高位了，低位是[0-15]，高位是[16-31]</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//需要变化 就构建高位放置的链表</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">// 如果没有尾，说明链表为空</span></span><br><span class="line">                                    hiHead = e;<span class="comment">// 链表为空时，头节点指向该元素</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 如果有尾，那么链表不为空，把该元素挂到链表的最后</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;<span class="comment">// 把尾节点设置为当前元素</span></span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">// 低位的元素组成的链表还是放置在原来的位置</span></span><br><span class="line">                            </span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;<span class="comment">//赋值 （原来位置</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高位的元素组成的链表放置的位置只是在原有位置上偏移了老数组的长度个位置</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             <span class="comment">// 销毁实例，等待GC回收</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// 例：hash为 17 在老数组放置在0下标，在新数组放置在16下标；                                   //hash为 18 在老数组放置在1下标，在新数组放置在17下标； </span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新的数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 总结一下</span></span><br><span class="line"><span class="comment"> *  1、如果你是新创建的话 旧的表的大小就是0 否则就是原来的大小</span></span><br><span class="line"><span class="comment"> *  2、 如果原table不为空且数组元素个数大于等于限定的最大容量（2的30次方），扩容阀值设置为int最大值</span></span><br><span class="line"><span class="comment"> *    直接返回。</span></span><br><span class="line"><span class="comment"> *  3、新的表的大小等于旧的乘2,如果其大小小于最大容量，并且旧的容量大于默认的初始化大小16，</span></span><br><span class="line"><span class="comment"> *     新的扩容阈值 = 旧的扩容阈值 * 2 </span></span><br><span class="line"><span class="comment"> *  4、如果是是调用无参构造函数创建的该map，并且第一次添加元素，给附上初始值16</span></span><br><span class="line"><span class="comment"> *  5、如果阈值值还为0，则设置临界值：新的阙值 =  如果新的容量&lt;最大的容量 并且 新的阈值&lt;最大的容量</span></span><br><span class="line"><span class="comment"> *     那么新的阙值 = 计算的  否则=最大int</span></span><br><span class="line"><span class="comment"> *  6、创建一个新的哈希数组桶 大小为新的容量，然后遍历旧的哈希桶</span></span><br><span class="line"><span class="comment"> *  7、如果旧的hash桶的元素不为null，旧的hash桶设置为null(主要为了使得数组可被回收)这里已经用e接收了</span></span><br><span class="line"><span class="comment"> *  8、如果你是一个元素，那么在新的hash桶中给你安排一个位置，</span></span><br><span class="line"><span class="comment"> *	   位置是你的hash值 &amp; 新的桶的容量-1（再次分配位置）</span></span><br><span class="line"><span class="comment"> *  9、如果你不只一个元素并且是TreeNode,那么调用split方法，进行树的修剪</span></span><br><span class="line"><span class="comment"> *  10、如果你是一个普通链表，且(e.hash &amp; oldCap) == 0，则挂到低位链，否则挂到高位链</span></span><br><span class="line"><span class="comment"> *  11、如果链表上存在元素，则尾插。</span></span><br><span class="line"><span class="comment"> *  12、把老数组赋空，便于GC回收。</span></span><br><span class="line"><span class="comment"> *  13、高位的元素组成的链表放置的位置只是在原有位置上偏移了老数组的长度个位置</span></span><br><span class="line"><span class="comment"> 		例：hash为 17 在老数组放置在0下标，在新数组放置在16下标；                                   	//hash为 18 在老数组放置在1下标，在新数组放置在17下标； </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="split-红黑树修剪-方法"><a href="#split-红黑树修剪-方法" class="headerlink" title="split(红黑树修剪)方法"></a><strong>split</strong>(红黑树修剪)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">上述方法在resize()过程中被调用 </span><br><span class="line">和链表的修剪差不多（再次操作看看是否要再次保留红黑树）</span><br><span class="line">目的是将树的数据重新散列到数组中</span><br><span class="line"><span class="comment">//被调用的代码 split(当前hash表，新的哈希桶，要分割的元素的下标，旧的容量) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;<span class="comment">//这里的this :    e = oldTab[j] 上下文中的代码</span></span><br><span class="line">            </span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//低位的头和低位的尾</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//高位的头和高位的尾</span></span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>; <span class="comment">//地位和高位的2个计数器</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;<span class="comment">//获取下一个节点</span></span><br><span class="line">                e.next = <span class="keyword">null</span>;<span class="comment">//设置为null</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果 e.hash 与 原来旧的容量 &amp; 为 0 说明不需要进行移动位置  </span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;<span class="comment">//将e 复制给头</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//如果尾巴不为null 尾巴的next 为 e</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;<span class="comment">//将e 作为新的尾巴</span></span><br><span class="line">                    ++lc;<span class="comment">//次数 + 1 </span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)<span class="comment">//否则需要移动位置</span></span><br><span class="line">                        hiHead = e;<span class="comment">//高位的链表和低位一样</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123; <span class="comment">//如果有链表</span></span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<span class="comment">//如果长度 &lt;= 6  </span></span><br><span class="line">                <span class="comment">//取消树化 将这个树里面的链表结构变成普通的链表结构</span></span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead; <span class="comment">//否则将地位复制给原来的下标</span></span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);<span class="comment">//进行树化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);<span class="comment">//进行了移位 位置偏移 下标 + 原来的容器大小</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="untreeify-非树化-方法"><a href="#untreeify-非树化-方法" class="headerlink" title="untreeify(非树化)方法"></a>untreeify(非树化)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果链表的长度 &lt;= UNTREEIFY_THRESHOLD(<span class="number">6</span>) 就进行非树化，否则就进行树化。</span><br><span class="line">这里的非树化就是将TreeNode转换成Node</span><br><span class="line">		<span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">            <span class="comment">//将q转换成普通的Nod return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span></span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p; <span class="comment">//头为p</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;<span class="comment">//返回这个链表</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeifyBin-树化-方法"><a href="#treeifyBin-树化-方法" class="headerlink" title="treeifyBin(树化)方法"></a>treeifyBin(树化)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">treeifyBin方法，应该可以解释为：把容器里的元素变成树结构   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tab：元素数组，</span></span><br><span class="line"><span class="comment"> * hash：hash值（要增加的键值对的key的hash值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果元素数组为空 或者 数组长度小于 树结构化的最小限制</span></span><br><span class="line"><span class="comment">     * MIN_TREEIFY_CAPACITY 默认值64，对于这个值可以理解为：如果元素数组长度小于这个值，没有必要去进行结构转换</span></span><br><span class="line"><span class="comment">     * 当一个数组位置上集中了多个键值对，那是因为这些key的hash值和数组长度取模之后结果相同。（并不是因为这些key的hash值相同）</span></span><br><span class="line"><span class="comment">     * 因为hash值相同的概率不高，所以可以通过扩容的方式，来使得最终这些key的hash值在和新的数组长度取模之后，拆分到多个数组位置上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize(); <span class="comment">// 扩容，可参见resize方法解析</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果元素数组长度已经大于等于了 MIN_TREEIFY_CAPACITY，那么就有必要进行结构转换了</span></span><br><span class="line">    <span class="comment">// 根据hash值和数组长度进行取模运算后，得到链表的首节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">// 定义首、尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// 将该节点转换为 树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">// 如果尾节点为空，说明还没有根节点</span></span><br><span class="line">                hd = p; <span class="comment">// 首节点（根节点）指向 当前节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 尾节点不为空，以下两行是一个双向链表结构</span></span><br><span class="line">                p.prev = tl; <span class="comment">// 当前树节点的 前一个节点指向 尾节点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 尾节点的 后一个节点指向 当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p; <span class="comment">// 把当前节点设为尾节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 继续遍历链表</span></span><br><span class="line">        <span class="comment">// 到目前为止 也只是把Node对象转换成了TreeNode对象，把单向链表转换成了双向链表</span></span><br><span class="line">        <span class="comment">// 把转换后的双向链表，替换原来位置上的单向链表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">//此处单独解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeify-打头树化-方法"><a href="#treeify-打头树化-方法" class="headerlink" title="treeify(打头树化)方法"></a>treeify(打头树化)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为HashMap的元素数组,</span></span><br><span class="line"><span class="comment"> * treeify方法是TreeNode类的一个实例方法，通过TreeNode对象调用，实现该对象打头的链表转换为树结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; <span class="comment">// 定义树的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123; <span class="comment">// 遍历链表，x指向当前节点、next指向下一个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>; <span class="comment">// 设置当前节点的左右节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果还没有根节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>; <span class="comment">// 当前节点的父节点设为空</span></span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">// 当前节点的红色属性设为false（把当前节点设为黑色）</span></span><br><span class="line">            root = x; <span class="comment">// 根节点指向到当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果已经存在根节点了</span></span><br><span class="line">            K k = x.key; <span class="comment">// 取得当前链表节点的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash; <span class="comment">// 取得当前链表节点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 定义key所属的Class</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span></span><br><span class="line">                <span class="comment">// GOTO1</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph; <span class="comment">// dir 标识方向（左右）、ph标识当前树节点的hash值</span></span><br><span class="line">                K pk = p.key; <span class="comment">// 当前树节点的key</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前树节点hash值 大于 当前链表节点的hash值</span></span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识当前链表节点会放到当前树节点的左侧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>; <span class="comment">// 右侧</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果两个节点的key的hash值相等，那么还要通过其他方式再进行比较</span></span><br><span class="line"><span class="comment">                 * 如果当前链表节点的key实现了comparable接口，并且当前树节点和链表节点是相同Class的实例，那么通过comparable的方式再比较两者。</span></span><br><span class="line"><span class="comment">                 * 如果还是相等，最后再通过tieBreakOrder比较一次</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 保存当前树节点</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果dir 小于等于0 ： 当前链表节点一定放置在当前树节点的左侧，但不一定是该树节点的左孩子，也可能是左孩子的右孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果dir 大于0 ： 当前链表节点一定放置在当前树节点的右侧，但不一定是该树节点的右孩子，也可能是右孩子的左孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩子 为 起始节点  再从GOTO1 处开始 重新寻找自己（当前链表节点）的位置</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂载到当前树节点的左或者右侧了。</span></span><br><span class="line"><span class="comment">                 * 挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点进行处理了。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 当前链表节点 作为 当前树节点的子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 作为左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// 作为右孩子</span></span><br><span class="line">                    root = balanceInsertion(root, x); <span class="comment">// 重新平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把所有的链表节点都遍历完之后，最终构造出来的树可能经历多个平衡操作，根节点目前到底是链表的哪一个节点是不确定的</span></span><br><span class="line">    <span class="comment">// 因为我们要基于树来做查找，所以就应该把 tab[N] 得到的对象一定根节点对象，而目前只是链表的第一个节点对象，所以要做相应的处理。</span></span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">// 单独解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="moveRootToFront-保证根节点-方法"><a href="#moveRootToFront-保证根节点-方法" class="headerlink" title="moveRootToFront(保证根节点)方法"></a>moveRootToFront(保证根节点)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把红黑树的根节点设为  其所在的数组槽 的第一个元素</span></span><br><span class="line"><span class="comment"> * 首先明确：TreeNode既是一个红黑树结构，也是一个双链表结构</span></span><br><span class="line"><span class="comment"> * 这个方法里做的事情，就是保证树的根节点一定也要成为链表的首节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// 根节点不为空 并且 HashMap的元素数组不为空</span></span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash; <span class="comment">// 根据根节点的Hash值 和 HashMap的元素数组长度  取得根节点在数组中的位置</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; <span class="comment">// 首先取得该位置上的第一个节点对象</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123; <span class="comment">// 如果该节点对象 与 根节点对象 不同</span></span><br><span class="line">            Node&lt;K,V&gt; rn; <span class="comment">// 定义根节点的后一个节点</span></span><br><span class="line">            tab[index] = root; <span class="comment">// 把元素数组index位置的元素替换为根节点对象</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">// 获取根节点对象的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">// 如果后节点不为空 </span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp; <span class="comment">// root后节点的前节点  指向到 root的前节点，相当于把root从链表中摘除</span></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>) <span class="comment">// 如果root的前节点不为空</span></span><br><span class="line">                rp.next = rn; <span class="comment">// root前节点的后节点 指向到 root的后节点</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 如果数组该位置上原来的元素不为空</span></span><br><span class="line">                first.prev = root; <span class="comment">// 这个原有的元素的 前节点 指向到 root，相当于root目前位于链表的首位</span></span><br><span class="line">            root.next = first; <span class="comment">// 原来的第一个节点现在作为root的下一个节点，变成了第二个节点</span></span><br><span class="line">            root.prev = <span class="keyword">null</span>; <span class="comment">// 首节点没有前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这一步是防御性的编程</span></span><br><span class="line"><span class="comment">         * 校验TreeNode对象是否满足红黑树和双链表的特性</span></span><br><span class="line"><span class="comment">         * 如果这个方法校验不通过：可能是因为用户编程失误，破坏了结构（例如：并发场景下）；也可能是TreeNode的实现有问题（这个是理论上的以防万一）；</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="putTreeVal-树的添加节点-方法"><a href="#putTreeVal-树的添加节点-方法" class="headerlink" title="putTreeVal(树的添加节点)方法"></a>putTreeVal(树的添加节点)方法</h4><p>​    当同一个位置上链表中的元素达到8个的时候，就会再将这些元素构建成一个红黑树（参见：treeifyBin方法分析），同时把==原来的单链表结构变成了双链表结构==，也就是这些==元素即维持着红黑树的结构又维持着双链表的结构==。当第9个相同hash值的键值对put过来时，发现该位置已经是一个树节点了，那么就会调用putTreeVal方法，将这个新的值设置到指定的key上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当存在hash碰撞的时候，且元素数量大于8个时候，就会以红黑树的方式将这些元素组织起来</span></span><br><span class="line"><span class="comment"> * map 当前节点所在的HashMap对象</span></span><br><span class="line"><span class="comment"> * tab 当前HashMap对象的元素数组</span></span><br><span class="line"><span class="comment"> * h   指定key的hash值</span></span><br><span class="line"><span class="comment"> * k   指定key</span></span><br><span class="line"><span class="comment"> * v   指定key上要写入的值</span></span><br><span class="line"><span class="comment"> * 返回：指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 定义k的Class对象</span></span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>; <span class="comment">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>; <span class="comment">// 父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点开始遍历，没有终止条件，只能从内部退出</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk; <span class="comment">// 声明方向、当前节点hash值、当前节点的键对象</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前节点hash 大于 指定key的hash值</span></span><br><span class="line">            dir = -<span class="number">1</span>; <span class="comment">// 要添加的元素应该放置在当前节点的左侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">// 如果当前节点hash 小于 指定key的hash值</span></span><br><span class="line">            dir = <span class="number">1</span>; <span class="comment">// 要添加的元素应该放置在当前节点的右侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">// 如果当前节点的键对象 和 指定key对象相同</span></span><br><span class="line">            <span class="keyword">return</span> p; <span class="comment">// 那么就返回当前节点对象，在外层方法会对v进行写入</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class="line"><span class="comment">             * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点</span></span><br><span class="line"><span class="comment">             * 如果得到了键的equals相等的的节点就返回</span></span><br><span class="line"><span class="comment">             * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123; <span class="comment">// 如果还没有比对过当前节点的所有子节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch; <span class="comment">// 定义要返回的节点、和子节点</span></span><br><span class="line">                searched = <span class="keyword">true</span>; <span class="comment">// 标识已经遍历过一次了</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了</span></span><br><span class="line"><span class="comment">                 * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了</span></span><br><span class="line"><span class="comment">                 * find 方法内部还会有递归调用。参见：find方法解析</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q; <span class="comment">// 找到了指定key键对应的</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点</span></span><br><span class="line">            dir = tieBreakOrder(k, pk); <span class="comment">// 再比较一下当前节点键和指定key键的大小</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 定义xp指向当前节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果dir小于等于0，那么看当前节点的左节点是否为空，如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">        * 如果dir大于等于0，那么看当前节点的右节点是否为空，如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">        * 如果以上两条当中有一个子节点不为空，这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next; <span class="comment">// 获取当前节点的next节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); <span class="comment">// 创建一个新的树节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;  <span class="comment">// 左孩子指向到这个新的树节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x; <span class="comment">// 右孩子指向到这个新的树节点</span></span><br><span class="line">            xp.next = x; <span class="comment">// 链表中的next节点指向到这个新的树节点</span></span><br><span class="line">            x.parent = x.prev = xp; <span class="comment">// 这个新的树节点的父节点、前节点均设置为 当前的树节点</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>) <span class="comment">// 如果原来的next节点不为空</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x; <span class="comment">// 那么原来的next节点的前节点指向到新的树节点</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));<span class="comment">// 重新平衡，以及新的根节点置顶</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回空，意味着产生了一个新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="balanceInsertion-树的平衡-方法"><a href="#balanceInsertion-树的平衡-方法" class="headerlink" title="balanceInsertion(树的平衡)方法"></a>balanceInsertion(树的平衡)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">红黑树插入节点后，需要重新平衡</span><br><span class="line"> root 当前根节点</span><br><span class="line"> x 新插入的节点</span><br><span class="line"> 返回重新平衡后的根节点</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>; <span class="comment">// 新插入的节点标为红色</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这一步即定义了变量，又开起了循环，循环没有控制条件，只能从内部跳出</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点、xpp：爷爷节点、xppl：左叔叔节点、xppr：右叔叔节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// L1</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 父节点不为空</span></span><br><span class="line">        <span class="comment">// 如果父节点为黑色 或者 【（父节点为红色 但是 爷爷节点为空） -&gt; 这种情况何时出现？】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) <span class="comment">// L2</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">// 如果父节点是爷爷节点的左孩子  // L3</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">// 如果右叔叔不为空 并且 为红色  // L3_1</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>; <span class="comment">// 右叔叔置为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 运行到这里之后，就又会进行下一轮的循环了，将爷爷节点当做处理的起始节点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果右叔叔为空 或者 为黑色 // L3_2</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">// 如果当前节点是父节点的右孩子 // L3_2_1</span></span><br><span class="line">                    root = rotateLeft(root, x = xp); <span class="comment">// 父节点左旋，见下文左旋方法解析</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// 获取爷爷节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果父节点不为空 // L3_2_2</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点 置为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; <span class="comment">// 爷爷节点不为空</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为 红色</span></span><br><span class="line">                        root = rotateRight(root, xpp);  <span class="comment">//爷爷节点右旋，见下文右旋方法解析</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果父节点是爷爷节点的右孩子 // L4</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123; <span class="comment">// 如果左叔叔是红色 // L4_1</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>; <span class="comment">// 左叔叔置为 黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 运行到这里之后，就又会进行下一轮的循环了，将爷爷节点当做处理的起始节点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果左叔叔为空或者是黑色 // L4_2</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">// 如果当前节点是个左孩子 // L4_2_1</span></span><br><span class="line">                    root = rotateRight(root, x = xp); <span class="comment">// 针对父节点做右旋，见下文右旋方法解析</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// 获取爷爷节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果父节点不为空 // L4_2_4</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点置为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; <span class="comment">//如果爷爷节点不为空</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 爷爷节点置为红色</span></span><br><span class="line">                        root = rotateLeft(root, xpp); <span class="comment">// 针对爷爷节点做左旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点左旋</span></span><br><span class="line"><span class="comment"> * root 根节点</span></span><br><span class="line"><span class="comment"> * p 要左旋的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123; <span class="comment">// 要左旋的节点以及要左旋的节点的右孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>) <span class="comment">// 要左旋的节点的右孩子的左节点 赋给 要左旋的节点的右孩子 节点为：rl</span></span><br><span class="line">            rl.parent = p; <span class="comment">// 设置rl和要左旋的节点的父子关系【之前只是爹认了孩子，孩子还没有答应，这一步孩子也认了爹】</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要左旋的节点的右孩子的父节点  指向 要左旋的节点的父节点，相当于右孩子提升了一层，</span></span><br><span class="line">        <span class="comment">// 此时如果父节点为空， 说明r 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>) </span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) <span class="comment">// 如果父节点不为空 并且 要左旋的节点是个左孩子</span></span><br><span class="line">            pp.left = r; <span class="comment">// 设置r和父节点的父子关系【之前只是孩子认了爹，爹还没有答应，这一步爹也认了孩子】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 要左旋的节点是个右孩子</span></span><br><span class="line">            pp.right = r; </span><br><span class="line">        r.left = p; <span class="comment">// 要左旋的节点  作为 他的右孩子的左节点</span></span><br><span class="line">        p.parent = r; <span class="comment">// 要左旋的节点的右孩子  作为  他的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点右旋</span></span><br><span class="line"><span class="comment"> * root 根节点</span></span><br><span class="line"><span class="comment"> * p 要右旋的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123; <span class="comment">// 要右旋的节点不为空以及要右旋的节点的左孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>) <span class="comment">// 要右旋的节点的左孩子的右节点 赋给 要右旋节点的左孩子 节点为：lr</span></span><br><span class="line">            lr.parent = p; <span class="comment">// 设置lr和要右旋的节点的父子关系【之前只是爹认了孩子，孩子还没有答应，这一步孩子也认了爹】</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要右旋的节点的左孩子的父节点  指向 要右旋的节点的父节点，相当于左孩子提升了一层，</span></span><br><span class="line">        <span class="comment">// 此时如果父节点为空， 说明l 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>) </span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p) <span class="comment">// 如果父节点不为空 并且 要右旋的节点是个右孩子</span></span><br><span class="line">            pp.right = l; <span class="comment">// 设置l和父节点的父子关系【之前只是孩子认了爹，爹还没有答应，这一步爹也认了孩子】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 要右旋的节点是个左孩子</span></span><br><span class="line">            pp.left = l; <span class="comment">// 同上</span></span><br><span class="line">        l.right = p; <span class="comment">// 要右旋的节点 作为 他左孩子的右节点</span></span><br><span class="line">        p.parent = l; <span class="comment">// 要右旋的节点的父节点 指向 他的左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>​     ConcurrentHashMap是Java并发包中提供的一个<strong>线程安全且高效</strong>的HashMap实现。<strong>==ConcurrentHashMap不允许key或value为null值==。</strong></p>
<h3 id="2-为什么HashMap用于多线程会出错？："><a href="#2-为什么HashMap用于多线程会出错？：" class="headerlink" title="2.为什么HashMap用于多线程会出错？："></a>2.为什么HashMap用于多线程会出错？：</h3><p>​             JDK1.7 的 HashMap在高并发环境下会形成<strong>环状链表</strong>，导致get操作时，进入死循环，所以，在并发环境中使用HashMap是非常危险的。</p>
<h3 id="3-为什么不用Hashtable？"><a href="#3-为什么不用Hashtable？" class="headerlink" title="3.为什么不用Hashtable？"></a>3.为什么不用Hashtable？</h3><p>​       HashTable线程安全的策略实现代价却太大了，简单粗暴，<strong>get/put</strong>所有相关操作都是synchronized<strong>的</strong>，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并<strong>发场景中性能就会非常差</strong>。</p>
<h3 id="4、ConcurrentHashMap-java7-中的实现方式"><a href="#4、ConcurrentHashMap-java7-中的实现方式" class="headerlink" title="4、ConcurrentHashMap java7 中的实现方式"></a>4、ConcurrentHashMap java7 中的实现方式</h3><p><img src="images/1.png" alt=""></p>
<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的==”分段锁”==思想。</p>
<h4 id="4-1-java7中的优缺点"><a href="#4-1-java7中的优缺点" class="headerlink" title="4.1 java7中的优缺点"></a>4.1 java7中的优缺点</h4><p>​    ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个==Segment==数组。每个段其实==就是一个小的Hashtable==，它们有自己的锁。==只要多个修改操作发生在不同的段上，它们就可以并发进行。（JDK7中是这样实现的）==</p>
<p>​    ==但是！！！==有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁.</p>
<p>​    所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</p>
<h3 id="ConcurrentHashMap-java8-中的实现"><a href="#ConcurrentHashMap-java8-中的实现" class="headerlink" title="ConcurrentHashMap java8 中的实现"></a>ConcurrentHashMap java8 中的实现</h3><h4 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h4><p>​    JDK8：ConcurrentHashMap在JDK8中进行了巨大改动，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用==CAS==算法。</p>
<h4 id="2、什么是volatille关键字？"><a href="#2、什么是volatille关键字？" class="headerlink" title="2、什么是volatille关键字？"></a>2、什么是volatille关键字？</h4><p>volatile是一种轻量级的同步机制，它主要有两个特性：</p>
<p>一是保证共享变量对所有线程的可见性；（==内存可见性==）</p>
<p>二是禁止指令重排序优化。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像<strong>num++这种复合操作（读写存）</strong>，volatile无法保证其原子性。</p>
<h4 id="3、重要属性"><a href="#3、重要属性" class="headerlink" title="==3、重要属性=="></a>==3、重要属性==</h4><h5 id="3-1-sizeCtl"><a href="#3-1-sizeCtl" class="headerlink" title="3.1 sizeCtl"></a>3.1 sizeCtl</h5><p>​    可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个==控制标识符==，在不同的地方有不同用途，而且它的<strong>取值不同，也代表不同的含义</strong>。</p>
<ul>
<li><strong>负数代表正在进行初始化或扩容操作</strong>         </li>
<li><strong>-1代表正在初始化</strong></li>
<li><strong>-N 表示有N-1个线程正在进行扩容操作</strong></li>
<li><strong>正数或0代表hash表还没有被初始化，</strong>这个数值表示初始化或下一次进行扩容的大小，==这一点类似于扩容阈值的概念==。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的</li>
</ul>
<h5 id="3-2初始化数组-initTable"><a href="#3-2初始化数组-initTable" class="headerlink" title="3.2初始化数组 initTable"></a>3.2初始化数组 initTable</h5><p>​    初始化方法主要应用了关键属性sizeCtl 如果这个值〈<strong>0，表示其他线程正在进行初始化，就放弃这个操作。</strong>在这也可以<strong>看出</strong>ConcurrentHashMap的==初始化只能由一个线程完成==。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p>
<h5 id="3-3-核心内容"><a href="#3-3-核心内容" class="headerlink" title="3.3 核心内容"></a>3.3 核心内容</h5><ul>
<li>forword （(transfer)扩容时标记，碰到这个标记直接跳过），==类似于大家一起搭积木==</li>
<li>Moved （在put时候碰到Moved ，则帮助其扩容 helptransfer）</li>
<li>sizeCtl</li>
<li>CAS</li>
<li>Volatile（val 和 next 都用了）</li>
<li>以上五点保证了 ConcurrentHashMap 的高并发情况下的线程安全问题</li>
<li>java7中只有1000多行代码，而在Java8中重新编写了现在有6000多行代码</li>
</ul>
<h4 id="PUT流程："><a href="#PUT流程：" class="headerlink" title="==PUT流程：=="></a>==PUT流程：==</h4><ul>
<li><strong>1、判断是否初始化过，没有则进行初始化。</strong></li>
<li><strong>2、通过Hash定位到数组的索引坐标，判断是否有Node 节点，</strong><ul>
<li><strong>如果没有则使用 CAS 进行添加，添加失败进入下次循环</strong></li>
</ul>
</li>
<li><strong>3、检查到内部在扩容，就帮助他一块扩容（Moved ）</strong></li>
<li><strong>4、如果 Node 节点存在，则使用 synchronized 锁住头结点，</strong><ul>
<li><strong>如果是链表结构就进行链表的添加操作</strong><ul>
<li><strong>如果是红黑树结构就进行红黑树的添加操作</strong></li>
<li><strong>5、判断链表的长度是否大于 8，如果大于就去转为树结构</strong></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Log4j/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Log4j/" itemprop="url">Log4j</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:44:17+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Log4j/" itemprop="url" rel="index">
                    <span itemprop="name">Log4j</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,064
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>log4j配置文件基本格式：</p>
</blockquote>
<pre><code>#配置根Logger
log4j.rootLogger  =   [ level ]   ,  appenderName1 ,  appenderName2 ,  …

#配置日志信息输出目的地Appender
log4j.appender.appenderName  =  fully.qualified.name.of.appender.class 
　　log4j.appender.appenderName.option1  =  value1 
　　… 
　　log4j.appender.appenderName.optionN  =  valueN 

#配置日志信息的格式（布局）
log4j.appender.appenderName.layout  =  fully.qualified.name.of.layout.class 
　　log4j.appender.appenderName.layout.option1  =  value1 
　　… 
　　log4j.appender.appenderName.layout.optionN  =  valueN 
　　
</code></pre><blockquote>
<blockquote>
<p>注意：[level] 是日志输出级别，共有5级：</p>
</blockquote>
</blockquote>
<pre><code>FATAL - 0  

ERROR - 3 表示严重错误，主要是程序的错误。

WARN - 4 表示一般的警告，如session丢失。

INFO - 6 表示一般要显示的信息，如登录登出信息。

DEBUG - 7 表示程序的调试信息 
</code></pre><blockquote>
<blockquote>
<p>Appender：为日志输出目的地，Log4j提供的appender有以下几种：</p>
</blockquote>
</blockquote>
<pre><code>org.apache.log4j.ConsoleAppender（控制台），

org.apache.log4j.FileAppender（文件），

org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），

org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），

org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre><blockquote>
<blockquote>
<p>Layout：日志输出格式，Log4j提供的layout有以下几种：</p>
</blockquote>
</blockquote>
<pre><code>org.apache.log4j.HTMLLayout（以HTML表格形式布局），

org.apache.log4j.PatternLayout（可以灵活地指定布局模式），

org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），

org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</code></pre><blockquote>
<blockquote>
<p>打印参数: Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，如下:</p>
</blockquote>
</blockquote>
<pre><code>%m   输出代码中指定的消息
</code></pre><p>　　%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL<br>　　%r   输出自应用启动到输出该log信息耗费的毫秒数<br>　　%c   输出所属的类目，通常就是所在类的全名<br>　　%t   输出产生该日志事件的线程名<br>　　%n   输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n”<br>　　%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921<br>　　%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 
　　</p>
<blockquote>
<blockquote>
<p>配置文件：</p>
</blockquote>
</blockquote>
<pre><code>### set log levels ###
log4j.rootLogger = debug ,  stdout ,  D ,  E

### 输出到控制台 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n

### 输出到日志文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = logs/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 保存异常信息到单独文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = logs/error.log ## 异常日志文件名
log4j.appender.D.Append = true
log4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><blockquote>
<blockquote>
<p>控制台选项</p>
</blockquote>
</blockquote>
<pre><code>Threshold=DEBUG:指定日志消息的输出最低层次。

ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。

Target=System.err：默认情况下是：System.out,指定输出控制台

FileAppender 选项

    Threshold=DEBUF:指定日志消息的输出最低层次。

    ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。

    File=mylog.txt:指定消息输出到mylog.txt文件。

    Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。

RollingFileAppender 选项

    Threshold=DEBUG:指定日志消息的输出最低层次。

    ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。

    File=mylog.txt:指定消息输出到mylog.txt文件。

    Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。

    MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。

    MaxBackupIndex=2:指定可以产生的滚动文件的最大数。
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Logback/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Logback/" itemprop="url">Logback</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:44:32+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Logback/" itemprop="url" rel="index">
                    <span itemprop="name">Logback</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  236
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Logback日志配置"><a href="#Logback日志配置" class="headerlink" title="Logback日志配置"></a>Logback日志配置</h2><p>程序中的日志的目的主要分为两个：1.做故障测试，在程序调试环节中起到非常重要的作用。2.显示程序运行状态。</p>
<h4 id="Logback主要模块"><a href="#Logback主要模块" class="headerlink" title="Logback主要模块"></a>Logback主要模块</h4><pre><code>1.logback-access 该模块与server容器集成，提供通过http来访问日志的功能，表示第三方软件可以通过logback这个日志工具来访问到记录日志。

2.logback-classic 该模块是log4j 

3.logback-core 该模块为前两个模块提供基础的服务。
</code></pre><h4 id="logback主要标签"><a href="#logback主要标签" class="headerlink" title="logback主要标签"></a>logback主要标签</h4><pre><code>1.logger 作为日志的记录器，存放日志对象、定义日志的类型以及日志的级别等。

2.appender 指定日志输出的目的地 这里的媒介可以是控制台、文件、远程套接字容器等。

3.layout 用来格式化日志信息输出
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">242</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.avantv.cn" target="_blank" title="AVANTV">
                      
                        <i class="fa fa-fw fa-user"></i>AVANTV</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">465.0k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
