<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="BangjinHu'Blog" />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="微信公众号：iProgrammer_ing">
<meta property="og:type" content="website">
<meta property="og:title" content="BangjinHu&#39;s Blog">
<meta property="og:url" content="http://bangjinhu.github.io/page/9/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="微信公众号：iProgrammer_ing">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BangjinHu&#39;s Blog">
<meta name="twitter:description" content="微信公众号：iProgrammer_ing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/page/9/"/>





  <title>BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/MySQL分区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/MySQL分区/" itemprop="url">MySQ-分区</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:25:33+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,462
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL分区可以管理非常大的表，采用分而治之的逻辑，分区引入分区键概念，让数据根据规则分布在不同的分区中，让一个大对象变成一些小对象。</p>
<pre><code>命令：show variables 查看当前MySQL是否支持分区
</code></pre><p>MySQL支持RANGE，LIST，HASH和KEY四种分区。其中，每个分区又都有一种特殊的类型。对于RANGE分区，有RANGE COLUMNS分区。对于LIST分区，有LIST COLUMNS分区。对于HASH分区，有LINEAR HASH分区。对于KEY分区，有LINEAR KEY分区。</p>
<h4 id="1-RANGE分区"><a href="#1-RANGE分区" class="headerlink" title="1.RANGE分区"></a>1.RANGE分区</h4><p>RANGE即范围分区，根据区间来判断位于哪个分区。如id值小于5在p0分区，如果id值大于5小于10在p1分区，类似地，依次类推得到各个分区。if…else if..。</p>
<pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
</code></pre><blockquote>
<p>注意：RANGE分区返回值必须是整数。</p>
</blockquote>
<h4 id="2-RANGE-COLUMNS分区"><a href="#2-RANGE-COLUMNS分区" class="headerlink" title="2.RANGE COLUMNS分区"></a>2.RANGE COLUMNS分区</h4><p>RANGE COLUMNS是RANGE分区的一种特殊类型，它与RANGE分区的区别如下：</p>
<pre><code>1. RANGE COLUMNS不接受表达式，只能是列名。而RANGE分区则要求分区的对象是整数。
2. RANGE COLUMNS允许多个列，在底层实现上，它比较的是元祖（多个列值组成的列表），而RANGE比较的是标量，即数值的大小。
3. RANGE COLUMNS不限于整数对象，date，datetime，string都可作为分区列。

CREATE TABLE rcx (
    a INT,
    b INT,
    c CHAR(3),
    d INT
)
PARTITION BY RANGE COLUMNS(a,d,c) (
    PARTITION p0 VALUES LESS THAN (5,10,&apos;ggg&apos;),
    PARTITION p1 VALUES LESS THAN (10,20,&apos;mmmm&apos;),
    PARTITION p2 VALUES LESS THAN (15,30,&apos;sss&apos;),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
</code></pre><blockquote>
<p>注意：同RANGE分区类似，它的区间范围必须是递增的，有时候，列涉及的太多，不好判断区间的大小，可采用下面的方式进行判断。<code>SELECT (5,10) &lt; (5,12), (5,11) &lt; (5,12), (5,12) &lt; (5,12);</code></p>
</blockquote>
<h4 id="3-LIST分区-列表分区"><a href="#3-LIST分区-列表分区" class="headerlink" title="3.LIST分区 列表分区"></a>3.LIST分区 列表分区</h4><pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
</code></pre><h4 id="4-LIST-COLUMNS分区"><a href="#4-LIST-COLUMNS分区" class="headerlink" title="4.LIST COLUMNS分区"></a>4.LIST COLUMNS分区</h4><p>LIST COLUMNS分区同样是LIST分区的一种特殊类型，它和RANGE COLUMNS分区较为相似，同样不接受表达式，同样支持多个列支持string,date和datetime类型。</p>
<pre><code>CREATE TABLE customers_1 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES IN(&apos;2010-02-01&apos;, &apos;2010-02-02&apos;, &apos;2010-02-03&apos;,
        &apos;2010-02-04&apos;, &apos;2010-02-05&apos;, &apos;2010-02-06&apos;, &apos;2010-02-07&apos;),
    PARTITION pWeek_2 VALUES IN(&apos;2010-02-08&apos;, &apos;2010-02-09&apos;, &apos;2010-02-10&apos;,
        &apos;2010-02-11&apos;, &apos;2010-02-12&apos;, &apos;2010-02-13&apos;, &apos;2010-02-14&apos;),
    PARTITION pWeek_3 VALUES IN(&apos;2010-02-15&apos;, &apos;2010-02-16&apos;, &apos;2010-02-17&apos;,
        &apos;2010-02-18&apos;, &apos;2010-02-19&apos;, &apos;2010-02-20&apos;, &apos;2010-02-21&apos;),
    PARTITION pWeek_4 VALUES IN(&apos;2010-02-22&apos;, &apos;2010-02-23&apos;, &apos;2010-02-24&apos;,
        &apos;2010-02-25&apos;, &apos;2010-02-26&apos;, &apos;2010-02-27&apos;, &apos;2010-02-28&apos;)
);
</code></pre><h4 id="5-HASH分区"><a href="#5-HASH分区" class="headerlink" title="5.HASH分区"></a>5.HASH分区</h4><p>和RANGE，LIST分区不同的是，HASH分区无需定义分区的条件。只需要指明分区数即可。</p>
<pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4;
</code></pre><blockquote>
<p>注意：1. HASH分区可以不用指定PARTITIONS子句，如上文中的PARTITIONS 4，则默认分区数为4。2. 不允许只写PARTITIONS，而不指定分区数。3. 同RANGE分区和LIST分区一样，PARTITION BY HASH (expr)子句中的expr返回的必须是整数值。4. HASH分区的底层实现其实是基于MOD函数。</p>
</blockquote>
<p>譬如，对于下表</p>
<pre><code>CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY HASH( YEAR(col3) )
    PARTITIONS 4;
</code></pre><p>如果你要插入一个col3为“2005-09-15”的记录，则分区的选择是根据以下值决定的：</p>
<pre><code>MOD(YEAR(&apos;2005-09-01&apos;),4)
=  MOD(2005,4)
=  1
</code></pre><h4 id="6-LINEAR-HASH分区"><a href="#6-LINEAR-HASH分区" class="headerlink" title="6.LINEAR HASH分区"></a>6.LINEAR HASH分区</h4><p>LINEAR HASH分区是HASH分区的一种特殊类型，与HASH分区是基于MOD函数不同的是，它基于的是另外一种算法。</p>
<pre><code>CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,
    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,
    job_code INT,
    store_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITIONS 4;
</code></pre><blockquote>
<p>说明：1. 它的优点是在数据量大的场景，譬如TB级，增加、删除、合并和拆分分区会更快，缺点是，相对于HASH分区，它数据分布不均匀的概率更大。</p>
</blockquote>
<h4 id="7-KEY分区"><a href="#7-KEY分区" class="headerlink" title="7.KEY分区"></a>7.KEY分区</h4><p>KEY分区其实跟HASH分区差不多，不同点如下：</p>
<pre><code>1. KEY分区允许多列，而HASH分区只允许一列。

2. 如果在有主键或者唯一键的情况下，key中分区列可不指定，默认为主键或者唯一键，如果没有，则必须显性指定列。

3. KEY分区对象必须为列，而不能是基于列的表达式。

4. KEY分区和HASH分区的算法不一样，PARTITION BY HASH (expr)，MOD取值的对象是expr返回的值，而PARTITION BY KEY (column_list)，基于的是列的MD5值。


CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;
</code></pre><p>在没有主键或者唯一键的情况下，格式如下：</p>
<pre><code>CREATE TABLE tm1 (
    s1 CHAR(32)
)
PARTITION BY KEY(s1)
PARTITIONS 10;
</code></pre><h4 id="8-LINEAR-KEY分区"><a href="#8-LINEAR-KEY分区" class="headerlink" title="8.LINEAR KEY分区"></a>8.LINEAR KEY分区</h4><p>同LINEAR HASH分区类似。</p>
<pre><code>CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;
</code></pre><blockquote>
<p>总结：</p>
</blockquote>
<pre><code>1. MySQL分区中如果存在主键或唯一键，则分区列必须包含在其中。
2. 对于原生的RANGE分区，LIST分区，HASH分区，分区对象返回的只能是整数值。
3. RANGE COLUMNS，LIST COLUMNS，KEY，LINEAR KEY分区对象只能是列，不能是基于列的表达式。
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/MySQL的存储引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/MySQL的存储引擎/" itemprop="url">MySQ-存储引擎</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:24:39+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,825
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="数据库与实例"><a href="#数据库与实例" class="headerlink" title="数据库与实例"></a>数据库与实例</h3><h5 id="数据库的概述："><a href="#数据库的概述：" class="headerlink" title="数据库的概述："></a>数据库的概述：</h5><p>​        简单说就是存放数据的仓库，这个仓库按一定的数据结构（数据的组织形式、或数据之间的联系）来组织和存储的，数据库分为关系型数据库（Oracle，MySQL，SQLServer）和非关系型数据库（NOSQL，Memcaced，redis等）</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>​        MySQL实例是由线程和内存组成，它是真正用于操作数据库文件的，一般情况下一个实例操作一个或多个数据库，在实例启动的时候MySQL会读取配置文件，MySQL如果找不到配置文件则会按照默认参数设置启动实例</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>​        只要由多个查询需要在同一时刻修改数据，都会产生并发控制问题，解决方法：并发控制</p>
<h6 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h6><ul>
<li>共享锁：读锁，它是共享的，互相不阻塞，多个用户在同一时刻可以读取同一个资源且互不干扰</li>
<li>排他锁 ：写锁，它会阻塞其他的写锁和读锁，写锁比读锁具有更高的优先级</li>
</ul>
<h6 id="锁策略"><a href="#锁策略" class="headerlink" title="锁策略"></a>锁策略</h6><ul>
<li>表锁：它是mysql中最基本的锁策略，并且开销最小，锁定整张表</li>
<li>行锁：最大程度支持并发处理，InnoDB就使用了行锁，但它的行锁不是那么简单（后续讲）</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​      ==实现了ACID，会需要更强的cpu处理能力，更大的内存和更大的磁盘空间==</p>
<ul>
<li><strong>原子性Atomicity</strong>：一个事务被视为一个不可分割的最小工作单元，整个事务的操作要么全部成功，要么全部       失败</li>
<li><strong>一致性consistency</strong>：就是一个事务没有提交commit，系统崩溃，那么事务中所做的修改不会保存到数据库中</li>
<li><strong>隔离性isolation</strong>：一个事务所作的操作在提交之前，对其他事务是不可见的</li>
<li><strong>持久性durability</strong>：一旦事务提交，所做的修改就会永久保存到数据库中，即使系统崩溃，改的数据也不会丢失</li>
</ul>
<p>​       MySQL==默认采用自动提交==AUTOCOMMIT模式，如果不是显示开始一个事务，每个查询都会被当作一个事务执行提交操作，可通过AUTOCOMMIT变量来启用或禁用自动提交模式</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>​       它是一个存储引擎，用来==负责mysql中的数据的存储和提取==，不会去解析SQL，但是会解析外键定义，它的<strong>数据都存储在表空间</strong>中tablespace，由一系列的数据文件组成，它采用MVCC来支持高并发，<strong>实现了四个标准的隔离级别</strong>，默认级别是：==<strong>REPEATABLE READ（可重复度读）</strong>==</p>
<p>​        InnoDB的表是基于==聚簇索引==建立的</p>
<p>​        表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page），表空间中的页大小都为 16KB，每个 16KB 大小的页中可以存放 2200 行的记录，对<code>nnodb_page_size</code> 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同</p>
<p>​         <strong>表的定义</strong>和<strong>数据索引</strong>等信息分开存储，其中<strong>表的定义</strong>存储在 <code>.frm</code>文件中，<strong>数据索引</strong>储在 <code>.ibd</code> 文件中</p>
<h5 id="在InnoDB中，它为每行记录都增加了三个隐藏的字段"><a href="#在InnoDB中，它为每行记录都增加了三个隐藏的字段" class="headerlink" title="在InnoDB中，它为每行记录都增加了三个隐藏的字段"></a>在InnoDB中，它为每行记录都增加了三个隐藏的字段</h5><ul>
<li><p>事务id：6字节</p>
</li>
<li><p>回滚指针：7字节</p>
</li>
<li><p>隐藏的id</p>
<p><img src="images\111.png" alt=""></p>
</li>
</ul>
<p>​        <strong>为了支持事务，引入如下概念：</strong></p>
<p>​         redo log：保存执行的SQL语句，当MySQL执行recovery时重新执行redo log记录里面的sql操作就好，当客户端每执行一个sql时，先被写到log buffer，当执行commit时，log buffer再被视情况刷新到磁盘</p>
<p>​         undo log：主要是用来回滚，就是复制事务前的数据库内容到undo buffer，再合适的时间undo buffer中的内容刷新到磁盘，它两都是环形缓冲，undo buffer均放在ibd数据文件（表空间）中，undo log被划分为多个段，具体某行的undo log就保存在某段，即<strong>回滚段</strong></p>
<h6 id="当事务1更改此行的值时，会进行如下操作："><a href="#当事务1更改此行的值时，会进行如下操作：" class="headerlink" title="当事务1更改此行的值时，会进行如下操作："></a>当事务1更改此行的值时，会进行如下操作：</h6><p>用排他锁锁定该行</p>
<p>记录redo log</p>
<p>把改行修改前的值copy到undo log</p>
<p>修改当前行的值，填写事务编号，使用回滚指针指向undo log中的修改前的行</p>
<p>​        当有多行修改记录时，通过回滚指针连在一起，可通过当前指针的回滚指针回溯，InnoDB的purge线程，它会查询比现在最老的活动事务还早道德undo log，删除它们</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><strong>未提交读</strong>：就是脏读，事务的修改即使没有提交，对其他事务都是可见的，事务可以读取未提交的数据</li>
<li><strong>提交读</strong>：一个事务所作的操作在提交之前，对其他事务是不可见的，即不可重复读（隔离性）</li>
<li>==<strong>可重复读</strong>==：解决了脏读，该级别保证在同一个事务中多次读取同样的结果是一致的，但是它解决不了幻读，<strong>幻读即在读取数据的时候，另一个事务又插入了 新的记录</strong>，当之前事务再次读取时，产生了幻行，InnoDB的通过<strong>MVCC</strong>解决了幻读</li>
<li><strong>可串行化</strong>：最高的级别，强制事务串行执行，避免了幻读，采用行锁</li>
</ul>
<h4 id="显示隐式锁"><a href="#显示隐式锁" class="headerlink" title="显示隐式锁"></a>显示隐式锁</h4><p>​       采用两阶段锁定协议，在事务执行过程中，随时都能锁，锁只有在执行commit或rollback时才会被释放，所有锁在同一时刻被释放，这是隐式锁定，InnoDB会根据隔离级别自动加锁</p>
<h3 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h3><p>​         它是行级锁的一个变种，通过保存数据在<strong>某个时间点的快照</strong>来实现，更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，每行数据都存在一个版本，每次数据更新时都会更新该版本，各个事务之间无干扰；保存时比较版本号，成功则覆盖，失败则rollback，在默认隔离级别下，MVCC的具体操作(innoDB)： ==InnoDB的MVCC通过在每行记录后面保存两个隐藏的列来实现，一个保存创建时间，一个保存删除时间==</p>
<ul>
<li>select：查找版本早于或=当前事务版本的数据行，确保读取的行在事务开始之前就已经存在，要么是事务自己插入的</li>
<li>insert：为插入的每一行保存当前系统版本号</li>
<li>delete删除每一行保存当前系统版本号为行删除标志</li>
<li>update：保存当前系统版本号，同时保存当前系统版本号到原来的行作为行删除标志</li>
</ul>
<p>​        InnoDB并没有实现核心的饿多版本共存，<strong>undo log里面的内容只是串行化的结果</strong>，不属于多版本共存，当事务影响到多行数据时，MVCC就无能为力，InnoDB只是提供读的非阻塞而已</p>
<h4 id="InnoDB缓存池"><a href="#InnoDB缓存池" class="headerlink" title="InnoDB缓存池"></a>InnoDB缓存池</h4><p>​           缓存索引、缓存行的数据、自适应哈希索引、插入缓冲、锁以及内部数据结构，使用缓存池可以延迟写入，就是合并多个写入操作，然后一起顺序写回，InnoDB严重依赖缓存池</p>
<h4 id="innodb相关磁盘文件："><a href="#innodb相关磁盘文件：" class="headerlink" title="innodb相关磁盘文件："></a>innodb相关磁盘文件：</h4><ul>
<li><ul>
<li>ibdata1:</li>
<li><ul>
<li>回滚段</li>
<li>表元数据</li>
<li>double write</li>
<li>insert buffer dump等</li>
</ul>
</li>
<li>ib_logfile0/1</li>
<li>.frm:表定义文件</li>
<li>.ibd:数据文件,innodb_file_per_table=1</li>
</ul>
<h4 id="性能相关参数："><a href="#性能相关参数：" class="headerlink" title="性能相关参数："></a>性能相关参数：</h4></li>
<li><p>innodb_log_file_size</p>
</li>
<li><p>innodb_log_files_in_group</p>
</li>
<li><p>原因：当redo log 采用轮寻范式ib_logfile0写完，写ib_logfile1完,清楚ib_logfile0并继续写入ib_logfile0;当ib_logfile1写完，ib_logfile0中还有数据没有持久化到磁盘，又来了新的写入，此时会阻塞新写入，强制刷新ib_logfile0到磁盘，再将新写，写入ib_logfile0;这样就是说，logfile越大其写入越不容易阻塞，写入性能也就越好。</p>
</li>
<li><p>数据节点每页16K</p>
</li>
<li><p>innodb数据块缓存池</p>
</li>
<li><p>数据读写经过缓存池</p>
<ul>
<li><p>数据以整页为单位读取</p>
</li>
<li><p>LRU策略（最少使用）换出，</p>
</li>
</ul>
<h4 id="innodb数据持久化：通过事务日志"><a href="#innodb数据持久化：通过事务日志" class="headerlink" title="innodb数据持久化：通过事务日志"></a>innodb数据持久化：通过事务日志</h4></li>
<li><p>innodb_flush_log_at_trx_commit</p>
</li>
<li><ul>
<li>0：每秒写入并持久化一次（不安全，性能高，无论mysql或服务器宕机，都会丢数据），<strong>延迟写</strong></li>
<li>1：每次commit都持久化（安全，性能低，IO负担重）<strong>，实时写，实时刷</strong></li>
<li>2：每次commit都写入内存的redo log缓存，每秒再刷新到磁盘（安全，性能折中，mysql宕机数据不会丢失，服务器宕机数据会丢失），<strong>实时写，延时刷</strong></li>
</ul>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>​         通过事务日志来减少提交事务时的开销，因为事务修改的数据和索引通常会映射到表空间的随机位置，这样刷新到磁盘需要很多随机IO，InnoDB用日志把<strong>随机变为顺序</strong>，InnoDB最后还是把变更写到数据文件，日志有固定的大小，它以<strong>环形方式写入</strong>，写到日志尾部时，会重新跳到头部开始，不会覆盖还没有写入到数据文件的日志记录</p>
<p>​       InnoDB变更任何数据时，会写一条变更记录到内存日志缓冲区，在缓冲区满的时候或事务提交的 时候，InnoDB都会刷写缓冲区的内容到磁盘日志文件，它默认通过一个后台线程来写脏页，并且会合并写入，更有效地顺序写出到磁盘</p>
<p>​        要修改日志文件大小，就要完全关闭MySQL，将旧的日志文件移到其他地方，重新配置参数，然后重启</p>
<h5 id="InnoDB刷新日志缓存"><a href="#InnoDB刷新日志缓存" class="headerlink" title="InnoDB刷新日志缓存"></a>InnoDB刷新日志缓存</h5><p>​       当它把日志缓冲刷新到磁盘日志文件上时，会使用一个Mutex锁住缓冲区，InnoDB有一个group Commit功能，可以在一个IO操作中提交多个事务，</p>
<p>​       <strong>日志缓冲文件写到日志文件</strong>：就是简单地把数据从InnoDB的内存缓冲转移到操作系统的缓存，即内存，并没有真正持久化</p>
<p>​       <strong>把日志刷新到持久化缓存</strong>：这是一个阻塞IO的调用，将缓存刷出缓存，并确认写到磁盘中，直到数据被完全写回才会完成</p>
<h5 id="双写缓存"><a href="#双写缓存" class="headerlink" title="双写缓存"></a>双写缓存</h5><p>​      InnoDB用双写缓存来避免当页没有写完整所导致的数据损坏，保证了数据完整性</p>
<p>​      当InnoDB从缓存池刷新页面到磁盘时，会先把它们放在双写缓冲（<strong>顺序的，只调用一次fsync()</strong>），然后再写到其所属的数据区域，保证每个页面的写入都是完整的并且是持久化的</p>
<p>​      如果一个不完整的页写到了双写缓存，InnoDB恢复时，用原始页面替换掉这个损坏页面</p>
<p>​      如果页的真实位置损坏了，InnoDB恢复时，用双写缓存的页面替换掉这个损坏页面，在每个页面末尾都会有一个校验值，能知道它什么时候损坏</p>
<h4 id="innodb关键特性"><a href="#innodb关键特性" class="headerlink" title="innodb关键特性"></a>innodb关键特性</h4></li>
<li><p>插入缓冲（insert buffer）</p>
</li>
<li><p>两次写（Double write）</p>
</li>
<li><p>自适应哈希索引（adaptive hash index）</p>
</li>
<li><p>异步io（Async IO）</p>
</li>
<li><p>刷新领接页（Flush Neighbor  Page）</p>
</li>
</ul>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/MySQL高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/MySQL高级/" itemprop="url">MySQ</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:26:23+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,560
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h2 id="数据文件："><a href="#数据文件：" class="headerlink" title="数据文件："></a>数据文件：</h2><p>MyISAM：</p>
<ol>
<li><p>frm 文件：存放表结构</p>
<ol start="2">
<li><p>myd 文件：存放表数据</p>
<ol start="3">
<li>myi 文件：存放表索引</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>INNODB：</p>
<ol>
<li>frm 存放表结构</li>
<li>ibd：</li>
</ol>
<h2 id="1-MySQL逻辑架构"><a href="#1-MySQL逻辑架构" class="headerlink" title="1.MySQL逻辑架构"></a>1.MySQL逻辑架构</h2><p>​    <img src="images/1.jpg" alt=""></p>
<p>​    <img src="images/2.jpg" alt=""></p>
<p><strong>连接层：</strong>，所包含的服务并不是MySQL所独有的技术。它们都是服务于C/S程序或者是这些程序所需要的 ：连接处理，身份验证，安全性等等。</p>
<p><strong>服务层</strong>。这是MySQL的核心部分。通常叫做 SQL Layer。在  MySQL据库系统处理底层数据之前的所有工作都是在这一层完成的，包括权限判断， sql解析，行计划优化， query cache  的处理以及所有内置的函数(如日期,时间,数学运算,加密)等等。各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视 图等。</p>
<p><strong>引擎层</strong>：通常叫做StorEngine Layer  ，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。就像Linux众多的文件系统  一样。每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎API来与它们交互的。这个接口隐藏  了各个存储引擎不同的地方。对于查询层尽可能的透明。这个API包含了很多底层的操作。如开始一个事  物，或者取出有特定主键的行。存储引擎不能解析SQL，互相之间也不能通信。仅仅是简单的响应服务器 的请求。</p>
<p><strong>存储层</strong>：数据存储层，主要是将数据存储到运行于裸设备上的文件系统之上，并完成与存储引擎的交互。</p>
<h2 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2.存储引擎"></a>2.存储引擎</h2><h3 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>
<p><img src="images/3.jpg" alt=""></p>
<p>支持八种存储引擎，默认使用<strong>InnoDB</strong>。</p>
<h3 id="2-InnoDB-和-MyISAM"><a href="#2-InnoDB-和-MyISAM" class="headerlink" title="2.InnoDB 和 MyISAM"></a>2.InnoDB 和 MyISAM</h3><h4 id="2-2-1两者的区别："><a href="#2-2-1两者的区别：" class="headerlink" title="2.2.1两者的区别："></a>2.2.1两者的区别：</h4><p><img src="images/4.jpg" alt=""></p>
<h4 id="2-2-2-为什么MyISAM-查询要比-InnoDB-要快"><a href="#2-2-2-为什么MyISAM-查询要比-InnoDB-要快" class="headerlink" title="2.2.2 为什么MyISAM 查询要比 InnoDB 要快"></a>2.2.2 为什么MyISAM 查询要比 InnoDB 要快</h4><p>INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多；<br>    1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少；<br>    2）innodb寻址要映射到块，再到行，MYISAM 记录的直接是文件的OFFSET，定位比INNODB要快<br>    3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护</p>
<p>MVCC ( Multi-Version Concurrency Control )多版本并发控制： </p>
<p>​    InnoDB：<strong>通过为每一行记录添加两个额外的隐藏的值来实现MVCC</strong>，这两个值一个记录这行数据<strong>何时被创建</strong>，另外一个记录这行<strong>数据何时过期（或者被删除）。</strong>但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLE  READ时这种策略是如何应用到特定的操作的：</p>
<p>​    SELECT InnoDB必须每行数据来保证它符合两个条件：</p>
<p>　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。</p>
<p>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。</p>
<h4 id="2-2-3主要区别："><a href="#2-2-3主要区别：" class="headerlink" title="2.2.3主要区别："></a>2.2.3主要区别：</h4><ul>
<li>1).<strong>［事务］</strong>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</li>
<li>2).<strong>［锁］</strong>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li>
<li>3).<strong>［全文索引］</strong>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li>
<li>4).<strong>［查询效率］</strong>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li>
<li>5).<strong>［外健］</strong>MyISAM不支持外健，InnoDB支持。</li>
<li>6).<strong>［count］</strong>==MyISAM保有表的总行数，InnoDB只能遍历==。</li>
<li>6).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li>
<li>7).<strong>InnoDB表比MyISAM表更安全</strong>，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li>
<li><strong>8）MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</strong></li>
<li>具体见：<a href="https://blog.csdn.net/silyvin/article/details/80140153" target="_blank" rel="noopener">https://blog.csdn.net/silyvin/article/details/80140153</a></li>
</ul>
<p><strong>9）InnoDB提供多版本数据支持  <a href="https://blog.csdn.net/zhangliangzi/article/details/51379274，MyIsam不支持" target="_blank" rel="noopener">https://blog.csdn.net/zhangliangzi/article/details/51379274，MyIsam不支持</a></strong></p>
<p><strong>10）两者都仅支持B＋树索引，不支持hash索引</strong></p>
<h4 id="2-2-4应用场景："><a href="#2-2-4应用场景：" class="headerlink" title="2.2.4应用场景："></a>2.2.4应用场景：</h4><ul>
<li>1).MyISAM管理<strong>非事务表</strong>。它提供<strong>高速存储和检索</strong>，以及<strong>全文搜索能力</strong>。如果应用中需要执行<strong>==大量的SELECT查询==</strong>，那么MyISAM是更好的选择。</li>
<li>2).InnoDB用于事务处理应用程序，具有众多特性，包括<strong>ACID事务支持</strong>。如果应用中需要<strong>==执行大量的INSERT或UPDATE操作==，则应该使用InnoDB</strong>，这样可以提高多用户<strong>并发操作的性能</strong>。</li>
</ul>
<h4 id="2-2-5为什么存储要使用B-树"><a href="#2-2-5为什么存储要使用B-树" class="headerlink" title="2.2.5为什么存储要使用B+树"></a>2.2.5为什么存储要使用B+树</h4><p><img src="images/5.jpg" alt=""></p>
<p><img src="images/6.jpg" alt=""></p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>​    B+树是一种<strong>平衡的多路查找树</strong></p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li><p>有n棵子树的结点中含有n个<a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97" target="_blank" rel="noopener">关键字</a>，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
</li>
<li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
<li><p>所有的非终端结点可以看成是<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">索引</a>部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。</p>
</li>
</ol>
<p>人话：</p>
<pre><code>1. 每一个父节点的元素都出现在子节点中，是子节点中最大（最小的）元素。
2. 叶子节点包含了全部的数据信息；
3. 每一个叶子节点都指向了下一个叶子节点，形成了一个有序链表；
4. ==**非叶子节点，只起到索引的作用。**==，不存储数据。
</code></pre><h5 id="优势："><a href="#优势：" class="headerlink" title="==优势：=="></a>==优势：==</h5><ol>
<li><p>单一节点存储更多的元素，使得查询的IO次数更少。</p>
</li>
<li><p>所有查询都要查找到叶子节点，查询性能稳定。</p>
</li>
<li><p>所有叶子节点形成有序链表，便于范围查询。(底部有链表)</p>
</li>
<li>B+树还有一个最大的好处，<strong>方便扫库</strong>，<strong>B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了</strong>，<strong>B+树支持range-query非常方便</strong>，而B树不支持。这是==数据库选用B+树的最主要原因==。</li>
</ol>
<h2 id="3-索引优化分析"><a href="#3-索引优化分析" class="headerlink" title="3.索引优化分析"></a>3.索引优化分析</h2><h3 id="3-1-SQL执行顺序"><a href="#3-1-SQL执行顺序" class="headerlink" title="3.1 SQL执行顺序"></a>3.1 SQL执行顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	* </span><br><span class="line">from </span><br><span class="line">	&lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line">where</span><br><span class="line">	&lt;where_condition&gt;</span><br><span class="line">group by</span><br><span class="line">	&lt;group_by_list&gt;</span><br><span class="line">having</span><br><span class="line">	&lt;having_condition&gt;</span><br><span class="line">order by</span><br><span class="line">	&lt;order_by_condition&gt;</span><br><span class="line">limit</span><br><span class="line">	&lt;limit_number&gt;</span><br></pre></td></tr></table></figure>
<p><img src="images/7.jpg" alt=""></p>
<h3 id="3-2-7种join理论"><a href="#3-2-7种join理论" class="headerlink" title="3.2 ==7种join理论=="></a>3.2 ==7种join理论==</h3><p><img src="images/8.jpg" alt=""></p>
<p><img src="images/9.jpg" alt=""></p>
<p>表结构：</p>
<p>​    <img src="images/10.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inner join</span><br><span class="line">select * from emp e inner join dept d on  d.id = e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/11.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left join </span><br><span class="line">select * from emp e left join dept d on  d.id = e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/12.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right join</span><br><span class="line">select * from emp e right join dept d on  d.id = e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/13.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A 的独有（B的 id为 null）</span><br><span class="line">select * from emp e left join dept d on  d.id = e.deptid where d.id is null;</span><br></pre></td></tr></table></figure>
<p><img src="images/14.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B 的独有（A 的id为null）</span><br><span class="line">select * from emp e right join dept d on  d.id = e.deptid where e.id is null;</span><br></pre></td></tr></table></figure>
<p><img src="images/15.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全集</span><br><span class="line"> select * from emp e right join dept d on  d.id = e.deptid</span><br><span class="line"> union</span><br><span class="line"> select * from emp e left join dept d on d.id= e.deptid;</span><br></pre></td></tr></table></figure>
<p><img src="images/16.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A的独有 加上 B的独有</span><br><span class="line">select * from emp e right join dept d on  d.id = e.deptid where e.id is null</span><br><span class="line">union</span><br><span class="line">select * from emp e left join dept d on  d.id = e.deptid where d.id is null;</span><br></pre></td></tr></table></figure>
<p><img src="images/17.png" alt=""></p>
<h3 id="3-3-什么是索引："><a href="#3-3-什么是索引：" class="headerlink" title="3.3  什么是索引："></a>3.3  什么是索引：</h3><p>​    索引是一种数据结构；</p>
<p>​    官方定义：索引是一种帮助MySQL高效获取数据的数据结构。</p>
<p>​    可以简单理解为是一种==排好序的快速查找数据结构==</p>
<p><img src="images/18.png" alt=""></p>
<h4 id="3-3-1-索引的优势劣势"><a href="#3-3-1-索引的优势劣势" class="headerlink" title="3.3.1 索引的优势劣势"></a>3.3.1 索引的优势劣势</h4><p>优点：创建索引可以大大提高系统的性能:<br>    第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>    第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>    第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>    第四，在使用分组和排序 子句进行<a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">数据检索</a>时，同样可以显著减少查询中分组和排序的时间。<br>    第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。     </p>
<p>缺点：</p>
<p>​    第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>​    第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。<br>​    第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 </p>
<h4 id="3-3-2索引的分类"><a href="#3-3-2索引的分类" class="headerlink" title="3.3.2索引的分类"></a>3.3.2索引的分类</h4><ul>
<li>单值索引：即一个索引包含一个列</li>
<li>唯一索引：索引列的值必须唯一</li>
<li>复合索引：一个索引可以包含多个列</li>
</ul>
<h2 id="创建索引-："><a href="#创建索引-：" class="headerlink" title="==创建索引==："></a>==创建索引==：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建：</span><br><span class="line">create index indesName on tableName(columnName(length));</span><br><span class="line"></span><br><span class="line">alter tableName Add index indexName on (columnName(length));</span><br><span class="line"></span><br><span class="line">删除;</span><br><span class="line">Drop index indexName on tableName；</span><br><span class="line"></span><br><span class="line">查看索引：</span><br><span class="line">show index from tableName;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-那些情况适合建立索引？"><a href="#3-3-3-那些情况适合建立索引？" class="headerlink" title="3.3.3 那些情况适合建立索引？"></a>3.3.3 那些情况适合建立索引？</h4><ol>
<li><strong>主键</strong>建立唯一索引</li>
<li>频繁<strong>作为查询条件</strong>的字段</li>
<li>查询中与其他表有关联的字段，比如<strong>外键</strong>建立索引</li>
<li>查询中<strong>排序的字段</strong>创建索引将大大提高排序的速度</li>
<li>查询中<strong>统计或者分组字段</strong></li>
<li>==高并发的情况下一般选择复合索引==</li>
</ol>
<h4 id="3-3-4-那些情况不适合建立索引？"><a href="#3-3-4-那些情况不适合建立索引？" class="headerlink" title="3.3.4 那些情况不适合建立索引？"></a>3.3.4 那些情况不适合建立索引？</h4><ol>
<li><strong>频繁更新的字段</strong>不适合创建索引，因为每次更新不单单是更新了记录还会更新索引文件。</li>
<li><strong>where条件里用不到的字段</strong>不创建索引</li>
<li><strong>表记录太少</strong>。</li>
<li><strong>数据重复且分布平均的表字段</strong>，因此应该只为最经常查询和最经常排序的数据列建立索引。如果某个数据列包含许多重复的内容，为它建立索引就没太大的实际效果。</li>
</ol>
<h4 id="3-3-5-什么是聚簇索引？什么是非聚簇索引？"><a href="#3-3-5-什么是聚簇索引？什么是非聚簇索引？" class="headerlink" title="3.3.5 什么是聚簇索引？什么是非聚簇索引？"></a>3.3.5 什么是聚簇索引？什么是非聚簇索引？</h4><p>​     在<a href="https://www.baidu.com/s?wd=%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《数据库原理》</a>里面，对聚簇索引的解释是:<strong>聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关</strong>。<strong>==正式因为如此，所以一个表最多只能有一个聚簇索引==</strong>。</p>
<pre><code>不过这个定义太抽象了。在SQL Server中，索引是通过二叉树的数据结构来描述的，我们可以这么理解
</code></pre><p>​    聚簇索引：<strong>索引的叶节点就是数据节点。</strong></p>
<p>​    非聚簇索引：<strong>叶节点仍然是索引节点，只不过有一个指针指向对应的数据块</strong></p>
<h3 id="3-4-性能分析前提"><a href="#3-4-性能分析前提" class="headerlink" title="3.4 性能分析前提"></a>3.4 性能分析前提</h3><ol>
<li><p>MysqI中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行划(<em><u>他认为最优的数据检索方式，<strong>但不见得是DBA认为是最优的</strong>，这部分最耗费时间</u></em>)</p>
</li>
<li><p>当客户端向MySQL请求一条Query,命令解析器模块完成请求分类，区别出是SELECT并转发给MySQLQuery Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些 常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一- 些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息(如果有)，看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p>
</li>
</ol>
<h3 id="3-5explain-命令"><a href="#3-5explain-命令" class="headerlink" title="3.5explain 命令"></a>3.5explain 命令</h3><h4 id="3-5-1-怎么玩？"><a href="#3-5-1-怎么玩？" class="headerlink" title="3.5.1 怎么玩？"></a>3.5.1 怎么玩？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain + SQL 语句</span><br><span class="line">例:</span><br><span class="line">	explain select * from emp;</span><br></pre></td></tr></table></figure>
<p>​    包含的信息：</p>
<p> <img src="images/19.png" alt=""></p>
<h4 id="3-5-2-能干什么？"><a href="#3-5-2-能干什么？" class="headerlink" title="3.5.2 能干什么？"></a>3.5.2 能干什么？</h4><ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以被使用</li>
<li>哪些索引实际被使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="3-5-3-explain-id介绍："><a href="#3-5-3-explain-id介绍：" class="headerlink" title="3.5.3 explain id介绍："></a>3.5.3 explain id介绍：</h4><p>​    select 查询的序列号，包含一组数字，表示查询中执行的select字句或者操作表的顺序。</p>
<p>​    三种情况：</p>
<pre><code>1. id 相同：执行顺序由上至下
2. id 不同：值越大越先执行
3. id 相同 也 不同：值越大越先执行，相同的执行顺序由上至下
</code></pre><p> <img src="images/20.png" alt=""></p>
<p> <img src="images/21.png" alt=""></p>
<p> <img src="images/22.png" alt=""></p>
<h4 id="3-5-4-explain之select-type和table介绍"><a href="#3-5-4-explain之select-type和table介绍" class="headerlink" title="3.5.4 explain之select_type和table介绍"></a>3.5.4 explain之select_type和table介绍</h4><p><strong>table</strong>：显示这一行数据时来自于哪一张表的。</p>
<p>select_type：显示此次查询的类型：</p>
<pre><code>1. simple：简单的 select 查询，其中不包含子查询或者 union
              2. primary：查询中若包含任何复杂的子部分，则最外层被标记为primary
          3. subquery：子查询
                    4. derived：衍生表
        5. union：若第二个select 出现在union 之后 ，则被标记为union
                 6. union result：
</code></pre><h4 id="3-5-5-explain之type介绍"><a href="#3-5-5-explain之type介绍" class="headerlink" title="3.5.5 explain之type介绍"></a>3.5.5 explain之type介绍</h4><p>type代表查询用了何种类型</p>
<p> <img src="images/23.png" alt=""></p>
<p>==从最好到最差依次为：==</p>
<p>​    ==system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all==</p>
<p><strong>一般来说最好达到 range 最好是 ref！</strong></p>
<p>type详解：</p>
<pre><code>1. system：表只有一行记录，这是const类型的特例，平时不会出现，可以忽略不计
2. const：常量查询
3. eq_ref：唯一性索引扫描，常见于主键或者唯一索引
4. ref：非唯一性索引扫描，返回匹配某个值的所有行（本质上也是索引查询），他可能会查出多个行与之匹配；
5. range：范围查询
6. index：遍历索引树
7. all：全表扫描
</code></pre><p> <img src="images/24.png" alt=""></p>
<p> <img src="images/25.png" alt=""></p>
<p> <img src="images/26.png" alt=""></p>
<p> <img src="images/27.png" alt=""></p>
<p> <img src="images/28.png" alt=""></p>
<h4 id="3-5-6-explain之possible-keys和key介绍"><a href="#3-5-6-explain之possible-keys和key介绍" class="headerlink" title="3.5.6 explain之possible_keys和key介绍"></a>3.5.6 explain之possible_keys和key介绍</h4><p>possible_keys：理论上要用到的索引，==实际上并不一定被用到。==</p>
<p>key：实际被用到的索引</p>
<h4 id="3-5-7explain之key-len介绍"><a href="#3-5-7explain之key-len介绍" class="headerlink" title="3.5.7explain之key_len介绍"></a>3.5.7explain之key_len介绍</h4><p>key_len：表示索引中用到的字节数，可以通过该数值计算查询中使用到的索引的长度，<strong>==越小越好==</strong></p>
<p>key_len大，查询的精度一般也大。理论上key_len越小越好，但是查询精度的提高必须得牺牲一定的空间</p>
<p><img src="images/29.png" alt=""></p>
<h4 id="3-5-8-explain之ref介绍"><a href="#3-5-8-explain之ref介绍" class="headerlink" title="3.5.8 explain之ref介绍"></a>3.5.8 explain之ref介绍</h4><p>ref： 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或者常量被用于查找索引列上的值。</p>
<p><img src="images/30.png" alt=""></p>
<p><img src="images/31.png" alt=""></p>
<h4 id="3-5-9-explain之rows介绍"><a href="#3-5-9-explain之rows介绍" class="headerlink" title="3.5.9 explain之rows介绍"></a>3.5.9 explain之rows介绍</h4><p>rows：根据表统计的信息以及索引的选用情况，大致估算出找到所需记录所<strong>==需要读取的行数。==</strong></p>
<p><img src="images/32.png" alt=""></p>
<h4 id="3-5-10-explain之Extra介绍"><a href="#3-5-10-explain之Extra介绍" class="headerlink" title="3.5.10 explain之Extra介绍"></a>3.5.10 explain之Extra介绍</h4><p>主要有以下三种情况：</p>
<p>​    Using filesort：九死一生，使用了文件内排序（<strong>MySQL中无法利用索引完成的排序操作称为:文件排序”</strong>）</p>
<p>​    Using temporary：十死无生，用不上索引，还使用了临时表</p>
<p>​    Using index：发财了，大好事，用上了索引</p>
<h3 id="3-6心法口诀"><a href="#3-6心法口诀" class="headerlink" title="==3.6心法口诀=="></a>==3.6心法口诀==</h3><p>==<strong>全值匹配我最爱，最左前缀要遵守；</strong>==<br><strong>==带头大哥不能死，中间兄弟不能断；==</strong><br><strong>==索引列上少计算，范围之后全失效；==</strong><br><strong>==百分like加右边，覆盖索引不写星；==</strong><br><strong>==不等空值还有or，索引失效要少用；==</strong><br><strong>==字符串里有引号，SQL高级也不难；==</strong></p>
<h3 id="3-7小表驱动大表（exists-和-in）"><a href="#3-7小表驱动大表（exists-和-in）" class="headerlink" title="3.7小表驱动大表（exists 和 in）"></a>3.7小表驱动大表（exists 和 in）</h3><p>永远小表驱动大表！！！<br>select * from emp e where e.deptno in (select deptno from dept d);（in 里面是小表）</p>
<p>select * from emp e where exists (select 1 from dept d where e.deptno = d.deptno);<br>（exists  里面是大表）</p>
<h3 id="3-8-order-by-和-group-by-优化"><a href="#3-8-order-by-和-group-by-优化" class="headerlink" title="3.8 order by 和 group by 优化"></a>3.8 order by 和 group by 优化</h3><p>order by 里面默认是升序 ASC。别跳楼机（上下上下）。</p>
<p>order by 满足以下两种情况会使用useing index：<br>    ==1、order by 语句使用索引最左前列==<br>    ==2、使用 where 字句 和 order by 字句条件列组合满足索引最左前列。==</p>
<h4 id="3-8-1-单路双路算法"><a href="#3-8-1-单路双路算法" class="headerlink" title="3.8.1 单路双路算法"></a>3.8.1 单路双路算法</h4><p>​    order by 双路算法：Mysql4.1之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和ORDER BY列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段。文件的磁盘IO非常耗时的，所以在Mysql4.1之后，出现了第二种算法，就是单路排序。<br>​    <strong>读取两次 排序一次 读取数据一次</strong></p>
<p>​    order by 单路算法：从磁盘读取查询所需要的所有列，按照ORDER BY在buffer对它进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在了内存里。<br>​    <strong>是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序</strong></p>
<p>​    <strong>存在问题</strong>：有可能单路排序算法一次拿不出数据，那么就还比双路排序更消耗IO，效率更慢！<br>在sort_buffer中，单路排序要比双路排序占很多空间，因为单路排序把所有的字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能读取sort_buffer容量大小的数据，进行排序(创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再次排序…从而多次I/O。偷鸡不成蚀把米。<br>​    ==<strong>一次拿不完，需要多拿几次。。。==</strong><br>比如：内存就是2M，一次查1000条数据刚好，也就是最大1000条数据，但是一次要查5000条，那么不够了，照这样需要查5次刚好，如果把2M改为10M，那么就刚好了</p>
<h4 id="3-8-2-如何提高-order-by的速度："><a href="#3-8-2-如何提高-order-by的速度：" class="headerlink" title="3.8.2 如何提高 order by的速度："></a>3.8.2 如何提高 order by的速度：</h4><ol>
<li><p>order by 时select * 不要用，这是一个大忌，要写出只需要query 的字段即可。</p>
<p>​    a：当查询的字段大小综合小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法—单路排序，否则用老算法—多路排序。假设只需要查10个字段，但是SELECT *会查80个字段，那么就容易把sort_buffer缓冲区用满。</p>
<pre><code>b：两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size大小。
</code></pre></li>
<li><p>尝试提高 sort_buffer_size</p>
<p>​    不管用哪种算法，提高这个参数都会提高效率。当然要根据系统能力去提高，因为这个参数是针对每个进程的。</p>
</li>
<li><p>尝试提高 max_length_for_sort_data </p>
<p>​    提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率</p>
</li>
</ol>
<h4 id="3-8-3-order-by-内功心法："><a href="#3-8-3-order-by-内功心法：" class="headerlink" title="3.8.3 order by 内功心法："></a>3.8.3 order by 内功心法：</h4><p>为排序使用索引<br>==MYSQL两种排序方式：文件排序和扫描有序索引排序==<br>==Mysql能为排序和查询使用相同的索引。也就是创建索引先把数据排序了，查询的时候再利用索引，一举两得。==</p>
<p>KEY a_b_c(a,b,c)<br><strong>order by 能使用索引最左前缀</strong></p>
<p>ORDER BY a<br>ORDER BY a,b<br>ORDER BY a,b,c<br>ORDER BY a DESC,b DESC,c DESC</p>
<p><strong>如果where使用索引的最左前缀定义为常量，则order by 能使用索引</strong></p>
<p>WHERE a = const ORDER BY b,c<br>WHERE a = const AND b = const ORDER BY c<br>WHERE a = const AND b &gt; const ORDER BY b,c</p>
<p>不使用索引进行排序</p>
<p>ORDER BY a ASC,b DESC, c DESC //<strong>排序不一致</strong><br>WHERE g = const ORDER BY b,c //<strong>丢失a索引</strong><br>WHERE a = const ORDER BY c //<strong>丢失b索引</strong><br>WHERE a = const ORDER BY a,d //<strong>d不是索引的一部分</strong><br>WHERE a in (….) ORDER BY b,c //<strong>对于排序来说，多个相等条件也是范围查询</strong></p>
<p>GROUP BY的优化</p>
<p>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。<br>当无法使用索隐裂，考虑增大max_length_for_sort_data和sort_buffer_size的参数设置。<br><strong>==WHERE 高于 HAVING，能写在WHERE限定的条件就不要去HAVING限定了。==</strong></p>
<h2 id="4-慢查询日志"><a href="#4-慢查询日志" class="headerlink" title="4.慢查询日志"></a>4.慢查询日志</h2><h3 id="4-1-什么是慢查询日志？"><a href="#4-1-什么是慢查询日志？" class="headerlink" title="4.1 什么是慢查询日志？"></a>4.1 什么是慢查询日志？</h3><p>​    MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中<strong>==响应时间超过阀值==</strong>的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p>
<p>​    <strong>long_query_time的默认值为10</strong>，意思是运行10S以上的语句。</p>
<p>​    <strong>默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数</strong>，<strong>当然，如果不是调优需要的话，一般不建议启动该参数</strong>，因为<strong>开启慢查询日志会或多或少带来一定的性能影响</strong>。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>
<h3 id="4-2-查看慢查询日志是否开启"><a href="#4-2-查看慢查询日志是否开启" class="headerlink" title="4.2 查看慢查询日志是否开启"></a>4.2 查看慢查询日志是否开启</h3><p>​    命令：(<strong>默认关闭的!!如果不是调优需要请不要开启！</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看：</span><br><span class="line">show variables like &apos;%slow_query_log%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="images/33.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置开启：</span><br><span class="line">set global slow_query_log = 1;</span><br></pre></td></tr></table></figure>
<p><img src="images/34.png" alt=""></p>
<p>需要注意的是使用set global slow_query_log=1;开启慢查询日志<strong>==只对当前数据库生效,如果MySQL重启后则会失效。==</strong></p>
<p><strong>一般不建议永久开启慢查询日志，如果一定要做，只能修改配置文件!!</strong>(自行百度)</p>
<h3 id="4-3-设置其他参数"><a href="#4-3-设置其他参数" class="headerlink" title="4.3 设置其他参数"></a>4.3 设置其他参数</h3><h4 id="4-3-1-查看当前默认慢查询时间："><a href="#4-3-1-查看当前默认慢查询时间：" class="headerlink" title="4.3.1 查看当前默认慢查询时间："></a>4.3.1 查看当前默认慢查询时间：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES LIKE &apos;%long_query_time%&apos;；</span><br><span class="line">默认是10秒</span><br></pre></td></tr></table></figure>
<p><img src="images/35.png" alt=""></p>
<p>long_query_time默认是10秒。也就是<strong>==大于10秒==</strong>的sql会记录在慢查询日志中。<strong>非大于等于</strong>。</p>
<h4 id="4-3-2-修改慢查询时间：（需要重连）"><a href="#4-3-2-修改慢查询时间：（需要重连）" class="headerlink" title="4.3.2 修改慢查询时间：（需要重连）"></a>4.3.2 修改慢查询时间：（需要重连）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set global long_query_time = 3; 设置慢查询时间为3秒</span><br><span class="line"></span><br><span class="line">show variables like &apos;%long_query_time%&apos;;再次查看 不好使了</span><br><span class="line"></span><br><span class="line">show global variables like &apos;%long_query_time%&apos;;需要这个命令查看</span><br><span class="line"></span><br><span class="line">然后重新连接就好了。</span><br></pre></td></tr></table></figure>
<p><img src="images/36.png" alt=""></p>
<h4 id="4-3-3-查看慢查询条数"><a href="#4-3-3-查看慢查询条数" class="headerlink" title="4.3.3 查看慢查询条数"></a>4.3.3 查看慢查询条数</h4><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show GLOBAL STATUS LIKE &apos;%Slow_queries%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="images/37.png" alt=""></p>
<h4 id="4-3-4-永久生效配置："><a href="#4-3-4-永久生效配置：" class="headerlink" title="4.3.4 永久生效配置："></a>4.3.4 永久生效配置：</h4><p><img src="images/38.png" alt=""></p>
<h3 id="4-4-日志分析工具-mysqldumpslow"><a href="#4-4-日志分析工具-mysqldumpslow" class="headerlink" title="4.4  日志分析工具 mysqldumpslow"></a>4.4  日志分析工具 mysqldumpslow</h3><p>​    在生产环境之中，如果要手工分析日志，查找，分析SQL，显然是一个体力活，MySQL提供了日志分析工具，<strong>mysqldumpslow！</strong></p>
<h4 id="4-4-1-windows怎么做！！"><a href="#4-4-1-windows怎么做！！" class="headerlink" title="4.4.1 windows怎么做！！"></a>4.4.1 windows怎么做！！</h4><p>​    以下是windows环境需要安装其他支持软件的步骤，<strong>非windows直接忽略</strong><br>​    windows要执行mysqldumpslow需要安装ActivePerl因为windows上这是一个perl脚本,需要安装ActivePerl才能执行，linux下就可以直接执行mysqldumpslow了。<br>​    安装ActivePerl的步骤我就不多说了。安装好后会在环境变量PATH中找到perl的bin目录。我重启了电脑让环境变量生效。</p>
<p>验证ActivePerl是否安装成功</p>
<p>​    <img src="images/39.png" alt=""></p>
<h4 id="4-4-2-怎么玩？"><a href="#4-4-2-怎么玩？" class="headerlink" title="4.4.2 怎么玩？"></a>4.4.2 怎么玩？</h4><p><img src="images/40.png" alt=""></p>
<p><img src="images/41.png" alt=""></p>
<h2 id="5-show-profile"><a href="#5-show-profile" class="headerlink" title="5. show profile"></a>5. show profile</h2><h3 id="5-1show-profile-是什么？"><a href="#5-1show-profile-是什么？" class="headerlink" title="5.1show profile 是什么？"></a>5.1show profile 是什么？</h3><p>是MySQL提供用来分析当前会话中语句执行的资源消耗情况，可以用于SQL调优的测量。</p>
<p>默认情况下是关闭的，默认存储最近15条的运行记录。</p>
<h3 id="5-2-怎么玩？"><a href="#5-2-怎么玩？" class="headerlink" title="5.2 怎么玩？"></a>5.2 怎么玩？</h3><ol>
<li>开启功能，默认是关闭的</li>
<li>运行SQL （select * from emp;）</li>
<li>查看结果：show profiles;</li>
<li>进行诊断：show profile cpu，block io for query 上一步前面的问题SQL的号码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">show variables like &apos;profiling&apos;;查看是否开启</span><br><span class="line"></span><br><span class="line">set profiling = on;开启</span><br><span class="line"> </span><br><span class="line">show variables like &apos;profiling&apos;;再次查看</span><br></pre></td></tr></table></figure>
<p><img src="images/42.png" alt=""></p>
<p>运行SQL：</p>
<p><img src="images/43.png" alt=""></p>
<p>==查看结果：==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>
<p><img src="images/44.png" alt=""></p>
<p>进行诊断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile cpu,block io query 6;</span><br></pre></td></tr></table></figure>
<p><img src="images/45.png" alt=""></p>
<p>show profiles 后面还可以有别的参数：</p>
<p><img src="images/46.png" alt=""></p>
<h3 id="5-3致命伤："><a href="#5-3致命伤：" class="headerlink" title="5.3致命伤："></a>5.3致命伤：</h3><p>那么如何查看show profile + 参数 查询出来的结果呢？</p>
<p><strong>==如果在status出现了以下内容，证明sql可能有问题==</strong></p>
<ol>
<li><p>converting HEAP to MYISAM</p>
</li>
<li><p>Creating tmp table 创建临时表</p>
</li>
<li><p>Copying to tmp table on disk</p>
</li>
<li><p>locked</p>
</li>
</ol>
<h4 id="5-3-1-converting-HEAP-to-MYISAM"><a href="#5-3-1-converting-HEAP-to-MYISAM" class="headerlink" title="5.3.1 converting HEAP to MYISAM"></a>5.3.1 converting HEAP to MYISAM</h4><p>==查询结果太大。内存不够用了，往磁盘上搬了。==</p>
<h4 id="5-3-2-Creating-tmp-table"><a href="#5-3-2-Creating-tmp-table" class="headerlink" title="5.3.2 Creating tmp table"></a>5.3.2 Creating tmp table</h4><p>==创建临时表：==</p>
<p>​    ==拷贝数据到临时表==</p>
<p>​    ==用完再删除==</p>
<h4 id="5-3-3-Copying-to-tmp-table-on-disk"><a href="#5-3-3-Copying-to-tmp-table-on-disk" class="headerlink" title="5.3.3 Copying to tmp table on disk"></a>5.3.3 Copying to tmp table on disk</h4><p>==把内存中临时表复制到磁盘，危险！！！！==</p>
<h4 id="5-3-4-locked（表锁了）"><a href="#5-3-4-locked（表锁了）" class="headerlink" title="5.3.4 locked（表锁了）"></a>5.3.4 locked（表锁了）</h4><h4 id="5-3-5-其他演示："><a href="#5-3-5-其他演示：" class="headerlink" title="5.3.5 其他演示："></a>5.3.5 其他演示：</h4><p><img src="images/47.png" alt=""></p>
<h2 id="6-数据库的锁机制"><a href="#6-数据库的锁机制" class="headerlink" title="6.数据库的锁机制"></a>6.数据库的锁机制</h2><h3 id="6-1-锁的定义"><a href="#6-1-锁的定义" class="headerlink" title="6.1 锁的定义"></a>6.1 锁的定义</h3><p>锁是计算机用来协调多个进程或线程并发访问某一个资源的机制。</p>
<p>在数据库之中，除了传统的计算资源（cpu，RAM，IO等）的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性，有效性是所有数据库，必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁是十分重要的，也十分复杂。</p>
<p><img src="images/48.png" alt=""></p>
<h3 id="6-2锁的分类"><a href="#6-2锁的分类" class="headerlink" title="6.2锁的分类"></a>6.2锁的分类</h3><p>读写锁，行锁，表锁。</p>
<p>读锁（共享锁）：针对同一份数据，多个读操作之间同时进行 不会有任何的影响</p>
<p>写锁（排它锁）：当前操作没有完成的时候，他会阻断其他的写锁和读锁。</p>
<p>表锁（偏读）</p>
<p>行锁（偏写）</p>
<h2 id="7-MyISAM-锁"><a href="#7-MyISAM-锁" class="headerlink" title="7. MyISAM 锁"></a>7. MyISAM 锁</h2><h3 id="7-1-读锁（MyISAM）"><a href="#7-1-读锁（MyISAM）" class="headerlink" title="7.1 读锁（MyISAM）"></a>7.1 读锁（MyISAM）</h3><p>偏向 MyISAM引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率高，并发度最低。</p>
<p>建表：</p>
<p><img src="images/49.png" alt=""></p>
<p><img src="images/50.png" alt=""></p>
<h4 id="7-1-1-手动添加表锁："><a href="#7-1-1-手动添加表锁：" class="headerlink" title="7.1.1 手动添加表锁："></a>7.1.1 手动添加表锁：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock table 表名字  read(write), 表名字2 read(write),其它;</span><br><span class="line"></span><br><span class="line">show open tables;查看表的锁定情况</span><br><span class="line"></span><br><span class="line">lock table mylock read,emp write;</span><br><span class="line">给mylock表加读锁（共享锁），给emp表加写锁（排它锁）</span><br><span class="line"></span><br><span class="line">unlock tables; 释放锁</span><br></pre></td></tr></table></figure>
<p><img src="images/51.png" alt=""></p>
<p><img src="images/52.png" alt=""></p>
<h4 id="7-1-2-读锁场景模拟："><a href="#7-1-2-读锁场景模拟：" class="headerlink" title="7.1.2 读锁场景模拟："></a>7.1.2 读锁场景模拟：</h4><p>给mylock 加上读锁：</p>
<p><img src="images/53.png" alt=""></p>
<p>都可以查互不影响。</p>
<p><strong>尝试session 1 进行update 操作：</strong></p>
<p><img src="images/54.png" alt=""></p>
<p><strong>不可以进行update操作；</strong></p>
<p><strong>尝试session 1 进行select 其他表操作：</strong></p>
<p><img src="images/55.png" alt=""></p>
<p><strong>不可以进行读其他表操作；</strong></p>
<p>尝试 session 2 进行update 操作；</p>
<p><img src="images/56.png" alt=""></p>
<p>session 2 一直处于阻塞状态；</p>
<p><strong>==在session 1解除锁定之后，session 2 才会执行。==</strong></p>
<p><img src="images/57.png" alt=""></p>
<h4 id="7-1-3-读锁总结"><a href="#7-1-3-读锁总结" class="headerlink" title="==7.1.3 读锁总结=="></a>==7.1.3 读锁总结==</h4><table>
<thead>
<tr>
<th>session 1</th>
<th style="text-align:center">session 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以读mylock</td>
<td style="text-align:center">可以读mylock</td>
</tr>
<tr>
<td>不可以读别的表</td>
<td style="text-align:center">可以读别的表</td>
</tr>
<tr>
<td>不可以update mylock</td>
<td style="text-align:center">不可以update（必须等待session 1释放锁）</td>
</tr>
<tr>
<td>不可以update 其他表</td>
<td style="text-align:center">可以update其他表</td>
</tr>
</tbody>
</table>
<p><strong>==一句话：读锁，别的可以读，写要阻塞，自己只能读自己。==</strong></p>
<h3 id="7-2写锁（MyISAM）"><a href="#7-2写锁（MyISAM）" class="headerlink" title="7.2写锁（MyISAM）"></a>7.2写锁（MyISAM）</h3><h4 id="7-2-1-写锁场景模拟"><a href="#7-2-1-写锁场景模拟" class="headerlink" title="7.2.1 写锁场景模拟"></a>7.2.1 写锁场景模拟</h4><p>session 1 给 mylock 加上 写锁；</p>
<p><img src="images/58.png" alt=""></p>
<p>session 1 <strong>可以读 可以写</strong>  <strong>不可以的读其他的</strong></p>
<p><img src="images/59.png" alt=""></p>
<p><img src="images/62.png" alt=""></p>
<p>sessoin 2  <strong>连读都不可以</strong></p>
<p><img src="images/60.png" alt=""></p>
<p>只有在 session 1 释放锁之后才可以查询；</p>
<p><img src="images/61.png" alt=""></p>
<h4 id="7-2-2-写锁总结"><a href="#7-2-2-写锁总结" class="headerlink" title="7.2.2 写锁总结"></a>7.2.2 写锁总结</h4><table>
<thead>
<tr>
<th style="text-align:center">session 1</th>
<th style="text-align:center">session 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可以读mylock</td>
<td style="text-align:center">不可以读mylock</td>
</tr>
<tr>
<td style="text-align:center">不可以读别的</td>
<td style="text-align:center">可以读别的</td>
</tr>
<tr>
<td style="text-align:center">可以update mylock</td>
<td style="text-align:center">不可以update mylock</td>
</tr>
</tbody>
</table>
<p><strong>==一句话总结：写锁，自己只可以自己玩自己的，不能玩别的，别人只能玩别的，不能玩你的。（独占）==</strong></p>
<h3 id="7-3-MyISAM案例总结"><a href="#7-3-MyISAM案例总结" class="headerlink" title="7.3  MyISAM案例总结"></a>7.3  MyISAM案例总结</h3><table>
<thead>
<tr>
<th style="text-align:center">锁类型</th>
<th style="text-align:center">可否兼容</th>
<th style="text-align:center">读锁</th>
<th style="text-align:center">写锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读锁</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">写锁</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>结论:</p>
<p>结合上表,所以对MyISAM表进行操作,会有以下情况:</p>
<p>1、对MyISAM表的读操作(加读锁) ,不会阻塞其他进程对同一表的读请求,但会阻塞对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。</p>
<p>2、对MyISAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作</p>
<p><strong>==简而言之,就是读锁会阻塞写,但是不会堵塞读。而写锁则会把读和写都堵塞,==</strong></p>
<h3 id="7-4-其他查看命令"><a href="#7-4-其他查看命令" class="headerlink" title="7.4 其他查看命令"></a>7.4 其他查看命令</h3><p>看看那些表 被锁了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &apos;table%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="images/63.png" alt=""></p>
<p>解释：</p>
<p>Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每次获取数值加一；<br>Table_locks_waited：出现表级锁定而发生等待的次数（不能立即获取锁，每次等待数值加一），<strong>==此值高说明出现严重的表级锁争用情况。==</strong></p>
<p>show status like ‘table%’;</p>
<p>主要看两行的后一行  Table_locks_waited的值偏大是不好的；</p>
<p><strong>==myisam的读写锁调度是写优先，myisam不适合做写为主表的引擎。写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。==</strong></p>
<h2 id="8-INNODB-锁"><a href="#8-INNODB-锁" class="headerlink" title="8. INNODB 锁"></a>8. INNODB 锁</h2><p><strong>InnoDB与MyISAM的最大不同有两点：一是支持事务，而是采用了行级锁。</strong></p>
<h3 id="8-1-数据库的事务（ACID）："><a href="#8-1-数据库的事务（ACID）：" class="headerlink" title="8.1 数据库的事务（ACID）："></a>8.1 数据库的事务（ACID）：</h3><h4 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h4><p>​    原子性是指事务包含的所有操作<strong>要么全部成功，要么全部失败</strong>回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h4 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h4><p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一<strong>个事务执行之前和执行之后都必须处于一致性状态。</strong></p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h4 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h4><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　关于事务的隔离性数据库提供了<strong>多种隔离级别</strong>，稍后会介绍到。</p>
<h4 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h4><p>　　持久性是指<strong>一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的</strong>，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h3 id="8-2-事务的隔离性"><a href="#8-2-事务的隔离性" class="headerlink" title="8.2 事务的隔离性"></a>8.2 事务的隔离性</h3><p>​    以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h4 id="​8-2-1更新丢失"><a href="#​8-2-1更新丢失" class="headerlink" title="​8.2.1更新丢失"></a>​8.2.1更新丢失</h4><p>​     当两个或多个事务选择同行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。<br>​    例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员<strong>覆盖前一个程序员</strong>所做的更改。</p>
<p><strong>如果在一一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</strong> </p>
<h4 id="8-2-2-脏读"><a href="#8-2-2-脏读" class="headerlink" title="8.2.2 脏读"></a>8.2.2 脏读</h4><p>​    <strong>一个事务读到另外一个事务已经修改还没有提交的数据。</strong>此时如果A事务回滚，那么 B读取到的数据就无效了，不符合一致性。</p>
<h4 id="8-2-3-不可重复读"><a href="#8-2-3-不可重复读" class="headerlink" title="8.2.3 不可重复读"></a>8.2.3 不可重复读</h4><p> 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做“不可重复读”.</p>
<p><strong>事务A读取到了事务B已经提交的修改数据，不符合隔高性</strong></p>
<p><strong>一句话:一个事务先后读取同一条记录，但两次读取的数据不同。</strong></p>
<h4 id="8-2-4-幻读"><a href="#8-2-4-幻读" class="headerlink" title="8.2.4 幻读"></a>8.2.4 幻读</h4><pre><code>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读“；
</code></pre><p><strong>一句话:事务A读取到了事务B体提交的新增数据，不符合隔高性。</strong></p>
<p>多说一句:幻读和脏读有点类似，</p>
<p><strong>==脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。==</strong></p>
<h3 id="8-3-数据库的事务隔离级别"><a href="#8-3-数据库的事务隔离级别" class="headerlink" title="8.3 数据库的事务隔离级别"></a>8.3 数据库的事务隔离级别</h3><p>脏读，幻读 和 不可重复读其实都是数据库一致性问题，必须由数据库提供一定的事务隔离机制来进行解决。</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交（read-uncommitted）</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>​     <strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“==串行化”==进行，这显然与==“并发”==是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力</strong>。</p>
<h4 id="8-3-1-INNODB-RR-隔离级别下-如何-避免幻读的"><a href="#8-3-1-INNODB-RR-隔离级别下-如何-避免幻读的" class="headerlink" title="==8.3.1 INNODB  RR 隔离级别下 如何 避免幻读的=="></a>==8.3.1 INNODB  RR 隔离级别下 如何 避免幻读的==</h4><p><strong>官方文档：在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 gap 锁或者 next-key锁 (行锁+gap锁)。</strong></p>
<ul>
<li><p><strong>其实 就是 通过 快照读（伪MVCC模式） + undo log + read view</strong> </p>
<ul>
<li>TRX_ID(事务 ID),     ROLL_PTR(回滚指针)</li>
</ul>
<p><img src="images/112.png" alt=""></p>
</li>
<li><p><strong>next-key锁（行锁 加上 gap锁）</strong></p>
<ul>
<li>gap 出现的场景<ul>
<li>不走索引（会上锁所有的gap）</li>
<li>where 命中不全（5,7,9 只命中了 5,7） 那么会在 5 - 9 之家加上 gap锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-查看当前事务的隔离级别"><a href="#8-3-1-查看当前事务的隔离级别" class="headerlink" title="8.3.1 查看当前事务的隔离级别"></a>8.3.1 查看当前事务的隔离级别</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;tx_isolation&apos;;</span><br><span class="line">默认是 RR（可重复读） 级别</span><br></pre></td></tr></table></figure>
<p><img src="images/64.png" alt=""></p>
<h4 id="8-3-2-：Spring-中的事务传播行为"><a href="#8-3-2-：Spring-中的事务传播行为" class="headerlink" title="8.3.2 ：Spring  中的事务传播行为"></a>8.3.2 ：Spring  中的事务传播行为</h4><p><strong>在TransactionDefinition接口中定义了七个事务传播行为：</strong></p>
<p>（1）PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 </p>
<p>（2）PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</p>
<p>（3）PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p>（4）PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<p>（5）PROPAGATION_NOT_SUPPORTED  总是非事务地执行，并挂起任何存在的事务</p>
<p>（6）PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常； </p>
<p>（7）PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p>
<h4 id="8-3-3-事务是否只读"><a href="#8-3-3-事务是否只读" class="headerlink" title="8.3.3 事务是否只读"></a>8.3.3 事务是否只读</h4><p><strong>是否只读</strong></p>
<p>​    如果事务只对后端的数据库进行读操作，数据库可以利用事务ID只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让他应用它认为合适的优化措施。因为是否只读是在事务启动的时候由数据库实施的，所以只有对那些具备可能启动一个新事务的传播行为（  PROPAGATION_REQUIRED , PROPAGATION_REQUIRED_NEW , PROPAGATION_NESTED  ）的方法来说，才有意义。</p>
<h4 id="8-3-3-事务超时"><a href="#8-3-3-事务超时" class="headerlink" title="8.3.3 事务超时"></a>8.3.3 事务超时</h4><p>​    为了使应用程序很好地运行，事务不能运行太长时间。因为超时时钟会在事务开始时启动，所以只有对那些具备可能启动一个新事务的传播行为（<br>PROPAGATION_REQUIRED , PROPAGATION_REQUIRED_NEW , PROPAGATION_NESTED<br>）的方法来说，才有意义。</p>
<h4 id="8-3-34-事务回滚"><a href="#8-3-34-事务回滚" class="headerlink" title="8.3.34.事务回滚"></a>8.3.34.事务回滚</h4><p>​    事务回滚规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有在遇到运行时期异常才回滚，而在遇到检查型异常时不会回滚</p>
<ol>
<li>Spring管理事务默认回滚的异常是什么？</li>
</ol>
<p>​      答案是 RuntimeException</p>
<h3 id="8-4-行锁（INNODB）"><a href="#8-4-行锁（INNODB）" class="headerlink" title="8.4 行锁（INNODB）"></a>8.4 行锁（INNODB）</h3><h4 id="8-4-1-行锁案例模拟"><a href="#8-4-1-行锁案例模拟" class="headerlink" title="8.4.1 行锁案例模拟"></a>8.4.1 行锁案例模拟</h4><p>建表，建立索引；</p>
<p><img src="images/65.png" alt=""></p>
<p>演示前先把 autocommit 关闭了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0；</span><br></pre></td></tr></table></figure>
<p><img src="images/66.png" alt=""></p>
<p>模拟开始：</p>
<p><strong>1) session 1 update 一行数据：</strong></p>
<p><img src="images/67.png" alt=""></p>
<p>session 2 查询不到，因为是session 1 <strong>没有提交</strong>；</p>
<p>提交之后：</p>
<p><img src="images/68.png" alt=""></p>
<p><strong>2) session 1 和 session 2 同时 update 同一行数据：</strong></p>
<p><img src="images/69.png" alt=""></p>
<p><strong>session 1 完成了 ，session 2 处于阻塞状态。</strong></p>
<p><strong>3） session 1 和 session 2 同时 update 不同行数据：</strong></p>
<p><img src="images/70.png" alt=""></p>
<p><strong>两个sessionupdate不同的行，不会有冲突</strong></p>
<h4 id="8-4-2-索引失效行锁变表锁"><a href="#8-4-2-索引失效行锁变表锁" class="headerlink" title="==8.4.2 索引失效行锁变表锁=="></a>==8.4.2 索引失效行锁变表锁==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update test_innodb set a = 41 where b = 4000;  varchar 没加单引号 导致索引失效</span><br><span class="line">update test_innodb set b = &apos;5000&apos; where a= 5; 导致不同行也会阻塞，行锁变为表锁</span><br></pre></td></tr></table></figure>
<p><img src="images/71.png" alt=""></p>
<h4 id="8-4-3-间隙锁的危害"><a href="#8-4-3-间隙锁的危害" class="headerlink" title="8.4.3  间隙锁的危害"></a>8.4.3  间隙锁的危害</h4><p><strong>前提a的值并不是自增的，1,3,4,5,6,7,8,9</strong>(表数据没有 2 )</p>
<p><img src="images/72.png" alt=""></p>
<p>演示：</p>
<p><img src="images/73.png" alt=""></p>
<p>session 1 操作 a&gt;1 and a&lt;6 的数据，虽然没有 2 但是他把2 也锁了，导致session 2 插入阻塞； </p>
<p>  间隙锁:</p>
<p>​      什么是间隙锁？</p>
<p>​      当我们用<strong>范围条件而不是相等条件</strong>检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;<strong>==对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”==</strong>，</p>
<p>​      <strong>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁) 。</strong></p>
<p>​      危害</p>
<p>​      因为Query执行过程中通过过范围查找的话，他<strong>会锁定整个范围内所有的索引键值，即使这个键值并不存在。</strong></p>
<p>​      间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被<strong>无辜的锁定</strong>.而造成在锁定的时候<strong>无法插入锁定键值范围内的任何数据</strong>。在某些场景下这可能会对性能<strong>造成很大的危害</strong></p>
<p>​    ==<strong>简单来说，session1使用了范围条件检索数据，比如id范围在3到10，那么即便id为6的数据不存在，它这不存在的一行也会被锁。如果另一个session想要插入id为6的数据的时候，就会阻塞。</strong>==</p>
<h4 id="8-4-4-如何锁定一行"><a href="#8-4-4-如何锁定一行" class="headerlink" title="8.4.4  如何锁定一行"></a>8.4.4  如何锁定一行</h4><p><img src="images/74.png" alt=""></p>
<p> 三步走：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_innodb where a = 3 for update;</span><br><span class="line">这时候其实已经锁定了某一行</span><br><span class="line">commit;  </span><br><span class="line">提交后就解锁了</span><br></pre></td></tr></table></figure>
<p><img src="images/75.png" alt=""></p>
<p>锁定一行的三步：</p>
<p>begin;</p>
<p><strong>select * from test_innodb_lock where a=8  ==for update==;</strong></p>
<p>这时候其实已经锁定了某一行</p>
<p>commit;  提交后就解锁了</p>
<h4 id="8-4-5-行锁总结"><a href="#8-4-5-行锁总结" class="headerlink" title="8.4.5  行锁总结"></a>8.4.5  行锁总结</h4><p>​      Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在<strong>整体并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统<strong>并发量较高的时候，Innodb的 整体性能和MyISAM相比就会有比较明显的优势了</strong>。</p>
<p>​      但是，Innodb的行级锁定同样也有其脆弱的一面，<strong>当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</strong></p>
<h4 id="8-4-6-查看行锁状态"><a href="#8-4-6-查看行锁状态" class="headerlink" title="8.4.6  查看行锁状态"></a>8.4.6  查看行锁状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &apos;innodb_row_lock%&apos; ;</span><br></pre></td></tr></table></figure>
<p><img src="images/76.png" alt=""></p>
<hr>
<p>各个状态量的说明如下：</p>
<p> Innodb_row_lock_current_waits:当前正在等待的锁定的数量<br> Innodb_row_lock_time：从系统启动到现在，锁定的总时间长度<br> Innodb_row_lock_time_avg：每次等待所花的平均时间<br> Innodb_row_lock_time_max：从系统启动到现在，最长一次等待时间<br> Innodb_row_lock_waits：从系统启动到现在，总等待次数</p>
<p>对于这五个变量，有三个比较重要:</p>
<p><strong>==Innodb_row_lock_current_waits:当前正在等待的锁定的数量==</strong></p>
<p> ==<strong>Innodb_row_lock_waits：从系统启动到现在，总等待次数</strong>==</p>
<p> ==<strong>Innodb_row_lock_time：从系统启动到现在，锁定的总时间长度</strong>==</p>
<h4 id="8-4-7-优化建议"><a href="#8-4-7-优化建议" class="headerlink" title="==8.4.7  优化建议=="></a>==8.4.7  优化建议==</h4><p>1）尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</p>
<p>2）合理设计索引，尽量缩小锁的范围</p>
<p>3）尽可能较少检索条件，避免间隙锁</p>
<p>4）尽量控制事务大小，减少锁定资源量和时间长度</p>
<p>5）尽可能低级别事务隔离</p>
<h3 id="8-5-prepare（预处理）-机制"><a href="#8-5-prepare（预处理）-机制" class="headerlink" title="==8.5  prepare（预处理） 机制=="></a>==8.5  prepare（预处理） 机制==</h3><h4 id="8-5-1-普通流程"><a href="#8-5-1-普通流程" class="headerlink" title="8.5.1 普通流程"></a>8.5.1 普通流程</h4><p>​    指客户端将要执行的SQL发送给服务器，服务器先进行编译后立刻执行</p>
<ul>
<li>mysql客户端发送SQL指令，服务器端接受指令，进行编译执行，返回结果给客户端</li>
<li>客户端接受执行结果，解析结果、</li>
<li>客户端再次发送sql指令(可能相同)，服务器端接受指令，编译执行，返回执行结果</li>
<li>客户端接受执行结果，解析结果</li>
</ul>
<p>​        <strong>这样每条sql语句请求一次，mysql服务器就要接收并处理一次，当一个脚本文件对同一条语句反复执行多次的时候，mysql服务器压力会变大</strong></p>
<h4 id="8-5-2-prepare-流程"><a href="#8-5-2-prepare-流程" class="headerlink" title="8.5.2 prepare 流程"></a>8.5.2 prepare 流程</h4><p>​    是指客户端将要执行的SQL先发送给服务器，服务器先进行编译，不执行。等到客户端要服务端执行时，发送一条执行指令，让服务器执行已经提前处理好的SQL指令是减轻服务器压力的一种技术。</p>
<ul>
<li><p>mysql客户端发送SQL指令(预处理包装)，服务器端接受指令，进行编译，返回预处理编译结果</p>
</li>
<li><p>客户端接受编译结果，解析结果，发送预处理执行指令</p>
</li>
<li><p>服务器端接受指令，执行编译后的预处理指令，返回执行结果</p>
</li>
<li><p>客户端接受执行结果，解析结果</p>
</li>
</ul>
<p>==<strong>其实就是省去了 编译的时间。</strong>==</p>
<h4 id="8-5-3-prepare-如何操作"><a href="#8-5-3-prepare-如何操作" class="headerlink" title="8.5.3 prepare 如何操作"></a>8.5.3 prepare 如何操作</h4><p>   将sql语句强制一分为二：</p>
<ul>
<li>第一部分为前面相同的命令和结构部分</li>
<li>第二部分为后面可变的数据部分</li>
</ul>
<p>​    在执行sql语句的时候，首<strong>先将前面相同的命令和结构部分发送给MySQL服务器</strong>，让MySQL服务器事先进行一次预处理（此时并没有真正的执行sql语句），而为了保证sql语句的结构完整性，在<strong>第一次发送sql语句</strong>的时候将其中可变的数据部分都用一个数据占位符来表示！比如问号？就是常见的数据<strong>占位符</strong>！</p>
<h4 id="8-5-4-预处理实现"><a href="#8-5-4-预处理实现" class="headerlink" title="8.5.4 预处理实现"></a>8.5.4 预处理实现</h4><p>1、 设置语句</p>
<p>2、set 值</p>
<p>3、 EXECUTE 执行</p>
<p>4、 删除 PREPARE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; PREPARE prod FROM &quot;INSERT INTO examlple VALUES(?,?)&quot;; </span><br><span class="line">mysql&gt; SET @p=&apos;1&apos;; </span><br><span class="line">mysql&gt; SET @q=&apos;2&apos;; </span><br><span class="line">mysql&gt; EXECUTE prod USING @p,@q; </span><br><span class="line">mysql&gt; SET @name=&apos;3&apos;; </span><br><span class="line">mysql&gt; EXECUTE prod USING @p,@name; </span><br><span class="line">mysql&gt; DEALLOCATE PREPARE prod;</span><br></pre></td></tr></table></figure>
<p>​    <strong>每一次执行完EXECUTE时，须执行DEALLOCATE PREPARE … 语句</strong>，这样可以释放执行中使用的所有<strong>数据库资源（如游标）</strong>，不仅如此，如果一个session的预处理<strong>语句过多</strong>，可能会达到max_prepared_stmt_count的上限值</p>
<h4 id="8-5-5-预处理优点"><a href="#8-5-5-预处理优点" class="headerlink" title="==8.5.5 预处理优点=="></a>==8.5.5 预处理优点==</h4><ul>
<li>预处理的执行效率相对于一般的sql执行操作，<strong>效率比较高</strong>,因为第二次执行只需要发送查询的参数，而不是整个语句</li>
<li>由于每次执行预处理语句时仅需发送参数的数据，从而减少了<strong>网络通信量</strong></li>
<li>使用PAREPARE STATEMENT可以<strong>减少每次执行SQL的语法分析</strong></li>
<li>预处理可以<strong>防止sql注入</strong>，因为预处理将sql语句与数据分开发送</li>
</ul>
<h2 id="9-mysql-主从复制"><a href="#9-mysql-主从复制" class="headerlink" title="9.mysql 主从复制"></a>9.mysql 主从复制</h2><p>.</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/NIO/" itemprop="url">Java NIO</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:29:55+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-NIO/" itemprop="url" rel="index">
                    <span itemprop="name">Java NIO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,271
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>[TOC]</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>java.io中最为核心的一个概念是流（stream），面向流编程。Java中，一个流要么是输入流，要么是输出流，不可能同时既是输入流同时又是输出流。</p>
<p>java.nio中拥有3个核心概念：Selector、Channel和Buffer。在java.nio中，我们是面向块（block）或缓冲区（buffer）编程。Buffer本身就是一块内存，底层实现上实际是一个数组。数据的读写都是通过Buffer来实现。</p>
<p>Java中提供7种原生数据类型都各自对应的Buffer类型。如IntBuffer、LongBuffer、ByteBuffer及CharBuffer等。但是没有BooleanBuffer类型。</p>
<p>Channel指的是可以向其写入数据或从中读取数据的对象，它类似于java.io中的Stream。所有数据的读写都是通过Buffer来进行的，永远不会出现直接向Channel写入数据或直接从Channel中读取数据的情况。</p>
<p>和Stream不同的是，Channel是双向的，一个流只可能是InputStream或OutputStream，Channel打开后则可以进行读取、写入或读写。</p>
<p>由于Channel是双向的，因此它能够更好的反映出底层操作系统的真实情况；在Linux系统中，底层操作系统的通道就是双向的。</p>
<blockquote>
<p>提示：Channel和Buffer总是在一起use的。</p>
</blockquote>
<p>NIO Buffer中3个重要状态属性的含义</p>
<pre><code>1. postion 2. limit 3. capacity

    0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity
</code></pre><p>通过NIO读取文件涉及到的3个步骤：</p>
<pre><code>1. 从FileInputStream获取到FileChannel对象。

2. 创建Buffer。

3. 将数据从Channel读取到Buffer中。
</code></pre><p>flip()方法作用</p>
<pre><code>1. 将limit值设置为当前的position

2. 将position设置为0
</code></pre><p>clear()方法</p>
<pre><code>1. 将limit值设置为capacity

2. 将position值设置为0
</code></pre><p>compact()方法</p>
<pre><code>1. 将所有未读的数据复制到buffer起始位置处

2. 将position设为最后一个未读元素的后面

3. 将limit设置为capacity

4. 现在buffer准备好，但是不会覆盖未读的数据
</code></pre><hr>
<h3 id="DirectBuffer-零拷贝"><a href="#DirectBuffer-零拷贝" class="headerlink" title="DirectBuffer | 零拷贝"></a>DirectBuffer | 零拷贝</h3><p>DirectByteBuffer 自身是（Java）堆上面对象，它背后真正承载数据的buffer是在（Java）堆外（native memory）中的。这是malloc()方法分配出来的内存，是用户态的。</p>
<h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><h4 id="Scattering-Gathering"><a href="#Scattering-Gathering" class="headerlink" title="Scattering | Gathering"></a>Scattering | Gathering</h4><h3 id="NIO-创建客户端"><a href="#NIO-创建客户端" class="headerlink" title="NIO 创建客户端"></a>NIO 创建客户端</h3><p>Java在创建客户端时</p>
<pre><code>1. 首先调用静态工厂方法SocketChannel.open()来创建一个新的 java.nio.channels.SocketChannel对象。该方法的参数是：java.net.SocketAddress对象，只是连接的主机和端口。

2. 通道以阻塞模式打开
</code></pre><h4 id="NIO零拷贝"><a href="#NIO零拷贝" class="headerlink" title="NIO零拷贝"></a>NIO零拷贝</h4><h5 id="传统的IO操作（OIO）"><a href="#传统的IO操作（OIO）" class="headerlink" title="传统的IO操作（OIO）"></a>传统的IO操作（OIO）</h5><p>内核空间 | 用户空间 | 硬件</p>
<p>1.读操作</p>
<p>Java虚拟机开始读操作，告知用户空间开始读操作，从而用户空间切换到内核空间，然后内核空间从硬件读取数据到内核空间的缓冲区，然后内核空间的数据原封不动拷贝到用户空间的缓存区中，然后在用户空间执行数据操作。</p>
<p>2.写操作</p>
<p>Java虚拟机调用write操作，将数据从用户空间拷贝到内核空间的缓存区，然后再由内核空间的缓存区拷贝到硬件。完成数据操作。</p>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p>零拷贝，没有从内核空间与用户空间的数据相互缓存。</p>
<p>内核空间收到用户空间的sendfile()操作，然后内核空间向硬件要数据，然后硬件将数据传送给内核空间的缓存区。然后写数据到目标socket的缓存区。然后返回sendfile()信息。</p>
<p>用户空间内存映射到内核空间，只在内核空间进行数据操作。</p>
<hr>
<h3 id="Reactor模式（反应器模式）"><a href="#Reactor模式（反应器模式）" class="headerlink" title="Reactor模式（反应器模式）"></a>Reactor模式（反应器模式）</h3><p>类似的模式 Proactor模式</p>
<p>Netty整体架构是Reactor模式的完整体现。</p>
<p>Reactor设计模式会设立一些服务请求，处理由一个或多个客户端并发发送的的处理请求。</p>
<h4 id="多线程IO致命缺陷"><a href="#多线程IO致命缺陷" class="headerlink" title="多线程IO致命缺陷"></a>多线程IO致命缺陷</h4><p>在最原始的网络编程思路就是服务器用一个while循环，不断监听端口是否有新的套接字连接，如果有，那么就调用一个处理函数处理。</p>
<pre><code>while(true){
    socket = accept();
    handle(socket);
}
</code></pre><p>这种方法的最大问题是无法并发，效率太低。如果当前的请求没有处理完，那么后面的请求只能被阻塞，服务器的吞吐量太低。然后在之后，想到了使用多线程，也就是很经典的connection per thread，每一个连接用一个线程处理。</p>
<pre><code>class BasicModel implements Runnable {
    public void run() {
        try {
            ServerSocket ss =
                    new ServerSocket(SystemConfig.SOCKET_SERVER_PORT);
            while (!Thread.interrupted())
                new Thread(new Handler(ss.accept())).start();
            //创建新线程来handle
            // or, single-threaded, or a thread pool
        } catch (IOException ex) { /* ... */ }
    }

    static class Handler implements Runnable {
        final Socket socket;
        Handler(Socket s) { socket = s; }
        public void run() {
            try {
                byte[] input = new byte[SystemConfig.INPUT_SIZE];
                socket.getInputStream().read(input);
                byte[] output = process(input);
                socket.getOutputStream().write(output);
            } catch (IOException ex) { /* ... */ }
        }
        private byte[] process(byte[] input) {
            byte[] output=null;
            /* ... */
            return output;
        }
    }
}
</code></pre><p>在上面对于每一个请求都分配一个线程，每个线程都独自处理上面的流程。</p>
<h5 id="1-多线程并发模式的优点"><a href="#1-多线程并发模式的优点" class="headerlink" title="1. 多线程并发模式的优点"></a>1. 多线程并发模式的优点</h5><p>在一定程度上极大地提高了服务器的吞吐量，因为之前的请求在read阻塞以后，不会影响到后续的请求，因为他们在不同的线程中。</p>
<h5 id="2-多线程并发模式的缺点"><a href="#2-多线程并发模式的缺点" class="headerlink" title="2. 多线程并发模式的缺点"></a>2. 多线程并发模式的缺点</h5><p>在于资源要求太高，系统中创建线程是需要比较高的系统资源的，如果连接数太高，系统无法承受，而且线程的反复创建-销毁也需要代价。</p>
<p>改进的方案便是：采用基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。使用Reactor模式，对线程的数量进行控制，一个线程处理大量的事件。</p>
<h4 id="Dispatch-Notifier-模式"><a href="#Dispatch-Notifier-模式" class="headerlink" title="Dispatch | Notifier 模式"></a>Dispatch | Notifier 模式</h4><p>在Java的NIO模式的Selector网络通讯就是一个简单的Reactor模型，是Reactor模型的朴素原型。</p>
<p>客户端连接到Reactor对象，然后Reactor对象派发客户端的请求到各个处理线程。Reactor本身不做任何操作，只是做一个中间商派发处理客户端各种请求。</p>
<blockquote>
<p>提示：实际上Reactor模式是基于Java NIO的，在它的基础上抽象出来两个组件：Reactor和Handler两个组件。</p>
</blockquote>
<blockquote>
<blockquote>
<p>Reactor 负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler处理。新的事件包括连接建立就绪、读就绪、写就绪等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Handler 负责将自身（handler）与事件绑定，负责事件的处理，完成Channel的读入，完成处理业务逻辑后负责将结果写出channel。</p>
</blockquote>
</blockquote>
<h4 id="1-Reactor1-Setup"><a href="#1-Reactor1-Setup" class="headerlink" title="1. Reactor1 - Setup"></a>1. Reactor1 - Setup</h4><pre><code>class Reactor implements Runnable {
    final Selector selector;
    final ServerSocketChannel serverSocketChannel;

    Reactor(int port) throws IOException {
        selector = Selector.open();
        serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().bind(new InetSocketAddress(port));
        serverSocketChannel.configureBlocking(false);//非阻塞
        SelectionKey sk = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//注册到selector上并处于等待客户端连接

        sk.attach(new Acceptor());//向其附加上任意的对象
    }
}
</code></pre><h4 id="2-Reactor2-Dispatch-Loop"><a href="#2-Reactor2-Dispatch-Loop" class="headerlink" title="2. Reactor2 - Dispatch Loop"></a>2. Reactor2 - Dispatch Loop</h4><pre><code>//thread
public void run(){
    try{
        while(!Thread.interrupted()){
            selector.select();
            Set selected = selector.selectedKeys();
            Iterator it = selected.iterator();
            while(it.hasNext()){
                dispatch((SelectionKey)(it.next()));//分发
                selected.clear();//处理的selector要清除掉
            }
        }
    }catch(IOException e){

    }
}

void dispatch(SelectionKey k){
    Runnable r = (Runnable) k.attachement();//获取之前attach()方法添加的对象
    if(r != null){
        r.run();
    }
}
</code></pre><h4 id="3-Reactor3-Acceptor"><a href="#3-Reactor3-Acceptor" class="headerlink" title="3. Reactor3 - Acceptor"></a>3. Reactor3 - Acceptor</h4><pre><code>class Acceptor implements Runnable {
    public void run(){
        try{
            SocketChannel c = serverSocketChannel.accept();
            if(c != null){
                new Handler(selector, c);//自定义handler或netty提供的
            }
        }catch(Exception e){

        }
    }
}
</code></pre><h4 id="4-Reactor4-Handler-Setup"><a href="#4-Reactor4-Handler-Setup" class="headerlink" title="4. Reactor4 - Handler Setup"></a>4. Reactor4 - Handler Setup</h4><pre><code>final class Handler implements Runnable {
    final SocketChannel socket;
    final SelectionKey sk;
    ByteBuffer input = ByteBuffer.allocate(MAXIN);
    ByteBuffer output = ByteBuffer.allocate(MAXOUT);

    static final int READING = 0, SENDING = 1;
    int state = READING;

    Handler(Selector sel, SocketChannel c){
        socket = c;
        c.configureBlocking(false);
        sk = socket.register(sel, 0);
        sk.attach(this);
        sk.interestOps(SelectionKey.OP_READ);
        sel.wakeup();
    }
}
</code></pre><h4 id="5-Reactor5-Request-handing"><a href="#5-Reactor5-Request-handing" class="headerlink" title="5. Reactor5 - Request handing"></a>5. Reactor5 - Request handing</h4><pre><code>public void run(){
    try{
        if(state == READING) read();
        else if(state == SENDING) send();
    }catch(IOException e){

    }
}

void read(){
    socket.read(input);
    if(inputIsComplete()){
        process();
        state = SENDING;
        sk.interestOps(SelectionKey.OP_WRITE);
    }
}

void send(){
    socket.write(output);
    if(outputIsComplete()){
        sk.cancel();
    }
}
</code></pre><h4 id="Reactor编程的优缺点"><a href="#Reactor编程的优缺点" class="headerlink" title="Reactor编程的优缺点"></a>Reactor编程的优缺点</h4><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><pre><code>1. 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的。

2. 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销

3. 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源

4. 可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性
</code></pre><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><pre><code>1. 相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。
</code></pre><hr>
<h4 id="BossGrouo-WorkerGroup-监听过程"><a href="#BossGrouo-WorkerGroup-监听过程" class="headerlink" title="BossGrouo | WorkerGroup 监听过程"></a>BossGrouo | WorkerGroup 监听过程</h4><pre><code>1. 首先存在多个客户端等待连接

2. 然后BossGroup监听OP_ACCEPT事件，一旦该事件被监听到之后就会将其注册到Selector中，并返回SelectionKey（包含了Selector的属性）集合，然后SelectionKey本身包装了SocketChannel对象（是与客户端真正建立连接的对象）

3. 对于netty对象而言，又会将SocketChannel对象包装成NioSocketChannel对象

4. 接着将NioSocketChannel注册到Worker当中的Selector选择器上面，而此选择器本身却是监听了READ事件本身的。那么接下来客户端有什么请求，就会直接跟workerGroup打交道。
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Nginx-Apache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Nginx-Apache/" itemprop="url">Nginx-Apache</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:29:17+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx-Apache/" itemprop="url" rel="index">
                    <span itemprop="name">Nginx-Apache</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  218
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Nginx-Apache"><a href="#Nginx-Apache" class="headerlink" title="Nginx-Apache"></a>Nginx-Apache</h2><p>[TOC]</p>
<h3 id="Apache较Nginx的优点"><a href="#Apache较Nginx的优点" class="headerlink" title="Apache较Nginx的优点"></a>Apache较Nginx的优点</h3><pre><code>1. rewrite功能比Nginx强大

2. 动态页面，Nginx处理动态请求是鸡肋，移动动态请求要Apache去做，Nginx只适合于静态和反向

3. 模块较于Nginx多
</code></pre><h3 id="Nginx较Apache优点"><a href="#Nginx较Apache优点" class="headerlink" title="Nginx较Apache优点"></a>Nginx较Apache优点</h3><pre><code>1. 轻量级，较Apache占用更少的内存及资源，支持更多的并发连接，体现更高的效率

2. 抗并发，Nginx处理请求是异步非阻塞的，Apache是阻塞型的，在高并发下Nginx能保持低资源低消耗高性能

3. Nginx本身就是一个反向代理服务器

4. 负载均衡能力突出
</code></pre><blockquote>
<p>Apache与Nginx核心区别：Apache是同步多线程模型，一个连接对应一个进程。Nginx是异步的，多个连接可以对应一个进程。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Netty/" itemprop="url">Netty</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:27:42+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index">
                    <span itemprop="name">Netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,570
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>[TOC]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>官方定义，它是一个异步的，基于时间Client/Server的网络框架，目标是提供一种简单、快速构建网络应用的方式，同时保证高吞吐量、低延时、高可靠性。</p>
<blockquote>
<p>提示：Netty其实就是一个NIO框架，它适用于服务器通讯相关的多种应用场景，主要还是针对于TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。</p>
</blockquote>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO，非阻塞IO，在JAVA中NIO的核心就是Selector机制。简单而言，创建一个Socket Channel，并将其注册到一个Selector上（多路复用器），这个Selector将会“关注”Channel上发生的IO读写事件，并在事件发生（数据就绪）后执行相关的处理逻辑。对于阻塞IO，它需要在read()、write()操作上阻塞而直到数据操作完毕，但是NIO则不需要，只有当Selector检测到此Channel上有事件时才会触发调用read、write操作。</p>
<blockquote>
<p>提示：NIO本身不是严格意义上的异步IO，最大的原因是因为Selector本身是阻塞的（selector需要通过线程阻塞的方式（其select方法）获取底层通道的事件变更，然后获取SelectionKey列表）。</p>
</blockquote>
<blockquote>
<blockquote>
<p>总结：我觉得最好的学习方式就是学好netty包里面的所有example代码。</p>
</blockquote>
</blockquote>
<h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>通道，一个逻辑通道，维护Socket上IO的write、read、connect等相关操作。我们可以看到Bootstrap、ServerBootstrap初始化之后都需要在channel(Channel channel)方法中指定内部需要创建的channel类型。</p>
<blockquote>
<p>提示：Channel中所有的操作均是异步的，IO操作都会返回一个ChannelFuture实例</p>
</blockquote>
<p> Channel接口中还包含了一个子接口：Unsafe；这个Unsafe和JDK自带的Unsafe没有关系，Netty中的Unsafe只是框架内部使用，主要用来操作底层的Socket，比如connect、close、read、write；即Channel接口中有关底层Socket操作的，将会有Unsafe来操作javaChannel()即可。</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>ChannelFuture表示Channel IO异步操作的结果。IO调用方法立即返回，但此时并不表示IO实际操作已经实际执行结束，只是返回一个ChannelFuture实例，具体执行的结果状态可以通过检测Future才能得到。</p>
<pre><code>boolean isDone()：操作是否完成，completed 还是 uncompleted

boolean isCanclled()：如果Future已经完成，则判断操作是否被取消。

boolean isSuccess()：同上。

Throwable cause()：如果执行失败，此处可以获取导致失败的exception信息。

ChannelFuture await()：等待，直到异步操作执行完毕，内部基于wait实现。

ChannelFuture sync()：等待，直到异步操作执行完毕，核心思想同await。我们得到Future实例后，可以使用sync()方法来阻塞当前线程，直到异步操作执行完毕。和await的区别为，如果异步操作失败，那么将会重新抛出异常（将上述cause()方法中的异常抛出）。await和sync一样，当异步操作执行完毕后，通过notifyAll()唤醒。

ChannelFuture addListener(GenericFutureListener listener)：向Future添加一个listener，当异步操作执行完毕后（无论成败），会依次调用listener的operationCompleted方法。
</code></pre><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>我们可以简单的认为EventLoopGroup是一个线程池调度服务，这和我们常用的FixedThreadPool在设计思想上没有太大区别；在Netty中比较常用的子类就是NioEventLoopGroup，它继承了ScheduledExecutorService。我们在创建NioEventLoopGroup时，可以指定线程池的容量，默认为：CPU处理器个数 * 2。</p>
<p>在NioEventLoop创建实例时会同时创建一个Selector，即每个NioEventLoop都持有一个Selector实例。由此可见，NioEventLoopGroup的线程池容量，就是线程的个数，也是Bootstrap中持有的Selector的数量。</p>
<p>每个NioEventLoop实例内部Thread负责select多个Channel的IO事件（NIO Selector.select），如果某个Channel有事件发生，则在内部线程中直接使用此Channel的Unsafe实例进行底层实际的IO操作。简单而言，就是让每个NioEventLoop管理一组Channel。</p>
<p>在ServerBootstrap中，创建两个NioEventLoopGroup，其中“bossGroup”为Acceptor 线程池，这个线程池只需要一个线程（大于1，事实上没有意义），它主要是负责accept客户端链接，并创建SocketChannel，此后从“workerGroup”线程池（reactor）中以轮询的方式(next)取出一个NioEventLoop实例，并将此Channel注册到NioEventLoop的selector上，此后将由此selector负责监测Channel上的读写事件（并由此NioEventLoop线程负责执行）。</p>
<p>由此可见，对于ServerBootstrap而言，bossGroup中的一个线程的selector只关注SelectionKey.OPT_ACCEPT事件。</p>
<h4 id="EventLoop-线程模型"><a href="#EventLoop-线程模型" class="headerlink" title="EventLoop | 线程模型"></a>EventLoop | 线程模型</h4><h3 id="ChannelHandler-Pipeline"><a href="#ChannelHandler-Pipeline" class="headerlink" title="ChannelHandler | Pipeline"></a>ChannelHandler | Pipeline</h3><pre><code>@Sharable 表示一个ChannelHandler可以被多个Channel安全的共享
</code></pre><p>在Netty中，从Socket通道中read数据进入Netty Handler的方向为inbound，从Netty handler向Socket通道write数据的方向为outbound。</p>
<h4 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h4><h5 id="void-channelRegistered-ChannelHandlerContext-ctx"><a href="#void-channelRegistered-ChannelHandlerContext-ctx" class="headerlink" title="void channelRegistered(ChannelHandlerContext ctx)"></a>void channelRegistered(ChannelHandlerContext ctx)</h5><p>当channel注册成功后执行，即channel绑定到NioEventLoop上，且将Channel注册到selector之后执行。</p>
<h5 id="void-channelActive-ChannelHandlerContext-ctx"><a href="#void-channelActive-ChannelHandlerContext-ctx" class="headerlink" title="void channelActive(ChannelHandlerContext ctx)"></a>void channelActive(ChannelHandlerContext ctx)</h5><p>channel注册首次成功后执行，即channelRegistered方法执行后调用。</p>
<h5 id="void-channelRead-ChannelHandlerContext-ctx-Object-msg"><a href="#void-channelRead-ChannelHandlerContext-ctx-Object-msg" class="headerlink" title="void channelRead(ChannelHandlerContext ctx,Object msg)"></a>void channelRead(ChannelHandlerContext ctx,Object msg)</h5><p>socket将已经读取到数据传递给handler，此方法在NIO中READ事件触发后并读取到任意字节数据后被fire</p>
<h5 id="void-channelReadComplete-ChannelHandlerContext-ctx"><a href="#void-channelReadComplete-ChannelHandlerContext-ctx" class="headerlink" title="void channelReadComplete(ChannelHandlerContext ctx)"></a>void channelReadComplete(ChannelHandlerContext ctx)</h5><p>read操作结束后调用；read数据首先被添加到Bytebuf中，如果这个Bytebuf已满，则会终止read操作，调用此方法。</p>
<h4 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h4><h5 id="void-read-ChannelHandlerContext-ctx"><a href="#void-read-ChannelHandlerContext-ctx" class="headerlink" title="void read(ChannelHandlerContext ctx)"></a>void read(ChannelHandlerContext ctx)</h5><p>…</p>
<blockquote>
<p>总结：Channel创建后，初始化其pipeline，当Channel注册到Selector后（包括绑定到NioEventLoop线程），执行ChannelInitializer这个特殊的handler并将开发者指定的其他多个handler添加到pipeline中；当NioEventLoop线程中，selector检测到NIO事件后，将会依次执行此Channel pipeline中的相应的fire方法（比如fireChannelRead()）,那么fire方法将会从head或者tail这两个特殊的handler开始，依次调用pipeline中其他handler的实际方法（比如channelRead()）。</p>
</blockquote>
<blockquote>
<p>注意：pipeline中的某个handler认为操作需要继续传递下去，那么在此handler的实际业务执行完毕之后要通过调用ChannelHandlerContext相应的fire方法，将事件继续传递给下一个handler；如果没有调用fire方法，那么此事件将会被终止。</p>
</blockquote>
<hr>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>该协议是完全重新设计的协议，旨在为了Web上的双向数据传输问题提供一个解决方案，可以让客户端与服务器之间在任意时刻传输消息。此要求它们能够异步处理消息回执。</p>
<h3 id="添加WebSocket支持"><a href="#添加WebSocket支持" class="headerlink" title="添加WebSocket支持"></a>添加WebSocket支持</h3><p>在从标准的HTTP或HTTPS协议切换到WebSocket时，将会使用一种称为升级握手的机制。因此在使用WebSocket应用程序将始终以HTTP/S作为开始，然后再执行升级。</p>
<p>我们应用程序将采用下面的约定：如果被请求的URL以/ws结尾，那我们将会把该协议升级为WebSocket。否则服务器将使用基本的HTTP/S。</p>
<p>在连接完成升级之后，所有数据传输都将使用WebSocket进行。</p>
<blockquote>
<p>WEBSOCKET帧 WebSocket以帧的方式进行传输数据，每一帧代表消息的一部分。一个完整的消息可能包含许多帧。</p>
</blockquote>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>RMI:remote method invocation 只针对Java</p>
<pre><code>client 

server
</code></pre><p>序列化与反序列化：或叫做编码与解码。</p>
<p>RPC Remote Procedure Call 远程过程调用 很多RPC框架是跨语言的。</p>
<pre><code>1. 定义一个接口说明文件：描述了对象（结构体）、对象成员、接口方法等一系列信息。

2. 通过RPC框架所提供的编译器，将接口说明文件编译成具体的语言文件。

3. 在客户端与服务器端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用远程方法。
</code></pre><blockquote>
<p>提示：在idea引入protobuf的时候注意pc上安装的protobuf版本号与gradle引入的版本号的一致性。</p>
</blockquote>
<h5 id="protobuf工程中使用git作为版本控制系统："><a href="#protobuf工程中使用git作为版本控制系统：" class="headerlink" title="protobuf工程中使用git作为版本控制系统："></a>protobuf工程中使用git作为版本控制系统：</h5><pre><code>1. git submodule git仓库里面的一个仓库

    这一命令可以关联到一个新的git仓库，是专门用来存放protobuf项目的。

    在原先的工程里面生成了一个protobuf工程，在新生成的protoc编译之后的文件放在对一个的仓库下面

2. git subtree 类似于git submodule

    这一命令是将这一仓库pull到该项目，但是是在合并而不是分成两个
</code></pre><h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h2><h3 id="Thrift-传输格式"><a href="#Thrift-传输格式" class="headerlink" title="Thrift 传输格式"></a>Thrift 传输格式</h3><pre><code>1. TBinaryProtocol 二进制格式

2. TCompactProtocol 压缩格式

3. TJSONProtocol JSON格式

4. TSimpleJSONProtocol 提供JSON只写协议，生成的文件很容易通过脚本语言解析

5. TDebugProtocol 使用易懂的可读文本格式，以便于debug
</code></pre><h3 id="Thrift-数据传输方式"><a href="#Thrift-数据传输方式" class="headerlink" title="Thrift 数据传输方式"></a>Thrift 数据传输方式</h3><pre><code>1. TSocket 阻塞式socket

2. TFramedTransport 以frame为单位进行传输，非阻塞式服务中使用

3. TFileTransport 以文本形式进行传输

4. TMemoryTransport 将内存用于IO，Java实现时内部实际使用了简单的ByteArrayOutputStream。

5. TZlibTransport 使用zlib进行压缩，与其它传输方式联合使用。当前无Java实现。
</code></pre><h3 id="Thrift-支持的服务类型"><a href="#Thrift-支持的服务类型" class="headerlink" title="Thrift 支持的服务类型"></a>Thrift 支持的服务类型</h3><pre><code>1. TSimpleServer 简单的单线程服务模型，常用于测试

2. TThreadPoolServer 多线程服务模型，使用标准的阻塞IO

3. TNonblockingServer 多线程服务模型，使用非阻塞IO(需要使用TFramedTransport数据传输方式)

4. THsHaServer THsHa引入了线程池去处理，其模型将读写任务放到线程池去处理。Half-sync/Half-async的处理模式：Half-aysnc是在处理IO事件上(accept/read/write io) 异步处理。 | Half-sync用于handler对rpc的同步处理。
</code></pre><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><a href="https://www.grpc.io/" target="_blank" rel="noopener">gRPC官方</a> <a href="https://github.com/grpc/grpc-java" target="_blank" rel="noopener">gRPC仓库</a> <a href="https://developers.google.cn/protocol-buffers" target="_blank" rel="noopener">Protobuf官网</a></p>
<p>RPC（远程过程调用）框架实际上是提供了一套机制，使得应用程序之间可以进行通信，同时遵循Server/Client模型。在我们使用的时候，客户端调用Server端的接口就像是调用本地的函数一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3959253-76284b64125a8673.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="RPC通信"></p>
<h3 id="gRPC-Restful"><a href="#gRPC-Restful" class="headerlink" title="gRPC | Restful"></a>gRPC | Restful</h3><p>gRPC和Restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而Restful api则不一定)。不过gRPC还是有些特有的优势。</p>
<pre><code>1. gRPC通过Protobuf定义接口，更加严格的接口约束。

2. Protobuf可以将数据序列化为二进制编码，从而大幅度减少需要传输的数据量，大幅度的提高性能。

3. gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）

4. 对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑gRPC服务，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。
</code></pre><blockquote>
<p>提示：我们不会单独的使用gRPC，而是将gRPC作为一个部件进行使用，这是因为在生产环境中，我们面对高并发的情况下，需要使用分布式系统去处理，而gRPC并没有提供分布式系统相关的一些组件，而且真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等必要的组件。</p>
</blockquote>
<h3 id="gRPC-开发的通用步骤"><a href="#gRPC-开发的通用步骤" class="headerlink" title="gRPC 开发的通用步骤"></a>gRPC 开发的通用步骤</h3><pre><code>1. 编写Protobuf来定义接口和数据类型

2. 编写gRPC Server端程序

3. 编写gRPC Client端程序
</code></pre><h3 id="proto3"><a href="#proto3" class="headerlink" title="proto3"></a>proto3</h3><h3 id="回调钩子"><a href="#回调钩子" class="headerlink" title="回调钩子"></a>回调钩子</h3><p>注册一个关闭Java虚拟机的钩子。Java虚拟机关闭响应两种类型的事件。</p>
<pre><code>1. 程序执行完之后正常的退出。

2. 用户主动中断或者系统事件导致的退出。

更多的看源码。

Runtime.getRuntime().addShutdownHook(new Thread(
    ()-&gt;{
        System.out.println(&quot;close jvm&quot;);
        GrpcServer.this.stop();
    }
));
</code></pre><blockquote>
<p>提示：回调钩子的作用在于在JVM关闭之前先关闭 GrpcServer.this.stop(); 。</p>
</blockquote>
<h3 id="gRPC-流式调用处理"><a href="#gRPC-流式调用处理" class="headerlink" title="gRPC 流式调用处理"></a>gRPC 流式调用处理</h3><blockquote>
<p>提示：gRPC的四种通信方式（1. 一般的RPC调用，一个请求对象，一个返回对象。2. 服务端流式RPC，一个请求对象，服务端可以传回多个结果对象。3. 客户端流式RPC，客户端传入多个请求，服务器返回一个响应结果。4. 双向流式RPC，结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象。）。</p>
</blockquote>
<pre><code>syntax = &quot;proto3&quot;;

package com.proto.xidian.edu.cn;

option java_package = &quot;com.proto.xidian.edu.cn&quot;;
option java_outer_classname = &quot;StudentProto&quot;;
option java_multiple_files = true;

service StudentService {
    rpc GetRealNameByUsername (MyRequest) returns (MyResponse) {}

//    rpc GetStudentsByAge(int32) returns (stream StudentResponse) {}

//    rpc GetStudentsByAge(StudentRequest) returns (stream StudentResponse) {}

    rpc GetStudentsWrapperByAges(stream StudentRequest ) returns (StudentResponseList) {}

}

message MyRequest {
    string username = 1;
}

message MyResponse {
    string realname = 2;
}

message StudentResponse {
    string name = 1;
    int32 age = 2;
    string city = 3;
}

message StudentRequest {
    int32 age = 1;
}

message StudentResponseList {
    repeated StudentResponse studentResponse = 1;
}
</code></pre><p>在处理过程中主要在返回stream类型的结果类型。在客户端发出一个请求之后，服务器返回的类型是tream（实际上就是一个迭代器）。</p>
<blockquote>
<p>提示：在编写.proto文件之后利用gradle构建工具对项目进行build操作，得到新生成的文件。</p>
</blockquote>
<h5 id="错误-error"><a href="#错误-error" class="headerlink" title="错误 error"></a>错误 error</h5><blockquote>
<p>  What went wrong:<br>    Some problems were found with the configuration of task ‘:generateProto’.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Value ‘directory ‘D:\projects\SSM_practice\netty_lecture\build/extracted-protos/main’’ specified for property ‘$2’ cannot be converted to a file.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Value ‘main Proto source’ specified for property ‘$1’ cannot be converted to a file.</p>
</blockquote>
</blockquote>
<p>解决：将Protobuf-Gradle-plugin版本更新到0.8.4或更高版本。</p>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><h3 id="gradlew"><a href="#gradlew" class="headerlink" title="gradlew"></a>gradlew</h3><p>gradlew 等价于gradle wrapper。使用者在本地pc上没有安装gradle工具的前提下，会自动构建项目。</p>
<h2 id="EventLoopGroup-1"><a href="#EventLoopGroup-1" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><pre><code>1. 在一个EventLoopGroup中可能会包含一个或多个EventGroup。

2. 一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定。

3. 所有由EventLoop所处理的各种IO事件都将在它所关联的那个Thread上进行处理。

4. 一个Channel在它的整个生命周期中只会注册在一个EventLoop上。

5. 一个EventLoop在运行过程中，会被分配给一个或多个Channel。
</code></pre><p>在Nettt中，Channel的实现一定是线程安全的。基于此，我们可以存储一个Channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用Channel相应的方法，即便当时有很多线程都在使用它也不会出现多线程问题，而且消息一定会按照顺序发送出去。</p>
<blockquote>
<p>重要结论：我们在业务开发过程中，不要将长时间执行的耗时任务放入到EventLoop的执行队列中，因为它将会一直阻塞该线程所对应的所有Channel上的其它执行任务，如果我们需要进行阻塞调用或耗时的操作（通常在开发中很常见），那么我们需要使用一个专门的EventExecutor（业务线程池）。</p>
</blockquote>
<pre><code>业务线程池（EventExecutor）通常的两种实现方式：

    1. 在ChannelHandler的回调方法中，使用自己定义的业务线程池，这样就可以实现异步调用。

    2. 借助Netty提供的向ChannelPipeline添加ChannelHandler时调用的addLast()方法来传递EventExecutor。
</code></pre><blockquote>
<p>说明：默认情况下（调用addLast(handler)），ChannelHandler中回调方法都是由IO线程所执行，如果调用了 ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler… handlers);方法，那么ChannelHandler中的回调方法就是由参数中的group线程组所执行的。</p>
</blockquote>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>JDK所提供的Future只能通过手工方式检查执行结果，而这个操作是会阻塞的。Netty则对ChannelFuture进行了增强，通过ChannelFutureListener以回调的方式来获取执行结果，去除了手工检查阻塞的操作。值得注意的是：ChannelFutureListener的operationComplete()方法是由IO线程执行的，因此要注意的是不要在这里执行耗时操作，否则需要通过另外的线程或线程池来执行。</p>
<h2 id="Channel-ChannelHandler-ChannelHandlerContext"><a href="#Channel-ChannelHandler-ChannelHandlerContext" class="headerlink" title="Channel | ChannelHandler | ChannelHandlerContext"></a>Channel | ChannelHandler | ChannelHandlerContext</h2><p>在Netty中有两种发送消息的方式，可以直接写到Channel中，也可以写到与ChannelHandler所关联的那个ChannelHandlerContext中。对于前一种方式来说，消息会从ChannelPipeline的末尾开始流动，而对于后一种方式来说，消息将从ChannelHandlerContext的下一个ChannelHandler开始流动。</p>
<p>结论：</p>
<pre><code>1. ChannelHandlerContext与ChannelHandler之间的关联绑定关系是永远都不会发生改变的，因此对其进行缓冲是没有任何问题的。

2. 对于与Channel的同名方法来说，ChannelHandlerContext的方法将会产生更短的事件流，所以我们应该在可能的情况下利用这个特性来提升应用的性能。
</code></pre><h2 id="Netty-提供的3种缓冲区类型"><a href="#Netty-提供的3种缓冲区类型" class="headerlink" title="Netty 提供的3种缓冲区类型"></a>Netty 提供的3种缓冲区类型</h2><pre><code>1. Heap Buffer (堆缓冲区)

    这是最常用的类型，ByteBuf将数据存储到JVM的堆空间中，并且将实际的数据存放到byte array中来实现。

    优点：由于数据存放在JVM的堆中，因此可以快速的创建与释放，并且他提供了直接访问内部字节数组的方法。

    缺点：每次读写数据时，都需要先将数据复制到直接缓冲区中再进行网络传输。

2. Direct Buffer (直接缓冲区)

    在堆之外直接分配内存空间，直接缓冲区并不会占用堆的容量空间，因为它是有操作系统在本地内存中进行的数据分配。

    优点：在使用Socket进行数据传递时，性能非常好，因为数据直接位于操作系统的本地内存中，所以不需要从JVM将数据复制到直接缓冲区中，性能很好。

    缺点：因为Direct Buffer是直接在操作系统内存中的，所以内存空间的分配与释放要比堆空间更加复杂，而且速度要慢一些。

    这里Netty提供内存池来解决这个问题。DirectBuf可以放在内存池里面。直接缓冲区并不支持通过字节数组的方式来访问数据。
</code></pre><blockquote>
<p>提示：对于后端的业务消息的编解码来说，推荐使用HeapByteBuf。对于IO通信线程在读写缓冲区时，推荐使用DirectByteBuf。</p>
</blockquote>
<pre><code>3. Composite Buffer (复合缓冲区)
</code></pre><h2 id="JDK的ByteBuffer与Netty的ByteBuf之间的差异"><a href="#JDK的ByteBuffer与Netty的ByteBuf之间的差异" class="headerlink" title="JDK的ByteBuffer与Netty的ByteBuf之间的差异"></a>JDK的ByteBuffer与Netty的ByteBuf之间的差异</h2><pre><code>1. Netty的ByteBuf采用了读写分离的策略（readerIndex | writerIndex），一个初始化（里面尚未有任何数据）的ByteBuf的readerIndex | writerIndex值都为0。

2. 当读索引与写索引处于同一个位置时，如果我们继续读取，就会抛出异常IndexOutBoundsException。

3. 对于ByteBuf的任何读写操作都会分别单独维护读索引和写索引。maxCapacity最大容量默认的限制就是Integer.MAX_VALUE。
</code></pre><h3 id="JDK的ByteBuffer的缺点"><a href="#JDK的ByteBuffer的缺点" class="headerlink" title="JDK的ByteBuffer的缺点"></a>JDK的ByteBuffer的缺点</h3><pre><code>1. final byte[] hb;这是JDK的ByteBuffer对象中用于存储数据的对象声明。可以看到，字节数组被声明为final的，也就是长度是固定不变的。一旦分配好之后就不能动态扩容和收缩。而且当待存储的数据字节很大时就很有可能抛出IndexOutBoundsException异常。如果要预防这个异常的抛出，那就需要在存储之前完全确定好待存储的字节大小。如果ByteBuffer的空间不足，我们只有一种解决方案：创建一个全新的ByteBuffer对象，然后再将之前的ByteBuffer中的数据复制过去，这些操作都需要我们自发完成。

2. ByteBuffer只使用一个position指针来表示位置信息，在进行读写切换的时候需要调用flip()方法或rewind()方法，使用起来不方便。
</code></pre><h3 id="Netty的ByteBuf的优点"><a href="#Netty的ByteBuf的优点" class="headerlink" title="Netty的ByteBuf的优点"></a>Netty的ByteBuf的优点</h3><pre><code>1. 存储字节的数组是动态的，其最大值默认是Integer.MAX_VALUE。这里的动态性是体现在write()方法中的，write()方法在执行时会判断
</code></pre><blockquote>
<p>提示：自旋锁，不断占用CPU进行自旋，直到条件满足跳出死循环为止。</p>
</blockquote>
<pre><code>//自旋锁的应用
for (;;) {
    int refCnt = this.refCnt;
    final int nextCnt = refCnt + increment;

    if (nextCnt &lt;= increment) {
        throw new IllegalReferenceCountException(refCnt, increment);
    }
    //判断或跳出
    if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
        break;
    }
}
</code></pre><h2 id="AtomicIntegerFieldUpdater-要点总结"><a href="#AtomicIntegerFieldUpdater-要点总结" class="headerlink" title="AtomicIntegerFieldUpdater 要点总结"></a>AtomicIntegerFieldUpdater 要点总结</h2><pre><code>1. 更新器更新的必须是int类型变量，不能是其包装类型。

2. 更新器更新的必须是volatile类型变量，确保线程之间共享变量时的立即可见性。

3. 待更新的变量不能是static的，必须要是实例变量。因为Unsafe.objectFieldOffset()方法不支持静态变量（CAS操作本质上是通过对象实例的偏移量来直接进行赋值）。

4. 更新器只能修改它可见范围内的变量，因为更新器是通过反射来得到这变量，如果变量不可见就会报错。
</code></pre><blockquote>
<p>提示：如果要更新的变量是包装类型的话，可以使用AtomicReferenceFieldUpdater来进行更新。</p>
</blockquote>
<h2 id="Netty-处理器概念"><a href="#Netty-处理器概念" class="headerlink" title="Netty 处理器概念"></a>Netty 处理器概念</h2><pre><code>1. Netty处理分类：入站处理器 | 出站处理器。

2. 入站处理器的顶层是ChannelInBoundHandler，出站处理器的顶层是ChannelOutBoundHandler。

3. 数据处理时常用的各种编解码器本质上都是处理器。

4. 编解码器：无论我们向网络中写入的数据是什么类型（int | char | String | 二进制等），数据在网络中传递时，其都是以字节流形式呈现的。

    编码：将数据由原本形式转换为字节流的操作称为编码（encode）。

    解码：将字节流转换成它原本的数据形式或其它格式称为解码（decode）。

    编解码统一称为codec。

5. 编码（从程序到网络 - 本质上是一种出站处理器（ChannelOutBoundHandler））

6. 解码（从网络到程序 - 本质上是一种入站处理器（ChannelInBoundHandler））

7. 在Netty中，编码器通常以XXXEncoder命名。解码器通常以XXXDecoder命名。
</code></pre><h2 id="TCP-粘包与拆包"><a href="#TCP-粘包与拆包" class="headerlink" title="TCP 粘包与拆包"></a>TCP 粘包与拆包</h2><p>粘包表示将多条数据粘在一起。拆包的概念与粘包相反，是将多条数据拆分开来。</p>
<h2 id="关于Netty编解码器的结论"><a href="#关于Netty编解码器的结论" class="headerlink" title="关于Netty编解码器的结论"></a>关于Netty编解码器的结论</h2><pre><code>1. 无论是编码器还是解码器，其所接受的消息类型必须要与待处理的参数类型一致，否则该编码器或解码器并不会执行。

2. 
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Python/" itemprop="url">Python</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:30:54+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  230
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>[TOC]</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h4><p>Python 中的标识符是区分大小写的。以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。</p>
<p>以双下划线开头的 <strong>foo 代表类的私有成员，以双下划线开头和结尾的 </strong>foo__ 代表 Python 里特殊方法专用的标识，如 <strong>init</strong>() 代表类的构造函数。</p>
<h4 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h4><p>在python代码块中，不使用大括号{}来控制类，函数以及其它逻辑判断，用缩进来写模块。</p>
<blockquote>
<p>提示：缩进的空白数量是可变的，但是所有代码块语句包含相同的缩进空白数量，需要严格执行。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Mybatis-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Mybatis-1/" itemprop="url">MyBatis 学习</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:46:32+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis/" itemprop="url" rel="index">
                    <span itemprop="name">Mybatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,699
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  47
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="Mybatis-FD"><a href="#Mybatis-FD" class="headerlink" title="Mybatis - FD"></a>Mybatis - FD</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="1-原生态JDBC程序存在问题"><a href="#1-原生态JDBC程序存在问题" class="headerlink" title="1.原生态JDBC程序存在问题"></a>1.原生态JDBC程序存在问题</h4><pre><code>public static void main(String[] args) {
    //设置连接为null
    Connection connection = null;
    //设置预处理状态为null
    PreparedStatement preparedStatement = null;
    //设置结果集为null
    ResultSet resultSet = null;
    //检查异常并抛出异常
        try {
            //1、加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //2、通过驱动管理类获取数据库链接
            connection =  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;);
            //3、定义sql语句 ?表示占位符
            String sql = &quot;select * from user where username = ?&quot;;
            //4、获取预处理statement
            preparedStatement = connection.prepareStatement(sql);
            //5、设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值
            preparedStatement.setString(1, &quot;Aaron&quot;);
            //6、向数据库发出sql执行查询，查询出结果集
            resultSet =  preparedStatement.executeQuery();
            //7、遍历查询结果集
            while(resultSet.next()){
                System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            //8、释放资源
            if(resultSet!=null){
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(preparedStatement!=null){
                try {
                    preparedStatement.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(connection!=null){
                try {
                    connection.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
</code></pre><blockquote>
<p>总结：1.JDBC在使用过程中数据库连接会频繁开启和关闭，会严重影响到数据库的性能。2.在程序中存在硬编码，数据库部分以及SQL执行部分。</p>
</blockquote>
<h2 id="Mybatis-框架原理"><a href="#Mybatis-框架原理" class="headerlink" title="Mybatis 框架原理"></a>Mybatis 框架原理</h2><pre><code>1.mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息。映射文件配置了SQL执行相关的信息。

2.mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂(sqlSessionFactory)。

3.通过SqlSessionFactory(会话工厂)，可以创建SqlSession即会话。Mybatis是通过SqlSession来操作数据库的。

4.SqlSession(会话)其本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。

5.Executor执行器要处理的SQL信息是封装到一个底层对象 MappedStatement 中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括Java的简单类型、HashMap集合对象、POJO对象类型。
</code></pre><hr>
<h2 id="Mybatis-入门程序"><a href="#Mybatis-入门程序" class="headerlink" title="Mybatis 入门程序"></a>Mybatis 入门程序</h2><h4 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h4><pre><code>1.创建数据表
2.添加相关依赖文件
3.添加log4j.properties文件(因为mybatis使用的日志包是log4j(在classpath路径下创建该文件))

    # Global logging configuration
    log4j.rootLogger=DEBUG, stdout
    # Console output...
    log4j.appender.stdout=org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
</code></pre><blockquote>
<p>注意：日志级别在开发阶段设置成DEBUG，在生产阶段设置成INFO或者ERROR。</p>
</blockquote>
<pre><code>4.编程步骤
    1.创建PO类，根据需求创建
        Public class User {
            private int id;
            private String username;// 用户姓名
            private String sex;// 性别
            private Date birthday;// 生日
            private String address;// 地址
            //以及一系列的get/set方法
            }
</code></pre><blockquote>
<p>注意：创建的po类属性名称应该和数据库表中的列名一致，如果表中的列名带有下划线，那么PO类中对应的属性名要采用驼峰式命名。驼峰式命名：骆驼式命名法就是当变量名或函数名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。</p>
</blockquote>
<pre><code>    2.创建全局配置文件SqlMapConfig.xml(是在classpath路径下创建配置文件)
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
        &lt;configuration&gt;
        &lt;!-- 配置mybatis的环境信息 --&gt;
        &lt;environments default=&quot;development&quot;&gt;
            &lt;environment id=&quot;development&quot;&gt;
                &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
                &lt;!-- 配置数据源，采用dbcp连接池 --&gt;
                &lt;dataSource type=&quot;POOLED&quot;&gt;
                    &lt;!—驱动和URL设置--&gt;
                    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
                    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
                &lt;/dataSource&gt;
            &lt;/environment&gt;
        &lt;/environments&gt;
        &lt;/configuration&gt;

    3.编写映射文件(xxxMapper.xml(mapper接口的实现类))
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper    
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

    4.加载映射文件，在SqlMapConfig.xml中进行加载
        &lt;!-- 加载mapper --&gt;
        &lt;mappers&gt;
            &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;
        &lt;/mappers&gt;

    5.编写测试程序，即编写Java代码，连接并操作数据库
        public class MybatisFirst {

        @Test
        public void findUserByIdTest() throws Exception{
            //1、读取配置文件
            String resource = &quot;SqlMapConfig.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            //2、根据配置文件创建SqlSessionFactory
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //3、SqlSessionFactory创建SqlSession
            SqlSession sqlSession = sqlSessionFactory.openSession();
            //4、SqlSession执行statement，并返回映射结果
            //第一个参数：statement的id，建议：namespace.statementId（确保唯一）
            //第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致
            User user = sqlSession.selectOne(&quot;findUserById&quot;, 1);
            //打印输出结果集
            System.out.println(user);
            //5、关闭SqlSession
            sqlSession.close();
        }
    }

5.mybatis.xml配置文件

    1.SqlSession 说明

        1.SqlSessionFactoryBuider
            通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory，将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例模式管理，在创建SqlSessionFactory的时候，只需要new一次SqlSessionFactoryBuilder即可。

        2.SqlSessionFactory
            通过SqlSessionFactory创建SqlSession，使用单例模式来管理SqlSessionFactory（工厂一旦创建，只使用一个实例）。

        3.SqlSession
            SqlSession是一个面向用户的接口，其提供了很多操作数据库的方法，同时其是线程不安全的，其最佳的应用场合是方法体内，将其定义为局部变量来使用。

    2.mybatis.xml配置文件

        &lt;!-- 3.配置SqlSessionFactory spring和MyBatis整合，不需要在mybatis的配置文件中写每个entity的映射文件 --&gt;
        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;!--1.配置数据源--&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;!--2.指定mybatis的全局配置文件--&gt;
            &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;
            &lt;!-- 自动扫描mapper.xml文件 --&gt;
            &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:sqlmapper/*.xml&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;

        &lt;!--批量配置mapper代理类，默认bean的id为类名首字母小写--&gt;
        &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;!--1.配置扫描包--&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.edu.xidian.c2.mapper&quot; /&gt;
            &lt;!--2.只有一个sqlSessionFactory时，默认不需要配置SqlSessionFactory,单独配置也可以--&gt;
            &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
</code></pre><blockquote>
<p>总结：1.首先读取配置文件，然后通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。<br>2.通过SqlSessionFactory创建SqlSession，然后调用SqlSession的操作数据库的方法。<br>3.最后关闭SqlSession。</p>
</blockquote>
<hr>
<blockquote>
<p>小结</p>
<blockquote>
<p>1.parameterType 指定输入参数的Java类型，可以填写别名或Java类的全限定名。</p>
<blockquote>
<p>2.resultType 指定输出结果的Java类型，可以填写别名或Java类的全限定名。</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>#{}和${}
    #{}：相当于预处理中的占位符？。

    #{}里面的参数表示接收java输入参数的名称。

    #{}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，#{}里面可以是value，也可以是其他。

    #{}可以防止SQL注入。

    ${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。

    ${}会引起SQL注入，所以要谨慎使用。

    ${}可以接受HashMap、简单类型、POJO类型的参数。

    当接受简单类型的参数时，${}里面只能是value。

selectOne：只能查询0或1条记录，大于1条记录的话，会报错
selectList：可以查询0或N条记录
</code></pre><hr>
<h2 id="Mybatis-开发DAO"><a href="#Mybatis-开发DAO" class="headerlink" title="Mybatis 开发DAO"></a>Mybatis 开发DAO</h2><p>我们知道，mybatis在项目开发中主要使用的地方就是开发DAO(数据访问层)。所以开发方式有两种。1.原始的DAO开发方式。2.Mapper代理开发方式。</p>
<h4 id="1-原始DAO开发方式"><a href="#1-原始DAO开发方式" class="headerlink" title="1.原始DAO开发方式"></a>1.原始DAO开发方式</h4><pre><code>实现步骤：
    1.根据需求创建po类
      这一步骤的实现所对应的属性名要与数据库中的属性名相对应
    2.编写全局配置文件
      这一步骤的实现是配置数据源等信息
    3.根据需求编写映射文件
      实现实体类与数据库之间的数据操作
    4.加载映射文件
    5.编写dao接口
        public interface UserDao {
            //根据用户ID来查询用户信息
            public User findUserById(int id);
            //根据用户名称来模糊查询用户信息列表
            public List&lt;User&gt; findUsersByName(String username);
            //添加用户
            public void insertUser(User user);
        }

    6.编写dao实现类
        public class UserDaoImpl implements UserDao {

            //注入SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;
            //使用构造方法来初始化SqlSessionFactory
            public UserDaoImpl(SqlSessionFactory sqlSessionFactory){
                this.sqlSessionFactory = sqlSessionFactory;
            }

            @Override
            public User findUserById(int id) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                //返回结果集
                return sqlSession.selectOne(&quot;test.findUserById&quot;, id);
            }

            @Override
            public List&lt;User&gt; findUsersByName(String username) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                return sqlSession.selectList(&quot;test.findUsersByName&quot;, username);
            }

            @Override
            public void insertUser(User user) {
                //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全
                SqlSession sqlSession = sqlSessionFactory.openSession();
                sqlSession.insert(&quot;test.insertUser&quot;, user);
            }

        }

    7.编写测试代码
        public class UserDaoTest {

            //声明全局的SqlSessionFactory
            private SqlSessionFactory sqlSessionFactory;

            @Before
            //此方法在测试方法执行之前执行，spring开发方式
            public void setUp() throws Exception {
                // 1、读取配置文件
                String resource = &quot;SqlMapConfig.xml&quot;;
                InputStream inputStream = Resources.getResourceAsStream(resource);
                // 2、根据配置文件创建SqlSessionFactory
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            }

            @Test
            public void testFindUserById() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                User user = userDao.findUserById(1);

                System.out.println(user);
            }

            @Test
            public void testFindUsersByName() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //调用UserDao对象的方法
                List&lt;User&gt; list = userDao.findUsersByName(&quot;小明&quot;);

                System.out.println(list);
            }

            @Test
            public void testInsertUser() {
                //构造UserDao对象
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                //构造User对象
                User user = new User();
                user.setUsername(&quot;东哥3&quot;);
                user.setAddress(&quot;清河宝盛西里3&quot;);

                //调用UserDao对象的方法
                userDao.insertUser(user);

                System.out.println(user.getId());
            }

        }
</code></pre><h4 id="2-mapper开发代理方式"><a href="#2-mapper开发代理方式" class="headerlink" title="2.mapper开发代理方式"></a>2.mapper开发代理方式</h4><p>使用Mapper代理的开发方式，我们只需要编写mapper接口，然后mybatis会自动为mapper接口生成动态代理实现类。</p>
<pre><code>1.mapper接口的全限定名要和mapper映射文件的namespace的值相同。
2.mapper接口的方法名称要和mapper映射文件中的statement的id相同。
3.mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。
4.mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致。
</code></pre><blockquote>
<p>提示：statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上，向数据库发送要执行的SQL语句，Statement对象用于执行不带参数的简单SQL语句。</p>
</blockquote>
<h2 id="Mybatis-映射文件"><a href="#Mybatis-映射文件" class="headerlink" title="Mybatis 映射文件"></a>Mybatis 映射文件</h2><pre><code>1.输入映射
    ParameterType

2.输出映射
    resultType

3.高级映射
    resultMap
</code></pre><h2 id="mybatis-高级映射"><a href="#mybatis-高级映射" class="headerlink" title="mybatis 高级映射"></a>mybatis 高级映射</h2><pre><code>1.mybatis框架执行过程：
  1.配置mybatis的配置文件(mybatis-config.xml)（名称不固定）。

  2.通过配置文件(mybatis-config.xml)，加载mybatis运行环境，创建SqlSessionFactory会话工厂,SqlSessionFactory在实际使用时按单例方式。

  3.通过SqlSessionFactory创建SqlSession，SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。

  4.调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。

  5.释放资源，关闭SqlSession

2.mybatis开发dao的方法
  1.使用原始的dao的方法
    这样需要编写dao接口和实现类，需要在dao实现类注入一个SqlSessionFactory工厂。

  2.mapper代理开发方法(推荐)
    0.编写mapper接口(dao接口)
      注意：在编写mapper.xml(映射文件)和mapper.java(接口)需要遵循开发规范

    1.mapper.xml中的namespace就是mapper.java的类的全路径名

    2.mapper.xml中statement的id值和mapper.java中方法名一致(如：insert/delete/update中的id值)

    3.mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法数据参数类型一致(parameterType类型与对应的接口方法参数类型一致)

    4.mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致(resultMap：定义出参，调用已经定义的&lt;resultMap&gt;&lt;/resultMap&gt;映射管理器的id值 

    resultType：定义出参，匹配普通Java类型或自定义pojo类型(出参类型若不指定，将为语句默认类型))
</code></pre><blockquote>
<p>注意：全局配置文件(mybatis-config.xml)可以配置properties属性、别名、mapper加载等。</p>
</blockquote>
<pre><code>3.输入映射
  1.parameterType：指定输入参数类型可以是简单类型、POJO、HashMap，而对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展。

4.输出映射
  1.resultType：查询到的列名和resultType指定的POJO的属性名一致，这样才能映射成功。
    作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中
    场合：

  2.resultMap：可以通过resultMap完成高级映射，如果查询到的列名和映射的POJO的属性名不一致时，通过resultMap设置别名和属性名之间的对应关系(映射关系)，可以完成映射。

    association
    作用：将关联查询信息映射到一个pojo对象中
    场合：为了方便查询关联信息可以使用association将关联 订单信息 映射为 用户对象 的pojo属性中。association适用于一对一查询。
</code></pre><blockquote>
<p>注意：使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap</p>
</blockquote>
<pre><code>collection
作用：将关联查询信息映射到一个list集合中
场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，而如果使用resultType无法将查询结果映射到list集合中。collection适用于一对多和多对多的查询。
</code></pre><blockquote>
<p>扩展：映射管理器<code>resultMap</code>：是<code>mybatis</code>中强大的工具，使用其可以进行 实体类之间 的映射，并且管理 结果和实体类 之间的映射关系。</p>
</blockquote>
<pre><code>resultMap映射管理器需要配置的属性：

    &lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;&lt;/resutlMap&gt;   
        id=&quot; &quot;:表示这个映射管理器的唯一标识，外部通过该值引用
        type = &quot; &quot;:表示需要映射的实体类

resultMap映射管理器需要配置的参数：

    &lt;id column = &quot; &quot; property= &quot; &quot; /&gt; 
        &lt;id&gt;标签指的是：结果集中结果唯一的列column(column：指定唯一标识用户信息的数据列)和实体属性property(property:映射到user实体类的哪个属性)的映射关系
            注意：&lt;id&gt;标签管理的列未必是主键列，需要根据具体需求指定

    &lt;result column= &quot; &quot; property=&quot; &quot; /&gt;  
        &lt;result&gt;标签指的是：结果集中普通列column和实体属性property的映射关系

resultMap映射管理器需要维护的关系：所谓关系维护是值在 主表查询时将其关联子表的结果也查询出来
</code></pre><hr>
<pre><code>resultMap元素中，允许有如下直接子元素：
    1.constructor：类在实例化时，用来注入结果到构造方法中,作用与result相同，同时可以标识出用这个字段值可以区分其他对象实例
        arg：注入到构造方法的一个普通结果
        idArg：ID参数，标记结果作为ID，可以帮助提高整体效能

    2.result：将数据表中的字段注入到Java对象属性中

    3.association：关联(一对一的关系)，表示在resultMap映射器中，通过&lt;association&gt;&lt;/association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来。

      作用：将关联查询的信息映射到一个POJO中
      &lt;association property=&quot;&quot; javaType=&quot;&quot;&gt;
          property：对象属性的名称，被维护实体在宿主实体(POJO)中的属性名
           javaType：对象属性的类型，被维护实体的类型
           column：所对应的外键字段名称
           select：使用另一个查询封装的结果

    4.collection：集合(一对多/多对多关系的维护)，对关联查询到的多条记录映射到集合对象中。

      作用：将关联查询用户信息映射到一个list集合中
      &lt;collection property=&quot;&quot; ofType=&quot;&quot;&gt;
      property=&quot;&quot; 将查询到的多条记录映射到相应的POJO类上对应的属性中
      ofType=&quot;&quot; 指定映射到List集合的pojo类型

    5.discriminator：使用结果集决定使用哪个个结果映射
</code></pre><blockquote>
<p>拓展：sql片段标签<sql>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用。</sql></p>
</blockquote>
<pre><code>注意：需要配置的属性，id=&quot;&quot; 表示需要改sql语句片段的唯一标识 引用：通过&lt;include refid=&quot;&quot;/&gt;标签引用，refid=&quot;&quot;中的值指向需要引用的&lt;sql&gt;中的id=&quot;&quot;属性。
</code></pre><blockquote>
<p>注意：在resultMap中应该注意两点</p>
</blockquote>
<pre><code>1.关联关系的维护可以根据实体类之间的实际情况进行嵌套维护

2.出现重复列名的处理，在实际操作过程中，查询到的结果可能会出现相同的列名，这样会对映射到实体属性带来影响甚至报错，所以可以通过对列取别名的方式来处理
</code></pre><p>5.高级映射<br>  1.将关联查询的列映射到一个POJO属性中(一对一)<br>  2.将关联查询的列映射到一个List<pojo>中(一对多)</pojo></p>
<hr>
<h2 id="mybatis动态sql语句"><a href="#mybatis动态sql语句" class="headerlink" title="mybatis动态sql语句"></a>mybatis动态sql语句</h2><p>6.常用的动态语句标签(通过动态sql标签可以进行条件判断，条件遍历等操作从而能够满足结果中的需要)</p>
<pre><code>&lt;where&gt;：这一标签的使用可以代替sql语句中的where关键字，一般放置在条件查询的最外层 
   where后面跟查询条件，简化sql语句中判断条件的书写 此中，mybatis会智能的将首个and或or给忽略

&lt;if&gt;：这一标签配置属性test=&quot;条件字符串&quot;，判断是否满足条件

&lt;set&gt;：这一标签常用于&lt;update&gt;更新语句中，替代sql的set关键字，特别是在联合&lt;if&gt;进行判断是否符合条件时，可以有效方式当某个参数为空或者不合法是错误的更新到数据库中
 mybatis set标签的使用：sql语句中的最后一个逗号会被set标记自动忽略

&lt;trim&gt;：在mapper.xml中对statement的定义，可以使用&lt;trim&gt;标签来填充和隐藏sql语句。
    功能：1.如果标签体中有SQL语句，就把修饰后的SQL语句拼接到之前的SQL语句上，如果标签体中没有SQL语句，那么这标签相当于不存在。2.这四个属性的默认值都是空字符串。

      trim属性 prefix：前缀   suffix：后缀 

      &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; prefixOverrides=&quot;,&quot; suffixOverrides=&quot;,&quot;&gt;

      属性：
        1.prefix=&quot;(&quot; 在trim标签定义的内容前填充对应内容
        2.suffix=&quot;)&quot; 在trim标签定义的内容后填充对应内容

        3.prefixOverrides=&quot;,&quot;  在trim定义中，隐藏头部对应的内容。这个属性指定一个字符串，这个字符串一定是SQL语句的前缀，如果不是前缀，这个属性不起作用。会用prefix属性指定的字符串替换掉这个属性指定的字符串。

        4.suffixOverrides=&quot;,&quot; 在trim定义的中，隐藏尾部对应的内容。这个属性指定一个字符串，这个字符串位一定是SQL语句的后缀，如果不是后缀，这个属性不起作用。其会用suffix属性指定的字符串替换这个属性指定的字符串。

mysql对查询结果排序：从表中查询出来的数据，可能是无序的，或者其排列顺序表示用户期望的，使用order by对查询结果进行排序。

    SELECT 字段名1，字段名2，... FROM 表名 ORDER BY 字段名1 [ASC|DESC]，字段名2[ASC|DESC],...

    参数说明：
        1.字段名1，字段名2,...：表示对查询结果排序的依据
        2.参数ASC：表示按照升序进行排序
        3.参数DESC：表示按照降序的方式进行排序
        4.默认情况下是按照ASC方式进行升序排序
</code></pre><blockquote>
<p>注意：当按照执行字段进行升序排序时，如果其中的某条记录的字段值是null时，则这条记录会在第一条显示，因为null值会被认为是最小值。</p>
</blockquote>
<pre><code>标签组：
  &lt;choose&gt;
    &lt;when&gt; //此元素的作用与Java中的switch效果差不多
    &lt;/when&gt;
    &lt;otherwise&gt;
    &lt;/otherwise&gt;
  &lt;/choose&gt; 
  也是一个用于条件判断的标签组，和&lt;if&gt;的不同之处在于条件从&lt;choose&gt;进入，去匹配&lt;when&gt;中的添加，一旦匹配马上结束，若到找不到匹配项，将执行&lt;otherwise&gt;中的语句；可以理解为&lt;if&gt;是 &amp;&amp; 关系 &lt;choose&gt;是 || 关系

  &lt;foreach&gt;标签：遍历集合类型的条件(在实现 mybatis in 语句查询时特别有用)
  属性：collection=&quot;array/list&quot; 是数组类型还是集合类型
        item=&quot; &quot; 参数名
    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;  开始符号，分隔符号，结束符号
    index=&quot;&quot; 结束下标位置，不配置该参数时，默认为全部遍历
</code></pre><blockquote>
<p>扩展：</p>
</blockquote>
<pre><code>MySQL JOIN语法
    join用于多表中字段之间的联系(...FROM table1(左表) INNER|LEFT|RIGHT JOIN table2(右表) ON condition)
大致功能：
    1.INNER JOIN（内连接取两表的交集）：取得两个表中存在连接匹配关系的记录(产生一组同时符合A和B的数据)。
    2.LEFT JOIN（左连接）：返回左表中所有的行，即在右表中没有匹配的记录。
    3.RIGHT JOIN（右连接）：返回右表中所有的行，即在左表中没有匹配的记录。
    4.OUTER JOIN(外连接)：求两个集合的并集。
    5.FULL JOIN：在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。


条件ON与Where的执行顺序
    ON：用来决定如何从B表中检索数据行
        如：A LEFT JOIN B ON 条件表达式 ON条件用来决定如何从B表中检索数据行，如果在B表中没有任何一行数据匹配ON的条件，将会额外生成一行所有列都为null的数据，在匹配阶段，where子句的条件不会使用吗，仅在匹配阶段完成以后，WHERE子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。
</code></pre><hr>
<h2 id="mybatis高级查询"><a href="#mybatis高级查询" class="headerlink" title="mybatis高级查询"></a>mybatis高级查询</h2><p>1.关联查询<br>  在查询一个结果的时候，查询出其他关联的结果集</p>
<p>2.子查询<br>  关联查询一般可以使用子查询来实现，但是一般情况下子查询的效率低于关联查询</p>
<p>3.集合查询<br>  集合查询是关联查询的一种，只不过它是一对多而已</p>
<p>4.mapper.xml源码分析</p>
<pre><code>1.namespace：对应mapper接口(类似dao接口)
2.resultMap：
  1.id：
</code></pre><p>5.一对一查询(resultType 实现)</p>
<p>使用resultType来进行一对一结果映射，查询出的列的个数和映射的属性的个数要一致。而且映射的属性要存在与一个大的对象中，它是一种平铺式的映射，即数据库查询出多少条记录，则映射成多少个对象。</p>
<pre><code>一对一查询(resultMap 实现)

使用resultMap来进行一对一结果映射，它是将关联对象添加到主信息的对象中，具体说是一种对象嵌套另一种对象的一种映射方式。

&lt;resultMap type=&quot;mybatis.po.OrdersExt&quot; id=&quot;OrdersAndUserRstMap&quot;&gt;
    &lt;!-- 订单信息 --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
    &lt;!-- 对象嵌套映射 --&gt;
    &lt;!-- association：一对一关联映射 --&gt;
    &lt;!-- property：关联信息查询的结果将要映射的扩展类中的对象属性名称 --&gt;
    &lt;!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --&gt;
    //association：表示在resultMap映射器中，通过&lt;association&gt;进行维护，在查询一个对象时，可以将关联的对应信息也查询出来
    &lt;association property=&quot;user&quot; javaType=&quot;mybatis.po.User&quot;&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;/association&gt;
</code></pre><blockquote>
<p>总结：在一对一映射结果时，使用<code>resultType</code>更加简单方便，如果有特殊要求(对象嵌套对象)时，需要使用<code>resultMap</code>进行映射，关联查询出其关联信息。</p>
</blockquote>
<p>6.一对多查询</p>
<pre><code>1.多对一的查询引入association，进行联合查询

     &lt;resultMap id=&quot;resultUserArticleList&quot; type=&quot;Article&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
            &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
            &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;
            &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
                    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
                    &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
                    &lt;result property=&quot;userAddress&quot; column=&quot;userAddress&quot; /&gt;            
            &lt;/association&gt;        
        &lt;/resultMap&gt;

    &lt;select id=&quot;getUserArticles&quot; parameterType=&quot;int&quot; resultMap=&quot;resultUserArticleList&quot;&gt;
           select user.id,user.userName,user.userAddress,article.id aid,article.title,article.content from user,article where user.id=article.userid and user.id=#{id}
    &lt;/select&gt;
</code></pre><blockquote>
<p>总结：在上述配置之后，将select语句与resultMap对应的映射结合起来，可以看出，用association来得到关联的用户，得到的所有文章都是同一个用户的。</p>
</blockquote>
<pre><code>2.复用已经定义好的resultMap，将association中对应的映射独立抽取出来，以至于能够达到复用的目的

    1.首先定义好一个resultMap
            &lt;resultMap type=&quot;User&quot; id=&quot;resultListUser&quot;&gt;
                &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
                &lt;result column=&quot;userName&quot; property=&quot;userName&quot; /&gt;
                &lt;result column=&quot;userAge&quot; property=&quot;userAge&quot; /&gt;
                &lt;result column=&quot;userAddress&quot; property=&quot;userAddress&quot; /&gt;
            &lt;/resultMap&gt;

    2.然后在新定义的resultMap中引用已定义的resultMap
        &lt;resultMap id=&quot;resultUserArticleList-2&quot; type=&quot;Article&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
                &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;
                &lt;result property=&quot;content&quot; column=&quot;content&quot; /&gt;        
                &lt;association property=&quot;user&quot; javaType=&quot;User&quot; resultMap=&quot;resultListUser&quot; /&gt;  //在这里使用association复用已经定义好的resultMap           
           &lt;/resultMap&gt;
</code></pre><p>7.多对多映射查询(只是一对多映射的特例)</p>
<pre><code>多对多映射查询只不过是一对多映射的特例，其是在一对多的基础上添加多个&lt;collection&gt;来表明多个数据表单之间的关系的。

如：

    1.定义resultMap

    &lt;!-- 查询用户即购买的商品信息的ResultMap --&gt;
    &lt;resultMap type=&quot;com.mybatis.entity.User&quot; id=&quot;userAndItemsResultMap&quot;&gt;
        &lt;!-- 用户信息 --&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!-- 订单信息
        一个用户对应多个订单，使用collection映射 
        在用户信息中关联映射商品订单信息--&gt;
        &lt;collection property=&quot;ordersList&quot; ofType=&quot;com.mybatis.entity.Orders&quot;&gt;
             &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
             &lt;result column=&quot;user_id&quot; property=&quot;userid&quot;/&gt;
            &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
            &lt;result column=&quot;createtime&quot; property=&quot;createTime&quot;/&gt;
            &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;

         &lt;!-- 订单明细
                 一个订单包括多个明细
                 在商品订单中关联映射商品订单的多个明细
              --&gt;
              &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.mybatis.entity.OrderDetail&quot;&gt;
                      &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
                     &lt;result column=&quot;items_id&quot;   property=&quot;itemsId&quot;/&gt;
                     &lt;result column=&quot;items_num&quot;  property=&quot;itemsNum&quot;/&gt;
                     &lt;result column=&quot;orders_id&quot;  property=&quot;ordersId&quot;/&gt;
                     &lt;!-- 商品信息
                          一个订单明细对应一个商品
                          然后这儿是一对一的关联映射，所以使用的association进行两者之间的映射 
                       --&gt;
                   &lt;association property=&quot;items&quot; javaType=&quot;com.mybatis.entity.Items&quot;&gt;
                       &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;
                       &lt;result column=&quot;items_name&quot; property=&quot;itemsName&quot;/&gt;
                       &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;
                       &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;
                   &lt;/association&gt;
              &lt;/collection&gt;
          &lt;/collection&gt;

    &lt;/resultMap&gt;
&lt;!-- 查询用户及用户购买的商品信息，使用resulaMap--&gt;

2.定义statement(statement表示Java执行数据库操作的一个重要接口，用于在已经建立的数据库连接的基础上向数据库发送要执行的SQL语句，Statement用于执行不带参数的简单SQL语句)

&lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;userAndItemsResultMap&quot;&gt;
        SELECT 
               t1.*,
               t2.username,
               t2.sex,
               t2.address,
               t3.id orderdetail_id,
               t3.items_id,
               t3.items_num,
               t3.orders_id,
               t4.itemsname items_name,
               t4.detail items_detail,
               t4.price items_price
        FROM
              orders t1,
              t_user t2,
              orderdetail t3,
              items t4
        WHERE t1.user_id =  t2.id AND  t3.orders_id=t1.id AND t3.items_id = t4.id
&lt;/select&gt;
</code></pre><blockquote>
<p>扩展<br><br>为了验证上述得到的结果是否正确，可以对其进行junit测试。</p>
</blockquote>
<pre><code>public class OrdersCustomMapperTest {
    //创建会话工厂
    private SqlSessionFactory sqlSessionFactory;
    //查询订单，关联查询用户信息，使用resultType实现的测试
    @Test
    public void TestFindOrdersUser() {
        //利用会话工厂创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 创建代理对象
        OrdersCustomMapper oc = sqlSession.getMapper(OrdersCustomMapper.class);
        // 调用mapper接口中的方法
        List&lt;OrdersCustom&gt; list = oc.findOrdersUser();
        //作为验证是否输出的list是否和要查询的结果正确
        System.out.println(list);
        //关闭会话
        sqlSession.close();
}
</code></pre><hr>
<h1 id="mybatis开发总结"><a href="#mybatis开发总结" class="headerlink" title="mybatis开发总结"></a>mybatis开发总结</h1><pre><code>1.一般的查询直接返回实体类型即可，而对于关联查询，处理方式之一就是：自己构造一个resultMap，名称为Map1。然后将自己所需要的字段在新建的resultMap中做一个映射，然后将查询结果设置为新建的Map1。
  注意：在Map1中可以多映射一些字段，为空的查询默认不映射

2.在Mapper层接口，我们一般设置该方法的返回值类型是：List&lt;Map&lt;String,Object&gt;&gt; 每一个list里面放有很多的map键值对

3.#{} 表示一个占位符，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，此外，#{}可以有效防止sql注入
  ${} 表示拼接sql串，通过${}可以将parameterType传入的内容拼接在sql中不进行jdbc类型转换

4.mybatis解决JDBC编程问题
  1.在SqlMapConfig.xml中配置数据库连接池管理数据库连接可以解决因为数据库频繁创建、释放连接而影响系统性能的问题

  2.模糊查询，resultType：表示是List的泛型类型 ${value} 固定写法只能写value表示拼接字符串
</code></pre><hr>
<h2 id="Mybatis整合Spring"><a href="#Mybatis整合Spring" class="headerlink" title="Mybatis整合Spring"></a>Mybatis整合Spring</h2><p>1.整合思路：</p>
<pre><code>1.数据源信息交给Spring管理
2.SqlSessionFactory交给Spring进行单例管理
3.由Spring来管理原始DAO的实现类或者Mapper代理的代理类
</code></pre><h4 id="2-1-具体整合步骤1："><a href="#2-1-具体整合步骤1：" class="headerlink" title="2.1 具体整合步骤1："></a>2.1 具体整合步骤1：</h4><pre><code>1.Mybatis
  1.在配置文件文件夹(config)下创建SqlMapConfig.xml
  2.配置属性文件(db.properties/log4j.properties)

注意：mybatis的配置文件中的数据源配置去掉，由spring进行管理配置。

2.Spring
  1.在配置文件文件夹(config)下创建application.xml
    1.加载Java的配置文件
    &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;
    2.创建数据源
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    //将数据库的驱动(driverClassName)、URL、username、password、maxActive、maxIdle属性值配置完

    3.配置SqlSessionFactory
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        //1.指定mybatis的全局配置文件路径
        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;&gt;
        //2.配置数据源
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3.整合代码
  1.原始DAO开发方式
    1.映射文件(User.xml)
    2.DAO接口代码以及DAO的实现类代码
    3.在application.xml中配置UserDao的实现类
        &lt;bean id=&quot;userDao&quot; class=&quot;xxx.xx.xxx.UserDaoImpl&quot;&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/proerty&gt;
        &lt;/bean&gt;
    4.编写测试代码

  2.mapper代理的方式
    1.映射文件(UserMapper.xml)
    2.Mapper接口
    3.配置mapper代理类
    1.单个mapper代理类的配置
        &lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
            //设置代理类接口
            &lt;property name=&quot;mapperInterface&quot; value=&quot;com.xx.xxx.xx.UserMapper&quot;&gt;&lt;/property&gt;
            //依赖注入SqlSessionFactory
            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;    
        &lt;/bean&gt;
    2.批量设置mapper代理类

              &lt;!--批量配置mapper代理类，默认bean的id为类名首字母小写--&gt;
            //通过MapperScannerConfigurer批量扫描创建代理对象
            &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
                &lt;!--配置扫描包--&gt;
                &lt;property name=&quot;basePackage&quot; value=&quot;cn.edu.xidian.c2.mapper&quot; /&gt;
                &lt;!--只有一个sqlSessionFactory时，默认不需要配置SqlSessionFactory,单独配置也可以--&gt;
                &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
</code></pre><hr>
<h4 id="2-2-具体整合步骤2："><a href="#2-2-具体整合步骤2：" class="headerlink" title="2.2 具体整合步骤2："></a>2.2 具体整合步骤2：</h4><pre><code>1.Maven引入需要的jar包(添加依赖 基本的依赖)

2.Spring与Mybatis的整合

  1.建立JDBC属性文件(jdbc.properties 文件编码改为utf-8)
  2.建立spring-mybatis.xml配置文件(用来完成spring和mybatis整合 主要是：自动扫描、自动注入、配置数据库)

3.Log4j的配置

  配置LOG4j的目的是为了更方便测试，使用日志来输出信息，然后所有的项目基本上都是这样一个基本的配置

  1.建立log4j.properties配置文件

4.JUnit测试

  1.创建测试用表
  2.利用MyBatis Generator自动创建代码 这个根据表自动创建实体类、mybatis映射文件、DAO接口

    使用MyBatis Generator自动创建代码 

  3.建立Service接口和实现类

  4.建立测试类

5.整合SpringMVC(springmvc的配置文件单独放，然后在web.xml文件中配置整合)

  1.配置springmvc.xml(主要是自动扫描控制器、视图模式、注解启动这三个的配置)
  2.配置web.xml文件 这里对spring-mybatis.xml配置文件的引入以及配置springmvc的servlet
</code></pre><hr>
<h2 id="Mybatis的逆向工程"><a href="#Mybatis的逆向工程" class="headerlink" title="Mybatis的逆向工程"></a>Mybatis的逆向工程</h2><p>概念：Mybatis提供来一个逆向工程工具，通过逆向工程，可以帮助程序员根据数据表单表来生成po类、mapper映射文件、mapper接口。<br>      就是通过数据库中的单表自动生成Java代码。</p>
<p>具体笔记见mybatis教案</p>
<h4 id="1-逆向工程使用步骤："><a href="#1-逆向工程使用步骤：" class="headerlink" title="1.逆向工程使用步骤："></a>1.逆向工程使用步骤：</h4><pre><code>1.创建generator配置文件
  generator.xml文件内容可以从逆向工程的jar包下的docs目录下的index.html文件中找到相关的源代码

2.使用java类来执行逆向工程

  public class Generator {
    public static void main(String[] args)  throws Exception{
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        File configFile = new File(&quot;config/generator.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    }

}

3.把生成的代码拷贝到项目中
  如果正式项目中已经有po类所在的包了，那么就只需要拷贝po类到指定包下就可以。如果正式项目中没有po包，那么就把逆向工程中整个po类的包拷贝过去。
Mapper.xml和mapper.java的拷贝与po类一样


4.在正式项目中使用逆向工程生成的代码

  public class ItemsMapperTest {

// spring上下文
private ApplicationContext ctx;

@Before
public void setUp() throws Exception {
    // 读取spring的上下文，然后封装到ctx
    ctx = new ClassPathXmlApplicationContext(
            &quot;spring/applicationContext.xml&quot;);
}

@Test
public void testSelectByExample() {
    ItemsMapper mapper = (ItemsMapper) ctx.getBean(&quot;itemsMapper&quot;);

    ItemsExample example = new ItemsExample();
    //使用它进行参数封装传递
    Criteria criteria = example.createCriteria();
    //设置参数
    criteria.andNameEqualTo(&quot;背包&quot;);

    List&lt;Items&gt; list = mapper.selectByExample(example);

    System.out.println(list);
}
</code></pre><p>}</p>
<pre><code>注意：
1.mapper.xml文件已经存在时，如果进行重新生成mapper.xml文件，内容不会被覆盖，而是进行mapper.xml文件内容的追加，结果会导致mybatis解析失败
解决方法：删除原来已经生成的mapper.xml文件再进行生成

2.mybatis自动生成的po以及mapper.java文件不是追加而是直接覆盖，所以不会出现此问题。
</code></pre><hr>
<h2 id="Mybatis-的查询缓存"><a href="#Mybatis-的查询缓存" class="headerlink" title="Mybatis 的查询缓存"></a>Mybatis 的查询缓存</h2><h4 id="1-mybatis缓存分析"><a href="#1-mybatis缓存分析" class="headerlink" title="1.mybatis缓存分析"></a>1.mybatis缓存分析</h4><p>mybatis提供查询缓存，如果缓存中有数据就不用从数据库中获取，用于减轻数据压力，提高系统性能。</p>
<pre><code>一级缓存：SqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)用于存储缓存数据，不同的sqlSession之间的缓存数据区域(HashMap)互相不影响。

二级缓存：mapper级别的缓存，多个SqlSession去操作同一个mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

注意：mybatis默认支持一级缓存

应用：在开发项目过程中，将mybatis与spring进行整合开发，事务控制在service中，一个service方法中包括很多mapper方法调用。
</code></pre><blockquote>
<p>注意：mybatis默认没有开启二级缓存</p>
</blockquote>
<h4 id="2-mybatis-开启二级缓存"><a href="#2-mybatis-开启二级缓存" class="headerlink" title="2.mybatis 开启二级缓存"></a>2.mybatis 开启二级缓存</h4><pre><code>1.在核心配置文件SqlMapConfig.xml中添加开启二级缓存总开关
  &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;

2.在UserMapper映射文件中开启二级缓存（开启mapper下的namespace的二级缓存，默认使用mybatis提供的PerpetualCache）
  &lt;cache&gt;&lt;/cache&gt;

3.实现序列化(因为二级缓存的数据不一定都是存储在内存中的，所以需要给缓存的对象执行序列化，如果该类存在父类，也需要给父类实现序列化)
</code></pre><h4 id="3-mybatis-禁用二级缓存"><a href="#3-mybatis-禁用二级缓存" class="headerlink" title="3.mybatis 禁用二级缓存"></a>3.mybatis 禁用二级缓存</h4><pre><code>在statement中设置userCache=false禁用当前select语句的二级缓存，每次查询都要去数据库中查询，默认情况下是true，该statement使用二级缓存。

&lt;select id=&quot;findUserById&quot;  parameterType=&quot;int&quot;  resultType=&quot;cn.itcast.mybatis.po.User&quot;  useCache=&quot;true&quot;&gt;
        SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre><h4 id="4-mybatis刷新二级缓存"><a href="#4-mybatis刷新二级缓存" class="headerlink" title="4.mybatis刷新二级缓存"></a>4.mybatis刷新二级缓存</h4><pre><code>见mybatis教案
</code></pre><hr>
<h4 id="5-mybatis-延迟加载"><a href="#5-mybatis-延迟加载" class="headerlink" title="5.mybatis 延迟加载"></a>5.mybatis 延迟加载</h4><pre><code>见mybatis教案
</code></pre><hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h4 id="1-Spring-MVC"><a href="#1-Spring-MVC" class="headerlink" title="1.Spring MVC"></a>1.Spring MVC</h4><pre><code>作用于WEB层，相当于Controller，用来处理用户请求。例：用户在地址栏输入http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法(虽然中间可能会包含很多业务，但是这些都不是SpringMVC来处理)
最终将结果返回给用户，并且返回相应的页面(可以只返回json/xml等格式数据)

总结：SpringMVC只负责跟用户打交道，做前面和后面的活，中间的实现过程等业务不是它负责。
</code></pre><h4 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2.Spring"></a>2.Spring</h4><pre><code>最常见，经常用到的是IOC容器，其可以装载bean(Java中的类，也包括service dao里面的)有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。
</code></pre><h4 id="3-mybatis"><a href="#3-mybatis" class="headerlink" title="3.mybatis"></a>3.mybatis</h4><pre><code>1.能够自由控制SQL
2.可以使用xml的方式来组织管理我们的SQL
</code></pre><hr>
<p>1.SSM整合</p>
<pre><code>1.Java各种对象的区分

PO 持久对象(entity) PO每个属性基本上都对应数据库表里面的某个字段，完全是一个符合Java Bean规范的Java对象，没有增强别的属性和方法。持久对象是由&lt;insert&gt;&lt;/insert&gt;数据库创建，由数据库&lt;delete&gt;&lt;/delete&gt;删除的。基本上持久对象生命周期和数据库密切相关。

VO 值对象 通常用于业务层(Service层)之间的数据传输，与PO一样只包含数据,此外应该抽象出业务对象。表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。

DTO 数据传输对象 是一种设计模式之间传输数据的软件应用系统 作用仅在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。

POJO 简单的Java对象 实际上可以理解POJO为简单的实体类 方便开发者使用数据库中的数据表
</code></pre><hr>
<h2 id="DTO-数据传输对象（起到数据封装与隔离的作用）"><a href="#DTO-数据传输对象（起到数据封装与隔离的作用）" class="headerlink" title="DTO 数据传输对象（起到数据封装与隔离的作用）"></a>DTO 数据传输对象（起到数据封装与隔离的作用）</h2><p>在实际的项目中，DTO分为两层传输</p>
<pre><code>1.Service层向Controller层，这一层的DTO封装Service执行结果给Controller简化业务数据，只提取部分业务相关字段或补充处理相关字段，不同业务可能有不同的此类dto，具有业务相关性。

2.Controller层向WEB前端，这一层DTO封装Controller执行结果，返回前端WEB，请求返回实体封装类，适用于所有ajax请求返回的类型实体，无业务相关性。
</code></pre><hr>
<h2 id="SSM整合知识点概括"><a href="#SSM整合知识点概括" class="headerlink" title="SSM整合知识点概括"></a>SSM整合知识点概括</h2><pre><code>1.Controller方法返回值(指定返回到哪个页面，指定返回到页面的数据)

    1)ModelAndView 

        modelAndView.addObject(&quot;itemList&quot;, list); 指定返回页面的数据

        modelAndView.setViewName(&quot;itemList&quot;);     指定返回的页面

    2)String(推荐使用)

        返回普通字符串,就是页面去掉扩展名的名称, 返回给页面数据通过Model来完成

        返回的字符串以forward:开头为请求转发

        返回的字符串以redirect:开头为重定向

    3)返回void(使用它破坏了springMvc的结构,所以不建议使用)

        可以使用request.setAttribut(因为我们写的是服务端，所以使用request对象向view中传输数据) 来给页面返回数据

        可以使用request.getRquestDispatcher().forward()来指定返回的页面

        如果controller返回值为void则不走springMvc的组件,所以要写页面的完整路径名称

    相对路径:相对于当前目录,也就是在当前类的目录下,这时候可以使用相对路径跳转

    绝对路径:从项目名后开始.
</code></pre><blockquote>
<p>注意：在springMvc中不管是forward还是redirect后面凡是以/开头的为绝对路径,不以/开头的为相对路径。</p>
</blockquote>
<pre><code>例如:
    forward:/items/itemEdit.action 为绝对路径

    forward:itemEdit.action为相对路径
</code></pre><hr>
<pre><code>2.架构级别异常处理

    此异常编写是实现全局异常处理器接口，目的主要为了防止项目上线后给用户抛500等异常信息,所以需要在架构级别上整体处理.hold住异常

    1.首先自定义全局异常处理器实现HandlerExceptionResolver接口
        public class GlobalHandleExceptionResolver implements HandlerExceptionResolver {//....

    2.在spirngMvc.xml中配置生效
</code></pre><hr>
<pre><code>3.上传图片

    1)在tomcat中配置虚拟图片服务器

    2)导入fileupload的jar包

    3)在springMvc.xml中配置上传组件

    4)在页面上编写上传域,更改form标签的类型

    5)在controller方法中可以使用MultiPartFile接口接收上传的图片

    6)将文件名保存到数据库,将图片保存到磁盘中
</code></pre><hr>
<pre><code>4.JSON数据交互

    1.首先在pom.xml中配置好需要的jar包(jackson的jar包)

    2.@Requestbody:将页面传到controller中的json格式字符串自动转换成java的pojo对象
      @ResponseBody:将java中pojo对象自动转换成json格式字符串返回给页面
</code></pre><hr>
<pre><code>5.RestFul风格支持

    此风格就是对URL的命名标准，此标准要求URL中只能有名词，要求URL中不能用?传参

    传参数：
        页面：${pageContext.request.contextPath}/items/itemEdit/${item.id}
        方法：@RequestMapping(&quot;/itemEdit/{id}&quot;)
        方法：@PathVariable(&quot;id&quot;) Integer id
</code></pre><hr>
<pre><code>6.拦截器

    作用：拦截请求，一般在登录的时候用得比较多
    1.需要编写自定义拦截器类,实现HandlerInterceptor接口
        public class AuthorizedInterceptor implements HandlerInterceptor {//......
    2.在spirngMvc.xml中配置拦截器生效
</code></pre><hr>
<pre><code>7.登录权限验证

    1)编写登录的Controller，编写跳转到登录页面，编写登录验证方法
    2)编写登录页面
    3)编写拦截器
</code></pre><blockquote>
<p>总结：随意访问一个页面，拦截器会拦截请求，会验证session是否有登录信息。如果已经登录，放。如果未登录，跳转到登录页面<br>          在登录页面输入用户名、密码，点击登录按钮，拦截器会拦截请求，如果登录路径在Controller方法中判断用户名和密码正确则将登录信息方法session中。</p>
</blockquote>
<hr>
<p>更新时间：2018/09/22</p>
<h2 id="Mybatis-项目开发经验"><a href="#Mybatis-项目开发经验" class="headerlink" title="Mybatis - 项目开发经验"></a>Mybatis - 项目开发经验</h2><h4 id="1-mybatis中selectkey的作用"><a href="#1-mybatis中selectkey的作用" class="headerlink" title="1.mybatis中selectkey的作用"></a>1.mybatis中selectkey的作用</h4><blockquote>
<blockquote>
<p><code>selectkey</code>在mybatis中是为了解决<code>insert</code>数据时不支持主键自动生成的问题，<code>selectkey</code>可以很随意的设置生成主键的方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在<code>selectkey</code>中的属性有：<br><code>1.keyProperty</code>：selectkey语句结果应该被设置的目标属性,指定存放生成主键的属性<br><code>2.resultType</code>：结果的类型，mybatis允许任何简单的类型用作主键的类型,包括字符串。<br>3.<code>order</code>：可以被设置为 <code>BEFORE</code> 或 <code>AFTER</code>。如果设置为 <code>BEFORE</code>,那么它会首先选择主键,设置 <code>keyProperty</code> 然后执行插入语句。如果设置为 <code>AFTER</code>,那么先执行插入语句,然后是 <code>selectKey</code> 元素-这和，如 Oracle 数据库相似,可以在插入语句中嵌入序列调用。所以<code>order</code>指定了查询主键的sql与insert的执行顺序，只要不是自增主键，<code>order</code>都设置为<code>before</code>。<br>4.<code>statementType</code>：MyBatis 支持 <code>STATEMENT PREPARED</code>和<code>CALLABLE</code> 语句的映射类型,分别代表 <code>reparedStatement</code> 和<code>CallableStatement</code> 类型。<br>4.<code>last_insert_id</code>：mysql的函数，配合insert语句一起使用。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：selectkey需要注意order属性，比如在mysql一类的自动增长类型的数据库中，order需要设置为after才能够取得正确的值。</p>
</blockquote>
<hr>
<h2 id="Mybatis-案例"><a href="#Mybatis-案例" class="headerlink" title="Mybatis - 案例"></a>Mybatis - 案例</h2><pre><code>package cn.edu.xidian.tjxt.dao;

import cn.edu.xidian.tjxt.vo.BodyCheckInfoVo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Logger;

@Repository
public class BodyCheckInfoDao {
    public static final Logger LOG = Logger.getLogger(String.valueOf(BodyCheckInfoDao.class));
    private JdbcTemplate jdbcTemplate;
    @Autowired
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate = jdbcTemplate;
    }
    //查看列是否存在函数
//    public boolean isColumnExist(ResultSet rs, String columnName) {
//        try {
//            if (rs.findColumn(columnName) &gt; 0 ) {
//                return true;
//            }
//        }
//        catch (SQLException e) {
//            return false;
//        }
//        return false;
//    }

    /**
     * 方法：bodyCheckInfoResultMap
     * 作用：数据库信息返回，controller中调用
     */
    public void bodyCheckInfoResultMap(ResultSet resultSet, BodyCheckInfoVo bodyCheckInfoVo) throws SQLException{
        bodyCheckInfoVo.setStudentId(resultSet.getInt(&quot;id&quot;));
        bodyCheckInfoVo.setName(resultSet.getString(&quot;name&quot;));
        bodyCheckInfoVo.setSex(resultSet.getString(&quot;sex&quot;));
        bodyCheckInfoVo.setStudentNum(resultSet.getString(&quot;student_num&quot;));//学生学号
        bodyCheckInfoVo.setIdNum(resultSet.getString(&quot;id_num&quot;));//学生身份证号
        bodyCheckInfoVo.setCheckTime(resultSet.getDate(&quot;check_time&quot;));//体检时间

//        bodyCheckInfoVo.setTuberculosis(resultSet.getString(&quot;tuberculosis&quot;));//肺结核检查结果，因为数据库中肺结核一栏为null值
        bodyCheckInfoVo.setListSubmit(resultSet.getInt(&quot;list_submit&quot;));//是否提交体检表单

        bodyCheckInfoVo.setPpdCheck(resultSet.getString(&quot;ppd_check&quot;));//ppd检查结果
        bodyCheckInfoVo.setKidney(resultSet.getString(&quot;kidney&quot;));//肾功检查结果
        bodyCheckInfoVo.setLiverFunction(resultSet.getString(&quot;liver_function&quot;));//肝功检查结果
        bodyCheckInfoVo.setBodyCheck(resultSet.getString(&quot;body_check&quot;));//体检结果

        bodyCheckInfoVo.setHepatitisBCheck(resultSet.getString(&quot;hepatitis_b_check&quot;));//乙肝检查结果
        bodyCheckInfoVo.setHemorrhagic1(resultSet.getString(&quot;hemorrhagic1&quot;));//出血热一
        bodyCheckInfoVo.setHemorrhagic2(resultSet.getString(&quot;hemorrhagic2&quot;));//出血热二
        bodyCheckInfoVo.setHemorrhagic3(resultSet.getString(&quot;hemorrhagic3&quot;));//出血热三

        bodyCheckInfoVo.setMeasles(resultSet.getString(&quot;measles&quot;));//麻腮风检查结果
        bodyCheckInfoVo.setHepatitisB1(resultSet.getString(&quot;hepatitis_b1&quot;));//乙肝一检查结果
        bodyCheckInfoVo.setHepatitisB2(resultSet.getString(&quot;hepatitis_b2&quot;));//乙肝二检查结果
        bodyCheckInfoVo.setHepatitisB3(resultSet.getString(&quot;hepatitis_b3&quot;));//乙肝三检查结果
        bodyCheckInfoVo.setHepatitisA1(resultSet.getString(&quot;hepatitis_a1&quot;));//甲肝一检查结果
        bodyCheckInfoVo.setHepatitisA2(resultSet.getString(&quot;hepatitis_a2&quot;));//甲肝二检查结果

    }

    //sql语句通过姓名、学号以及身份证号三者联合查询
    private static final String FIND_BODY_CHECK_INFOS = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE student_num = ? AND name = ? AND id_num LIKE ? &quot;;

    //sql语句
    private static final String FIND_BODY_CHECK_INFO_BY_ID_NUM_SQL = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE id_num LIKE ?&quot;;
    private static final String FIND_BODY_CHECK_INFO_BY_STUDENT_NUM =  &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE student_num = ? &quot;;
    private static final String FIND_BODY_CHECK_INFO_BY_NOTICE_NUM = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE notice_num = ? &quot;;
    private static final String FIND_BODY_CHECK_INFO_BY_NAME = &quot;SELECT *,examination_record.id AS eid FROM student LEFT JOIN examination_record ON student.id = examination_record.sid &quot;
            + &quot; WHERE name = ?&quot;;

    //通过三个变量联合查询，得到的结果认为只有一个
    public BodyCheckInfoVo findBodyCheckInfos(String studentNum,String name,String idNum){
        if (studentNum == null || studentNum.equals(&quot;&quot;)) return null;
        if (name == null || name.equals(&quot;&quot;)) return null;
        if (idNum == null || idNum.equals(&quot;&quot;)) return null;
        if (idNum.length() != 6) return null;
        final BodyCheckInfoVo bodyCheckInfoVos = new BodyCheckInfoVo();
        jdbcTemplate.query(FIND_BODY_CHECK_INFOS, new Object[]{studentNum,name,&quot;%&quot;+idNum},
                new RowCallbackHandler() {
                    @Override
                    public void processRow(ResultSet resultSet) throws SQLException {
                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVos);
                    }
                });
        if(bodyCheckInfoVos.getStudentId() == null) return null;
        return bodyCheckInfoVos;
    }

    //通过身份证号码查询，可能有多条信息，所以用返回List
//    public List&lt;BodyCheckInfoVo&gt; findBodyCheckInfoVoByIdNum(String idNum) {
//        if (idNum.length() != 6) return null;
//        if (idNum == null || idNum.equals(&quot;&quot;)) return null;
//            return jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_ID_NUM_SQL, new Object[]{&quot;%&quot; + idNum}, new RowMapper&lt;BodyCheckInfoVo&gt;() {
//                public BodyCheckInfoVo mapRow(ResultSet resultSet, int i) throws SQLException {
//                    BodyCheckInfoVo bodyCheckInfoVo = new BodyCheckInfoVo();
//                    bodyCheckInfoResultMap(resultSet, bodyCheckInfoVo);
//                    return bodyCheckInfoVo;
//                }
//            });
//    }

    //通过学号查询，可能有多条信息(留级保留学号的情况)，所以用返回List
//    public List&lt;BodyCheckInfoVo&gt; findBodyCheckInfoVoByStudentNum(String studentNum) {
//        if(studentNum == null || studentNum.equals(&quot;&quot;)) return null;
//        return jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_STUDENT_NUM, new Object[]{studentNum},
//                new RowMapper&lt;BodyCheckInfoVo&gt;() {
//                    public BodyCheckInfoVo mapRow(ResultSet resultSet,int i) throws SQLException {
//                        BodyCheckInfoVo bodyCheckInfoVo = new BodyCheckInfoVo();
//                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVo);
//                        return  bodyCheckInfoVo;
//                    }
//                });
//    }

    //通过通知书号码查询，认为只有一个
//    public BodyCheckInfoVo findBodyCheckInfoVoByNoticeNum(String noticeNum) {
//        if(noticeNum == null || noticeNum.equals(&quot;&quot;)) return null;
//        final BodyCheckInfoVo bodyCheckInfoVo= new BodyCheckInfoVo();
//        jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_NOTICE_NUM, new Object[]{noticeNum},
//                new RowCallbackHandler() {
//                    @Override
//                    public void processRow(ResultSet resultSet) throws SQLException {
//                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVo);
//                    }
//                });
//        if(bodyCheckInfoVo.getStudentId() == null) return null;
//        return bodyCheckInfoVo;
//    }

    //新增查询方式
    //通过学生姓名查询学生体检信息,因为可能有重名的情况，所以返回用List
//    public List&lt;BodyCheckInfoVo&gt; findBodyCheckInfoVoByName(String name) {
//        if(name == null || name.equals(&quot;&quot;)) return null;
//        return jdbcTemplate.query(FIND_BODY_CHECK_INFO_BY_NAME, new Object[]{name},
//                new RowMapper&lt;BodyCheckInfoVo&gt;() {
//                    public BodyCheckInfoVo mapRow(ResultSet resultSet,int i) throws SQLException{
//                        BodyCheckInfoVo bodyCheckInfoVo = new BodyCheckInfoVo();
//                        bodyCheckInfoResultMap(resultSet,bodyCheckInfoVo);
//                        return  bodyCheckInfoVo;
//                    }
//                });
//    }
}
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Nginx/" itemprop="url">Nginx</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:28:17+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index">
                    <span itemprop="name">Nginx</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  29
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1.正向代理</p>
<p>如果将局域网外的Internet想象成一个巨大的资源库，则局域网内的客户端要访问Internet需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<p>2.反向代理</p>
<p>客户端对代理无感知，因为客户端不需要任何配置都可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的代理服务器地址，隐藏了真是服务器IP地址。</p>
<p>3.负载均衡</p>
<p>反向代理服务器将客户端请求平均分担到各个服务器中。</p>
<p>4.动静分离</p>
<p>这里为了加快网站的解析速度，可以将动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
<p>在服务器Tomcat中部署动态资源，然后在专门的静态资源服务器中部署静态资源。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="1-安装编译工具和库文件"><a href="#1-安装编译工具和库文件" class="headerlink" title="1. 安装编译工具和库文件"></a>1. 安装编译工具和库文件</h4><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel
</code></pre><h4 id="2-安装PCRE"><a href="#2-安装PCRE" class="headerlink" title="2. 安装PCRE"></a>2. 安装PCRE</h4><p>pcre作用让Nginx支持rewrite功能。</p>
<pre><code>1. wget http://...
2. 解压目录 tar -zxvf pcre...
3. 进入安装包
4. 编译安装 ./configure make &amp;&amp; make install
5. 查看pcre版本
</code></pre><h4 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3. 安装Nginx"></a>3. 安装Nginx</h4><pre><code>1. 获取资源 wget http://....
2. 解压目录 tar -zxvf nginx..
3. 进入安装目录
4. 编译安装 
    ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35 make &amp;&amp; make install
5. 查看版本号
    /usr/local/webserver/nginx/sbin/nginx -v
</code></pre><h4 id="4-Nginx配置"><a href="#4-Nginx配置" class="headerlink" title="4. Nginx配置"></a>4. Nginx配置</h4><pre><code>1. 创建Nginx运行使用的用户www

    /usr/sbin/groupadd www 

    /usr/sbin/useradd -g www www

2. 配置ngin.conf

3. 检查配置是否正确

    /usr/local/webserver/nginx/sbin/nginx -t

4. 启动Nginx

    /usr/local/webserver/nginx/sbin/nginx
</code></pre><blockquote>
<p>提示：在上面所有的配置文件配置完成之后，如果在浏览器中访问不了网页，可能是因为Linux的防火墙开着，关闭防火墙便能够访问。在关闭防火墙之后还需要开放端口号才能够访问。</p>
</blockquote>
<pre><code>centos7防火墙：

    开启：systemctl start firewalld.service
    关闭：systemctl stop firewalld.service
    重启：systemctl restart firewalld.service

    systemctl status firewalld 查看firewalld状态

    firewall-cmd --zone=public --add-port=8080/tcp --permanent 开启端口号

    sudo firewall-cmd --add-port=8001/tcp --permanent 设置端口号8001

    sudo firewall-cmd --add-port=8080/tcp --permanent 设置端口号8080

    firewall-cmd --reload 重启防火墙

    firewall-cmd --list-all 查看防火墙列表

    ...
</code></pre><h4 id="5-Nginx常用命令"><a href="#5-Nginx常用命令" class="headerlink" title="5. Nginx常用命令"></a>5. Nginx常用命令</h4><blockquote>
<p>提示：在我们使用Nginx操作命令前提条件是我们必须进入Nginx的目录。</p>
</blockquote>
<pre><code>1. 查看Nginx版本号

    在/sbin/目录下使用 ./nginx -v 命令

2. 启动Nginx

    ./nginx

3. 关闭Nginx  

    ./nginx -s stop

4. 重新加载Nginx

    ./nginx -s reload
</code></pre><blockquote>
<p>提示：命令 ps -ef | grep nginx 查看Nginx进程。</p>
</blockquote>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="1-全局块"><a href="#1-全局块" class="headerlink" title="1. 全局块"></a>1. 全局块</h4><p>配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</p>
<p>从配置文件开始到events之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令。</p>
<h4 id="2-events块"><a href="#2-events块" class="headerlink" title="2. events块"></a>2. events块</h4><p>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</p>
<p>在该块中的配置指令主要影响Nginx服务器与用户的网络连接。</p>
<h4 id="3-HTTP块"><a href="#3-HTTP块" class="headerlink" title="3. HTTP块"></a>3. HTTP块</h4><p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p>
<p>该部分是Nginx中配置最为频繁的部分，代理、缓存和日志定义等绝大多数的功能和第三方的模块配置都在这里。</p>
<blockquote>
<p>注意：http块也可以包括http全局块、server块。</p>
</blockquote>
<h5 id="3-1-http全局块"><a href="#3-1-http全局块" class="headerlink" title="3.1 http全局块"></a>3.1 http全局块</h5><p>在http全局配置的指令包括文件引入、mime-type定义、日志自定义、连接超时时间、单链接请求数量上限等。</p>
<h5 id="3-2-server块"><a href="#3-2-server块" class="headerlink" title="3.2 server块"></a>3.2 server块</h5><p>配置虚拟主机的相关参数，一个http中可以有多个server。每个server块就相当于一个虚拟主机。</p>
<p>该块和虚拟主机有密切关系，虚拟主机从用户角度看和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p>
<p>每个server又可以分为全局server块以及可以同时包括多个location块。</p>
<ol>
<li>全局server块</li>
</ol>
<p>最常见的配置是本虚拟主机的监听配置和本虚拟主机的名称和IP配置。</p>
<ol start="2">
<li>location块</li>
</ol>
<p>一个server块可以配置多个location块，该块的主要作用是基于Nginx服务器接收到请求字符串，对虚拟主机名称（IP别名）之外的字符串进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，或其它第三方模块的配置。</p>
<h5 id="配置请求的路由，以及各种页面的处理情况"><a href="#配置请求的路由，以及各种页面的处理情况" class="headerlink" title="配置请求的路由，以及各种页面的处理情况"></a>配置请求的路由，以及各种页面的处理情况</h5><pre><code>########### 每个指令必须有分号结束。#################
#user administrator administrators;  #配置用户或者组，默认为nobody nobody。
#worker_processes 2;  #允许生成的进程数，默认为1
#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址
error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
events {
    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    worker_connections  1024;    #最大连接数，默认为512
}
http {
    include       mime.types;   #文件扩展名与文件类型映射表
    default_type  application/octet-stream; #默认文件类型，默认为text/plain
    #access_log off; #取消服务日志    
    log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; #自定义格式
    access_log log/access.log myFormat;  #combined为日志格式的默认值
    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。

    upstream mysvr {   
      server 127.0.0.1:7878;
      server 192.168.10.121:3333 backup;  #热备
    }

    error_page 404 https://www.baidu.com; #错误页

    server {
        keepalive_requests 120; #单连接请求上限次数。
        listen       4545;   #监听端口
        server_name  127.0.0.1;   #监听地址       
        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
           #root path;  #根目录
           #index vv.txt;  #设置默认页
           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表
           deny 127.0.0.1;  #拒绝的ip
           allow 172.18.5.54; #允许的ip           
        } 
    }
}

上面是nginx的基本配置，需要注意的有以下几点：

1、几个常见配置项：

 1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；
 2.$remote_user ：用来记录客户端用户名称；
 3.$time_local ： 用来记录访问时间与时区；
 4.$request ： 用来记录请求的url与http协议；
 5.$status ： 用来记录请求状态；成功是200；
 6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；
 7.$http_referer ：用来记录从那个页面链接访问过来的；
 8.$http_user_agent ：记录客户端浏览器的相关信息；

2、惊群现象：一个网路连接到来，多个睡眠的进程被同事叫醒，但只有一个进程能获得链接，这样会影响系统性能。
3、每个指令必须有分号结束。
</code></pre><h3 id="第2章-Nginx反向代理配置"><a href="#第2章-Nginx反向代理配置" class="headerlink" title="第2章 Nginx反向代理配置"></a>第2章 Nginx反向代理配置</h3><pre><code>1. 在Windows系统的hosts文件中进行域名和IP对应关系的配置。

2. 在Nginx中进行请求转发的配置（反向代理配置）

3. 访问网站
</code></pre><h4 id="2-1-Nginx实现反向代理"><a href="#2-1-Nginx实现反向代理" class="headerlink" title="2.1 Nginx实现反向代理"></a>2.1 Nginx实现反向代理</h4><ol>
<li>效果</li>
</ol>
<p>在使用Nginx反向代理，根据访问的路径不同跳转到不同的端口的服务中。</p>
<pre><code>1. Nginx的监听端口为 9001。

2. 访问http://localhost:9001/edu/ 跳转到localhost:8008/
3. 访问http://localhost:9001/vod/ 跳转到localhost:8089/
</code></pre><ol start="2">
<li><p>准备工作</p>
<ol>
<li><p>准备两个Tomcat服务器，一个8080端口，一个8081端口。</p>
<p> 提示：如果这里配置了两个tomcat但只有一个能访问，并且配置文件server.xml文件中三个端口号没有冲突的情况下，那么可能是配置的端口号没有开放对外访问。此时应该设置设置防火墙的开放端口号。</p>
</li>
<li><p>创建文件夹以及测试文件放到tomcat的目录下。</p>
<p> 在tomcat目录的webapps目录下创建将要访问的文件和文件夹。</p>
</li>
</ol>
</li>
<li><p>具体配置</p>
<ol>
<li><p>找到Nginx的配置文件，然后在里面做反向代理配置</p>
<p> server {</p>
<pre><code>listen       9001;
server_name  192.168.8.122;

location ~ /edu/ {
    proxy_pass: http://127.0.0.1:8080;
}

location ~ /vod/ {
    proxy_pass: http://127.0.0.1:8089;
}
</code></pre><p> }</p>
</li>
<li><p>开放对外访问的端口号</p>
<ol>
<li><p>查看已经开放端口号</p>
</li>
<li><p>增加开放端口号</p>
</li>
<li><p>测试增加开放端口号是否能访问</p>
<p>提示：如果有些时候在配置好之后还是无法访问，可以重启一下tomcat，可能是之前的配置没有生效，重启之后让之前的配置生效。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>配置nginx.conf配置文件的反向代理设置之后，重启Nginx</p>
</li>
</ol>
<h4 id="2-2-Nginx实现负载均衡"><a href="#2-2-Nginx实现负载均衡" class="headerlink" title="2.2 Nginx实现负载均衡"></a>2.2 Nginx实现负载均衡</h4><ol>
<li>实现效果</li>
</ol>
<p>浏览器输入地址<a href="http://192.168.8.122/edu/a.html。负载均衡效果，平均分配到8080和8089端口中去。" target="_blank" rel="noopener">http://192.168.8.122/edu/a.html。负载均衡效果，平均分配到8080和8089端口中去。</a></p>
<ol start="2">
<li><p>准备工作</p>
<ol>
<li><p>准备两台tomcat服务器，一台8080，一台8089。</p>
</li>
<li><p>在两台tomcat里面webapps目录下创建名称为edu的文件夹，在edu文件夹下创建页面a.html，用于测试。</p>
</li>
</ol>
</li>
<li><p>在Nginx的配置文件中进行负载均衡的配置</p>
</li>
</ol>
<h4 id="2-3-Nginx实现动静分离"><a href="#2-3-Nginx实现动静分离" class="headerlink" title="2.3 Nginx实现动静分离"></a>2.3 Nginx实现动静分离</h4><ol>
<li><p>准备工作</p>
<ol>
<li><p>在Linux中准备静态资源</p>
</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="2-4-Nginx高可用集群"><a href="#2-4-Nginx高可用集群" class="headerlink" title="2.4 Nginx高可用集群"></a>2.4 Nginx高可用集群</h4><ol>
<li><p>在Linux中配置两个ip</p>
<ol>
<li><p>在/etc/sysconfig/network-scripts/目录下修改ifcfg-ens2文件</p>
<p> IPADDR1=…//加入新的ip</p>
</li>
<li><p>重启更新网络服务</p>
<p> systemctl restart network</p>
</li>
<li><p>查看是否配置成功</p>
<p> ip addr </p>
<p> 提示：这里使用ipconfig命令查看不了新配置的IP。</p>
</li>
</ol>
</li>
</ol>
<p>高可用，在Nginx宕机的情况下，整个服务还能够正常运行。</p>
<pre><code>1. 在这里配置的时候需要两台Nginx服务器

2. 需要keepalived

3. 需要虚拟IP
</code></pre><ol>
<li><p>准备工作</p>
<ol>
<li><p>需要两个服务器</p>
</li>
<li><p>在两台服务器上安装Nginx</p>
</li>
<li><p>在两台服务器上安装keepalived</p>
<ol>
<li><p>在两台服务器上使用命令 yum 进行安装</p>
<p> yum install keepalived -y</p>
</li>
<li><p>在安装完成之后，在etc目录里面生成目录keepalived，有文件keepalived.conf</p>
</li>
</ol>
</li>
<li><p>完成高可用配置（主从配置）</p>
<ol>
<li><p>修改/etc/keepalived/keepalived.conf配置文件</p>
</li>
<li><p>在/usr/local/src添加检测脚本</p>
</li>
<li><p>启动两台服务器上的Nginx和keepalived</p>
<ol>
<li><p>启动Nginx ./nginx</p>
</li>
<li><p>启动keepalived systemctl start keepalived.service</p>
</li>
</ol>
</li>
<li><p>测试</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Nginx的原理"><a href="#Nginx的原理" class="headerlink" title="Nginx的原理"></a>Nginx的原理</h3><h4 id="多个worker和一个master机制的优势"><a href="#多个worker和一个master机制的优势" class="headerlink" title="多个worker和一个master机制的优势"></a>多个worker和一个master机制的优势</h4><ol>
<li><p>可以使用 nginx -s reload 命令进行热部署操作</p>
</li>
<li><p>对于每个worker进程来说，独立的进程不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，会方便很多。然后独立进程，进程之间不会相互影响，一个进程结束之后，其它进程还在工作，服务不会中断。</p>
</li>
<li><p>合适数量的worker的数量设置，Nginx与Redis类似，都采用了IO多路复用机制，每个worker都是一个独立的进程，每个进程只有一个主线程，通过异步非阻塞的方式处理请求。所以worker的数量和服务器CPU核心数相等最好。</p>
</li>
</ol>
<h4 id="连接数-worker-connection"><a href="#连接数-worker-connection" class="headerlink" title="连接数 worker_connection"></a>连接数 worker_connection</h4><pre><code>1. 发送请求占用了worker的几个连接数（2或者4个）

2. Nginx有1个master和4个worker，每个worker支持最大的连接数为1024，支持最大的并发数是多少?

    普通的静态访问最大并发数是：

        worker_connections * worker_process / 2

    如果是HTTP作为反向代理来说，支持最大并发数量是：

        worker_connections * worker_process / 4
</code></pre><h3 id="第3章-Nginx的基本配置和优化"><a href="#第3章-Nginx的基本配置和优化" class="headerlink" title="第3章 Nginx的基本配置和优化"></a>第3章 Nginx的基本配置和优化</h3><h4 id="3-2-Nginx的虚拟主机配置"><a href="#3-2-Nginx的虚拟主机配置" class="headerlink" title="3.2 Nginx的虚拟主机配置"></a>3.2 Nginx的虚拟主机配置</h4><p>虚拟主机，将服务器上的主机分成一台台“虚拟”主机，每台虚拟主机都可以是一台独立的网站，同一台服务器的虚拟主机之间是独立的。</p>
<blockquote>
<p>提示：Nginx可以配置多种类型的虚拟主机。1.基于IP的虚拟主机。2.基于域名的虚拟主机。3.基于端口的虚拟主机。</p>
</blockquote>
<h5 id="3-2-1-基于IP的虚拟主机"><a href="#3-2-1-基于IP的虚拟主机" class="headerlink" title="3.2.1 基于IP的虚拟主机"></a>3.2.1 基于IP的虚拟主机</h5><pre><code>http
{
    #第一个虚拟主机
    server
    {
        listen  ...:..;
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    #第一个虚拟主机
    server
    {
        listen  ...:..;
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    ...

}
</code></pre><blockquote>
<p>提示：从上面配置文件我们可以得到一段server{}文件表示一个虚拟主机。如果需要配置多段虚拟主机，那么配置多段server{}即可。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：如果需要在eth0网卡设备上添加两个IP别名 192.168.8.122 | 192.168.2.132 可以通过 ifconfig | route 命令操作。</p>
</blockquote>
</blockquote>
<h5 id="3-2-2-配置基于域名的虚拟主机"><a href="#3-2-2-配置基于域名的虚拟主机" class="headerlink" title="3.2.2 配置基于域名的虚拟主机"></a>3.2.2 配置基于域名的虚拟主机</h5><p>基于域名的虚拟主机配置最常见的虚拟主机配置，只需要配置DNS服务器，然后将主机名映射到正确的IP地址，然后配置Nginx服务器，令其识别不同的主机名便可。</p>
<pre><code>http
{
    #第一个虚拟主机
    server
    {
        #监听的端口
        listen  80;
        #主机名字
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件，顺序从左到右
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    #第一个虚拟主机
    server
    {
        listen  ...:..;
        server_name  ...;
        access_log logs/...;
        location /
        {
            #默认首页文件
            index index.html index.htm;

            #html文件存放的目录
            root /data/htdocs/..;

        }
    }

    ...

}
</code></pre><h4 id="3-3-Nginx日志文件配置与切割"><a href="#3-3-Nginx日志文件配置与切割" class="headerlink" title="3.3 Nginx日志文件配置与切割"></a>3.3 Nginx日志文件配置与切割</h4><p>在虚拟主机开始的配置文件中配置的时候，就已经使用了access_log进行了日志记录。这里再说Nginx日志记录，与日志记录的指令包括：log_format用来设置日志的格式。access_log用来设置日志文件的存放路径、格式和缓存大小。</p>
<p>日志文件的切割最常见的就是按照天数切割。具体配置。</p>
<h4 id="3-4-Nginx的压缩输出配置"><a href="#3-4-Nginx的压缩输出配置" class="headerlink" title="3.4 Nginx的压缩输出配置"></a>3.4 Nginx的压缩输出配置</h4><p>经过gzip压缩之后页面大小可以变为原来的0.3左右，这样浏览器访问速度将会更快。</p>
<h4 id="3-5-Nginx的自动列目录配置"><a href="#3-5-Nginx的自动列目录配置" class="headerlink" title="3.5 Nginx的自动列目录配置"></a>3.5 Nginx的自动列目录配置</h4><pre><code>location / {
    autoindex on;
}
</code></pre><h4 id="3-6-Nginx浏览器本地缓存设置"><a href="#3-6-Nginx浏览器本地缓存设置" class="headerlink" title="3.6 Nginx浏览器本地缓存设置"></a>3.6 Nginx浏览器本地缓存设置</h4><p>浏览器缓存可以通过 expires 指令输出 header 头来实现。</p>
<pre><code>expires [time|epoch|off]
</code></pre><hr>
<h3 id="第6章-Nginx-HTTP负载均衡和反向代理的配置与优化"><a href="#第6章-Nginx-HTTP负载均衡和反向代理的配置与优化" class="headerlink" title="第6章 Nginx HTTP负载均衡和反向代理的配置与优化"></a>第6章 Nginx HTTP负载均衡和反向代理的配置与优化</h3><p>负载均衡，多台服务器之间协同工作，提高计算机系统处理能力和计算强度，满足当前业务需求。在多个设备之间实现合理业务分配的方法。是多个服务器之间组成一个服务器集合，每台服务器都具有等价的地位，都可以单独的对外提供服务而无需其它服务的辅助。</p>
<p>反向代理，以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络的服务器，将从服务器上得到的结果返回给Internet上请求的客户端。</p>
<h4 id="6-1-Nginx代理服务设置"><a href="#6-1-Nginx代理服务设置" class="headerlink" title="6.1 Nginx代理服务设置"></a>6.1 Nginx代理服务设置</h4><pre><code>1. 设置404页面导向地址

    error_page 404 https://...;#错误页
    proxy_intercept_errors on; #如果被代理服务器返回的状态码为400或大于400，设置的error_page配置起作用，默认为off

2. 如果我们的代理只允许接受get、post请求方法一种

    proxy_method get; #支持客户端的请求方法 post/get

3. 设置支持的HTTP协议版本

    proxy_http_version 1.0; #Nginx服务器提供代理服务的HTTP协议版本

4. 解决负载均衡采用轮询方式时，有一台服务器挂掉导致客户端一直等待的问题。

    proxy_connect_timeout 1;  #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
    proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。
    proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。
    proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。

5. 如果upstream指令配置了一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺序交由下一组服务器处理

    proxy_next_upstream timeout; #反向代理upstream中设置的服务器组出现故障时，被代理服务器返回的状态值。


6. 如果需要通过HTTP获取用户的真实ip而非代理ip作设置

    proxy_set_header Host $host; #
    proxy_set_header X-Real-IP $remote_addr; #将源ip赋值给x-real-ip，这样可以在程序中$X-Real-IP来获取源ip
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #在Nginx作为代理服务器时，设置的ip列表会将经过的机器ip代理机器ip都记录下来
</code></pre><h4 id="6-2-Web负载均衡方法"><a href="#6-2-Web负载均衡方法" class="headerlink" title="6.2 Web负载均衡方法"></a>6.2 Web负载均衡方法</h4><pre><code>1. 手动选择方式

    如我们在网页上下载的时候让我们选择电信1、电信2、连通1、连通2等方式

2. DNS轮询方式

    很多域名注册商都对同一主机名添加多条A记录，这就是DNS轮询，DNS将解析请求按照A记录的顺序随机分配到不同的IP上，从而完成了负载均衡。

    缺点：

        1.可靠性低


        2.负载分配不均衡

            DNS负载均衡采用的是简单的轮询负载方法，不能区分服务器的差异，不能反映服务器当前的情况。

3. 四/七层负载均衡

    1. 四层负载均衡：基于IP+端口的负载均衡，通过虚拟IP+端口接收请求，然后再分配到真实的服务器

        主要通过报文中的目标地址和端口，再加上负载均衡设置的服务器选择方式，决定最终的内部服务器。

    2. 七层负载均衡：基于URL等应用层信息的负载均衡，通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器

        或称为内容交换，主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

    3. 二层负载均衡：基于MAC地址，通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址。

    4. 三层负载均衡：基于IP地址，通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址。

    5. 四到七层负载均衡：表示在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。

         1. 负载均衡器通常称为四层交换机或七层交换机

            1. 四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。

            2. 七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。
</code></pre><h5 id="6-2-1-Nginx负载均衡详解"><a href="#6-2-1-Nginx负载均衡详解" class="headerlink" title="6.2.1 Nginx负载均衡详解"></a>6.2.1 Nginx负载均衡详解</h5><p>Upstream配置是写一组被代理的服务器地址，然后配置负载均衡的算法，这里被代理的服务器地址有两种写法：</p>
<pre><code>1. 
    upstream mysvr {
        server 192.168.1.12:2050;
        server 192.168.1.8:1204;
    }
    server {
        ...
        location ~*^.+$ {
            proxy_pass http://mysvr; #请求转向mysvr定义的服务器列表
        }
    }

    1. 热备：当一台服务器发生事故时，才启用第二台服务器提供服务。

        upstream mysvr {
            server 127.0.0.1:5252;
            server 192.168.10.125:5524 backup; #热备
        }

    2. 轮询：Nginx默认就是轮询其权重都默认为1，服务器处理在多个之间转换，如果后端服务器down掉，能自动剔除

        upstream mysvr {
            server 127.0.0.1:2525;
            server 192.168.25.25:1245;
        }

    3. 加权轮询：根据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置则默认是1。权重越大分配到的访问越多。

        upstream mysvr {
            server 127.0.0.1:2525 weight=1;
            server 192.168.52.2 weight=2;
        }

    4. ip_hash：Nginx会让相同的客户端ip请求相同的服务器（每个访客固定访问一个后端服务器）。

        upstream mysvr {
            server 127.0.0.1:1245
            server 192.168.12.145:1246
            ip_hash;
        }

    5. Nginx负载均衡配置状态参数

        1. down 表示当前的server暂时不参与负载均衡

        2. backup 预留的备份机器

        3. max_fails 允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream模块定义的错误

        4. fail_timeout 在经理max_fails次失败之后，暂停服务的时间

            upstream mysvr { 
                server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;
                server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    
            }

        5. fair 按照服务器的响应时间来分配请求，响应时间短的优先分配
</code></pre><h4 id="6-3-Nginx负载均衡与反向代理"><a href="#6-3-Nginx负载均衡与反向代理" class="headerlink" title="6.3 Nginx负载均衡与反向代理"></a>6.3 Nginx负载均衡与反向代理</h4><p>upstream指令用于设置一组可以在 proxy_pass 和 fastcgi_pass 指令中使用的代理服务器，默认的负载均衡方式为轮询。upstream模块中的server指令用于指定后端服务器的名称和参数，名称可以是ip、域名、端口号后socket。</p>
<p>在server{…}虚拟主机内，通过 proxy_pass 和 fastcgi_pass 指令设置进行反向代理的 upstream 服务器集群。</p>
<pre><code>proxy_set_header指令用于在反向代理的后端web服务器发起请求时添加指定的header头信息。

在后端web服务器有多个 基于域名的虚拟主机 时，要通过添加Header头信息Host，用于指定请求的域名，这样后端web服务器才能识别该反向代理访问请求由哪一个虚拟主机来处理。

在使用反向代理之后，后端web服务器不能通过 $_SERVER[&quot;REMOTE_ADDR&quot;] 变量来获取用户的真是ip，获取到的将是Nginx负载均衡服务器的ip。需要添加Nginx反向代理时的头信息 X-Forwarded-For得到真实的ip。
</code></pre><h5 id="6-3-2-Nginx负载均衡与反向代理实现动、静态网页分离"><a href="#6-3-2-Nginx负载均衡与反向代理实现动、静态网页分离" class="headerlink" title="6.3.2 Nginx负载均衡与反向代理实现动、静态网页分离"></a>6.3.2 Nginx负载均衡与反向代理实现动、静态网页分离</h5><p>动、静态分离就是让动态Java等程序网页去访问JavaWeb服务器，让缓存页、图片、JavaScript、CSS、Flash去访问squid等缓存服务器。</p>
<p>通过location指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使得浏览器缓存过期时间，减少与服务器之前的请求和流量。具体的expires定义：给一个资源设置一个过期时间，也就是无需去服务器验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。</p>
<h4 id="6-4-Nginx负载均衡的HTTP-upstream模块"><a href="#6-4-Nginx负载均衡的HTTP-upstream模块" class="headerlink" title="6.4 Nginx负载均衡的HTTP upstream模块"></a>6.4 Nginx负载均衡的HTTP upstream模块</h4><p>upstream提供一个简单方法来实现轮询和客户端ip之间的后端服务器负载均衡，并可以对后端服务器进行健康检查。</p>
<h5 id="6-4-1-ip-hash指令"><a href="#6-4-1-ip-hash指令" class="headerlink" title="6.4.1 ip_hash指令"></a>6.4.1 ip_hash指令</h5><p>ip_hash指令能够将客户端ip的请求通过哈希算法定位到同一个后端服务器，也就是说当再访问此ip下的其它URL时，还是会定位到该服务器上。</p>
<p>ip_hash指定无法保证后端服务器的负载均衡。</p>
<p>如果后端服务器有时需要从Nginx负载均衡（已使用ip_hash）中摘除一段时间，需要标记其为down，而不是直接从配置文件中删掉或注释掉该后端服务器的信息。</p>
<h5 id="6-4-2-server指令"><a href="#6-4-2-server指令" class="headerlink" title="6.4.2 server指令"></a>6.4.2 server指令</h5><p>该指令用于指定后端服务器的名称和参数，服务器的名称可以是一个域名、ip地址、端口号或者socket。</p>
<pre><code>参数：

    1. weight 权重，权重数值越高，被分配到的客户端请求数越多。默认为1

    2. max_fails 在fail_timeout指定时间内对后端服务器请求失败的次数。

    3. fail_timeout 在经过max_fails次数后，暂停的时间。

    4. down 标记服务器永久离线。

    5. backup 仅在非backup服务器全部繁忙或死机才启用。
</code></pre><h5 id="6-4-3-upstream指令"><a href="#6-4-3-upstream指令" class="headerlink" title="6.4.3 upstream指令"></a>6.4.3 upstream指令</h5><p>设置一组可以在 proxy_pass 和 fastcgi_pass 指令中使用的代理服务器，默认的负载均衡方式是轮询。</p>
<h4 id="6-5-Nginx负载均衡服务器的双机高可用"><a href="#6-5-Nginx负载均衡服务器的双机高可用" class="headerlink" title="6.5 Nginx负载均衡服务器的双机高可用"></a>6.5 Nginx负载均衡服务器的双机高可用</h4><p>在Web服务器集群当做一个城池的话，那么负载均衡服务器相当于城门，城门破了，那么服务就不能正常提供。</p>
<ol>
<li><p>双机高可用的方式目前有两种：</p>
<ol>
<li><p>一台主服务器加一台从服务器，在主服务器宕机之后，从服务器接管主服务器的虚拟IP继续提供服务  </p>
</li>
<li><p>两台负载均衡服务器都处于活动状态，各自绑定一个公网虚拟IP，提供负载均衡服务</p>
</li>
</ol>
</li>
</ol>
<h3 id="第7章-Nginx的rewrite规则"><a href="#第7章-Nginx的rewrite规则" class="headerlink" title="第7章 Nginx的rewrite规则"></a>第7章 Nginx的rewrite规则</h3><p>Rewrite主要功能是实现URL的重写，Nginx的rewrite规则采用PCRE。通过rewrite规则，可以实现规范的URL，根据变量来做URL转向及选择配置。</p>
<h4 id="7-2-Nginx-Rewrite相关指令"><a href="#7-2-Nginx-Rewrite相关指令" class="headerlink" title="7.2 Nginx Rewrite相关指令"></a>7.2 Nginx Rewrite相关指令</h4><pre><code>1. break指令

2. if指令，该指令不支持嵌套和多个条件&amp;&amp;和||处理

    ~ 表区分大小写字母匹配
    ~* 表示不区分大小写字母匹配

    !~ 和!~* 作用相反，表示不匹配

    -f 和 !-f 判断文件是否存在

    -d 和 !-d 判断目录是否存在

    -e 和 !-e 判断文件或目录是否存在

    -x 和 !-x 判断文件是否可执行

3. return

4. rewrite指令，该指令根据表达式来重定向URI或者修改字符串

5. set指令，用于定义一个变量并赋值。
</code></pre><h3 id="第9章-Nginx的Web缓存服务与新浪的开源NCACHE模块"><a href="#第9章-Nginx的Web缓存服务与新浪的开源NCACHE模块" class="headerlink" title="第9章 Nginx的Web缓存服务与新浪的开源NCACHE模块"></a>第9章 Nginx的Web缓存服务与新浪的开源NCACHE模块</h3><p>Web缓存服务中，最著名的数Squid。</p>
<h4 id="9-2-Nginx的Web缓存服务"><a href="#9-2-Nginx的Web缓存服务" class="headerlink" title="9.2 Nginx的Web缓存服务"></a>9.2 Nginx的Web缓存服务</h4><h5 id="9-2-1-proxy-cache相关指令集"><a href="#9-2-1-proxy-cache相关指令集" class="headerlink" title="9.2.1 proxy_cache相关指令集"></a>9.2.1 proxy_cache相关指令集</h5><pre><code>1. proxy_cache 该指令用于设置哪个缓存区将被使用。

2. proxy_cache_path 设置缓存文件的存放路径

    该指令只能在http标签内配置

3. proxy_cache_methods 用于设置缓存哪些http方法，默认缓存http get/head方法，不缓存http post方法

4. proxy_cache_min_use 该指令用于设置缓存的最小使用次数，默认1

5. proxy_cache_valid 用于对不同返回状态码URL设置不同缓存时间

6. proxy_cache_key 设置Web缓存的key值
</code></pre><h5 id="9-2-3-fastcgi-cache相关指令集"><a href="#9-2-3-fastcgi-cache相关指令集" class="headerlink" title="9.2.3 fastcgi_cache相关指令集"></a>9.2.3 fastcgi_cache相关指令集</h5><pre><code>1. fastcgi_cache 该指令用于设置哪个缓存区将被使用

2. fastcgi_cache_path 设置缓存文件存放路径

    只能在http标签内使用

3. fastcgi_cache_methods 设置缓存哪些http方法，默认http get/head方法，不缓存http post方法

4. fastcgi_cache_min_use 设置缓存的最小使用次数，默认值是1

5. fastcgi_cache_valid 对不同返回状态码的URL设置不同的缓存时间

6. fastcgi_cache_key 设置Web缓存的key值
</code></pre><h4 id="9-3-基于Nginx的NCACHE缓存-新浪开源"><a href="#9-3-基于Nginx的NCACHE缓存-新浪开源" class="headerlink" title="9.3 基于Nginx的NCACHE缓存-新浪开源"></a>9.3 基于Nginx的NCACHE缓存-新浪开源</h4><h3 id="第12章-Nginx的核心模块"><a href="#第12章-Nginx的核心模块" class="headerlink" title="第12章 Nginx的核心模块"></a>第12章 Nginx的核心模块</h3><p>Nginx的模块分为核心模块、标准HTTP模块、可选HTTP模块、邮件模块、第三方模块和补丁。</p>
<p>核心模块包括：1.主模块 2.事件模块</p>
<h4 id="12-1-主模块指令"><a href="#12-1-主模块指令" class="headerlink" title="12.1 主模块指令"></a>12.1 主模块指令</h4><pre><code>1. daemon 在生产环境不使用daemon | master_process指令，其只用于开发调试 
2. env 定义变量集合

3. debug_points 调试器内设置断点

4. error_log 错误日志记录

    级别：

        main部分：error

        http部分：crit

        server部分：crit

5. lock_file Nginx可采用异步互斥进行访问控制

6. master_process 开发调试

7. pid pid文件内记录当前Nginx主进程id好

8. ssl_engine 设置首选的ssl引擎

9. user 指定Nginx Worker进程的用户和组，默认的用户名和组名都是nobody。

10. worker_rlimit_core 指定每个Nginx进程的最大core文件大小

11. worker_rlimit_nofile 指定Nginx进程可以打开的最大文件描述符数量

...
</code></pre><h4 id="12-3-事件模块指令"><a href="#12-3-事件模块指令" class="headerlink" title="12.3 事件模块指令"></a>12.3 事件模块指令</h4><pre><code>1. accept_mutex 连接互斥锁进行顺序的accept()调用

2. accept_mutex_delay 
</code></pre><h3 id="第13章-Nginx的标准HTTP模块"><a href="#第13章-Nginx的标准HTTP模块" class="headerlink" title="第13章 Nginx的标准HTTP模块"></a>第13章 Nginx的标准HTTP模块</h3><p>HTTP模块在编译Nginx时自动编译进来，除非使用configure命令禁止编译这些模块。</p>
<h4 id="13-1-HTTP核心模块"><a href="#13-1-HTTP核心模块" class="headerlink" title="13.1 HTTP核心模块"></a>13.1 HTTP核心模块</h4><h5 id="13-2-HTTP-Upstream模块"><a href="#13-2-HTTP-Upstream模块" class="headerlink" title="13.2 HTTP Upstream模块"></a>13.2 HTTP Upstream模块</h5><p>HTTP Upstream 模块是与反向代理、负载均衡相关的模块，包含ip_hash | server | upstream等指令。</p>
<h4 id="13-3-HTTP-Access模块"><a href="#13-3-HTTP-Access模块" class="headerlink" title="13.3 HTTP Access模块"></a>13.3 HTTP Access模块</h4><pre><code>1. allow 允许指定的ip或ip段地址访问虚拟主机或目录

2. deny 拒绝..
</code></pre><h4 id="13-4-HTTP-Auth-Basic模块"><a href="#13-4-HTTP-Auth-Basic模块" class="headerlink" title="13.4 HTTP Auth Basic模块"></a>13.4 HTTP Auth Basic模块</h4><p>该模块采用基于HTTP基本身份验证的用户名和密码登录方式，来保护虚拟主机和目录。</p>
<pre><code>1. auth_basic 指定弹出登录框中提示的名称
</code></pre><h4 id="13-10-geo模块"><a href="#13-10-geo模块" class="headerlink" title="13.10 geo模块"></a>13.10 geo模块</h4><p>geo模块主要负责做全局负载均衡，可以根据不同的客户端ip访问到不同的服务器。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Redis - Java 集成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Redis - Java 集成/" itemprop="url">Redis - Java集成</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:47:20+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  230
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis与Jedis"><a href="#Redis与Jedis" class="headerlink" title="Redis与Jedis"></a>Redis与Jedis</h2><p>在这整个过程中，Redis起到缓存的作用，首先是客户端向Redis服务器中请求获取数据，如果在Redis中存在相应的数据，则直接返回，否则将请求发送到数据库中获取数据，此时数据库返回客户端请求的数据并且更新Redis服务器中的数据，以便后面的操作请求到相同的数据的时候不用再向数据库请求数据，Redis服务器可以直接返回。</p>
<blockquote>
<p>注意：在数据库中的信息更改的时候，也需要同步更新Redis服务器中的数据信息，不然的话客户端会取到没有更新的数据。</p>
</blockquote>
<p>Jedis是Java版的Redis客户端，用来服务Redis的操作。</p>
<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><h2 id="Jedis基本通用配置及使用"><a href="#Jedis基本通用配置及使用" class="headerlink" title="Jedis基本通用配置及使用"></a>Jedis基本通用配置及使用</h2>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">242</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.avantv.cn" target="_blank" title="AVANTV">
                      
                        <i class="fa fa-fw fa-user"></i>AVANTV</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">465.0k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
