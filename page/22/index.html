<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="BangjinHu'Blog" />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="微信公众号：iProgrammer_ing">
<meta property="og:type" content="website">
<meta property="og:title" content="BangjinHu&#39;s Blog">
<meta property="og:url" content="http://bangjinhu.github.io/page/22/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="微信公众号：iProgrammer_ing">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BangjinHu&#39;s Blog">
<meta name="twitter:description" content="微信公众号：iProgrammer_ing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/page/22/"/>





  <title>BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/设计模式 - 过滤器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/设计模式 - 过滤器模式/" itemprop="url">设计模式 - 过滤器</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:28:11+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  619
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式将它们连接起来。它结合多个标准来获取单一标准。</p>
<h4 id="过滤器模式的具体实现"><a href="#过滤器模式的具体实现" class="headerlink" title="过滤器模式的具体实现"></a>过滤器模式的具体实现</h4><p><strong>1.创建一个类 在该类上应用标准</strong><br></p>
<pre><code>public class Person {

   private String name;
   private String gender;
   private String maritalStatus;

   public Person(String name,String gender,String maritalStatus){
      this.name = name;
      this.gender = gender;
      this.maritalStatus = maritalStatus;    
   }

   public String getName() {
      return name;
   }
   public String getGender() {
      return gender;
   }
   public String getMaritalStatus() {
      return maritalStatus;
   }  
}
</code></pre><p><strong>2.为标准（Criteria）创建一个接口</strong><br></p>
<pre><code>import java.util.List;

public interface Criteria {
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);
}
</code></pre><p><strong>3.创建实现 Criteria 接口的实体类</strong><br></p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class CriteriaMale implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;)){
            malePersons.add(person);
         }
      }
      return malePersons;
   }
}

import java.util.ArrayList;
import java.util.List;

public class CriteriaFemale implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;)){
            femalePersons.add(person);
         }
      }
      return femalePersons;
   }
}

import java.util.ArrayList;
import java.util.List;

public class CriteriaSingle implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;)){
            singlePersons.add(person);
         }
      }
      return singlePersons;
   }
}

import java.util.List;

public class AndCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public AndCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);     
      return otherCriteria.meetCriteria(firstCriteriaPersons);
   }
}

import java.util.List;

public class OrCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public OrCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);
      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);

      for (Person person : otherCriteriaItems) {
         if(!firstCriteriaItems.contains(person)){
           firstCriteriaItems.add(person);
         }
      }  
      return firstCriteriaItems;
   }
}
</code></pre><p><strong>4.使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表</strong><br></p>
<pre><code>import java.util.ArrayList; 
import java.util.List;

public class CriteriaPatternDemo {
   public static void main(String[] args) {
      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));
      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));
      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));

      Criteria male = new CriteriaMale();
      Criteria female = new CriteriaFemale();
      Criteria single = new CriteriaSingle();
      Criteria singleMale = new AndCriteria(single, male);
      Criteria singleOrFemale = new OrCriteria(single, female);

      System.out.println(&quot;Males: &quot;);
      printPersons(male.meetCriteria(persons));

      System.out.println(&quot;\nFemales: &quot;);
      printPersons(female.meetCriteria(persons));

      System.out.println(&quot;\nSingle Males: &quot;);
      printPersons(singleMale.meetCriteria(persons));

      System.out.println(&quot;\nSingle Or Females: &quot;);
      printPersons(singleOrFemale.meetCriteria(persons));
   }

   public static void printPersons(List&lt;Person&gt; persons){
      for (Person person : persons) {
         System.out.println(&quot;Person : [ Name : &quot; + person.getName() 
            +&quot;, Gender : &quot; + person.getGender() 
            +&quot;, Marital Status : &quot; + person.getMaritalStatus()
            +&quot; ]&quot;);
      }
   }      
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里通过创建一个Person对象，Criteria接口和实现了该接口的实体类，来过滤Person对象的列表。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/设计模式 - 迭代器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/设计模式 - 迭代器模式/" itemprop="url">设计模式 - 迭代器</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:28:19+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>场景</p>
<pre><code>1. 访问一个集合对象的内容而无需暴露它内部表示。

2. 遍历不同的集合结构提供统一的接口。
</code></pre><p>优点</p>
<pre><code>1. 分离集合对象的遍历行为
</code></pre><p>缺点</p>
<pre><code>1. 类的个数成对增加
</code></pre><p>相关设计模式</p>
<pre><code>1. 迭代器模式与访问者模式
</code></pre><blockquote>
<p>注意：迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部程序透明的访问集合内的数据。</p>
</blockquote>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><strong>1.创建接口</strong><br></p>
<pre><code>public interface Iterator {
   public boolean hasNext();
   public Object next();
}

public interface Container {
   public Iterator getIterator();
}
</code></pre><p><strong>2.创建实现 Container 接口的实体类 该类有实现了 Iterator 接口的内部类 NameIterator</strong><br></p>
<pre><code>public class NameRepository implements Container {
   public String names[] = {&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {

      int index;

      @Override
      public boolean hasNext() {
         if(index &lt; names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }     
   }
}
</code></pre><p><strong>3.使用 NameRepository 来获取迭代器 并打印名字</strong><br></p>
<pre><code>public class IteratorPatternDemo {
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println(&quot;Name : &quot; + name);
      }  
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>提示：聚合对象拥有两个职责：1.存储数据。2.遍历数据。</p>
</blockquote>
<p>可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为。</p>
<p>迭代器模式提供一种方法来访问聚合对象，不用暴露这个对象的内部表示。</p>
<p>将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/设计模式 - 适配器模式 - 重点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/设计模式 - 适配器模式 - 重点/" itemprop="url">设计模式 - 适配器</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:28:31+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  766
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>适配器模式是作为两个不兼容接口之间的桥梁，它结合了两个独立接口的功能。这里的适配器模式和代理模式相像。</p>
<pre><code>1.适配器模式表示有一个接口需要实现，但现成对象不满足，需要加一层适配器来进行适配。

    默认适配器模式
    类适配器模式
    对象适配器模式
</code></pre><blockquote>
<p>提示：类适配器和对象适配器的异同：一个采用继承，一个采用组合。类适配器属于静态实现，对象适配器属于动态实现，对象适配需要多实例化一个对象。对象适配器用得比较多。</p>
</blockquote>
<p>通过继承的方法，适配器自动获得了所需要的大部分方法。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p><strong>1.为媒体播放器和更高级的媒体播放器创建接口</strong><br></p>
<pre><code>public interface MediaPlayer {
   public void play(String audioType, String fileName);
}

public interface AdvancedMediaPlayer { 
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}
</code></pre><p><strong>2.创建实现 AdvancedMediaPlayer 接口的实体类</strong><br></p>
<pre><code>public class VlcPlayer implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);      
   }

   @Override
   public void playMp4(String fileName) {
      //什么也不做
   }
}

public class Mp4Player implements AdvancedMediaPlayer{

   @Override
   public void playVlc(String fileName) {
      //什么也不做
   }

   @Override
   public void playMp4(String fileName) {
      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);      
   }
}
</code></pre><p><strong>3.创建实现 MediaPlayer 接口的适配器类</strong><br></p>
<pre><code>public class MediaAdapter implements MediaPlayer {

   //将具体对象注入到适配器中，帮助适配器实现部分方法
   AdvancedMediaPlayer advancedMusicPlayer;

   public MediaAdapter(String audioType){
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) ){
         advancedMusicPlayer = new VlcPlayer();       
      } else if (audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         advancedMusicPlayer = new Mp4Player();
      }  
   }

   @Override
   public void play(String audioType, String fileName) {
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;)){
         advancedMusicPlayer.playVlc(fileName);
      }else if(audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}
</code></pre><p><strong>4.创建实现 MediaPlayer 接口的实体类</strong><br></p>
<pre><code>public class AudioPlayer implements MediaPlayer {
   MediaAdapter mediaAdapter; 

   @Override
   public void play(String audioType, String fileName) {    

      //播放 mp3 音乐文件的内置支持
      if(audioType.equalsIgnoreCase(&quot;mp3&quot;)){
         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);         
      } 
      //mediaAdapter 提供了播放其他文件格式的支持
      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) 
         || audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      }
      else{
         System.out.println(&quot;Invalid media. &quot;+
            audioType + &quot; format not supported&quot;);
      }
   }   
}
</code></pre><p><strong>5.使用 AudioPlayer 来播放不同类型的音频格式</strong><br></p>
<pre><code>public class AdapterPatternDemo {
   public static void main(String[] args) {
      AudioPlayer audioPlayer = new AudioPlayer();

      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);
      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);
      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);
      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);
   }
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果一个类需要实现此类没有的功能，而其它类有的功能，这时候就可以实现一个该类的适配器类，使用其它类的对象来实现其功能。</p>
<blockquote>
<p>提示：适配器模式和代理模式的区别(比较对象适配器模式和代理模式)：<br>1.代理模式是增强原方法，而适配器是提供”将狗包装成鸭，然后当做鸭来用””。狗和鸭之间原本没有继承关系。</p>
</blockquote>
<p>适配器模式引入一个被称为适配器的包装类，它所包装的对象称为适配者。将一个接口转换成希望的另一个接口，是接口不兼容的哪些类一起工作。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/锁问题 - InnoDB锁问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/锁问题 - InnoDB锁问题/" itemprop="url">InnoDB锁问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:29:04+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,724
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="锁问题-InnoDB锁问题"><a href="#锁问题-InnoDB锁问题" class="headerlink" title="锁问题 - InnoDB锁问题"></a>锁问题 - InnoDB锁问题</h2><p>[TOC]</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<blockquote>
<p>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用。</p>
</blockquote>
<p>行级锁：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度高。</p>
<blockquote>
<p>行级锁更适用于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。</p>
</blockquote>
<p>页面锁：开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。</p>
<h4 id="查询表级锁争用的情况"><a href="#查询表级锁争用的情况" class="headerlink" title="查询表级锁争用的情况"></a>查询表级锁争用的情况</h4><pre><code>show status like &apos;table%&apos;

- 查看table_locks_waited和table_locks_immediate状态变量分析系统上的表锁定争夺。
</code></pre><h4 id="表级锁的锁模式"><a href="#表级锁的锁模式" class="headerlink" title="表级锁的锁模式"></a>表级锁的锁模式</h4><p>表级锁的两种模式，表共享模式和表独占写锁。</p>
<h4 id="加入表锁"><a href="#加入表锁" class="headerlink" title="加入表锁"></a>加入表锁</h4><p>lock table 显式给某一表加上表锁。</p>
<h4 id="获取InnoDB行锁争用情况"><a href="#获取InnoDB行锁争用情况" class="headerlink" title="获取InnoDB行锁争用情况"></a>获取InnoDB行锁争用情况</h4><pre><code>show status like &apos;innodb_row_lock%&apos; 

    - innodb_row_lock_waits 和 innodb_row_lock_time_avg值比较高，可以通过查询information_schema数据库中相关的表来查看锁的情况
</code></pre><h4 id="InnoDB行锁模式以及加锁方法"><a href="#InnoDB行锁模式以及加锁方法" class="headerlink" title="InnoDB行锁模式以及加锁方法"></a>InnoDB行锁模式以及加锁方法</h4><pre><code>1. 共享锁（S），允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁。

2. 排它锁（X），允许获得排它锁的事务更新数据，阻止其它事务取得相同数据集的共享锁和排它锁。
</code></pre><blockquote>
<p>提示：为了允许行锁和表锁共存，实现多粒度锁机制，innodb还有两种内部使用的意向锁（表锁）。</p>
</blockquote>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁。</p>
<blockquote>
<p>注意：该行锁实现特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p>
</blockquote>
<pre><code>1. 在不通过索引条件查询时，InnoDB会锁定表中的所有记录。

2. 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然访问不同行的记录，但是如果是使用相同的索引键，会出现锁冲突的。

3. 不论使用何种所以，InnoDB都会使用行锁来对数据加锁。

4. 
</code></pre><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>事务是一组操作的执行单元，相对于数据库操作来说，事务管理的是一组SQL指令(增删改)，事务的一致性要求这个事务内的操作必须全部执行成功，如果在此过程出现差错，如一条sql语句没有执行成功，那么这一组操作都将全部回滚。</p>
<h4 id="1-事务的性质-ACID"><a href="#1-事务的性质-ACID" class="headerlink" title="1.事务的性质(ACID)"></a>1.事务的性质(ACID)</h4><pre><code>这里可以用四个词来解释事务：
    A（atomic 原子性）：发生就是全部都发生，不发生全都不发生
    C（consistent 一致性）：数据应该不被破坏
    I（isolate 隔离性）：用户间操作不相混淆
    D（durable 持久性）：永久保存，如保存到数据库中等
</code></pre><h4 id="2-事务管理接口"><a href="#2-事务管理接口" class="headerlink" title="2.事务管理接口"></a>2.事务管理接口</h4><p>所谓的事务管理就是按照给定的事务规则来执行提交和回滚事务操作。</p>
<h4 id="0-0-spring事务管理的两种方式"><a href="#0-0-spring事务管理的两种方式" class="headerlink" title="0.0 spring事务管理的两种方式"></a>0.0 spring事务管理的两种方式</h4><pre><code>1)编程式事务管理(不用)
2)声明式事务管理
    1.基于xml配置文件实现
    2.基于注解方式实现
</code></pre><h4 id="0-1-声明式事务管理-xml配置"><a href="#0-1-声明式事务管理-xml配置" class="headerlink" title="0.1 声明式事务管理(xml配置)"></a>0.1 声明式事务管理(xml配置)</h4><pre><code>1.配置文件的方式使用aop思想配置

  1.配置事务管理器
  &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;
  2.配置事务的增强
  &lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;&quot; propagation=&quot;&quot;/&gt;//指定运行事务的匹配规则 propagation：
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  3.配置切面
  &lt;aop:config&gt;
    //1.切入点
    &lt;aop:pointcut expression=&quot;&quot; id=&quot;&quot;/&gt;
    //2.切面
    &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;//表示的意思是将哪个增强(advice-ref)用到哪一个切面(pointcut-ref)上面
  &lt;/aop:config&gt;

2.
</code></pre><h4 id="0-2-声明式事务管理-注解"><a href="#0-2-声明式事务管理-注解" class="headerlink" title="0.2 声明式事务管理(注解)"></a>0.2 声明式事务管理(注解)</h4><pre><code>1.配置事务管理器
  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframwork.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
  &lt;/bean&gt;

2.配置事务注解
  &lt;tx:annnotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

3.在要使用事务的方法所在类上面添加注释

  @Transactional
  public class OrdersService{
    private OrdersDao ordersDao;
    public void setOrdersDao(OrdersDao ordersDao){

        }
        //调用dao的方法，业务逻辑层写转账业务等
        //要使用到的业务逻辑
    public void accountMoney(){

        }    
    }
</code></pre><h4 id="1-PlatformTransactionManager-接口1"><a href="#1-PlatformTransactionManager-接口1" class="headerlink" title="1.PlatformTransactionManager 接口1"></a>1.PlatformTransactionManager 接口1</h4><pre><code>1.事务管理器：PlatformTransactionManager
    1)Spring针对不同的DAO层框架都提供了不同的实现类
    2)无论是使用基于xml配置文件方式实现事务管理还是使用基于注解方式实现事务管理，首先都需要配置事务管理器
</code></pre><blockquote>
<p>案例：搭建转账环境</p>
</blockquote>
<pre><code>1.创建数据库表，添加数据(创建基本的用户信息(用户名、密码))
2.创建service类和dao类，完成注入关系

&lt;bean id=&quot;orderService&quot; class=&quot;cn.itcast.service.OrderService&quot;&gt;
    &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;ordersDao&quot; class=&quot;cn.itcast.dao.OrdersDao&quot;&gt;
    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<blockquote>
<p>注意：service层又叫做业务逻辑层，dao层单纯对数据库做操作，在dao层不添加业务</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：在bean.xml文件配置时候是service中注入dao，dao中注入模板，模板中注入dataSource</p>
</blockquote>
<h4 id="2-TransactionDefinition-接口2"><a href="#2-TransactionDefinition-接口2" class="headerlink" title="2.TransactionDefinition 接口2"></a>2.TransactionDefinition 接口2</h4><p>事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</p>
<h4 id="3-TransactionStatus-接口3"><a href="#3-TransactionStatus-接口3" class="headerlink" title="3.TransactionStatus 接口3"></a>3.TransactionStatus 接口3</h4><p>事务运行状态</p>
<h4 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4.事务隔离级别"></a>4.事务隔离级别</h4><p>事务的隔离级别定义一个事务可能受其他并发事务影响的程度。在我们项目中，多个事务并发运行会操作相同的数据来完成各自的任务，所以在这一过程中会导致一些问题的出现。</p>
<p><strong>1.脏读</strong><br><br>脏读表示一个事务正在访问数据并对数据进行修改，而这修改还没有提交到数据库中，另外的事务也访问该数据，然后使用这个数据，因为这个数据还没有提交，所以另外一个事务读到的数据是脏数据，所做的操作是不正确的。</p>
<p><strong>2.丢失修改</strong><br><br>表示在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改这个数据后，第二个事务也修改这个数据，这样第一个事务内修改的数据结果丢失，从而称之为丢失修改。</p>
<p><strong>3.不可重复读</strong><br><br>表示在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问该数据。那么在两个事务操作之后，第一个事务读取的数据可能不一样。</p>
<p><strong>4.幻读</strong><br><br>幻读与不可重复读类似，表示一个事务读取数据，然后另外一个并发事务又插入数据，从而在第一个事务读取时会发现一些原本不存在的数据，这就像幻觉，从而是幻读。</p>
<blockquote>
<p>注意：为了解决数据库读一致性的问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式：1.在读取数据前对其加锁，阻止其它事务对其进行修改。2.通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别的一致性读取。</p>
</blockquote>
<h4 id="5-获取InnoDB行锁争用情况"><a href="#5-获取InnoDB行锁争用情况" class="headerlink" title="5.获取InnoDB行锁争用情况"></a>5.获取InnoDB行锁争用情况</h4><p>在这里通过innodb_row_lock状态命令来分析系统上的行锁争用情况。</p>
<pre><code>SHOW STATUS LIKE &apos;innodb_row_lock%&apos;
</code></pre><p><strong>5.1 InnoDB的行锁模式和加锁方法</strong><br><br>InnoDB实现两种类型行锁：1.共享锁，允许一个事务去读一行，阻止其它事务获得相同数据集的排它锁。2.排它锁，允许获得排它锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排它写锁。</p>
<p><strong>5.2 InnoDB行锁实现方式</strong><br><br>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来记录加锁。</p>
<pre><code>1.Record lock：对索引项加锁
2.Gap lock：对索引之间的间隙加锁，第一条记录前或者最后一条记录之后的间隙加锁
3.Next-key lock：前两种的组合，对记录及其前面的间隙加锁
</code></pre><blockquote>
<p>提示：InnoDB这种行锁实现的特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：在实际应用过程中需要注意InnoDB行锁的这一特性，否则将导致大量的锁冲突。</p>
</blockquote>
</blockquote>
<pre><code>1.在不通过索引条件查询时，InnoDB会锁定表中的所有记录 
2.因为MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。
3.当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不管是使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁
4.有些时候，即使在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全盘扫描效率高，其就不会使用索引，这时InnoDB会对所有记录加锁。
</code></pre><p><strong>5.3 什么时候使用表锁</strong><br><br>对于InnoDB表，绝大部分时间都使用行级锁，因为事务和行级锁往往使我们选择InnoDB的理由。</p>
<pre><code>1.如果事务需要更新大部分或者全部数据，表比较大，这种情况可以使用表锁来提高效率。
2.事务涉及多个表，复杂，容易引起死锁。这种情况使用表锁。
</code></pre><p><strong>5.4 避免死锁</strong><br></p>
<pre><code>1.如果不同程序并发存取多个表，尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
2.程序批量处理数据的时候，如果事先对数据排序，保证每个线程按照固定的顺序来处理记录，也可以降低出现死锁的机会。
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/错误日志/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/错误日志/" itemprop="url">Redis - Java集成</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:42:56+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,308
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="1-Caused-by-org-apache-ibatis-exceptions-TooManyResultsException-Expected-one-result-or-null-to-be-returned-by-selectOne-but-found-5"><a href="#1-Caused-by-org-apache-ibatis-exceptions-TooManyResultsException-Expected-one-result-or-null-to-be-returned-by-selectOne-but-found-5" class="headerlink" title="1. Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 5"></a>1. Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 5</h4><p>解：该错误时因为查询到的记录是多条，而返回的类型值允许是一条或者没有，所以出错。所以在数据返回的时候将返回类型变为List集合，那么就能正确执行。</p>
<h4 id="2-Zero-date-value-prohibited-nested-exception-is-java-sql-SQLException-Zero-date-value-prohibited"><a href="#2-Zero-date-value-prohibited-nested-exception-is-java-sql-SQLException-Zero-date-value-prohibited" class="headerlink" title="2.Zero date value prohibited; nested exception is java.sql.SQLException: Zero date value prohibited"></a>2.Zero date value prohibited; nested exception is java.sql.SQLException: Zero date value prohibited</h4><p>解：在数据库连接的URL之后加上 <code>&amp;zeroDateTimeBehavior=convertToNull</code>。这种方法的值一共有三种：</p>
<pre><code>1.exception：默认值，会抛出异常。
2.CONVERT_TO_NULL：将出错的那个0000-00-00字段的值转为null
3.round：转成0001-01-01 14:00:00
</code></pre><p>或者将数据表中对应的值将其改成null</p>
<h4 id="3-Cause-java-sql-SQLIntegrityConstraintViolationException-Column-‘email’-in-where-clause-is-ambiguous"><a href="#3-Cause-java-sql-SQLIntegrityConstraintViolationException-Column-‘email’-in-where-clause-is-ambiguous" class="headerlink" title="3.Cause: java.sql.SQLIntegrityConstraintViolationException: Column ‘email’ in where clause is ambiguous"></a>3.Cause: java.sql.SQLIntegrityConstraintViolationException: Column ‘email’ in where clause is ambiguous</h4><p>这里表示数据查询过程中查询的列重复了，没有指定哪个表的中的列被查询，指定之后就不会出现这样的错误。</p>
<p>或者在服务实现时候，用正确的列名替换错误的列名。</p>
<h4 id="org-springframework-beans-factory-BeanCreationException"><a href="#org-springframework-beans-factory-BeanCreationException" class="headerlink" title="org.springframework.beans.factory.BeanCreationException"></a>org.springframework.beans.factory.BeanCreationException</h4><p>出现此类异常的情况有很多：</p>
<pre><code>1.可能是你的数据库类名称引用错误。
</code></pre><h4 id="maven-jetty启动很慢的问题-报错：Timeout-scanning-annotations"><a href="#maven-jetty启动很慢的问题-报错：Timeout-scanning-annotations" class="headerlink" title="maven jetty启动很慢的问题 报错：Timeout scanning annotations"></a>maven jetty启动很慢的问题 报错：Timeout scanning annotations</h4><blockquote>
<p>原因：</p>
</blockquote>
<pre><code>The Jetty8 have to scan all the jar files to search those &quot;Servlet3&quot; features (web-fragment / annotations ... etc ) 
</code></pre><blockquote>
<p>解决：</p>
</blockquote>
<pre><code>1.在web.xml中的&lt;web-app&gt;末尾加上metadata-complete=&quot;true&quot;，此段程序一般没有效果。

2.1 创建一个文件jetty-context.xml文件，将之放置到java路径下的resources文件目录下。

&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;http://www.eclipse.org/jetty/configure.dtd&quot;&gt;
&lt;Configure class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt;
    &lt;Call name=&quot;setAttribute&quot;&gt;
        &lt;Arg&gt;org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern&lt;/Arg&gt;
        &lt;Arg&gt;.*/.*jsp-api-[^/]\.jar$|./.*jsp-[^/]\.jar$|./.*taglibs[^/]*\.jar$
        &lt;/Arg&gt;
    &lt;/Call&gt;
&lt;/Configure&gt;

2.2 然后将pom.xml中的jetty依赖换掉

&lt;plugin&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;9.3.10.v20160621&lt;/version&gt;
  &lt;configuration&gt;
    &lt;contextXml&gt;src/main/resources/jetty-contexts.xml&lt;/contextXml&gt;
    &lt;webAppConfig&gt;
      &lt;defaultsDescriptor&gt;src/main/resources/jetty-contexts.xml&lt;/defaultsDescriptor&gt;
      &lt;contextPath&gt;/solr&lt;/contextPath&gt;
    &lt;/webAppConfig&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;

2.3 然后重启jetty-run就可以啦
</code></pre><h4 id="jetty-run-Dorg-eclipse-jetty-annotations-maxWait-120"><a href="#jetty-run-Dorg-eclipse-jetty-annotations-maxWait-120" class="headerlink" title="jetty:run -Dorg.eclipse.jetty.annotations.maxWait=120"></a>jetty:run -Dorg.eclipse.jetty.annotations.maxWait=120</h4><p>这里表示的是在maven jetty:run 启动命令之后追加参数。</p>
<h4 id="org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘org-springframework-web-servlet-resource-DefaultServletHttpRequestHandler-0’-Initialization-of-bean-failed"><a href="#org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘org-springframework-web-servlet-resource-DefaultServletHttpRequestHandler-0’-Initialization-of-bean-failed" class="headerlink" title="org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler#0’: Initialization of bean failed;"></a>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler#0’: Initialization of bean failed;</h4><p>解决：在springmvc.xml中在<a href="mvc:default-servlet-handler/" target="_blank" rel="noopener">mvc:default-servlet-handler/</a>添加上在web.xml中的<servlet-name>效果如下：<br>&lt;mvc:default-servlet-handler default-servlet-name=”SpringMVC”/&gt;</servlet-name></p>
<h4 id="org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘configController’-Injection-of-autowired-dependencies-failed"><a href="#org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘configController’-Injection-of-autowired-dependencies-failed" class="headerlink" title="org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘configController’: Injection of autowired dependencies failed;"></a>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘configController’: Injection of autowired dependencies failed;</h4><p>解决：因为在Service实现类里面没有添加@Service标签，发生这种错误的原因要么是注解问题，要么是配置文件多写什么或者少写什么。</p>
<h4 id="No-mapping-found-for-HTTP-request-with-URI-teacher-teacher-exam-export-in-DispatcherServlet-with-name-‘B’"><a href="#No-mapping-found-for-HTTP-request-with-URI-teacher-teacher-exam-export-in-DispatcherServlet-with-name-‘B’" class="headerlink" title="No mapping found for HTTP request with URI [/teacher/teacher/exam/export] in DispatcherServlet with name ‘B’"></a>No mapping found for HTTP request with URI [/teacher/teacher/exam/export] in DispatcherServlet with name ‘B’</h4><p>解决：原因是因为Controller没有加载到资源，没有找到资源，原因可能是配置文件没有配置扫描到对应的controller或者是web.xml中没有配置，然后还有一种情况就是在Controller中的对应的方法路径写错。</p>
<h4 id="java-lang-ArrayIndexOutOfBoundsException-数据下标越界错误"><a href="#java-lang-ArrayIndexOutOfBoundsException-数据下标越界错误" class="headerlink" title="java.lang.ArrayIndexOutOfBoundsException 数据下标越界错误"></a>java.lang.ArrayIndexOutOfBoundsException 数据下标越界错误</h4><p>解决：查看为什么会数组下标越界，一般都是最后面的一个元素访问的时候访问了本不存在的数组下标值的元素。</p>
<h4 id="can-not-be-referenced-from-a-static-context-此错误表示不能在静态上下文引用类"><a href="#can-not-be-referenced-from-a-static-context-此错误表示不能在静态上下文引用类" class="headerlink" title="can not be referenced from a static context 此错误表示不能在静态上下文引用类"></a>can not be referenced from a static context 此错误表示不能在静态上下文引用类</h4><p>解决：此时是因为没有在static方法中声明类对象，然后在声明类对象之后再引用该声明对象的方法就能够使用该方法啦。</p>
<h4 id="Error-querying-database-Cause-java-sql-SQLSyntaxErrorException-Unknown-column-‘name’-in-‘field-list’"><a href="#Error-querying-database-Cause-java-sql-SQLSyntaxErrorException-Unknown-column-‘name’-in-‘field-list’" class="headerlink" title="### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘name’ in ‘field list’"></a>### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘name’ in ‘field list’</h4><p>解决：</p>
<h4 id="javax-servlet-ServletException-Could-not-resolve-view-with-name"><a href="#javax-servlet-ServletException-Could-not-resolve-view-with-name" class="headerlink" title="javax.servlet.ServletException: Could not resolve view with name"></a>javax.servlet.ServletException: Could not resolve view with name</h4><p>解决：此问题可能是因为在写springmvc的时候少写一些东西导致的问题。认真检查springmvc的程序是否正确。</p>
<h4 id="Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘course-section-‘1-2’"><a href="#Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘course-section-‘1-2’" class="headerlink" title="### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘course_section = ‘1-2’"></a>### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘course_section = ‘1-2’</h4><p>解决：此错误可能是因为mapper.xml中的文件少写了一些东西，比如：逗号，名称与主体或者数据库里面的名称不一致导致。此时应该注意检查xml文件的问题。</p>
<h4 id="Cannot-determine-value-type-from-string-‘B楼-114’-nested-exception-is-java-sql-SQLDataException-Cannot-determine-value-type-from-string-‘B楼-114’"><a href="#Cannot-determine-value-type-from-string-‘B楼-114’-nested-exception-is-java-sql-SQLDataException-Cannot-determine-value-type-from-string-‘B楼-114’" class="headerlink" title="Cannot determine value type from string ‘B楼#114’; nested exception is java.sql.SQLDataException: Cannot determine value type from string ‘B楼#114’"></a>Cannot determine value type from string ‘B楼#114’; nested exception is java.sql.SQLDataException: Cannot determine value type from string ‘B楼#114’</h4><p>解决：可能是因为xml文件的字段拼写或者是语法错误，认真检查。</p>
<h4 id="org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found"><a href="#org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found" class="headerlink" title="org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)"></a>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</h4><p>解决：要么是接口或者xml文件找不到，要么是两者之间不匹配</p>
<h4 id="Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘-VALUES-‘胡邦金’-’-at-line-34"><a href="#Error-updating-database-Cause-java-sql-SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘-VALUES-‘胡邦金’-’-at-line-34" class="headerlink" title="### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘)VALUES(‘胡邦金’,’ at line 34"></a>### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘)VALUES(‘胡邦金’,’ at line 34</h4><p>解决：这样的错误可能是因为在sql语句中逗号的原因，所以使用<trim>关键字解决。</trim></p>
<h4 id="org-springframework-beans-InvalidPropertyException-Invalid-property-‘courseTeacher-’-of-bean-class-cn-edu-xidian-see-entity-AppointmentCourse-Property-referenced-in-indexed-property-path-‘courseTeacher-’-is-neither-an-array-nor-a-List-nor-a-Map-returned-value-was"><a href="#org-springframework-beans-InvalidPropertyException-Invalid-property-‘courseTeacher-’-of-bean-class-cn-edu-xidian-see-entity-AppointmentCourse-Property-referenced-in-indexed-property-path-‘courseTeacher-’-is-neither-an-array-nor-a-List-nor-a-Map-returned-value-was" class="headerlink" title="org.springframework.beans.InvalidPropertyException: Invalid property ‘courseTeacher[]’ of bean class [cn.edu.xidian.see.entity.AppointmentCourse]: Property referenced in indexed property path ‘courseTeacher[]’ is neither an array nor a List nor a Map; returned value was []"></a>org.springframework.beans.InvalidPropertyException: Invalid property ‘courseTeacher[]’ of bean class [cn.edu.xidian.see.entity.AppointmentCourse]: Property referenced in indexed property path ‘courseTeacher[]’ is neither an array nor a List nor a Map; returned value was []</h4><p>解决：对于这样的错误可能是因为在数据库表中设置该字段的值不为空，然后前台传参进去是为空的，所以导致两者不一致而产生错误。所以检查前台或者数据库表中字段值是否设置得当。</p>
<h4 id="Error-updating-database-Cause-java-sql-SQLIntegrityConstraintViolationException-Duplicate-entry-‘14020310013’-for-key-‘u-sno’"><a href="#Error-updating-database-Cause-java-sql-SQLIntegrityConstraintViolationException-Duplicate-entry-‘14020310013’-for-key-‘u-sno’" class="headerlink" title="### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry ‘14020310013’ for key ‘u_sno’"></a>### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry ‘14020310013’ for key ‘u_sno’</h4><p>解决：确保在开发过程中索引唯一性，也就是在插入数据的时候，具有唯一性约束条件的列的值有重复。</p>
<h4 id="echarts-js-11954-Uncaught-Error-series-type-should-be-specified"><a href="#echarts-js-11954-Uncaught-Error-series-type-should-be-specified" class="headerlink" title="echarts.js:11954 Uncaught Error: series.type should be specified."></a>echarts.js:11954 Uncaught Error: series.type should be specified.</h4><p>解决：这里需要自己加载option，就是自己定义的option。                majorChart.setOption(optionMajor);然后就不会报错了。</p>
<h4 id="1054-Unknown-column-‘雷达信号处理国家重点实验室’-in-‘where-clause’"><a href="#1054-Unknown-column-‘雷达信号处理国家重点实验室’-in-‘where-clause’" class="headerlink" title="1054 - Unknown column ‘雷达信号处理国家重点实验室’ in ‘where clause’"></a>1054 - Unknown column ‘雷达信号处理国家重点实验室’ in ‘where clause’</h4><p>解决：需要注意的是该列是字符串类型，需要加上单引号。双引号解析为字段变量或关键字，单引号解析为字段的值。</p>
<h4 id="bad-SQL-grammar-nested-exception-is-java-sql-SQLSyntaxErrorException-Unknown-column-‘电路CAD研究所’-in-‘where-clause’"><a href="#bad-SQL-grammar-nested-exception-is-java-sql-SQLSyntaxErrorException-Unknown-column-‘电路CAD研究所’-in-‘where-clause’" class="headerlink" title="; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: Unknown column ‘电路CAD研究所’ in ‘where clause’"></a>; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: Unknown column ‘电路CAD研究所’ in ‘where clause’</h4><p>解决：将最后的字段用单引号括起来。</p>
<h4 id="后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了"><a href="#后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了" class="headerlink" title="后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了"></a>后台在查询数据库之后输出值为空的情况可能是mybatis中没有返回resultMap类型，将其设置为resultMap类型返回的话，后台就有值了</h4><h4 id="使用datatables分页数据的时候报错413-full-head"><a href="#使用datatables分页数据的时候报错413-full-head" class="headerlink" title="使用datatables分页数据的时候报错413 full head"></a>使用datatables分页数据的时候报错413 full head</h4><p>解决：这里是因为请求的实体过大的缘故，将请求方式get改为post。</p>
<blockquote>
<p>注意：在为了避免此错误出现，尽量减少请求主体的大小。</p>
</blockquote>
<h4 id="Property-referenced-in-indexed-property-path-‘columns-0-data-’-is-neither-a"><a href="#Property-referenced-in-indexed-property-path-‘columns-0-data-’-is-neither-a" class="headerlink" title="Property referenced in indexed property path ‘columns[0][data]’ is neither a"></a>Property referenced in indexed property path ‘columns[0][data]’ is neither a</h4><p>解决：这里是因为在datatable中没有设置datatable的声明类。在配置文件中要配置其声明类DataTableArgumentResolver。</p>
<h4 id="Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25"><a href="#Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25" class="headerlink" title="Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25"></a>Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25</h4><p>解决：使用jetty:run-war</p>
<h4 id="在导入的mysql数据文件出现中文乱码时候，在mysql-sql源文件中设置编码-set-names-‘utf8’-问题解决。"><a href="#在导入的mysql数据文件出现中文乱码时候，在mysql-sql源文件中设置编码-set-names-‘utf8’-问题解决。" class="headerlink" title="在导入的mysql数据文件出现中文乱码时候，在mysql.sql源文件中设置编码 set names ‘utf8’; 问题解决。"></a>在导入的mysql数据文件出现中文乱码时候，在mysql.sql源文件中设置编码 set names ‘utf8’; 问题解决。</h4><h4 id="time-zone-错误，直接在数据库链接后面加上-serverTimezone-UTC-即可。"><a href="#time-zone-错误，直接在数据库链接后面加上-serverTimezone-UTC-即可。" class="headerlink" title="time_zone 错误，直接在数据库链接后面加上 ?serverTimezone=UTC 即可。"></a>time_zone 错误，直接在数据库链接后面加上 ?serverTimezone=UTC 即可。</h4><p>解决：jdbc.url=jdbc:mysql://127.0.0.1:3306/bilibili?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</p>
<h4 id="Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25-run-default-cli-on-project-BodyCheck-Failure"><a href="#Failed-to-execute-goal-org-mortbay-jetty-maven-jetty-plugin-6-1-25-run-default-cli-on-project-BodyCheck-Failure" class="headerlink" title="Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25:run (default-cli) on project BodyCheck: Failure"></a>Failed to execute goal org.mortbay.jetty:maven-jetty-plugin:6.1.25:run (default-cli) on project BodyCheck: Failure</h4><p>解决：根据错误日志可以知道是因为项目端口号被占用，换用其它端口号或者停掉当前端口号。</p>
<h4 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h4><p>解决：这个错误一般出现在断点续传中，含义是请求范围错误，例如：</p>
<p>一个文件的大小是10000000 byte，你请求起始点大于或等于10000000 时，即会返回416</p>
<pre><code>&lt;form action=&quot;&quot; method=&quot;post&quot; class=&quot;form-horizontal&quot; enctype=&quot;application/x-www-form-urlencoded&quot; &gt;
</code></pre><p>在页面上加入上面的程序，请求的链接的页面会解决416错误。</p>
<h4 id="416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。"><a href="#416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。" class="headerlink" title="416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。"></a>416错误还是没有解决，上面的解决方式可能只是凑巧一会儿就好了，但是到后面还是会报错。</h4><p>解决：利用其它服务器，获取其它服务器的视频位置，然后在ckplayer视频路径下添加上，视频能够正常播放。</p>
<h4 id="HTTP-400错误-一般来说是因为前后台之间传递参数不一致所导致的"><a href="#HTTP-400错误-一般来说是因为前后台之间传递参数不一致所导致的" class="headerlink" title="HTTP 400错误 一般来说是因为前后台之间传递参数不一致所导致的"></a>HTTP 400错误 一般来说是因为前后台之间传递参数不一致所导致的</h4><p>解决：这里我要解决的是前台传递一个List&lt;对象&gt;到后台，所以在使用ajax传递之前需要将这样一个List对象转换成String类型，然后将Stirng类型通过ajax方式传递给后台。在后台通过@RequestBody注解接收，还需要类型是List&lt;对象&gt;类型。</p>
<h4 id="如何解决在mybatis中加入java-util-List类型的数据"><a href="#如何解决在mybatis中加入java-util-List类型的数据" class="headerlink" title="如何解决在mybatis中加入java.util.List类型的数据"></a>如何解决在mybatis中加入java.util.List类型的数据</h4><h4 id="报错-jetty-server-exiting"><a href="#报错-jetty-server-exiting" class="headerlink" title="报错 jetty server exiting"></a>报错 jetty server exiting</h4><p>解决：将Java虚拟机停掉重新启动项目便可。</p>
<h4 id="PreparedStatementCallback-uncategorized-SQLException-for-SQL-Incorrect-integer-value-‘’-for-column-‘payment-status’-at-row-1"><a href="#PreparedStatementCallback-uncategorized-SQLException-for-SQL-Incorrect-integer-value-‘’-for-column-‘payment-status’-at-row-1" class="headerlink" title="PreparedStatementCallback; uncategorized SQLException for SQL Incorrect integer value: ‘’ for column ‘payment_status’ at row 1"></a>PreparedStatementCallback; uncategorized SQLException for SQL Incorrect integer value: ‘’ for column ‘payment_status’ at row 1</h4><p>解决：将数据表里面的对应的Integer类型转换成varchar类型。报错消失。</p>
<h4 id="DataTables插件不能正常使用的时候，排查前端是否写对。中是否包含-lt-list-gt"><a href="#DataTables插件不能正常使用的时候，排查前端是否写对。中是否包含-lt-list-gt" class="headerlink" title="DataTables插件不能正常使用的时候，排查前端是否写对。中是否包含&lt;#list&gt;"></a>DataTables插件不能正常使用的时候，排查前端是否写对。<tbody></tbody>中是否包含&lt;#list&gt;</h4><h4 id="Truncated-incorrect-DOUBLE-value-‘2019-12-13-15-52-20’"><a href="#Truncated-incorrect-DOUBLE-value-‘2019-12-13-15-52-20’" class="headerlink" title="Truncated incorrect DOUBLE value: ‘2019-12-13 15:52:20’"></a>Truncated incorrect DOUBLE value: ‘2019-12-13 15:52:20’</h4><p>解决：将UPDATE teacher_employment_post_feedback SET ctime = “2019-12-13 15:52:20” and utime = “2020-01-03 15:43:20”语句中的and改为’,’</p>
<h4 id="nested-exception-is-org-apache-ibatis-reflection-ReflectionException-There-is-no-getter-for-property-named-‘condition’-in-‘class-com-llq-DataTables-condition-DTCondition’"><a href="#nested-exception-is-org-apache-ibatis-reflection-ReflectionException-There-is-no-getter-for-property-named-‘condition’-in-‘class-com-llq-DataTables-condition-DTCondition’" class="headerlink" title="nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named ‘condition’ in ‘class com.llq.DataTables.condition.DTCondition’"></a>nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named ‘condition’ in ‘class com.llq.DataTables.condition.DTCondition’</h4><p>解决：在写程序的时候出现错误，在传递的参数中没有condition变量，也就是在.xml文件中不用condition.where这样的来引用。直接${where}来引用即可。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/项目开发经验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/项目开发经验/" itemprop="url">Redis - Java集成</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:42:50+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  420
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>

---
title: Java程序开发项目经验
tags:
  - 项目开发
categories: 
  - 学习笔记
copyright: true
showdonate: true
date: 2018-06-05 09:22:26
comments: true
password: 
---
<blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="1-Tomcat与jetty"><a href="#1-Tomcat与jetty" class="headerlink" title="1.Tomcat与jetty"></a>1.Tomcat与jetty</h3><p>jetty和Tomcat是两款著名的开源webserver/servlet容器。</p>
<pre><code>两者之间的比较：

    1.jetty更加的轻量级
    2.jetty更加灵活，表现在可扩展性
</code></pre><hr>
<h3 id="2-web-xml文件配置"><a href="#2-web-xml文件配置" class="headerlink" title="2.web.xml文件配置"></a>2.web.xml文件配置</h3><p>修改在<code>webapp</code>路径下的<code>web.xml</code>文件需要根据规定的顺序添加操作权限，否则会报错。或者将<code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</code>这一段校验代码删掉，问题就解决了。这时因为我们添加的部分的代码符合<code>xml</code>文档规范，但是不符合<code>web-app_2_3.dtd</code>所定义的规范。</p>
<hr>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/undefined/项目开发经验/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/项目开发过程记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/项目开发过程记录/" itemprop="url">Redis - Java集成</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T08:42:42+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,919
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h3 id="1-Tomcat与jetty"><a href="#1-Tomcat与jetty" class="headerlink" title="1.Tomcat与jetty"></a>1.Tomcat与jetty</h3><p>jetty和Tomcat是两款著名的开源webserver/servlet容器。</p>
<pre><code>两者之间的比较：

    1.jetty更加的轻量级
    2.jetty更加灵活，表现在可扩展性
</code></pre><hr>
<h3 id="2-web-xml文件配置"><a href="#2-web-xml文件配置" class="headerlink" title="2.web.xml文件配置"></a>2.web.xml文件配置</h3><p>修改在<code>webapp</code>路径下的<code>web.xml</code>文件需要根据规定的顺序添加操作权限，否则会报错。或者将<code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</code>这一段校验代码删掉，问题就解决了。这时因为我们添加的部分的代码符合<code>xml</code>文档规范，但是不符合<code>web-app_2_3.dtd</code>所定义的规范。</p>
<hr>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><blockquote>
<p>注意：在使用IDEA开发的时候，mapper类只能建立在resource目录下，不能建立在Java的包下面，不然会映射不了。</p>
</blockquote>
<pre><code>1.首先编写entity
2.然后编写接口
3.接下来使用mapper
4.最后编写测试用例，直接使用junit测试
    //测试dao层
    // 使用Springtest测试框架
    @RunWith(SpringJUnit4ClassRunner.class)
    // 加载配置
    @ContextConfiguration(&quot;/spring/spring-*.xml&quot;) 
    public class MyBatisTest {
        @Autowired
        private ScoreDao scoreDao;

        @Test
        public void testAddScore() {
            Score score = new Score();
            score.setChangeType(&quot;充钱钱&quot;);
            score.setScore(10);
            int insert = scoreDao.insertScore(score);
            System.out.print(&quot;insert :&quot;+insert);
        }
    }

5.测试整个框架(使用SpringMVC)
    1.编写业务逻辑接口
    2.然后编写业务逻辑接口的实现类
    3.然后编写controller将springmvc的解析视图解析出来
</code></pre><hr>
<h3 id="4-Redis-单机版以及测试版"><a href="#4-Redis-单机版以及测试版" class="headerlink" title="4.Redis 单机版以及测试版"></a>4.Redis 单机版以及测试版</h3><hr>
<h3 id="5-SSM-项目开发"><a href="#5-SSM-项目开发" class="headerlink" title="5.SSM 项目开发"></a>5.SSM 项目开发</h3><h4 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h4><h4 id="Service接口文件与ServiceImpl实现类文件"><a href="#Service接口文件与ServiceImpl实现类文件" class="headerlink" title="Service接口文件与ServiceImpl实现类文件"></a>Service接口文件与ServiceImpl实现类文件</h4><p>1.ServiceImpl文件<br>对于ServiceImpl中的文件只是实现Service接口中的方法函数，在Service接口的返回类型：<br>1.一般表示操作(删除/更新/添加)的方法函数返回Boolean类型。<br>2.表示查找返回其需要的类型(实体类型/实体类型的List)。<br><br>实现步骤：<br><br>    1.在接口类实现之前添加@Service注解<br><br>    2.然后在class中注入相关的mapper接口<br><br>    3.最后实现相关的方法函数</p>
<p>2.Service文件<br><br>对于Service文件只是声明此文件中将要实现的方法函数。</p>
<hr>
<h4 id="1-http-400-error"><a href="#1-http-400-error" class="headerlink" title="1.http 400 error"></a>1.http 400 error</h4><p>http 400 错误表示请求无效(bad request) 在ajax请求后台数据时会报http 400 错误，表示这个请求没有进入后台服务里。</p>
<ul>
<li><p>原因：<br>  1.前端提交数据的字段名称或者或者字段类型和后台的实体类不一致，或者前端提交的参数跟后台需要的参数不一致，导致参数无法封装。<br>  2.前端提交到后台的数据应该是JSON字符串类型，而前端没有将此对象转化为字符串类型。</p>
</li>
<li><p>解决方案：<br>  1.对照字段名称、类型保证一致性。<br>  2.使用stringify将前端传递的对象转化为字符串 如：data:JSON.stringify(param);</p>
</li>
</ul>
<hr>
<p>1.<code>JSON.toJSON()</code>方法可以将Date对象转换为字符串，并格式化为JSON数据格式。</p>
<pre><code>var Date = new Date();
var Date_New = Date.toJSON();
</code></pre><p>2.<code>JSON.toJSONString()</code>方法将对象转换为JSON格式数据。</p>
<hr>
<h2 id="Spring-开发注解"><a href="#Spring-开发注解" class="headerlink" title="Spring 开发注解"></a>Spring 开发注解</h2><pre><code>1.@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT) 表示该类需要Spring加入事务，propagation=Propagation.REQUIRED 属性指有事务就处于当前事务中，没有事务就创建一个事务。isolation=Isolation.DEFAULT 表示使用事务的默认隔离级别。
</code></pre><hr>
<h4 id="tld文件"><a href="#tld文件" class="headerlink" title=".tld文件"></a>.tld文件</h4><hr>
<h2 id="调试错误-状态码-400-404等"><a href="#调试错误-状态码-400-404等" class="headerlink" title="调试错误 状态码(400 404等)"></a>调试错误 状态码(400 404等)</h2><h4 id="1-http-400-Bad-request"><a href="#1-http-400-Bad-request" class="headerlink" title="1. http 400(Bad request)"></a>1. http 400(Bad request)</h4><p>在ajax请求后台数据时有时会报 HTTP 400 错误 - 请求无效 (Badrequest)，出现这个请求无效报错说明<code>请求没有进入到后台服务</code>里。</p>
<p><strong>原因：</strong></p>
<pre><code>1）前端提交数据的字段名称或者是字段类型和后台的实体类不一致，导致无法封装。
2）前端提交的到后台的数据应该是json字符串类型，而前端没有将对象转化为字符串类型。
</code></pre><p><strong>解决方案：</strong></p>
<pre><code>1）对照字段名称，类型保证一致性
2）使用stringify将前端传递的对象转化为字符串
    data: JSON.stringify(param)。
</code></pre><h4 id="2-空指针异常"><a href="#2-空指针异常" class="headerlink" title="2. 空指针异常"></a>2. 空指针异常</h4><p><strong>1.空指针异常发生情况</strong></p>
<pre><code>1.字符串变量没有初始化
2.接口类型的对象没有用具体的类初始化
    如：
        List list;//这个就会报错
        List list = new ArrayList();//这就不会报错

3.在一个对象的值为空，而我们没有判断为空的情况时会报错
</code></pre><p><strong>2.空指针异常解决方案</strong><br><br>重点关注报错发生在的行，通过空指针异常产生的两条主要原因诊断具体的错误。同时为了避免空指针的发生，最好在做判断处理时将“null”或者空值放于设定的值之前。</p>
<blockquote>
<p>注意：大多数的空指针异常都是与对象的操作相关</p>
</blockquote>
<h4 id="3-springmvc"><a href="#3-springmvc" class="headerlink" title="3. springmvc"></a>3. springmvc</h4><pre><code>//判断obj是否空指针，如果是则抛出空指针异常
Objects.requireNonNull(obj);
</code></pre><p><strong>1.修</strong><br></p>
<pre><code>//这表示修改之前首先获取到需要修改的信息，返回给前台
@RequestMapping(&quot;/student/mod/{sid}&quot;)
public String student_modify(@PathVariable(&quot;sid&quot;) Integer sid, Model model, HttpSession session) {
    Objects.requireNonNull(sid);

    Student student = studentService.findById(sid);
    Integer tid = (Integer) session.getAttribute(Constant.SESSION_KEY_FOR_TEACHER_ID);
    Teacher admin = teacherService.findById(tid);

    model.addAttribute(&quot;student&quot;, student);
    model.addAttribute(&quot;admin&quot;, admin);
    return &quot;admin/student_mod&quot;;
}

//表示在上面的获取修改的值之后，在这里执行修改操作
@RequestMapping(&quot;/student/mod/do&quot;)
public String student_modify_do(Student student) {

    LOG.info(&quot;modify: &quot; + student);
    student.setYear(Integer.valueOf(student.getGrade()) + 4 + &quot;&quot;);
    studentService.saveOrUpdate(student);

    return &quot;redirect:/admin/student&quot;;
}
</code></pre><p><strong>2.删</strong><br></p>
<pre><code>//这里表示根据所在项的id值删除该项
@RequestMapping(&quot;/student/dlt/{sid}&quot;)
@ResponseBody
public Object student_delete(@PathVariable(&quot;sid&quot;) Integer sid, Model model) {
    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();

    LOG.info(&quot;delete student: sid = &quot; + sid);
    Student student = studentService.findById(sid);
    try {
        studentService.delete(sid);
        LOG.info(&quot;delete student = &quot; + student);
        result.put(&quot;code&quot;, ResultCodeEnum.SUCCESS.getVal());
    } catch (Exception e) {
        result.put(&quot;code&quot;, ResultCodeEnum.FAILED.getVal());
    }
    return result;
}
</code></pre><p><strong>3.增</strong><br></p>
<pre><code>//首先给出添加页面
@RequestMapping(&quot;/student/add&quot;)
public String student_add(Model model, HttpSession session) {
    Integer tid = (Integer) session.getAttribute(Constant.SESSION_KEY_FOR_TEACHER_ID);
    Teacher admin = teacherService.findById(tid);

    model.addAttribute(&quot;admin&quot;, admin);
    return &quot;admin/student_add&quot;;
}

//增加操作
@RequestMapping(&quot;/student/add/do&quot;)
public String student_add_do(Student student) {

    LOG.info(&quot;add student = &quot; + student);
    studentService.saveOrUpdate(student);

    return &quot;redirect:/admin/student&quot;;
}
</code></pre><p><strong>4.DataTables分页插件</strong><br></p>
<pre><code>@RequestMapping(value = &quot;/thesis-varify/process/{year}/{modify}&quot;, produces = {&quot;application/json;charset=UTF-8&quot;})
@ResponseBody
public Object thesisVarifyProcess(@PathVariable(&quot;year&quot;) String year,
                                  @PathVariable(&quot;modify&quot;) Integer modify,
                                  //这标签的作用是将其绑定在request上面
                                  @DataTableArgument DataTableRequest dtRequest,
                                  @RequestParam(value = &quot;showColumns[]&quot;, required = false) String[] showColumns) {

    //新建的接收前台的数据容器
    DataTableResponse&lt;ThesisVarifyVo&gt; dtResponse = new DataTableResponse&lt;&gt;();
    if (modify == -1) modify = null;
    List&lt;ThesisVarifyVo&gt; thesisVarifyVos = adminService
            .queryThesisVarifyVoForDataTable(dtRequest, showColumns, year, modify);
    //然后将从数据库中查询到的数据封装到返回前台的容器中
    dtResponse.setData(thesisVarifyVos);
    //表示查询的数据
    dtResponse.setRecordsFiltered(adminService
            .countFilteredThesisVarifyVoForDataTable(dtRequest, showColumns, year, modify));
    //表示总的记录
    dtResponse.setRecordsTotal(adminService.countTotalThesisVarifyVoForDataTable());
    dtResponse.setDraw(dtRequest.getDraw());

    return JSON.toJSONString(dtResponse);
}
</code></pre><p><strong>5.DataTables服务端参数</strong><br></p>
<pre><code>1.发送到服务器端的参数
    draw 计数器，返回数据用这个记录
    start 开始记录
    length 每页条数
    search[value] 检索文字
    order[i][column] int 排列列的序号，i表示有几个排序 order[0][column]表示有一个服务器端
    order[i][dir] 排序方式“desc” “asc”

    注：下面comuns中的i取值从0~columns.length，所有的columns信息都发送到了服务器
        columns[i][data]：columns上定义的data属性值
        columns[i][name]：columns上定义的name属性值
        columns[i][searchable]：列能不能检索
        columns[i][orderable]：列能不能排序
        columns[i][search][value]：列的检索值 string

2.服务器返回的数据
    draw：和Request的draw设定成一样的值
    recordsTotal：所有的总件数
    recordsFiltered：筛选后的总件数
    data：返回的数据
        每一行数据上面，可以包含这几个可选项
            DT_RowId：加在行上的ID值
            DT_RowClass：加在行上的Class
            DT_RowData：加在行上的额外数据（object）
            DT_RowAttr：加在行上的属性（object）
            error:如果有错误，就设定这个值，没有错误，不要包含这个值
</code></pre><hr>
<h2 id="前台向后端传参数"><a href="#前台向后端传参数" class="headerlink" title="前台向后端传参数"></a>前台向后端传参数</h2><h4 id="1-get方式"><a href="#1-get方式" class="headerlink" title="1.get方式"></a>1.get方式</h4><pre><code>&lt;a href=&quot;/teacher/coursework/export?courseName=${tWorks.courseName}&quot; class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; 下载《${tWorks.courseName}》作业表&lt;/a&gt;
</code></pre><h4 id="2-post方式"><a href="#2-post方式" class="headerlink" title="2.post方式"></a>2.post方式</h4><hr>
<h2 id="mysql联合查询-3表联合查询"><a href="#mysql联合查询-3表联合查询" class="headerlink" title="mysql联合查询(3表联合查询)"></a>mysql联合查询(3表联合查询)</h2><pre><code>//最开始的mysql 3表联合查询语句
SELECT
    student_course_work.sclass,
    student.sname,
    student.sno,
    student_course_work.submit_time,
    teacher_course_work.course_name
FROM
    student_course_work
INNER JOIN student ON student.id = student_course_work.sid
INNER JOIN teacher_course_work ON teacher_course_work.tid = student_course_work.tid
WHERE
    course_id = #{courseId}
</code></pre><blockquote>
<p>注意：这里需要说明一点的就是，这里的联合查询会出现重复的结果，所以在这种情况下的查询是不能使用的。</p>
</blockquote>
<pre><code>//修改后的mysql联合查询语句
SELECT
    student_course_work.sclass,
    student.sname,
    student.sno,
    student_course_work.submit_time,
    teacher_course_work.course_name
FROM
    student_course_work
INNER JOIN student ON student.id = student_course_work.sid
INNER JOIN teacher_course_work ON teacher_course_work.id = student_course_work.course_id
WHERE
    course_id = #{courseId}
</code></pre><hr>
<h2 id="FreeMarker-contains-amp-seq-contains"><a href="#FreeMarker-contains-amp-seq-contains" class="headerlink" title="FreeMarker - contains &amp; seq_contains"></a>FreeMarker - contains &amp; seq_contains</h2><h4 id="1-contains"><a href="#1-contains" class="headerlink" title="1.contains"></a>1.contains</h4><p>该字段是String上的方法，作用与字符串上，主要用来查找字符串或者字符是否存在在指定的字符串中，返回true or false。</p>
<h4 id="2-seq-contains"><a href="#2-seq-contains" class="headerlink" title="2.seq_contains"></a>2.seq_contains</h4><p>如果要判断序列中是否包含某个指定的元素，可以使用序列的内建函数seq_contains。</p>
<blockquote>
<p>注1：seq_contains这个内建函数从FreeMarker 2.3.1 版本开始可用。而在2.3版本中不存在。</p>
<blockquote>
<p>注2：在开发过程中，该查找的参数大多数情况下都是返回数据，需要注意数据类型一致，如果数据类型不一致会报错。</p>
</blockquote>
</blockquote>
<hr>
<h2 id="权限-Permissions"><a href="#权限-Permissions" class="headerlink" title="权限 Permissions"></a>权限 Permissions</h2><p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p>
<pre><code>1.在执行视图的dispatch()方法前，会先进行视图访问权限的判断
2.在通过get_object()获取具体对象时，会进行对象访问权限的判断
</code></pre><hr>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>在向map中插入值的时候，注意前后类型的区别。</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
//key和value值的类型都是String
map.put(&quot;name&quot;,name);

Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
//key和value的值分别是String和Integer
map.put(&quot;sno&quot;,sno);

Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
//key的类型必须是String，而sno的类型可以是任意的，Integer，String等。
map.put(&quot;sno&quot;,sno);
</code></pre><hr>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>获取List集合中的一行，使用<code>list.get(i)</code>，然后再获取该行中的某一列<code>list.get(i).getName();</code></p>
<hr>
<h2 id="Ajax提交表单-SpringMVC接收"><a href="#Ajax提交表单-SpringMVC接收" class="headerlink" title="Ajax提交表单 SpringMVC接收"></a>Ajax提交表单 SpringMVC接收</h2><h4 id="1-serialize-方法"><a href="#1-serialize-方法" class="headerlink" title="1.serialize()方法"></a>1.serialize()方法</h4><p><strong>1.1 前台JavaScript的编写</strong><br></p>
<pre><code>function insert(){
    $.ajax({
        type:&quot;POST&quot;,
        url:&quot;${pageContext.request.contextPath}/order/insert&quot;,
        data : $(&quot;#fom&quot;).serialize(),             
        success  :function (res) {
            console.log(res); 
        error:function () {                
        }
    });
}
</code></pre><p><strong>1.2 后台SpringMVC的数据接收</strong><br></p>
<pre><code>@RequestMapping(value = &quot;/insert&quot;,method = RequestMethod.POST)
public String insert( Order order){
   int result=this.orderSerivce.insert(order);
   if(result==1){
       System.out.println(&quot;添加失败&quot;);
       return &quot;101&quot;;
   }
   return &quot;100&quot;;
}
</code></pre><blockquote>
<p>注意：后台SpringMVC用对象参数接收，可以自动转换为对象，需要注意name要和对象中的参数名相同。</p>
</blockquote>
<h4 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2.JSON.stringify()"></a>2.JSON.stringify()</h4><p><strong>2.1 前台程序的编写</strong><br></p>
<pre><code>function insert(){
    $.ajax({
        type:&quot;POST&quot;,
        url:&quot;${pageContext.request.contextPath}/user/insert&quot;,
        async:false,
        data :JSON.stringify({
            username : $(&quot;input[name=&apos;username&apos;]&quot;).val(),
            password: $(&quot;input[name=&apos;password&apos;]&quot;).val(),
            role : {
                id : &quot;&quot;,
                name: $(&quot;select[name=&apos;name&apos;]&quot;).val()
            }
        }),
        contentType: &quot;application/json;charset=UTF-8&quot;,
      /*如果不写这个,仔细看后台会出现Content type &apos;application/x-www-form-urlencoded;charset=UTF-8&apos; not supported   */ 
        dataType:&quot;json&quot;,
        success  :function (res) {
            console.log(res);
            if(res==100){
                $(&quot;#msg&quot;).html(&quot;&lt;font size=&apos;60px&apos;&gt; success &lt;/font&gt;&quot;).show(700).delay(3000).hide(500);
            }else {
                $(&quot;#msg&quot;).html(&quot;&lt;font size=&apos;60px&apos;&gt;  fail &lt;/font&gt;&quot;).show(700).delay(3000).hide(500);
            }
            window.location.href=&quot;http://localhost:8080/user/findall?page=1&quot;
        },
        error:function () {
            $(&quot;#msg&quot;).html(&quot;&lt;font size=&apos;60px&apos;&gt;  fail &lt;/font&gt;&quot;).show(700).delay(3000).hide(500);
            window.location.href=&quot;http://localhost:8080/user/findall?page=1&quot;
        }
    });
}
</code></pre><p><strong>2.2 后台程序的编写</strong><br></p>
<pre><code>@ResponseBody
@RequestMapping(value = &quot;/insert&quot;,method = RequestMethod.POST)
public String insert(@RequestBody User user){
   int result=this.userSerivce.insert(user);
   if(result==0){
       return &quot;101&quot;;
   }
   return &quot;100&quot;;
}
</code></pre><blockquote>
<p>注意：后台用@RequestBody接收, @RequestBody只接收JSON对象的字符串，所以在前台开始的时候需要将json格式对象转换成json格式对象的字符串格式。</p>
</blockquote>
<p><strong>2.3 JSON.parseObject() | JSON.toJSONString() 区别</strong><br><br>JSON.parseObject，是将Json字符串转化为相应的对象；JSON.toJSONString则是将对象转化为Json字符串。</p>
<hr>
<h2 id="SpringMVC-项目开发经验"><a href="#SpringMVC-项目开发经验" class="headerlink" title="SpringMVC 项目开发经验"></a>SpringMVC 项目开发经验</h2><h2 id="Java-文件流"><a href="#Java-文件流" class="headerlink" title="Java 文件流"></a>Java 文件流</h2><p>我们衡量输入、输出时总是站在运行本程序所在内存的角度。</p>
<hr>
<h3 id="javascript-–-gt-replace-g-“-“-g-是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。"><a href="#javascript-–-gt-replace-g-“-“-g-是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。" class="headerlink" title="javascript –&gt; replace(/-/g, “/“) /-/g 是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。"></a>javascript –&gt; replace(/-/g, “/“) /-/g 是正则表达式，表示素有短横线替换为斜杠，其中g表示全局替换。</h3><hr>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Redis/" itemprop="url">Redis</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:47:28+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,152
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  56
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>[TOC]</p>
<h3 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h3><ul>
<li>IDEA集成Redis可视化插件，直接在IDEA的setting的plugin中下载Iedis安装就行(付费)。</li>
<li>Redis可视化工具 RedisDestopManager</li>
</ul>
<p>Redis 是一个基于内存的高性能key-value数据库，通过提供多种键值数据类型来适应不同场景下的存储需求。<br></p>
<blockquote>
<p>应用场景：1.会话缓存(session cache)(数据查询、短链接、新闻内容、商品内容等) 2.全页缓存(FPC) 3.任务队列(秒杀、抢购、12306) 4.排行榜/计数器 5.发布/订阅 6.分布式集群架构中的session分离 7.数据过期处理</p>
</blockquote>
<blockquote>
<p>扩展：为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。NoSQL：not-Only SQL表示非关系型数据库，作为关系型数据库的良好补充。</p>
</blockquote>
<h4 id="1-Redis特点"><a href="#1-Redis特点" class="headerlink" title="1.Redis特点"></a>1.Redis特点</h4><p>优点：<br><br>1.速度快，因为数据都是存储在内存中的，类似于HashMap，HashMap的优势就在于查找和操作的时间复杂度都为O(1)。Redis在本质上是一个<code>KEY-VALUE</code>类型的内存数据库，很像<code>memcached</code>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。<br></p>
<p>2.由于其是纯内存操作，所以性能非常好，是已知性能最快的key-value DB。<br></p>
<p>3.reids支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached只能保存1MB数据。<br></p>
<p>4.支持丰富的数据类型，支持string，list，set，sorted set，hash。</p>
<p>5.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>6.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<p>缺点：<br><br>7.reids的缺点主要是，数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h4 id="2-Redis支持的数据类型"><a href="#2-Redis支持的数据类型" class="headerlink" title="2.Redis支持的数据类型"></a>2.Redis支持的数据类型</h4><ul>
<li>String  可以是字符串，整数或浮点数，对整个字符串或者字符串中的一部分执行操作。</li>
<li>List 表示一个链表</li>
<li>Sets 求交集/并集</li>
<li>Sorted Set</li>
<li>hashs</li>
</ul>
<h4 id="3-Redis需要将所有数据放到内存中的原因"><a href="#3-Redis需要将所有数据放到内存中的原因" class="headerlink" title="3.Redis需要将所有数据放到内存中的原因"></a>3.Redis需要将所有数据放到内存中的原因</h4><p>1.Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。<br><br>2.如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br><br>3.如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<blockquote>
<p>注意：1.reids是单进程单线程的，利用队列技术将并发访问变成串行访问，消除传统数据库串行控制的开销。<br>2.</p>
</blockquote>
<h4 id="4-Redis常见性能问题解决"><a href="#4-Redis常见性能问题解决" class="headerlink" title="4.Redis常见性能问题解决"></a>4.Redis常见性能问题解决</h4><p>1.master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。<br><br>2.如果数据比较重要，某个<code>Slave</code>开启<code>AOF</code>备份数据，策略设置为每秒同步一次。(slave?aof?是啥)<br><br>3.为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。<br><br>4.尽量避免在压力很大的主库上增加从库。<br><br>5.从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3等，这样的结构方便解决单点故障问题，实现Slave对Master的替换，如果Master挂了可以立刻启用Slave1做Master，其他不变。</p>
<h4 id="5-Redis与memcached的区别"><a href="#5-Redis与memcached的区别" class="headerlink" title="5.Redis与memcached的区别"></a>5.Redis与memcached的区别</h4><p>1.memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。<br><br>2.redis的速度比memcached快很多。<br><br>3.redis可以持久化其数据。(数据的持久化就是将内存中的数据模型转化为存储模型，数据模型是任何的数据结构或者是对象，存储模型可以是关系型/xml文件/二进制流) </p>
<p>狭义：持久化仅仅是将对象数据永久保存在数据库中。</p>
<p>广义：持久化包括和数据库相关的各种操作，封装数据访问细节，为大部分业务逻辑提供面向对象的API。</p>
<h4 id="6-Redis持久化方案区别-优缺点"><a href="#6-Redis持久化方案区别-优缺点" class="headerlink" title="6.Redis持久化方案区别/优缺点"></a>6.Redis持久化方案区别/优缺点</h4><p>首先我们知道，Redis为我们提供两种持久化的方式，RDB(Redis DataBase)/AOF(Append Only File)。<br>1.RDB方式：快照式的持久化方法，将某一时刻的数据持久化到磁盘中。</p>
<pre><code>1.因为Redis在持久化的过程中，会首先将数据写入到一临时文件中，在持久化过程都结束之后才会用此临时文件替换已经持久化好的文件。所以因为这个特性让我随时进行备份。
2.于RDB方式，Redis单独创建一个子进程来进行持久化，主进程不会进行任何IO操作，这就确保Redis很好的性能。
3.如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
</code></pre><p>2.AOF方式：将执行过的 <code>写指令</code> 记录下来，在数据恢复时按照<code>从前到后</code>的顺序再将指令执行一遍。</p>
<pre><code>1.AOF 命令以Redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。默认的 AOF 持久化策略是每秒钟 fsync 一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。

2.如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。

3.因为此种是采用追加的方式，所以如果我们不做任何处理的话，AOF文件会变得越来越大。所以在此Redis提供AOF文件重写机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

4.在进行AOF重写时，我们仍然采用是先写临时文件，最后在全部完成之后再替换掉的流程，所以在断电、磁盘满等问题都不会影响AOF文件的可用性。
</code></pre><h4 id="7-如何维护集群之间的关系-集群之间如何建立连接"><a href="#7-如何维护集群之间的关系-集群之间如何建立连接" class="headerlink" title="7.如何维护集群之间的关系(集群之间如何建立连接)"></a>7.如何维护集群之间的关系(集群之间如何建立连接)</h4><h4 id="8-Redis存取实体的方式"><a href="#8-Redis存取实体的方式" class="headerlink" title="8.Redis存取实体的方式"></a>8.Redis存取实体的方式</h4><p>在存储的时候需要将实体 <code>序列化</code> ，然后可以当字符串一样存储，取数据也一样，取出来的数据要 <code>反序列化</code> 。</p>
<h4 id="9-Redis保留时间"><a href="#9-Redis保留时间" class="headerlink" title="9.Redis保留时间"></a>9.Redis保留时间</h4><p>Redis保留时间在未设置的情况下会一直存在，除非服务停掉且没有保存到磁盘。如果已手动或自动保存过，则再次启动服务还会存在。</p>
<hr>
<h3 id="将Redis配置成服务"><a href="#将Redis配置成服务" class="headerlink" title="将Redis配置成服务"></a>将Redis配置成服务</h3><p>将redis做成服务之后，后面就可以直接在cmd中输入命令 redis-server –service-start 启动</p>
<pre><code>redis-server --service-install redis-windows-conf 在redis的目录执行，将redis做成服务
</code></pre><h3 id="cmd命令框进入Redis目录，输入-redis-server-exe-redis-windows-conf-命令启动redis服务"><a href="#cmd命令框进入Redis目录，输入-redis-server-exe-redis-windows-conf-命令启动redis服务" class="headerlink" title="cmd命令框进入Redis目录，输入 redis-server.exe  redis.windows.conf 命令启动redis服务"></a>cmd命令框进入Redis目录，输入 redis-server.exe  redis.windows.conf 命令启动redis服务</h3><hr>
<blockquote>
<p>提示：Redis虽然是作为数据库开发，但是还可以作为缓存、队列系统使用。Redis可以为每个键设置生存时间TTL，到时间之后就是自动删除。</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>所谓事务就是一组命令的集合，事务同命令一样都是Redis最小执行单位，一个事务中的命令要么执行，要么都不执行。</p>
<h2 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>NoSql是一种解决高并发、高可用、高可扩展性以及大数据存储等系列问题的解决方案。</p>
<blockquote>
<p>提示：NoSql是非关系型数据库，不能代替关系型数据库，只是关系型数据库的一个良好补充。</p>
</blockquote>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><pre><code>1.键值存储（key-value）

2.列存储

3.文档数据库（mogondb）

4.图形数据库
</code></pre><h4 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h4><p>缓存、分布式集群架构session分离、任务队列等。然后它的应用场景真的很多。</p>
<h4 id="Redis处理逻辑"><a href="#Redis处理逻辑" class="headerlink" title="Redis处理逻辑"></a>Redis处理逻辑</h4><p>用户请求过来之后，首先判断Redis里面是否存在，如果存在则直接返回Redis中的数据给用户，没有则查询数据库。如果数据库中不存在则返回空或者提醒用户。</p>
<p><strong>1.添加操作</strong><br><br>如果是需要放入缓存的数据，那么在向mysql数据库中插入成功后，生成对应的key值，并存入Redis中。</p>
<p><strong>2.修改操作</strong><br><br>向mysql数据库中修改成功后，修改Redis中的数据，但是Redis并没有更新语句，所以只能先删除，再添加完成更新操作。</p>
<blockquote>
<p>注意：程序操作Redis的操作可能会失败，那么此时mysql中的数据已经修改，但是Redis中的数据依旧是上一次的数据，从而导致数据不一致的问题，所以是先操作Redis还是mysql需要注意。</p>
</blockquote>
<p><strong>3.删除操作</strong><br><br>和修改操作一样，先删除数据，然后再更新缓存，但是还得注意数据一致性的问题。</p>
<p><strong>4.查询操作</strong><br><br>首先通过Redis查询，如果缓存中已经存在数据则直接返回即可，此时就不再需要通过mysql数据库来获取数据，减少对mysql的请求，如果缓存中不存在数据，则依然通过mysql数据库查询，查询到数据后，存入Redis缓存中。</p>
<h4 id="缓存存储策略"><a href="#缓存存储策略" class="headerlink" title="缓存存储策略"></a>缓存存储策略</h4><p><strong>1.缓存数据特点</strong><br></p>
<pre><code>1.热点数据
2.实时性要求不高数据
3.业务逻辑简单数据
</code></pre><p><strong>2.缓存失效策略</strong><br></p>
<ul>
<li>定时删除，在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</li>
<li>惰性删除，key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期则删除，返回null。</li>
<li>定期删除，每隔一段时间执行一次删除过期key操作。</li>
<li></li>
</ul>
<hr>
<blockquote>
<p>在Linux中安装并配置好redis之后启动</p>
</blockquote>
<pre><code>1. ./redis-server 命令只是前端启动，在启动之后不能做任何操作

    ctrl + c 停止启动前端模式

2. ./redis-server ./redis.conf 这里的redis配置文件已经修改过

3. ./bin/redis-cli shutdown 停止redis客户端

4. ./bin/redis-cli 进入当前redis的客户端
</code></pre><hr>
<h2 id="Redis可执行文件说明"><a href="#Redis可执行文件说明" class="headerlink" title="Redis可执行文件说明"></a>Redis可执行文件说明</h2><pre><code>命令名 | 命令说明
---|---
redis-server | redis服务器
redis-cli | redis命令行客户端
redis-benchmark | redis性能测试工具
redis-check-aof | aof文件修复工具
redis-check-dump | RDB文件检查工具
redis-sentinel | sentinel服务器（2.8以后）
</code></pre><hr>
<h2 id="Redis-API的理解和使用"><a href="#Redis-API的理解和使用" class="headerlink" title="Redis API的理解和使用"></a>Redis API的理解和使用</h2><pre><code>1.keys[pattern] 遍历所有key，时间复杂度是O(N)
2.dbsize 遍历所有key，时间复杂度O(1)
3.expire key seconds key在seconds秒后过期，时间复杂度是O(1)
4.ttl key 查看key剩余的过期时间 时间复杂度是O(1)
5.persist key 去掉key的过期时间    O(1)
6.exists 检查key是否存在 O(1)
7.del key 删除指定的key-value O(1)
</code></pre><hr>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1.String（字符串）"></a>1.String（字符串）</h4><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
<pre><code>字符串常用的命令：

    1.赋值

        1. set key value

    2.取值

        1. get key

    3.先获取值在设置值

        1. getset key value

    4.删除

        1. del key

    5.数值的增减

        1. incr key 将指定的key的value递增1，如果该值不存在则初始化为0之后再incr后为1，如果value值不能转换成整型，操作失败

        2. decr key 将指定的key的value递减1，如果该值不存在则初始化为0之后再decr后为-1，如果value值不能转换成整型，操作失败

    6.扩展命令

        1. incrby key m 将指定的key的value值递增m，其它的类似上面的操作

        2. decrby key m 将指定的key的value值递减m，其它的类似上面的操作

        3. append key m 将在指定的key之后追加m，然后返回的是该字符串的长度（3 + 5 = 35）
</code></pre><h4 id="2-Hash（哈希）"><a href="#2-Hash（哈希）" class="headerlink" title="2.Hash（哈希）"></a>2.Hash（哈希）</h4><p>Redis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<blockquote>
<p>提示：可以看作是具有string的key和string的value的类型的map容器</p>
</blockquote>
<pre><code>哈希常用命令：

    1. 存储

        1. hset key keyOne value 表示在名字为key的哈希中存放一个键值对（keyOne，value）

        2. hmset key keyOne valueOne keyTwo valueTwo 表示在名字为key的哈希中一次性存放多个键值对

    2. 取值

        1. hget key keyone 表示在key的哈希中取到哪个属性

        2. hmget key keyone keytwo 表示一次性可以取得多个属性值

        3. hgetall key 获取key中的所有属性和属性值

    3. 删除

        1. hdel key keyone 删除一个或多个

        2. del key 删除整个集合

    4. 数值的增加

        1. hincrby key value m 表示给key集合中的value值增加m

    5. 自学命令

        1. hexists key keyOne 判断哈希key中的keyone是否存在，存在返回1

        2. hlen key 得到哈希key中有多少个属性

        3. hkeys key 获取所有的属性

        4. hvals key 获取key集合里面所有的值
</code></pre><blockquote>
<p>提示： Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。每个 hash 可以存储 2^32 -1 键值对（40多亿）。</p>
</blockquote>
<h4 id="3-List（列表）"><a href="#3-List（列表）" class="headerlink" title="3.List（列表）"></a>3.List（列表）</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<pre><code>链表常用命令：

    1. 两端添加

        1. lpush key valueOne valueTwo valueThree ... 从左端向list中添加数据

        2. rpush key valone valtwo valthree ... 从右侧向list中添加数据

    2. 查看列表

        1. lrange key m n 查看m到n之间的数据元素

    3. 两端弹出

        1. lpop key 左端弹出

        2. rpop key 右端弹出

    4. 获取列表元素个数

        1. llen key 获取列表中元素的个数

    5. 扩展命令

        1. lpushx key x 只有在key列表存在的时候才会向其头部插入x

        2. rpush key x ...右侧insert

        3. lrem key count keyone 在list列表中删除count个keyone，当count为0时，删除里面所有的keyone

        4. lset key count keytwo 在list列表中指定的count角标处插入某一个值keytwo

        5. linsert key before keyOne valueOne 在key列表中的keyone之前插入valueone（之后只需要before改成after）

        6. rpoplpush listOne listTwo 将listone里面的尾部数据弹出压入到listTwo的头部
</code></pre><h4 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4.Set（集合）"></a>4.Set（集合）</h4><p>Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<blockquote>
<p>sadd 命令 添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p>
</blockquote>
<pre><code>set常用命令：

    1. 添加

        1. sadd key value1 value2 value3 ... 向set中添加值

    2. 删除

        1. srem key value1 value2 ... 删除set中存在的value


    3. 获得集合中元素

        2. smembers key 查看key的set中有哪些元素

        3. sismember key m 判断m是否存在set集合中 

    4. 集合中差集的运算

        1. sdiff setone settwo 比较两个set集合中的差集

    5. 集合的交集运算

        1. sinter setone settwo 比较两个set集合中相同的部分

    6. 集合的并集运算

        1. sunion setone settwo 并集操作

    7. 扩展命令

        1. scard setOne 获取set集合中的元素个数

        2. srandmember setone 随机获取set集合中的元素

        3. sdiffstore setstore setOne setTwo 将setOne与setTwo集合之间相差的值存储到setstore中

        4. sinterstore ... 求两个集合的交集然后存储到新的set中去

        5. sunionstore ... 求两个集合的并集然后存储到新的set中去
</code></pre><h4 id="5-zset-sorted-set：有序集合"><a href="#5-zset-sorted-set：有序集合" class="headerlink" title="5.zset(sorted set：有序集合)"></a>5.zset(sorted set：有序集合)</h4><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<blockquote>
<p>zadd 命令 添加元素到集合，元素在集合中存在则更新对应score</p>
</blockquote>
<pre><code>常用命令：

    1. 添加

        1. zadd keyset socre keyOne ... 向zset中添加元素

    2. 获取

        1. zscore keyset keyone 获取keyone的分数

        2. zcard keyset 获取keyset中具体的成员数量

    3. 删除

        1. zrem keyset keyOne 删除keyone这个元素

        2. zremrangebyrank keyset 0 4 按照范围来进行删除

        3. zremrangebyscore keyset 80 100 按照分数进行删除，删除80-100之间的元素



    4. 查看

        1. zrange keyset 0 -1 查看所有的元素

        2. zrange keyset 0 -1 withscores 查看所有带有分数的元素

    5. 扩展命令

        1. zincrby keyset count keyOne 将keyOne的值加上count

        2. zcount keyset 80 90 查看80-90之间成员的个数

        3. 
</code></pre><h4 id="6-Redis的keys的通用操作"><a href="#6-Redis的keys的通用操作" class="headerlink" title="6.Redis的keys的通用操作"></a>6.Redis的keys的通用操作</h4><pre><code>常用命令：

    1. keys * 查看所有key

    2. keys keyset? 查看keyset开头的key名称

    3. expire key 1000 设置时间

    4. type keyset 查看类型

    5. ttl keyset 查看ttl
</code></pre><h4 id="7-Redis事务特性"><a href="#7-Redis事务特性" class="headerlink" title="7.Redis事务特性"></a>7.Redis事务特性</h4><pre><code>1. multi 开启事务

2. exec 提交事务

3. discard 回滚事务

4. watch 是一个乐观锁，可以在执行exec命令之前监视任意数量的数据库键，在exec命令执行时，检查被监视的键是否有一个是否已经被修改，如果是则服务器拒绝执行事务。
</code></pre><h4 id="8-Redis脚本命令"><a href="#8-Redis脚本命令" class="headerlink" title="8.Redis脚本命令"></a>8.Redis脚本命令</h4><p>Redis 脚本使用 Lua 解释器来执行脚本。 Reids 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>
<pre><code>脚本常用命令：

    1. 
</code></pre><h4 id="9-数据备份与恢复"><a href="#9-数据备份与恢复" class="headerlink" title="9.数据备份与恢复"></a>9.数据备份与恢复</h4><p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<h4 id="10-Redis管道技术"><a href="#10-Redis管道技术" class="headerlink" title="10.Redis管道技术"></a>10.Redis管道技术</h4><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。</p>
<p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p>
<h4 id="11-Redis数据库"><a href="#11-Redis数据库" class="headerlink" title="11.Redis数据库"></a>11.Redis数据库</h4><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中。</p>
<blockquote>
<p>提示：dbnum属性的值由服务器配置的database选项决定，默认情况下是16，所以Redis服务器默认会创建16个数据库。</p>
</blockquote>
<p><strong>1.切换数据库</strong><br></p>
<pre><code>1.默认情况下会选择0号数据库，SELECT 命令来切换到目标数据库

    通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能，这是SELECT命令的实现原理。


2.清空整个数据库的 flushdb 命令，通过删除键空间中所有键值对实现。
</code></pre><p><strong>4.设置键的生存时间或过期时间</strong><br></p>
<pre><code>1. 设置过期时间

    通过expire命令或者pexpipe命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间TTL，在经过指定的时间之后服务器会删除生存时间为0的键。

    1. expire key ttl 将key的生存时间设置为ttl秒

    2. pexpire key ttl 将key的生存时间设置为ttl毫秒

    3. expireat key timestamp 将key过期时间设置为timestamp所指定的秒数时间戳

    4. pexpireat key timestamp 将key过期时间设置为timestamp所指定的毫秒数时间戳

    提示：pexpire、expire、expireat命令在最终转换之后的执行效果与pexpireat命令一样

2. 保存过期时间

    1. 

3. 移除过期时间

    1. persist命令可以移除一个键的过期时间 persist key

4. 计算并返回剩余生存时间

    1. TTL 命令以秒为单位返回键的剩余生存时间

    2. PTTL 命令以毫秒为单位返回键的剩余生存时间

5. 过期键的判定

    步骤：

        1. 检查给定键是否存在于过期字典，如果存在则取得键的过期时间

        2. 检查当前Unix时间戳是否大于键的过期时间，大于则过期，否则未过期
</code></pre><p><strong>5.过期键的删除策略</strong><br></p>
<pre><code>1. 定时删除，设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。

2. 惰性删除，放任键过期不管，但是每次获取键时，都检查取得的键是否过期，过期则删除

3. 定期删除，每隔一段时间都对数据库进行一次检查，删除里面的过期键
</code></pre><p><strong>6.AOF | RDB和复制功能对过期键的处理</strong><br></p>
<pre><code>1. 生存RDB文件

    在执行save命令或者bgsave命令创建新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

2. 载入RDB文件


3. AOF文件写入

    过期键在被惰性删除或定期删除之后，程序会向AOF文件追加一个del命令，显式记录该键已经被删除。
</code></pre><hr>
<h2 id="第9章-数据库"><a href="#第9章-数据库" class="headerlink" title="第9章 数据库"></a>第9章 数据库</h2><p>服务器中的数据库，服务器将素有数据库都保存在服务器状态 redis.h/redisServer结构的db数组中。</p>
<h3 id="9-1-切换数据库"><a href="#9-1-切换数据库" class="headerlink" title="9.1 切换数据库"></a>9.1 切换数据库</h3><p>Redis客户端在默认情况下，目标数据库是0号数据库，但客户端可以通过执行 SELECT 命令来切换目标数据库。</p>
<h3 id="9-4-设置键的生存时间或过期时间"><a href="#9-4-设置键的生存时间或过期时间" class="headerlink" title="9.4 设置键的生存时间或过期时间"></a>9.4 设置键的生存时间或过期时间</h3><p>通过 EXPIRE 命令或者 PEXPIRE 命令客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（TTL），在经过指定的秒数或毫秒数之后，服务器会自动删除生存时间为0的键。</p>
<p>SETEX 命令可以在设置一个字符串键的同时为键设置过期时间。</p>
<h3 id="9-5-过期键删除策略"><a href="#9-5-过期键删除策略" class="headerlink" title="9.5 过期键删除策略"></a>9.5 过期键删除策略</h3><p>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器的过期时间来临时，立即执行对键的删除操作。</p>
<p>…</p>
<hr>
<h2 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a>Redis持久化方案</h2><h4 id="1-Rdb方式"><a href="#1-Rdb方式" class="headerlink" title="1.Rdb方式"></a>1.Rdb方式</h4><p>这种方式是Redis默认的方式，redis通过快照来将数据持久化到磁盘。恢复时直接将快照文件读到内存中，来达到恢复数据。RDB持久化是指在==指定的时间间隔内将内存中的数据集快照写入磁盘。== 这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p>
<pre><code>命令生成RDB文件

    1. SAVE 该命令会阻塞Redis服务器进程，直到RDB文件创建完毕，在服务器阻塞期间，不能处理任何命令请求

    2. BGSAVE 该命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求

        BGSAVE命令被触发的条件：

            1.服务器在900秒内，对数据库进行至少一次操作

                save 900 1  #900秒内如果超过1个key被修改，则发起快照保存

            2.服务器在300秒内，对数据库进行至少10次操作

                save 300 10 #300秒内容如超过10个key被修改，则发起快照保存

            3.服务器在60秒内，对数据库进行至少10000次操作

                save 60 10000
1.优点

    1. 如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。

    2. RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。

    3. RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。
</code></pre><blockquote>
<p>注意：如果redis非法关闭，那么就会丢失最后一次持久化之后的数据。如果数据不重要，则可以不用关心。如果数据不允许丢失，那么使用aof方式。</p>
</blockquote>
<h4 id="2-Aof方式"><a href="#2-Aof方式" class="headerlink" title="2.Aof方式"></a>2.Aof方式</h4><p>Redis默认不使用该方式持久化，Aof方式的持久化，是操作一次Redis数据库，则将操作的记录存储到aof持久化文件中。将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)。当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p>
<pre><code>默认的保存配置：

    appendonly yes              //启用aof持久化方式

    # appendfsync always      //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用

    appendfsync everysec     //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐

    # appendfsync no    //完全依赖os，性能最好,持久化没保证
</code></pre><p>RDB持久化保存数据库状态的方法是将msg/fruits/numbers三个键的键值对保存到RDB文件中。</p>
<p>AOF持久化则是将服务器执行的SET/SADD/RPUSH三个命令保存到AOF文件。</p>
<p>AOF持久化功能可以分为：命令追加（append）、文件写入、文件同步（sync）。</p>
<hr>
<h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><p>Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis客户端在我们之前下载的的 redis 的安装包中。</p>
<h4 id="1-redis-cli"><a href="#1-redis-cli" class="headerlink" title="1.$ redis-cli"></a>1.$ redis-cli</h4><p>启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。如果需要在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。</p>
<pre><code>语法：$ redis-cli -h host -p port -a password
</code></pre><hr>
<h2 id="Redis-键-key"><a href="#Redis-键-key" class="headerlink" title="Redis 键(key)"></a>Redis 键(key)</h2><p>Redis 键命令用于管理 redis 的键。</p>
<pre><code>1.DEL key 该命令用于在 key 存在时删除 key。
2.DUMP key  序列化给定 key ，并返回被序列化的值。
3.EXISTS key 检查给定 key 是否存在。
4.EXPIRE key seconds 为给定 key 设置过期时间，以秒计。
5.EXPIREAT key timestamp  EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。
6.PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。
7.PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计
8.KEYS pattern  查找所有符合给定模式( pattern)的 key 。
9.MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。
10.PERSIST key  移除 key 的过期时间，key 将持久保持。
11.PTTL key  以毫秒为单位返回 key 的剩余的过期时间。
12.TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。
13.RANDOMKEY 从当前数据库中随机返回一个 key 。
14.RENAME key newkey  修改 key 的名称
15.RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。
16.TYPE key 返回 key 所储存的值的类型。
</code></pre><hr>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>执行slaveof命令或者设置slaveof选项，让一个服务器去复制另一个服务器，称被复制的服务器是主服务器（master），而对主服务器进行复制的服务器是从服务器（slave）。</p>
<pre><code>1. 主服务器：能够进行读写操作

2. 从服务器：只能进行读操作
</code></pre><h4 id="1-主从复制的优点"><a href="#1-主从复制的优点" class="headerlink" title="1. 主从复制的优点"></a>1. 主从复制的优点</h4><pre><code>1. 数据冗余，实现数据的热备份

2. 故障恢复，避免单点故障带来的服务不可用

3. 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量

4. 高可用基础，是哨兵机制和集群实现的基础
</code></pre><h4 id="2-主从复制的配置"><a href="#2-主从复制的配置" class="headerlink" title="2. 主从复制的配置"></a>2. 主从复制的配置</h4><pre><code>1. 首先在xshell中建立三个连接窗口，并将redis.conf配置文件复制三份，将它们的端口改掉

2. 然后分别启动三个端口的redis客户端

3. info 命令查看每个redis服务在小型集群中扮演的角色

4. 然后在master中设置name值为name，那么在slave中也能得到name的值
</code></pre><h4 id="3-主从复制的实现原理"><a href="#3-主从复制的实现原理" class="headerlink" title="3. 主从复制的实现原理"></a>3. 主从复制的实现原理</h4><p>主从复制可以分为三个阶段：1.连接建立 2.数据同步 3.命令传播。</p>
<pre><code>1. 连接建立

    1. slaveof命令之后，从服务器根据设置的master的ip地址和端口号，创建连向主服务器的socket套接字连接。

    2. 然后确认是否主服务器可用，发送ping命令。

    3. 身份验证，如果主服务器设置了requirepass选项，那么从服务器必须配置masterauth选项。

    4. 在身份验证完之后，从服务器会发送自己的监听端口，主服务器会保存下来。

2. 数据同步

    在主服务器与从服务器连接确认各自身份之后，就开始同步数据，从服务器向主服务器发送 PSYNC 命令，执行同步操作，并将自己的数据库状态更新到主服务器的数据库状态。主要分为完整重同步和部分重同步。

    1. 完整重同步

        1. slave连接上master第一次复制的时候是完整同步

        2. 如果当主从断线，重新连接复制的时候有可能是完成重同步。

    2. 部分重同步

        用于处理断线后重复制的情况

3. 命令传播

    在完成数据同步之后，主从服务器的数据暂时达到一定状态，在主服务器执行了客户端的写命令之后，主从数据库不再一致。所以此时为了保持一致性，每执行一个命令都会向从服务器发送同样的写命令。

4. 心跳检测

    在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送命令：

        REPLCONF ACK &lt;replication_offset&gt; replication_offset是从服务器当前的复制偏移量。

        发送replconf ack对于主服务器作用：

            1. 检测主从服务器的网络连接状态
            2. 辅助实现min-slave选项
            3. 检测命令丢失
</code></pre><hr>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>岗哨、哨兵是Redis的高可用性解决方案，其可以监视任意多个主服务器以及这些主服务器下的从服务器。</p>
<pre><code>1. 监控：哨兵会不断的检查master和slave是否运行正常

2. 提醒：当被监控的某个redis异常，哨兵可以通过API或者其它应用程序发送通知

3. 自动故障迁移：当一个master不能正常工作时，哨兵会开始一次自动故障迁移操作，会将失效的master的其中一个slave升级为新的master。
</code></pre><blockquote>
<p>提示：只靠redis主从复制和哨兵机制不足以实现redis高可用，理由是：因为如果某一节点死机之后，不会实现自动重启。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：最稳健实现高可用的方式，redis主从复制+哨兵监控（监控、提醒、自动故障迁移）+keepalived（自动重启），如果重启多次仍然不成功可以通过邮件或短信方式提醒。</p>
</blockquote>
</blockquote>
<h4 id="1-检测主观下线状态"><a href="#1-检测主观下线状态" class="headerlink" title="1. 检测主观下线状态"></a>1. 检测主观下线状态</h4><p>在默认的情况下，sentinel会以每秒一次的频率向所有与它创建了命令连接的实例发送ping命令，并通过ping命令回复来判断实例是否在线。</p>
<p>down-after-milliseconds选项值不仅会被sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器属下的所有从服务器，以及其他的主观下线状态。</p>
<h4 id="2-检测客观下线状态"><a href="#2-检测客观下线状态" class="headerlink" title="2. 检测客观下线状态"></a>2. 检测客观下线状态</h4><p>当sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线，它会向同样监视这一主服务器的其它sentinel进行询问，其它监控是否回答认为主服务器已经进入下线状态。</p>
<h4 id="3-选举领头羊"><a href="#3-选举领头羊" class="headerlink" title="3. 选举领头羊"></a>3. 选举领头羊</h4><p>在判断主服务器下线时，监视这个下线主服务器的各个sentinel会进行协商，选举出一个领头sentinel，并由领头sentinel对下线主服务器执行故障转移操作。</p>
<h4 id="4-故障转移"><a href="#4-故障转移" class="headerlink" title="4. 故障转移"></a>4. 故障转移</h4><p>在选举产生出领头sentinel之后，领头sentinel将对已下线的主服务器执行故障转移操作，该操作包括：</p>
<pre><code>1. 在已下线的主服务器属下的所有从服务器里面挑选出一个从服务器，并将其转换成主服务器。

2. 让已下线的主服务器属下的所有从服务器改为复制新的主服务器。

3. 将已下线的主服务器设置为新的主服务器的从服务器。
</code></pre><hr>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过==分片来进行数据共享，并提供复制符故障转移功能。==</p>
<pre><code>优点：

    1. 将数据自动切分到多个节点的能力

    2. 当集群中一部分节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力

    3. 支持动态扩容

数据共享：

    Redis使用数据分片而非一致性哈希

主从复制：

    集群中的每个节点都有1-n个复制品

一致性保证：

    集群不保证数据的强一致性，在特定条件下，Redis集群可能会丢失已经被执行过的写命令。
</code></pre><h3 id="1-节点"><a href="#1-节点" class="headerlink" title="1.节点"></a>1.节点</h3><p>一个redis集群通常由多个节点组成，要组建一个真正意思上的集群需要将各个独立节点连接起来，构成一个包含多个节点的集群。</p>
<p>连接各个节点的工作可以使用 CLUSTER MEET 命令完成。</p>
<pre><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;
</code></pre><p>CLUSTER NODES 命令查看集群中的各个节点。</p>
<p>一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据 cluster-enable 配置选项是否为 yes 来决定是否开启服务器的集群模式。</p>
<h3 id="2-槽指派"><a href="#2-槽指派" class="headerlink" title="2. 槽指派"></a>2. 槽指派</h3><p>Redis集群==通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这些槽中的其中一个，集群中每个节点可以处理0个或最多16384个槽。==</p>
<p>集群中内置这些槽之后，会将所有的物理节点映射到这些槽上，或者说将这些槽均等的分配给各个节点。当需要在Redis集群中存放一个数据（key-value）时，Redis会先对key进行crc16算法，然后得到一个结果，再将这个结果对16384取余，这个余数则对应【0-16383】中的一个槽，然后决定key-value存放在哪个节点中，所以某一个节点挂了，那么该节点对应的槽就无法使用，从而导致集群无法正常工作。</p>
<p>通过向节点发送 CLUSTER ADDSLOTS 命令，可以将一个或多个槽指派给节点负责。</p>
<h3 id="3-重新分片"><a href="#3-重新分片" class="headerlink" title="3. 重新分片"></a>3. 重新分片</h3><p>重新分片操作可以将任意数量的已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p>
<hr>
<h3 id="Linux集群搭建"><a href="#Linux集群搭建" class="headerlink" title="Linux集群搭建"></a>Linux集群搭建</h3><pre><code>1. 新建目录cluster存放将要配置的文件

    1. conf：存放配置文件
    2. data：存放数据
    3. logs：存放日志
    4. script：存放脚本

2. 配置redis.conf文件，配置端口号、cluster-enabled yes 的注释打开、然后配置文件的logs等。

3. 启动redis服务器

4. 查看是否启动服务器进程

    ps aux|grep redis

5. redis 5.0之后支持cluster

    ./bin/redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006
</code></pre><h2 id="Pipeline-流水线"><a href="#Pipeline-流水线" class="headerlink" title="Pipeline 流水线"></a>Pipeline 流水线</h2><h4 id="1-1次网络命令通信模型"><a href="#1-1次网络命令通信模型" class="headerlink" title="1. 1次网络命令通信模型"></a>1. 1次网络命令通信模型</h4><p>在客户端将命令通过网路传递到服务器，然后服务器经过计算之后返回结果给客户端的过程所用的时间为：</p>
<pre><code>1次时间 = 1次网络时间 + 1次命令时间
</code></pre><h4 id="2-批量网络命令模型"><a href="#2-批量网络命令模型" class="headerlink" title="2.批量网络命令模型"></a>2.批量网络命令模型</h4><p>表示在1次网络命令通信模型的迭代n次。那么在这过程中所用掉的时间时：</p>
<pre><code>n次时间 = n次网络时间 + n次命令时间
</code></pre><h4 id="3-流水线"><a href="#3-流水线" class="headerlink" title="3.流水线"></a>3.流水线</h4><p>在这里使用流水线技术，那么就是将所有命令打包在一起，然后用掉一次网络时间将所有的命令传递到服务器，然后服务器用掉n此命令时间处理计算这些命令，然后将计算结果返回给客户端。</p>
<pre><code>1次pipeline(n条命令) = 1次网络时间 + n次命令时间
</code></pre><blockquote>
<p>注意：Redis的命令时间时微秒级的。然后pipeline每次条数需要控制。</p>
</blockquote>
<blockquote>
<p>提示：pipeline只能作用在一个redis节点上面。</p>
</blockquote>
<hr>
<h2 id="第18章-Redis-发布-订阅"><a href="#第18章-Redis-发布-订阅" class="headerlink" title="第18章 Redis 发布/订阅"></a>第18章 Redis 发布/订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。这中机制类似于电台的发布，用户可以订阅多个电台的消息，然后电台发布消息供用户读取。</p>
<blockquote>
<p>理解：实现订阅和发布，那么在这里就有消息的发送方和接收方。</p>
<blockquote>
<p>发送方：1.通过JedisConnection的Pub/Sub相关的方法来向Redis服务发布消息。2.通过RedisTemplate的convertAndSend方法来实现这一功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>接收方：在接收方包括监听消息并输出，需要实现消息监听类，并且在xml中注册实现此类。</p>
</blockquote>
</blockquote>
<p><strong>1.两种方式实现监听类</strong><br></p>
<pre><code>1.实现MessageListener接口，实现onMessage()方法。
2.使用自定义的类。
</code></pre><h4 id="发布订阅和消息队列"><a href="#发布订阅和消息队列" class="headerlink" title="发布订阅和消息队列"></a>发布订阅和消息队列</h4><p>通过执行SUBSCRIBE命令客户端可以订阅一个或多个频道，从而成为这些频道的订阅者。</p>
<p>通过命令 UNSUBSCRIBE 命令退订某个或某些频道。</p>
<p>PUBSUB CHANNELS [pattern] 命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的。</p>
<p>PUBSUB NUMSUB [channel-1 channel-2 ..] 命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量</p>
<h2 id="PUBSUB-NUMPAT-命令用于返回服务器当前被订阅模式的数量。"><a href="#PUBSUB-NUMPAT-命令用于返回服务器当前被订阅模式的数量。" class="headerlink" title="PUBSUB NUMPAT 命令用于返回服务器当前被订阅模式的数量。"></a>PUBSUB NUMPAT 命令用于返回服务器当前被订阅模式的数量。</h2><h2 id="第19章-Redis-事务"><a href="#第19章-Redis-事务" class="headerlink" title="第19章 Redis 事务"></a>第19章 Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<pre><code>批量操作在发送 EXEC 命令前被放入队列缓存。
收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。
</code></pre><p>一个事务从开始到执行会经历以下三个阶段：</p>
<pre><code>开始事务。
命令入队。
执行事务。
</code></pre><p>MULTI 命令表示一个事务的开始。WATCH命令是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过，如果是，服务器拒绝执行事务，并返回执行失败的空回复。</p>
<p>当一个处于事务状态的客户端向服务器发送EXEC命令时，该EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p>
<p>DISCARD命令表示关闭事务操作。</p>
<hr>
<h2 id="第20章-Redis-Lua脚本"><a href="#第20章-Redis-Lua脚本" class="headerlink" title="第20章 Redis Lua脚本"></a>第20章 Redis Lua脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>
<p>EVALSHA命令可以根据脚本的SHA1校验来对脚本进行求职，但这个命令要求校验和对应的脚本必须至少被EVAL命令执行过一次。</p>
<hr>
<h2 id="第21章-排序"><a href="#第21章-排序" class="headerlink" title="第21章 排序"></a>第21章 排序</h2><p>Redis的sort命令可以对==列表键、集合或有序集合的值==进行排序。</p>
<pre><code>1. lrange：按插入顺序进行排序

    lrange numbers 0 -1

2. sort：按值从小到大进行排序

    sort numbers

    1. sort alphabet ALPHA sort命令使用ALPHA选项对一个包含字符串值的集合键进行排序

    2. sort &lt;key&gt; ASC 命令执行升序排序

    3. sort &lt;key&gt; DESC 命令执行降序排序
</code></pre><hr>
<h2 id="第22章-二进制位数组"><a href="#第22章-二进制位数组" class="headerlink" title="第22章 二进制位数组"></a>第22章 二进制位数组</h2><p>Redis提供了setbit/getbit/bitcount/bitop四个命令用于处理二进制位数组（位数组）。</p>
<pre><code>1. setbit 命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值为0或1。

2. getbit 命令获取位数组指定偏移量上的二进制位的值。

3. bitcount 命令用于统计位数组里面值为1的二进制位的数量。

4. bitop 命令用于对多个位数组进行按位与|或|异或运算。
</code></pre><hr>
<h2 id="第23章-慢查询日志"><a href="#第23章-慢查询日志" class="headerlink" title="第23章 慢查询日志"></a>第23章 慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可通过该功能产生的日志监视和优化查询速度。</p>
<pre><code>1. 配置慢查询日志

    1. 指定执行时间超过多少微秒的命令请求会被记录到日志中

        CONFIG SET slowlog-log-slower-than 0

    2. 指定服务器最多保存多少条慢查询日志

        CONFIG SET slowlog-max-len 5

2. 输入查询命令

    set msg &quot;...&quot;

    set num 000

    set database &quot;redis&quot;

3. slowlog get 命令查看服务器所保存的慢查询日志
</code></pre><hr>
<h2 id="第24章-监控器"><a href="#第24章-监控器" class="headerlink" title="第24章 监控器"></a>第24章 监控器</h2><p>通过monitor命令，客户端可以将自己变为一个监视器，实时接收并打印出服务器当前处理的命令请求相关信息。</p>
<hr>
<h2 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p>
<h2 id="Redis-服务器"><a href="#Redis-服务器" class="headerlink" title="Redis 服务器"></a>Redis 服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p>
<hr>
<h2 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h2><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令</p>
<pre><code>redis 127.0.0.1:6379&gt; CONFIG GET dir
</code></pre><h4 id="Bgsave"><a href="#Bgsave" class="headerlink" title="Bgsave"></a>Bgsave</h4><p>创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</p>
<hr>
<h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p>
<h4 id="设置密码与否"><a href="#设置密码与否" class="headerlink" title="设置密码与否"></a>设置密码与否</h4><pre><code>127.0.0.1:6379&gt; CONFIG get requirepass
</code></pre><h4 id="修改密码参数"><a href="#修改密码参数" class="headerlink" title="修改密码参数"></a>修改密码参数</h4><pre><code>127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;
127.0.0.1:6379&gt; CONFIG get requirepass
</code></pre><h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><pre><code>127.0.0.1:6379&gt; AUTH password
</code></pre><hr>
<h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<pre><code>命令：redis-benchmark [option] [option value]
</code></pre><h2 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h2><hr>
<h2 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h4 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h4><pre><code>通过利用多台计算机内存的和值，允许我们构造更大的数据库。
通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。
</code></pre><h4 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h4><hr>
<h2 id="Java使用Redis"><a href="#Java使用Redis" class="headerlink" title="Java使用Redis"></a>Java使用Redis</h2><p>在Java使用Redis之前要确定已经安装Redis服务以及Java Redis驱动</p>
<h4 id="1-连接到Redis服务"><a href="#1-连接到Redis服务" class="headerlink" title="1.连接到Redis服务"></a>1.连接到Redis服务</h4><pre><code>//Java程序连接到redis服务 在编写完下面的程序之后编译便可
import redis.clients.jedis.Jedis;

public class RedisJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);
        //查看服务是否运行
        System.out.println(&quot;服务正在运行: &quot;+jedis.ping());
    }
}
</code></pre><h4 id="2-Java使用redis服务实例"><a href="#2-Java使用redis服务实例" class="headerlink" title="2.Java使用redis服务实例"></a>2.Java使用redis服务实例</h4><pre><code>//redis Java String 实例
import redis.clients.jedis.Jedis;

public class RedisStringJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);
        //设置 redis 字符串数据
        jedis.set(&quot;runoobkey&quot;, &quot;www.runoob.com&quot;);
        // 获取存储的数据并输出
        System.out.println(&quot;redis 存储的字符串为: &quot;+ jedis.get(&quot;runoobkey&quot;));
    }
}

//Redis Java List(列表) 实例
import java.util.List;
import redis.clients.jedis.Jedis;

public class RedisListJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);
        //存储数据到列表中
        jedis.lpush(&quot;site-list&quot;, &quot;Runoob&quot;);
        jedis.lpush(&quot;site-list&quot;, &quot;Google&quot;);
        jedis.lpush(&quot;site-list&quot;, &quot;Taobao&quot;);
        // 获取存储的数据并输出
        List&lt;String&gt; list = jedis.lrange(&quot;site-list&quot;, 0 ,2);
        for(int i=0; i&lt;list.size(); i++) {
            System.out.println(&quot;列表项为: &quot;+list.get(i));
        }
    }
}

//Redis Java Keys 实例
import java.util.Iterator;
import java.util.Set;
import redis.clients.jedis.Jedis;

public class RedisKeyJava {
    public static void main(String[] args) {
        //连接本地的 Redis 服务
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;连接成功&quot;);

        // 获取数据并输出
        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); 
        Iterator&lt;String&gt; it=keys.iterator() ;   
        while(it.hasNext()){   
            String key = it.next();   
            System.out.println(key);   
        }
    }
}
</code></pre><hr>
<h4 id="1-单实例连接Redis"><a href="#1-单实例连接Redis" class="headerlink" title="1.单实例连接Redis"></a>1.单实例连接Redis</h4><pre><code>@Test
public void JedisClient(){
    //Jedis
    Jedis jedis = new Jedis(&quot;localhost&quot;,6379);
    //通过redis赋值
    jedis.set(&quot;s2&quot;,&quot;222&quot;);
    //通过redis取值
    String result = jedis.get(&quot;s2&quot;);
    System.out.println(result);
    //关闭jedis
    jedis.close();
}
</code></pre><h4 id="2-使用Jedis连接池连接Redis服务器"><a href="#2-使用Jedis连接池连接Redis服务器" class="headerlink" title="2.使用Jedis连接池连接Redis服务器"></a>2.使用Jedis连接池连接Redis服务器</h4><pre><code>@Test
public void JedisPool(){
    //JedisPool
    JedisPool pool = new JedisPool(&quot;localhost&quot;,6379);
    //通过连接池获取jedis对象
    Jedis jedis = pool.getResource();
    jedis.set(&quot;s4&quot;,&quot;12&quot;);
    String result = jedis.get(&quot;s4&quot;);
    System.out.println(result);

    //关闭Jedis客户端
    jedis.close();
    //关闭连接池
    pool.close();
}
</code></pre><h4 id="3-Spring整合JedisPool"><a href="#3-Spring整合JedisPool" class="headerlink" title="3.Spring整合JedisPool"></a>3.Spring整合JedisPool</h4><p><strong>3.1 pom.xml添加依赖</strong><br></p>
<p><strong>3.2 applicationContext.xml配置文件</strong><br></p>
<pre><code>&lt;!--1.首先是连接池配置--&gt;
&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
    &lt;!--1.1 最大连接数--&gt;
    ...
    //这些需要配置的东西可以得到，略
&lt;/bean&gt;

&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt;
    ...
&lt;/bean&gt;
</code></pre><h4 id="4-测试实例"><a href="#4-测试实例" class="headerlink" title="4.测试实例"></a>4.测试实例</h4><pre><code>@Test
public void JedisPoolTest(){
    JedisPool pool = (JedisPool) applicationContext.getBean(&quot;jedisPool&quot;);
    Jedis jedis = null;
    try{
        jedis = pool.getResource();
        jedis.set(&quot;name&quot;,&quot;lisi&quot;);
        String name = jedis.get(&quot;name&quot;);
        System.out.println(name);
    }catch(Exception e){
        e.printStackTrace();
    }finally{
        if(jedis != null){
            jedis.close();
        }
    }
}
</code></pre><hr>
<hr>
<p>前言：1.声明式缓存注解：Spring提供四个注解来声明缓存规则。</p>
<pre><code>@Cacheable 在方法执行前Spring先查看缓存中是否有数据。如果有数据则直接返回缓存数据，没有则调用方法返回值放入缓存中。

@CachePut 无论如何都会将方法的返回值放入缓存中。

@CacheEvict 将一条或多条数据从缓存中删除。

@Caching 可通过@Caching 注解组合多个注解策略在一个方法上。
</code></pre><blockquote>
<p>注意：@Cacheable | @CachePut | @CacheEvict 都有 value 属性，指定的是要使用的缓存名称。key 属性指定的是数据在缓存中存储的键。</p>
</blockquote>
<hr>
<h2 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h2><h3 id="SpringMVC集成Redis"><a href="#SpringMVC集成Redis" class="headerlink" title="SpringMVC集成Redis"></a>SpringMVC集成Redis</h3><p>一般的思路是首先加载配置文件，创建redis连接池，然后实例化RedisTemplate对象，最后持有这个实例开始读写操作。</p>
<h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1.pom.xml"></a>1.pom.xml</h4><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
  &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
  &lt;version&gt;1.0.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;redis.clients&lt;/groupId&gt;
  &lt;artifactId&gt;jedis&lt;/artifactId&gt;
  &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="2-spring-mybatis-xml-spring-dao-xml"><a href="#2-spring-mybatis-xml-spring-dao-xml" class="headerlink" title="2.spring-mybatis.xml(spring-dao.xml)"></a>2.spring-mybatis.xml(spring-dao.xml)</h4><pre><code>&lt;!--Jedis配置--&gt;
&lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
    &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;
    &lt;property name=&quot;maxActive&quot; value=&quot;${redis.maxActive}&quot; /&gt;
    &lt;property name=&quot;maxWait&quot; value=&quot;${redis.maxWait}&quot; /&gt;
    &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;
&lt;/bean&gt;

&lt;!--Redis服务器配置相关信息--&gt;
&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;
      p:host-name=&quot;${redis.host}&quot;
      p:port=&quot;${redis.port}&quot;
      p:password=&quot;${redis.pass}&quot;
      p:pool-config-ref=&quot;poolConfig&quot;/&gt;

&lt;!--Redis操作模板，面向对象的模板--&gt;
&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;
    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;
    &lt;!--如果不配置Serializer，那么存储的时候只能使用String，如果使用对象类型存储会提示错误--&gt;
    &lt;property name=&quot;keySerializer&quot;&gt;
        &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt;
    &lt;/property&gt;
    &lt;property name=&quot;valueSerializer&quot;&gt;
        &lt;bean class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot; /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<blockquote>
<p>提示：Spring Data Redis提供了RedisTemplate 和 StringRedisTemplate模板。模板封装了对redis操作，提供了较高级的数据访问方案。从名字可以看出后者只关注字符串类型，当redis的key和value都是字符串时候建议使用StringRedisTemplate。RedisTemplate的很多功能以子API的形式提供，他们区分了单个值和集合值得场景。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：在使用Redis的时候首先是注入了RedisTemplate对象，我们可以根据Spring中的JdbcTemplate，RedisTemplate封装了RedisConnection，具有连接管理，序列化和Redis操作等功能。还有针对String的支持对象StringRedisTemplate。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：Redis操作视图接口类是 ValueOperations，对应的Redis String/value操作。还有其他的操作视图：ListOperations | SetOperations | ZSetOperations 和 HashOperations 。ValueOperations 插入缓存是可以设置失效时间，这里设置的失效时间是 10 s。</p>
</blockquote>
</blockquote>
<h4 id="3-使用key和value的序列化器"><a href="#3-使用key和value的序列化器" class="headerlink" title="3.使用key和value的序列化器"></a>3.使用key和value的序列化器</h4><p>当某个key-value保存到Redis存储的时候，key和value都会使用Redis序列化器进行序列化。这一步已经在上面的配置文件中配置过。</p>
<pre><code>1.JdkSerializationRedisSerializer POJO对象的存取场景，使用JDK本身序列化机制，然后将普通POJO类进行序列化操作。

2.StringRedisSerializer key或者value是字符串的场景，将会根据指定charset对数据的字节序列编码成string。

3.JacksonJsonRedisSerializer Jackson-Json工具提供了JavaBean与Json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。

4.OxmSerializer 提供了将JavaBean与xml之间的转换能力，目前可用的三方支持包括jaxb,apache-xmlbeans。redis存储的数据将是xml工具。
</code></pre><blockquote>
<p>注意：RedisTemplate中需要声明4种serializer，默认为“JdkSerializationRedisSerializer”：</p>
</blockquote>
<pre><code>a) keySerializer ：对于普通K-V操作时，key采取的序列化策略
b) valueSerializer：value采取的序列化策略
c) hashKeySerializer： 在hash数据结构中，hash-key的序列化策略
d) hashValueSerializer：hash-value的序列化策略
</code></pre><blockquote>
<blockquote>
<p>注意：同样地，StringRedisTemplate也需要申明4中serializer，但是默认为“StringRedisSerializer”。</p>
</blockquote>
</blockquote>
<h4 id="4-RedisTemplate-使用"><a href="#4-RedisTemplate-使用" class="headerlink" title="4.RedisTemplate 使用"></a>4.RedisTemplate 使用</h4><p><strong>1.opsForXXX</strong><br><br>这里可以针对不同的数据结构(String, List, ZSet, Hash）读封装了比较使用的调用方式 opsForXXX。</p>
<h4 id="4-Util"><a href="#4-Util" class="headerlink" title="4.Util"></a>4.Util</h4><p><strong>1.RedisCache</strong><br></p>
<pre><code>package cn.edu.xidian.B.redis;

//这一工具类的实现是为能够使用redis的客户端操作数据
public class RedisCache implements Cache {

    private static JedisConnectionFactory jedisConnectionFactory;

    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //Redis客户端
    @Autowired
    private Jedis redisClient = createClient();

    private String id;

    public RedisCache(final String id){
        if (id == null){
            throw new IllegalArgumentException(&quot;此处必须传入参数id&quot;);
        }
        System.out.println(&quot;id:&quot; + id);
        this.id = id;
    }

    @Override
    public String getId() {
        return this.id;
    }

    @Override
    public void putObject(Object key, Object value) {
        redisClient.set(SerializeUtil.serialize(key.toString()), SerializeUtil.serialize(value));

    }

    @Override
    public Object getObject(Object o) {
        byte[] ob = redisClient.get(SerializeUtil.serialize(o.toString()));
        if (ob == null) {
            return null;
        }
        Object value = SerializeUtil.unSerialize(ob);
        return value;
    }

    @Override
    public Object removeObject(Object key) {
        return redisClient.expire(SerializeUtil.serialize(key.toString()), 0);
    }

    @Override
    public void clear() {
        redisClient.flushDB();

    }

    @Override
    public int getSize() {
        return Integer.valueOf(redisClient.dbSize().toString());
    }

    @Override
    public ReadWriteLock getReadWriteLock() {
        return readWriteLock;
    }

    protected static Jedis createClient(){
        try {
            @SuppressWarnings(&quot;resource&quot;)
            JedisPool pool = new JedisPool(new JedisPoolConfig(), &quot;127.0.0.1&quot;, 6379);
            return pool.getResource();
        }catch (Exception e){
            e.printStackTrace();
        }
        throw new RuntimeException(&quot;初始化连接池错误！&quot;);
    }

    public static void setJedisConnectionFactory(JedisConnectionFactory jedisConnectionFactory){
        RedisCache.jedisConnectionFactory = jedisConnectionFactory;
    }
}
</code></pre><p><strong>2.RedisCacheTransfer</strong><br></p>
<pre><code>package cn.edu.xidian.B.redis;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
//此中实现的是为了将bean里面注入的给到rediscache
public class RedisCacheTransfer {
    @Autowired
    public void setJedisConnectionFactory(JedisConnectionFactory jedisConnectionFactory){
        RedisCache.setJedisConnectionFactory(jedisConnectionFactory);
    }
}
</code></pre><p><strong>3.SerializeUtil</strong><br></p>
<pre><code>package cn.edu.xidian.B.redis;

import java.io.*;
//此类实现的是存储数据的序列化与反序列化
public class SerializeUtil {

    /**
     * 序列化
     * @param object
     * @return
     */
    public static byte[] serialize(Object object){
        ObjectOutputStream oos = null;
        ByteArrayOutputStream baos = null;
        try {
            baos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(baos);

            oos.writeObject(object);
            byte[] bytes = baos.toByteArray();
            return bytes;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 反序列化
     * @param bytes
     * @return
     */
    public static Object unSerialize(byte[] bytes){
        ByteArrayInputStream bais = null;
        try {
            bais = new ByteArrayInputStream(bytes);
            ObjectInputStream ois = new ObjectInputStream(bais);
            return ois.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre><h4 id="5-entity"><a href="#5-entity" class="headerlink" title="5.entity"></a>5.entity</h4><pre><code>User.java
package cn.edu.xidian.B.entity;

import java.io.Serializable;
//这里的User.java类作序列化为了后面能够持久化数据
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private Integer id;
    private String userName;
    private String password;
    private Integer age;

    public static long getSerialVersionUID() {
        return serialVersionUID;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, userName=&apos;&quot; + userName + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;}&apos;;
    }
}
</code></pre><h4 id="6-Service"><a href="#6-Service" class="headerlink" title="6.Service"></a>6.Service</h4><p><strong>1.Service接口</strong><br></p>
<pre><code>package cn.edu.xidian.B.service;

import cn.edu.xidian.B.entity.User;
//在此接口中只声明了一个方法
public interface UserService {
    User selectByPrimaryKey(Integer id);
}
</code></pre><p><strong>2.Service实现类</strong><br></p>
<pre><code>package cn.edu.xidian.B.service.impl;

import cn.edu.xidian.B.entity.User;
import cn.edu.xidian.B.mapper.UserMapper;
import cn.edu.xidian.B.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public User selectByPrimaryKey(Integer id) {
        return userMapper.selectByPrimaryKey(id);
    }
}
</code></pre><h4 id="7-mapper"><a href="#7-mapper" class="headerlink" title="7.mapper"></a>7.mapper</h4><p><strong>1.接口</strong><br></p>
<pre><code>package cn.edu.xidian.B.mapper;

import cn.edu.xidian.B.entity.User;
import org.springframework.stereotype.Component;

@Component
public interface UserMapper {
    User selectByPrimaryKey(Integer id);
}
</code></pre><p><strong>2.xml文件</strong><br></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;cn.edu.xidian.B.mapper.UserMapper&quot;&gt;
    &lt;cache type=&quot;cn.edu.xidian.B.redis.RedisCache&quot;/&gt;
    &lt;resultMap id=&quot;BaseResultMapper&quot; type=&quot;cn.edu.xidian.B.entity.User&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
        &lt;result property=&quot;userName&quot; column=&quot;username&quot;/&gt;
        &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
        &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;
            resultMap=&quot;BaseResultMapper&quot;&gt;
        select
        id,username,password,age
        from user
        where id = #{id}
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre><h4 id="8-controller"><a href="#8-controller" class="headerlink" title="8.controller"></a>8.controller</h4><pre><code>package cn.edu.xidian.B.controller;

import cn.edu.xidian.B.entity.User;
import cn.edu.xidian.B.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    @RequestMapping(&quot;/showuser&quot;)
    public String toIndex(HttpServletRequest request, Model model){
//        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));
        int userId = 1;
        User user = userService.selectByPrimaryKey(userId);

        model.addAttribute(&quot;user&quot;,user);
        return &quot;/showuser&quot;;
    }
}
</code></pre><hr>
<blockquote>
<p>注意：上面的系列步骤是将数据库的数据存储到redis中，然后查询相关的数据时候直接到redis中查询。</p>
</blockquote>
<hr>
<h2 id="Redis-查询数据"><a href="#Redis-查询数据" class="headerlink" title="Redis 查询数据"></a>Redis 查询数据</h2><p>此方法配置文件都和上面的一样，只是在工具类实现上与上面方法不一致。是使用redis自带的StringRedisTemplate实现的数据增删改查。</p>
<h4 id="1-RedisCacheUtil"><a href="#1-RedisCacheUtil" class="headerlink" title="1.RedisCacheUtil"></a>1.RedisCacheUtil</h4><pre><code>package cn.edu.xidian.B.util;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component(&quot;redisCache&quot;)
public class RedisCacheUtil {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 此方法表示向Hash中添加值
     * @param key 对应数据库表名
     * @param field 对应数据表中唯一索引
     * @param value 存入redis的值
     */
    public void hashSet(String key, String field, String value){
        if (key == null || &quot;&quot;.equals(key)){
            return;
        }
        stringRedisTemplate.opsForHash().put(key,field,value);
    }

    /**
     * 此方法表示从redis中取值
     * @param key
     * @param filed
     * @return
     */
    public String hashGet(String key, String filed){
        if (key == null || &quot;&quot;.equals(key)){
            return null;
        }
        return (String) stringRedisTemplate.opsForHash().get(key,filed);
    }

    /**
     * 此方法是判断存在key以及hash key
     * @param key
     * @param field
     * @return
     */
    public boolean hashExists(String key, String field){
        if (key == null || &quot;&quot;.equals(key)){
            return false;
        }
        return stringRedisTemplate.opsForHash().hasKey(key,field);
    }

    /**
     * 此方法查询key中对应多少条数据
     * @param key
     * @return
     */
    public long hashSize(String key){
        if (key == null || &quot;&quot;.equals(key)){
            return 0L;
        }
        return stringRedisTemplate.opsForHash().size(key);
    }

    public void hashDel(String key, String field){
        if (key == null || &quot;&quot;.equals(key)){
            return;
        }
        stringRedisTemplate.opsForHash().delete(key,field);
    }
}
</code></pre><h4 id="2-Controller"><a href="#2-Controller" class="headerlink" title="2.Controller"></a>2.Controller</h4><pre><code>package cn.edu.xidian.B.controller;

import cn.edu.xidian.B.util.RedisCacheUtil;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Controller
@RequestMapping(&quot;/redis&quot;)
public class RedisController {
    @Resource
    private RedisCacheUtil redisCacheUtil;

    @RequestMapping(&quot;/list&quot;)
    @ResponseBody
    public String getList(HttpServletResponse response, HttpServletRequest request){
        String redis = redisCacheUtil.hashGet(&quot;student&quot;,&quot;test&quot;);
        System.out.println(redis);
        return &quot;success&quot;;
    }

    @RequestMapping(&quot;/add&quot;)
    @ResponseBody
    public String add(HttpServletResponse response, HttpServletRequest request){
        redisCacheUtil.hashSet(&quot;student&quot;, &quot;test&quot;, &quot;小明&quot;);
        return &quot;success&quot;;
    }
}
</code></pre><hr>
<h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><h4 id="1-开启声明缓存支持"><a href="#1-开启声明缓存支持" class="headerlink" title="1.开启声明缓存支持"></a>1.开启声明缓存支持</h4><p>在配置类上使用 @EnableCaching 注解。</p>
<pre><code>@Configuration
@EnableCaching
public class AppConfig{
    //....
}
</code></pre><h4 id="2-SpringBoot的支持"><a href="#2-SpringBoot的支持" class="headerlink" title="2.SpringBoot的支持"></a>2.SpringBoot的支持</h4>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Servlet/" itemprop="url">Servlet</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:48:38+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13,715
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  56
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p>开发步骤：</p>
</blockquote>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器</li>
</ul>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html" target="_blank" rel="noopener">Servlet API Documentation</a></p>
</blockquote>
<h4 id="生命周期相关方法-life-cycle-methods"><a href="#生命周期相关方法-life-cycle-methods" class="headerlink" title="生命周期相关方法(life-cycle methods)"></a>生命周期相关方法(life-cycle methods)</h4><p>Servlet的生命周期通过<code>java.servlet.Servlet</code>接口中的<code>init()</code>、<code>service()</code>、和<code>destroy()</code>方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。（见文末【参考链接】）</p>
<h4 id="手动编写第一个servlet"><a href="#手动编写第一个servlet" class="headerlink" title="手动编写第一个servlet"></a>手动编写第一个servlet</h4><p>1.在tomcat中新建一个web应用<code>hello</code>，在web应用中新建一个<code>WEB-INF/classes</code>目录</p>
<p>2.在<code>classes</code>目录新建一个<code>FirstServlet</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span><span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"hello servlet!!!"</span>.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编译，<code>javac -cp %CATALINA_HOME%/lib/servlet-api.jar  -d . FirstServlet.java</code>,命令行手动编译参考<a href="http://www.iitshare.com/under-the-cmd-compile-the-java.html" target="_blank" rel="noopener">这里</a></p>
<p>4.在<code>WEB-INF</code>目录中新建一个<code>web.xml</code>文件，配置servlet的对外访问路径</p>
<p>5.启动tomcat访问</p>
<h4 id="servlet的调用过程和生命周期"><a href="#servlet的调用过程和生命周期" class="headerlink" title="servlet的调用过程和生命周期"></a>servlet的调用过程和生命周期</h4><p>时序图 -&gt; servlet的调用过程和生命周期</p>
<h4 id="servlet的开发细节"><a href="#servlet的开发细节" class="headerlink" title="servlet的开发细节"></a>servlet的开发细节</h4><ul>
<li><strong>标签</strong>:<code>&lt;servlet&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，<code>&lt;servlet-mapping&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code></li>
<li><strong>映射</strong>:<code>web.xml</code>中一个<code>&lt;servlet&gt;</code>可对应多个<code>&lt;servlet-mapping&gt;</code></li>
<li><p><strong>通配符</strong>:<code>&lt;servlet-mapping&gt;</code>的<code>&lt;url-pattern&gt;</code>可以使用通配符，两种固定格式：<code>*.扩展名</code>；以<code>/</code>开头，以<code>/*</code>结尾</p>
</li>
<li><p><strong>对象</strong>:servlet由servlet引擎调用，不能独立运行。客户端多次请求，服务器只创建一个servlet实例，之后驻留内存中继续服务直至web容器退出才销毁它。</p>
</li>
<li><strong>请求</strong>:服务器针对客户端的每一次请求都会创建新的<code>request</code>和<code>response</code>对象(它们的生命周期很短)，传给<code>service</code>方法。</li>
<li><strong>加载</strong>:servlet实例的创建和<code>init</code>方法的调用是在第一次请求时，而非服务器启动时，除非在<code>&lt;servlet&gt;</code>标签配置<code>&lt;load-on-start-up&gt;</code>,数字越小优先级越高</li>
<li><strong>缺省</strong>:映射路径为正斜杠<code>/</code>，则为当前web应用的缺省servlet,不匹配的都交给缺省</li>
<li><strong>线程安全</strong>:访问同一资源会引发线程安全问题; <code>SingleThreadModel</code>标记接口(已弃用)</li>
<li><strong>ServletConfig</strong>:在<code>&lt;servlet&gt;</code>标签配置<code>&lt;init-param&gt;</code>，通过<code>getServletConfig</code>方法获得配置。可配置输出字符集，读哪个配置文件等等。</li>
<li><strong>ServletContext</strong>:代表当前web应用，含有一些web应用全局性方法，实现web资源共享、servlet转发等。通过<code>ServletConfig.getServletContext</code>方法获得，在<code>&lt;context-param&gt;</code>标签配置。</li>
</ul>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>API:<a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/ServletContext.html" target="_blank" rel="noopener">Interface ServletContext</a></p>
<p><strong>概念</strong><br></p>
<p>一个web应用所有servlet共享同一个ServletContext对象，可实现数据共享。ServletContext被称为context<strong>域</strong>对象。</p>
<p>域：作用范围 context域：整个应用程序范围。</p>
<p>ServletContext域：</p>
<ol>
<li>这是一个容器</li>
<li>说明了这个容器的作用范围，也就是应用程序范围</li>
</ol>
<p>转发:客户机一次请求；重定向：客户机两次请求</p>
<p>作用</p>
<ul>
<li>获取web应用的初始化参数</li>
<li>实现servlet转发</li>
<li>利用ServletContext对象读取资源文件<ul>
<li>获得文件路径</li>
<li>读取资源文件的三种方式</li>
<li>.properties文件（属性文件）</li>
</ul>
</li>
</ul>
<p>配置文件：properties文件和xml文件；数据有关系使用xml文件，没有关系则使用properties文件。</p>
<p>1.通过<code>ServletContext</code>的<code>getResourceAsStream</code>方法，读取properties文件</p>
<p>模板代码(注意文件位置不同写路径会不同)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/org/iot/servlet/db.properties"</span>);</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();<span class="comment">//map</span></span><br><span class="line">properties.load(in);</span><br></pre></td></tr></table></figure>
<p>2.通过<code>servletContext</code>的<code>getRealPath</code>方法得到资源的绝对路径，再通过传统方式(<code>FileInputStream</code>)读取</p>
<p>3.通过类装载器去读，<code>ClassLoader</code>的<code>getResourceAsStream</code>(如果读取资源文件的程序不是servlet)，文件不能太大。<strong>只装载一次</strong>，所以如要读到更新后的数据，通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据（用<code>getResource</code>得到path，再用<code>FileInputStream</code>）</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://blog.csdn.net/evankaka/article/details/46673051" target="_blank" rel="noopener">servlet和Jsp生命周期解读</a></p>
</blockquote>
<hr>
<p>Servlet </p>
<pre><code>1.Servlet程序编写  生命周期
2.ServletAPI Request Response 
3.Cookie 和 Session 
</code></pre><p>1.理论<br>    Servlet 用来开发 动态web资源</p>
<pre><code>静态web资源 ： 固定数据文件
动态web资源 ： 通过程序动态生成数据文件 

注意：Servlet技术基于Request-Response编程模型  HTTP协议也是基于请求响应 模型。Servlet技术 用来 开发基于HTTP web 应用程序 

接触 JavaEE API 程序接口和已经实现接口类的使用 JavaEE：Java Platform, Enterprise Edition 缩写 
</code></pre><p>2.Servlet快速入门<br>    1.创建web project<br>    2.编写 class 继承 HttpServlet<br>    3.在web.xml 配置Servlet程序虚拟访问路径<br>      用户在浏览器上通过这个路径访问编写Servlet程序</p>
<pre><code>4.覆盖doGet或者doPost方法进行输出 (表示输出函数是doPost/doGet方法)

总结：Servlet 动态生成网页文件 
</code></pre><p>3.Servlet执行过程</p>
<pre><code>1.用户在客户端发起url请求 ： http://localhost/day05/hello   web.xml /hello 映射 HelloServlet程序

  在servlet写好之后，通过在web.xml文件中配置相应路径响应的servlet，然后将其映射过去。

2.用户提交请求时，get方式提交 执行 HelloServlet的 doGet 方法   post方式提交 执行 HelloServlet的 doPost 方法 

  用户在前台提交表单的方式 method=&quot;post/get&quot; 对应在servlet中执行相应的doPost/doPost方法
</code></pre><p>4.Servlet程序在编写和运行时，需要 javaee 类库 （API支持）</p>
<pre><code>* 在学习javase  List 需要 import java.util.List  需要 jre/lib/rt.jar 
* MyEclipse 自动导入 javaee5 liberary  存在 javaee.jar  提供 Servlet 需要类 API支持 （开发环境使Servlet程序正常编译）
* Serlvet程序运行tomcat环境中 没有javaee.jar , 在 tomcat/lib/servlet-api.jar 提供Servlet程序运行需要 类API 支持 （运行环境需要的）
</code></pre><p>5.手动编写Servlet运行</p>
<pre><code>1.在webapps 新建 day05test目录   此为虚拟应用
2.在day05test 新建 WEB-INF/classes
3.将编写Servlet的java源码文件 放入 classes ，在 WEB-INF 配置web.xml 
4.编译Servlet的 java程序 

// 通过 -classpath 指定 Servlet需要jar 包
javac -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java
//生成Servlet package结构    
javac -d . -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java
</code></pre><p>6.Servlet运行原理分析</p>
<pre><code>编写Servlet程序没有 main函数，tomcat调用Servlet程序执行

通过myeclipse向导创建 Servlet   在创建Servlet程序的同时，生成 web.xml 配置

* 生成Servlet信息非常复杂，想生成 Servlet 内容整洁一些，精简一些的话就修改Servlet模板 
    1、myeclipse工具   安装目录 common / plugins
    com.genuitec.eclipse.wizards_8.5.0.me201003052220.jar
    2、解压缩 templates/Servlet.java  这个就是Servlet模板 
</code></pre><p>7.通过API Servlet继承关系<br>    Servlet接口<br>    实现类 ： GenericServlet<br>    子类 HttpServlet 编写Servlet 继承HttpServlet </p>
<pre><code>* 编写Servlet 间接 实现 Servlet 接口  （简化开发）

Servlet接口 提出，为了解决基于请求-响应模型数据处理 （并没有涉及与HTTP协议相关 API）
GenericServlet 实现接口 通用Servlet 也没有提供与 HTTP协议相关 API 
HttpServlet 引入与 协议相关 API 
</code></pre><p>8.Servlet生命周期 </p>
<pre><code>init(ServletConfig config)  初始化 
service(ServletRequest req, ServletResponse res)  提供服务方法
destroy()  销毁 

1、tomcat服务器启动时，没有创建Servlet对象

2、第一次访问时，tomcat构造Servlet对象，调用 init，执行service 

3、从第二次以后访问 tomcat 不会从新创建Servlet对象，也不会调用init   每一次访问都会调用service

4、当服务器重启或正常关闭时 调用destroy （正常关闭 shutdown.bat）

注意：Servlet对象是tomcat创建的，每次请求调用Servlet中service方法，tomcat服务器会在每次调用Servlet的service方法时，为该方法创建Request对象和Response对象

* 在 JavaEE API 中没有Request和Response实现类   实现类由Servlet服务器提供的，tomcat提供实现类 weblogic 提供实现类 


service方法 和 HttpServlet doGet/doPost 关系区别（必须阅读HttpServlet源代码） 

在HttpServlet代码实现中，根据请求方式不同 调用相应doXXX方法 get方式请求  doGet  post方式   doPost 

配置Servlet随tomcat服务器启动时 进行初始化   &lt;load-on-startup &gt;(web.xml中配置)  *&lt;load-on-startup &gt; 参数可以是一个数字 0-9 代表服务器加载优先级 0 最高 

例如：在tomcat启动时，想通过Servlet加载一些框架配置文件 配置随服务器启动 （struts1 ）

结论：
    1、编写Servlet 继承HttpServlet
    2、编写Servlet 不需要覆盖service方法，只需要覆盖doGet和doPost 方法

    Servlet初始化时覆盖init() ，无需覆盖init(config) ？？ 
    * init(Config) 调用 init() 

注意：当doGet和doPost代码逻辑相同时，可以相互调用，简化编程
</code></pre><p>9.一个Servlet可以配置多个 url-pattern (web.xml)</p>
<pre><code>URL 配置格式 三种：
    1、完全路径匹配  (以/开始 ) 例如：/hello /init 
        * 当前工程没有被正确发布，访问该工程所有静态资源、动态资源而发生404错误  表示工程启动时出错了 
        * 查看错误时 分析错误
            1) 单一错误 ： 从上到下 查看第一行你自己写的代码 （有的错误与代码无关，查看错误信息）
            2）复合错误 Caused by ---- 查看最后一个Caused by 
            * Invalid &lt;url-pattern&gt; init2 in servlet mapping 

    2、目录匹配 (以/开始) 例如：/*  /abc/* 
        / 代表网站根目录 

    3、扩展名 (不能以/开始) 例如：*.do *.action 
        典型错误 /*.do 

    优先级：完全匹配 &gt; 目录匹配 &gt; 扩展名匹配 
</code></pre><p>10.路径问题：编写九九乘法表</p>
<pre><code>1、需要用户在客户端输入一个数字
2、Servlet接收客户输入数字 打印对应乘法表 
</code></pre><p>例如：在chengfabiao.html 通过 action 访问 ChengfabiaoServlet  路径可以用绝对路径和相对路径 </p>
<pre><code>1.相对路径：相对当前网页地址 路径  例如 chengfabiao  ./chengfabiao  ../chengfabiao
    例如： http://localhost/day05/chengfabiao.html  提交 action=&quot;chengfabiao&quot; 

* 将url最后地址换成相对路径 
结果： http://localhost/day05/chengfabiao    服务器端 /chengfabiao

    例如： http://localhost/day05/aaa/chengfabiao.html 提交 action=&quot;chengfabiao&quot;
    结果： http://localhost/day05/aaa/chengfabiao    服务器 /chengfabiao 
        * /aaa/chengfabiao 与服务器 /chengfabiao 不匹配 出现404 

    http://localhost/day05/aaa/chengfabiao.html 提供 action=&quot;../chengfabiao&quot; 
    结果：http://localhost/day05/aaa/../chengfabiao   ..和/aaa抵消 http://localhost/day05/chengfabiao 可以匹配服务器 /chengfabiao

结论：如果用相对路径提交请求，考虑当前路径， 当前访问服务器资源路径不同   相对路径写法不同

绝对路径 解决相对路径，会根据当前地址改变问题。 
例如： /day05/chengfabiao 、http://localhost/day05/chengfabiao

绝对路径 以/开始 /访问服务器根目录 
例如： 客户端访问服务器，不管当前路径是什么   / 服务器根目录 http://localhost/day05   找到虚拟目录day05工程  /day05/chengfabiao  找到 day05工程下配置 虚拟路径/chengfabiao

结论： 客户端路径 /工程虚拟目录/servlet虚拟路径 例如：/day05/chengfabiao
服务器端 配置web.xml 不需要写工程虚拟目录  只要直接写/servlet虚拟路径  例如：/chengfabiao 
</code></pre><hr>
<h4 id="掌握Servlet程序编写"><a href="#掌握Servlet程序编写" class="headerlink" title="掌握Servlet程序编写"></a>掌握Servlet程序编写</h4><pre><code>通过路径 访问Servlet 程序
    * Servlet 生命周期

    init 程序初始化
    service 程序业务层
    destroy 程序销毁    
</code></pre><p>1.学习init方法  init(ServletConfig)  通过ServletConfig 获得Servlet初始化参数</p>
<p>  1、创建一个Servlet</p>
<p>  2、在 web.xml 中 <servlet> 标签内通过 <init-param> 标签为Servlet配置初始化参数<br>    <init-param><br>        <param-name>itcast</param-name><br>        <param-value>传智播客</param-value><br>    </init-param></init-param></servlet></p>
<p>  3、在Servlet程序中通过ServletConfig对象获得itcast对应数据<br>    getInitParameter —— 通过name获得value<br>    getInitParameterNames  —– 获得所有name </p>
<ul>
<li><p>思考 ：如何在 doGet 或 doPost 方法中获得 Servlet 初始化参数？ </p>
<p>1.将ServletConfig对象保存实例成员变量<br>2.GenericServlet 已经将 ServletConfig 保存成员变量，在子类中通过 getServletConfig() 方法获得初始化参数</p>
<p>结论：子类Servlet不需要覆盖 init(ServletConfig) 只需要通过GenericServlet中 getServletConfig() 获得ServletConfig对象<br>应用：在init-param 指定配置文件位置和名称，配置Servlet随服务器启动创建 load-on-startup  </p>
</li>
<li><p>ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得 每个Servlet程序都对应一个ServletConfig对象 </p>
</li>
<li><p>ServletContext 是Servlet上下文对象，每一个工程都会创建单独ServletContext对象，这个对象代表当前web工程，操作ServletContext，必须通过 ServletConfig 获得对象 </p>
<p>应用：</p>
<pre><code>1、 获得整个web应用初始化参数
2、 实现全局数据共享
3、 实现服务器端转发功能
4、 读取web工程资源文件
</code></pre></li>
</ul>
<hr>
<p>1.获取WEB应用的初始化参数 和 ServletConfig 对象不同 </p>
<ul>
<li>ServletConfig对象配置参数，只对配置Servlet有效，如果配置参数，所有Servlet都可以访问 通过ServletContext<br><context-param></context-param></li>
</ul>
<p>2.通过 ServletContext 在多个Servlet间 共享数据<br>    案例：在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1 </p>
<pre><code>    在CountServlet 初始化过程中，向ServletContext 保存访问次数 方法：ServletContext  setAttribute 

    每次访问次数 +1  数据存放ServletContext中 所有Servlet都可以获得该数据

* 在ServletContext中保存数据，所有Servlet都可以访问 
</code></pre><p>3.通过 ServletContext 完成服务器程序转发 </p>
<pre><code>什么是转发？ 转发和重定向区别 ？
getRequestDispatcher(java.lang.String path)  完成转发

使用转发还是重定向？ 转发性能好于重定向，请求次数好 

案例：统计字母次数
    request.getParameter(&quot;content&quot;) 获得form 提交内容 content 就是 textarea name属性
</code></pre><p>4.利用ServletContext对象读取资源文件</p>
<pre><code>1.使用java application 读取文件，读取当前工程下所有文件  使用相对路径读取文件

2.使用Servlet读取文件 只能读取WebRoot下所有文件  必须使用绝对磁盘路径读取文件 

3.通过站点根目录绝对路径 获得磁盘绝对路径 getServletContext().getRealPath(“/WEB-INF/info.txt”)

注意：因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，通过Class类对象读取该目录下文件 
    String filename3 = c.getResource(&quot;/a1.txt&quot;).getFile();  表示： / 代表 /WEB-INF/classes 

结论：在WEB工程中，必须将文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx  getServletContext().getRealPath(&quot;/xxx&quot;);   /代表WebRoot 
如果读取文件恰好位于 WEB-INF/classes 通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径   / 代表 /WEB-INF/classes 
</code></pre><p>注意：<br>    缺省Servlet 功能：处理其他Servlet都不处理请求<br>    tomcat/conf/web.xml  org.apache.catalina.servlets.DefaultServlet 作为缺省Servlet </p>
<pre><code>总结：
    1、编写Servlet HelloServlet
    2、修改Servlet模板 
    3、Servlet生命周期 理论重点掌握
    4、Servlet url三种写法 完全、目录、扩展名
    5、路径问题：绝对路径   案例 九九乘法表
           将web.xml 配置路径复制到网页 在路径前 /工程名
    6、ServletConfig 和ServletContext 读取初始化参数区别 ？
    7、ServletContext数据共享案例   统计访问次数
    8、ServletContext转发案例   统计字母出现次数
    9、读取web工程中资源文件   绝对路径
        在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx   getServletContext().getRealPath(&quot;/xxx&quot;);  /代表WebRoot 
        如果读取文件 恰好位于 WEB-INF/classes   通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes 
    10、缺省Servlet 了解功能将静态资源数据内容读取写给客户端 
</code></pre><hr>
<h4 id="HttpServletResponse-HttpServletRequest-关键：了解HTTP协议"><a href="#HttpServletResponse-HttpServletRequest-关键：了解HTTP协议" class="headerlink" title="HttpServletResponse HttpServletRequest(关键：了解HTTP协议)"></a>HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</h4><p>Web服务器(TOMCAT)收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象和代表响应的response对象。所以获取客户端提交的数据，只需要找到request对象即可，然后如果需要向容器输出数据，只需要找response对象即可。</p>
<p><strong>1.HttpServletResponse</strong><br></p>
<pre><code>1.响应行 setStatus(int sc);//设置相应状态码 HTTP/1.1 200
2.响应头 setHeader(String name,String value);//设置响应头信息 
      请求重定向 sendRedirect(String location);

  浏览器使用的码表(告知)
    response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

  告知客户端不缓存
    response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
    response.setDataHeader(&quot;expires&quot;,0);
3.相应正文
    setCharacterEncoding(String charset);//告知服务器使用什么编码
    setContentType(String type);
</code></pre><p><strong>2.HttpServletRequest</strong><br></p>
<pre><code>1.请求行
  Get方式 URL链接：http://localhost:8080/day09/servlet/req1?username=zs  协议：http/1.1

    getMethod(); 获得请求方式
    getRequestURL();返回客户端发出请求时的完整URL。
    getRequestURI(); 返回请求行中的资源名部分。
    getContextPath(); 当前应用的虚拟目录 /day09_01_request
    getQueryString() ; 返回请求行中的参数部分。

2.请求消息头

  String getHeader(String name)  根据头名称得到头信息值
  Enumeration   getHeaderNames()  得到所有头信息name
  Enumeration   getHeaders(String name)  根据头名称得到相同名称头信息值

3.请求正文

获取表单数据相关的方法
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  getParameter(name) 根据表单中name属性的名，获取value属性的值方法 
  getParameterValues（String name）专为复选框提供的方法
  getParameterNames() 得到表单提交的所有name的方法 
  getParameterMap 到表单提交的所有值的方法   //做框架用，非常实用
  getInputStream  以字节流的方式得到所有表单数据

扩展：
    操作非表单数据相关的方法(request是一个域对象)
        void setAttribute(String name, Object value);
        Object getAttribute(String name);
        void removeAttribute(String name);

    请求转发相关方法

        //得到请求转发或请求包含的协助对象
        RequestDispatcher getRequestDispatcher(String path)
        forward(ServletRequest request, ServletResponse response) //转发的方法
        include(ServletRequest request, ServletResponse response) //请求包含

    请求编码相关方法

        //解决post方式编码
        request.setCharacterEncoding(&quot;UTF-8&quot;); //告诉服务器客户端什么编码,只能处理post请求方式

        //解决get方式编码
        String name = new String(name.getBytes(“iso-8859-1”),”UTF-8”);
</code></pre><hr>
<h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2><p>两条主线<br>    1、HTTP协议<br>    2、Servlet生命周期 </p>
<p>1.init()方法中参数 ServletConfig 对象的使用</p>
<p>  通过 ServletConfig 获得 ServletContext 对象来使用</p>
<p>2.service()方法 含有两个参数对象 ServletRequest ServletResponse </p>
<p>  在实际开发Servlet过程中不需要覆盖service,HttpServlet 根据请求方式自动调用 doGet 或者 doPost doGet和doPost参数 HttpServletRequest 和 HttpServletResponse </p>
<hr>
<p>3.HttpServletRequest HttpServletResponse (学习重点)</p>
<p>  客户端每次请求都会创建request对象和response对象 作用：被传递service / doGet / doPost </p>
<p>  1.HttpServletRequest 封装客户端相关信息，服务器Servlet程序可以 通过request对象 操作客户端信息<br>  2.HttpServletResponse 封装服务器向客户端发送响应数据信息，Servlet程序 通过response对象 向客户端发送响应</p>
<p>4.Response常用的API</p>
<pre><code>1.setStatus 设置响应行 当中 状态码
2.setHeader 设置响应头信息
3.getOutputStream 获得字节流 ---- 输出响应体内容
4.getWriter 获得字符流 ---- 输出响应体内容
</code></pre><p>注意：</p>
<ul>
<li>HttpServletResponse 继承 ServletResponse 接口 ，ServletResponse 并没有提供与HTTP协议相关API ，HttpServletResponse 添加了与协议相关 API</li>
<li>JavaEE API 中并没有提供 HttpServletResponse 实现类 —- 实现类由tomcat服务器提供的</li>
</ul>
<p>5.服务器常用状态码 ： 200 302 304 404 500 </p>
<pre><code>200 请求处理成功
302 客户端重定向
304 客户端访问资源没有被修改，客户端访问本地缓存
404 访问资源不存在
500 服务器内部出错
</code></pre><p>6.案例：</p>
<pre><code>1.通过302 + Location 头信息实现页面重定向效果 
    response.setStatus(302);
    response.setHeader(&quot;Location&quot;, &quot;/day06/welcome.html&quot;); // 相对路径 和 绝对路径

注意：* / 由客户端定向服务器，代表客户端 / , 必须添加工程虚拟目录 

   头信息存在多个值

    Accept-Encoding: gzip, deflate --- key:value1,value2 
    response.addHeader 用于设置响应头有多个值 ------ 不常用 
重点：setHeader 

在Response API 中提供sendRedirect ---- 完成302+Location重定向效果 
例如： response.sendRedirect(&quot;/day06/welcome.html&quot;);

2.登陆重定向


3.自动刷新网页 

* 登陆成功，5秒后自动跳转XX页面 
原理：通过refresh 头信息 
格式 -----   refresh: 时间;url=跳转路径
例如： refresh:3;url=http://www.itcast.cn -------- 3秒后自动跳转http://www.itcast.cn 网站 

注意：* HTML 页面中存在一类非常特殊标签 &lt;meta&gt; ，&lt;meta&gt; 起到设置头信息作用 
&lt;meta content=&quot;3;url=/day06/response/demo3/result.html&quot; http-equiv=&quot;refresh&quot;&gt; ---- 完成自动跳转 

4.通过response头信息设置 浏览器禁止缓存

原理：和禁用缓存相关头信息 三个 
Cache-Control:no-cache
Expires:Thu, 01 Dec 1994 16:00:00 GMT  ----- setDateHeader(&quot;expires&quot;,-1);
Pragma : no-cache

IE 工具---Internet选项 ---常规 --- 设置 --- 查看文件
对于Servlet生成HTML页面，经常需要改变，禁止Servlet动态程序缓存 
注意：* 设置Expires时，通常 setDateHeader 为过期时间设置一个毫秒值，生成HTTP响应时，会自动转换日期字符串表示 
</code></pre><p>通过response 生成 客户端响应体，通过字节流和字符流两种输出方式 </p>
<pre><code>* 哪些情况用字节流？ 哪些情况用字符流 ？ 
    文件拷贝 ---- 字节流 
    分析文件内容 --- 字符流 （中文操作 字符流）

5.输出中文信息

对中文信息进行编码 
response.setCharacterEncoding(&quot;utf-8&quot;);
response.setContentType(&quot;text/html;charset=utf-8&quot;); 

setCharacterEncodig 和 setContentType 区别 ？

结论：开发中只需要使用setContentType 就可以了
</code></pre><blockquote>
<p>注意：<br>    1、getOutputStream和getWriter 不能同时使用<br>    2、必须在getOutputStream和getWriter 之前 设置响应 编码<br>    3、getOutputStream和getWriter 输出内容 是 HTTP响应体<br>    4、getOutputStream和getWriter 存在缓冲区的 ，在service方法结束时，自动关闭流，flush缓冲区内容</p>
</blockquote>
<pre><code>6.文件下载
第一种：通过超链接 完成文件下载 
* 如果浏览器可以识别该文件格式，直接打开，只有链接文件浏览器不识别文件格式，才会实现下载 

第二种：通过Servlet程序实现下载 
原理：通过Servlet读取目标程序，将资源返回客户端
通过程序下载文件 设置两个头信息 Content-Type Content-Disposition 
response.setContentType(getServletContext().getMimeType(filename));  ---- 设置文件类型 
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+ filename); ---- 设置文件以附件形式下载（对于浏览器识别格式文件）

7.验证码输出案例 
Java图形API 生成验证码图片 ----- 了解 
为什么需要验证码 ？防止有人通过程序恶意攻击网站 
验证码为什么是图片 ？为什么雪花或者干扰线？  
常用验证码 ： 字母和数字 

验证码旋转效果 
rotate(double theta, double x, double y)  ----- 参数 theta 旋转弧度 
2PI 弧度 = 360 角度 

-30 ---- 30 角度 

验证码看不清楚，点击切换验证码 ---- 编写JavaScript程序 
方法一：设置验证码图片不缓存
方法二：每次访问使url 不同 ----- url?new Date().getTime() 当前时间 
</code></pre><hr>
<p>HttpServletRequest 分为四个部分</p>
<pre><code>HttpServletRequest 想比 ServletRequest 添加与协议相关 API

1、获取客户机信息
    URI和URL区别
    url:http://localhost/day06/request1  --- 完整
    uri:/day06/request1  ---- 部分

    URI 包含 URL的 ，URL 一定完成路径，URI可以相对路径 
    http://localhost/day06/request1 是一个URL 同时也是 URI
    ./hello  /day06/request1 ---- 都是URI 不是URL 

获得ip ： request.getRemoteAddr();

获得当前访问资源路径 ： request.getRequestURI().substring(request.getContextPath().length());


2、获取请求头信息
    getHeader 获得头信息的值，转换一个字符串
    getHeaders 获得头信息值 ，获得Enumeration
    getHeaderNames 获得所有头信息名称  返回 Enumeration

    * 掌握getHeader使用，遍历Enumeration 获得所有头信息

    编写防盗链程序，存在合法referer不是盗链，否则控制目标资源无法访问 ！
    * 通过URL 绕过盗链判断

3、获取请求参数

    请求参数：指用户通过请求提交服务器一些数据

        &lt;a href=&quot;url?xxx=xxx&quot; &gt;
        &lt;form method=&quot;get&quot;&gt;
        &lt;form method=&quot;post&quot;&gt;

    如：/day06/request4?name=zhangsan&amp;city=beijing  这一路径中包括两个参数的 name 和 city 

request常用API四个

    getParameter
    getParameterValues
    getParameterNames
    getParameterMap 

非空校验
    if (username != null &amp;&amp; username.trim().length() &gt; 0) {} //短路 

乱码问题
    post方法：request.setCharacterEncoding(&quot;客户端编码集&quot;);

    get乱码手动解决
        username = URLEncoder.encode(username, &quot;ISO-8859-1&quot;);// 用ISO编码
        username = URLDecoder.decode(username, &quot;utf-8&quot;); // 用utf-8解码
        简化上面写法 ： username = new String(username.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);

get乱码 配置tomcat默认解码字符集
    在tomcat/conf/server.xml 
    Connector中 添加一个属性 URIEncoding=&quot;utf-8&quot;

结论：开发时，尽量不要修改tomcat默认解码集 ，提交请求请尽量使用post ，如果非要使用get ，手动编码

问题：http://localhost/day06/servlet?username=zhangsan+lisi
在服务器端 通过 request.getParameter(&quot;username&quot;) 结果是 ？？？ ----- zhangsan lisi 


4、利用请求域传递对象
    HttpServletRequest 和 ServletContext 类似 都是数据域对象 ， 以Map方式保持数据

    区分：存活时间不同 

    ServletContext对象 服务器启动对象创建，服务器停止对象销毁
    ServletRequest对象 当产生一次请求时 创建，当响应结束后，对象销毁 

    通过request转发请求，request保存数据进行Servlet之间传递 ---- 应用？
    Servlet进行数据处理 --- 生成结果 --- 转发结果给JSP显示 
</code></pre><p>注意：</p>
<pre><code>1、在使用forward之前 不能将响应内容传输到客户端
    情况一 response输出流执行flush 
    情况二 同一个Servlet不能连续使用forward 和 redirect
2、在执行forward 和 redirect时，清除之前写入响应流数据 
3、ServletContext进行转发 路径必须/开始，request进行转发路径可以使用相对路径 

转发和重定向区别
    1、转发一次请求、一次响应 重定向 两次请求 两次响应
    2、转发只能跳转站内程序，重定向定向任何站点 
    3、转发 URL地址不变 ，重定向URL地址改变 
    4、转发 对客户端不可见，重定向对客户端可见 
    5、转发共享同一个Request中数据，重定向两次请求，不同Request对象，不能共享Request数据 
</code></pre><ul>
<li>request.setAttribute 必须和 request.getRequestDispatcher().forward 一起使用 </li>
</ul>
<p>RequestDispatcher 的 include 方法 用来做页面布局 —— &lt;%@include%&gt; <a href="jsp:include" target="_blank" rel="noopener">jsp:include</a><br>将页面公共部分抽取出来，通过include 引用到页面中 —- 更加方便维护 </p>
<hr>
<p>总结：<br>    1、Response 四个必须 API setStatus setHeader getOutputStream getWriter<br>    setStatus 状态码<br>    setHeader 头信息<br>    getOutputStream getWriter  响应体</p>
<pre><code>2、重定向 302 + Location ---- 简写 sendRedirect 
案例 用户登录重定向 

3、refresh自动刷新网页 
&lt;meta&gt; 标签使用 

4、禁用浏览器缓存 三个头字段 

5、响应中文乱码 ---- 都使用setContentType

6、文件下载 超链接和Servlet程序 
    Servlet程序 设置两个头字段 Content-Type Content-Disposition

7、验证码程序 （写完整存档）
    * 验证码点击切换 两种方法 

8、request请求行相关API getRequestURI getContextPath getRemoteAddr getMethod  
    思考：获得访问资源路径 

9、request头信息获得（不重要） ---- 掌握防盗链案例

10、获得请求参数 乱码解决 get 、post  （超级重要）

11、转发共享request数据 、include进行页面布局 ---- 了解即可
</code></pre><hr>
<p>POST编码与GET编码</p>
<p>1.POST编码<br>  &lt;%@page pageEncoding=”UTF-8”%&gt; 浏览器当前是什么编码就以什么编码提交<br>  Servlet：因为客户端没有告诉服务器，请求正文的编码，于是服务器默认用ISO-8859-1进行编码，从而出现乱码<br>  解决方法：告诉服务器请求正文的数据应该使用的编码是什么(request.setCharacterEncoding(“UTF-8”);)</p>
<p>2.GET编码<br>  &lt;%@page pageEncoding=”UTF-8”%&gt; 浏览器当前是什么编码就以什么编码提交<br>  Servlet：URL地址后的参数服务器默认用ISO-8859-1进行编码，这样会产生乱码<br>  解决方法：如果依照POST的解决乱码的方法，结果是无效的。需要拿到原始的二进制数据，然后用UTF-8进行重新编码</p>
<p>  byte b[] = name.getBytes(“ISO-8859-1”);//1010101<br>  String name = new String(b,”UTF-8”);//解决</p>
<hr>
<p>Request Response对象解决乱码的应用</p>
<pre><code>1.服务器解决乱码
response.setContentType(&quot;text/html;charset=gbk&quot;);
2.浏览器解决乱码
request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre><hr>
<p>Servlet技术</p>
<pre><code>1、Servlet程序编写 ----- 生命周期
2、ServletAPI Request Response 
3、Cookie 和 Session 
</code></pre><p>注意：Servlet 用来 动态web资源 开发<br>    静态web资源 ： 固定数据文件<br>    动态web资源 ： 通过程序动态生成数据文件 </p>
<pre><code>Servlet技术基于Request-Response编程模型 ---- HTTP协议也是基于请求响应 模型 
* Servlet技术 用来 开发基于HTTP web 应用程序 

接触 JavaEE API ------ 程序 接口 和 已经实现接口 类的 使用 
JavaEE ---- Java Platform, Enterprise Edition  缩写 
</code></pre><hr>
<p>Servlet快速入门<br>    1、创建web project<br>    2、编写 class 继承 HttpServlet<br>    3、在web.xml 配置 Servlet程序 虚拟访问路径 </p>
<pre><code>    * 用户在浏览器上通过这个路径 访问编写Servlet程序 
4、覆盖doGet或者doPost方法 进行输出 

* Servlet 动态生成 网页文件 

执行过程
    1、用户在客户端发起url请求 ： http://localhost/day05/hello ----- web.xml /hello 映射 HelloServlet程序
    2、用户提交请求时，get方式提交 执行 HelloServlet的 doGet方法 post方式提交 执行 HelloServlet的doPost 方法 

Servlet程序在编写和运行时，需要javaee 类库 （API支持）
    * 在学习javase  List 需要 import java.util.List  需要 jre/lib/rt.jar 
    * MyEclipse 自动导入 javaee5 liberary  存在 javaee.jar  提供 Servlet 需要类 API支持 （开发环境使Servlet程序正常编译）
    * Serlvet程序运行tomcat环境中 没有javaee.jar , 在 tomcat/lib/servlet-api.jar 提供Servlet程序运行需要 类API 支持 （运行环境需要的）

手动编写Servlet运行
    1、在webapps 新建 day05test目录 --- 虚拟应用
    2、在day05test 新建 WEB-INF/classes
    3、将编写Servlet的java源码文件 放入 classes ，在 WEB-INF 配置web.xml 
    4、编译Servlet的 java程序 

设置classpath路径
    javac -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java  // 通过 -classpath 指定 Servlet需要jar 包

生成Servlet package结构 
    javac -d . -classpath E:\apache-tomcat-6.0.14\lib\servlet-api.jar HelloServlet.java


Servlet运行原理分析
    编写Servlet程序没有 main函数 ---- tomcat调用Servlet程序执行

    通过myeclipse向导 创建Servlet ---- 创建Servlet程序，生成web.xml 配置 
        * 生成Servlet信息非常复杂，想生成Servlet 内容整洁一些，精简一些 ------ 修改Servlet模板 
        1、myeclipse工具 ---- 安装目录 common / plugins
            com.genuitec.eclipse.wizards_8.5.0.me201003052220.jar

        2、解压缩 templates/Servlet.java --- 这个就是Servlet模板 

通过API Servlet继承关系 
    Servlet接口 ---- 实现类 ： GenericServlet ------ 子类 HttpServlet  ------ 编写Servlet 继承HttpServlet 
        * 编写Servlet 间接 实现 Servlet 接口  （简化开发）
    Servlet接口 提出，为了解决基于请求-响应模型数据处理 （并没有涉及与HTTP协议相关 API）
    GenericServlet 实现接口 通用Servlet 也没有提供与 HTTP协议相关 API 
    HttpServlet 引入与 协议相关 API 
</code></pre><hr>
<p>Servlet生命周期 </p>
<pre><code>1.init(ServletConfig config)  初始化 
2.service(ServletRequest req, ServletResponse res)  提供服务方法
3.destroy()  销毁 

1、tomcat服务器启动时，没有创建Servlet对象

//默认第一次请求时创建servlet实例，应用存在实例就存在，在实例被卸载，实例就销毁
2、第一次访问时，tomcat构造Servlet对象，调用 init，执行service 

3、从第二次以后访问 tomcat 不会从新创建Servlet对象，也不会调用init  每一次访问都会调用service 
4、当服务器重启或正常关闭时 调用destroy （正常关闭 shutdown.bat）

Servlet对象是tomcat创建的，每次请求调用Servlet中service方法，tomcat服务器会在每次调用Servlet的service方法时，为该方法创建Request对象和Response对象 
* 在 JavaEE API 中没有Request和Response实现类   实现类由Servlet服务器提供的，tomcat提供实现类 weblogic 提供实现类 

service方法 和 HttpServlet doGet/doPost 关系区别？ 必须阅读HttpServlet源代码 
在HttpServlet代码实现中，根据请求方式不同 调用相应doXXX方法 get方式请求 --- doGet  post方式 --- doPost 

配置Servlet随tomcat服务器启动时 进行初始化   &lt;load-on-startup &gt;
*&lt;load-on-startup &gt; 参数可以是一个数字 0-9 代表服务器加载优先级 0 最高 
例如：在tomcat启动时，想通过Servlet加载一些框架配置文件 配置随服务器启动 （struts1 ）
</code></pre><p>结论：<br>    1、编写Servlet 继承HttpServlet<br>    2、编写Servlet 不需要覆盖service方法，只需要覆盖doGet和doPost 方法</p>
<pre><code>Servlet初始化时覆盖init() ，无需覆盖init(config) ？？ 
* init(Config) 调用 init() 

当doGet和doPost代码逻辑相同时，可以相互调用，简化编程
</code></pre><hr>
<p>Servlet的三种创建方式</p>
<pre><code>1.实现javax.servlet.Servlet接口

2.实现javax.servlet.GenericServlet类(适配器模式)

3.继承javax.servlet.http.HttpServlet类(模板方法设计模式) 这种方式是开发中常用的方法

public class ServletDemo extends HttpServlet{
    protected void doGet(HttpServletRequest req,HttpServleResponse resp) throws ServletException,IOExcption{
        System.out.println(&quot;get方法实现&quot;);
        }
    protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException,IOException{
        System.out.println(&quot;doPost方法实现&quot;);
        }
    }
</code></pre><hr>
<pre><code>web.xml映射细节

    1.配置多个映射路径（配置多个&lt;servlet-mapping&gt;）：

        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;    
            &lt;servlet-name&gt;&lt;/servet-name&gt;
            &lt;url-pattern&gt;&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;

    2.通配符*代表任意字符串

        1.url-pattern: *.do  以*.字符串的请求都可以访问   注：不要加/ (扩展名匹配)
        2.url-pattern: /*  任意字符串都可以访问 (绝对匹配)
        3.url-pattern：/action/* 以/action开头的请求都可以访问 (开头匹配)

    注意：如果url-pattern的值是/，表示执行默认映射。所有资源都是servlet
</code></pre><hr>
<p>一个Servlet可以配置多个url-pattern </p>
<p>URL 配置格式 三种：<br>    1、完全路径匹配  (以/开始 ) 例如：/hello /init </p>
<pre><code>    * 当前工程没有被正确发布，访问该工程所有静态资源、动态资源 发生404 ----- 工程启动时出错了 
    * 查看错误时 分析错误
1) 单一错误 ： 从上到下 查看第一行你自己写代码 （有的错误与代码无关，查看错误信息）
2）复合错误 Caused by ---- 查看最后一个Caused by 
* Invalid &lt;url-pattern&gt; init2 in servlet mapping 

2、目录匹配 (以/开始) 例如：/*  /abc/* 
/ 代表网站根目录 

3、扩展名 (不能以/开始) 例如：*.do *.action 
典型错误 /*.do 

优先级：完全匹配&gt;目录匹配 &gt; 扩展名匹配 
</code></pre><p>路径问题：编写九九乘法表<br>    1、需要用户在客户端输入一个数字<br>    2、Servlet接收客户输入数字 打印对应乘法表 </p>
<pre><code>在chengfabiao.html 通过 action 访问 ChengfabiaoServlet  路径可以用绝对路径和相对路径 

相对路径：相对当前网页地址 路径  例如 chengfabiao  ./chengfabiao ../chengfabiao
例如： http://localhost/day05/chengfabiao.html  提交 action=&quot;chengfabiao&quot;

* 将url最后地址换成相对路径 
结果： http://localhost/day05/chengfabiao  ----- 服务器端 /chengfabiao

例如： http://localhost/day05/aaa/chengfabiao.html 提交 action=&quot;chengfabiao&quot;
结果： http://localhost/day05/aaa/chengfabiao  ----- 服务器 /chengfabiao 
* /aaa/chengfabiao 与服务器 /chengfabiao 不匹配 出现404 

http://localhost/day05/aaa/chengfabiao.html 提供 action=&quot;../chengfabiao&quot; 
结果：http://localhost/day05/aaa/../chengfabiao ---- &gt; ..和/aaa抵消 http://localhost/day05/chengfabiao 可以匹配服务器 /chengfabiao

结论：如果用相对路径提交请求，考虑当前路径， 当前访问服务器资源路径不同 ---- 相对路径写法不同

绝对路径 解决相对路径，会根据当前地址改变问题。 例如： /day05/chengfabiao 、http://localhost/day05/chengfabiao
绝对路径 以/开始 /访问服务器根目录 
例如： 客户端访问服务器，不管当前路径是什么 --- / 服务器根目录 http://localhost
/day05 --- 找到虚拟目录day05工程  /day05/chengfabiao --- 找到 day05工程下配置 虚拟路径/chengfabiao

结论： 客户端路径 /工程虚拟目录/servlet虚拟路径 例如：/day05/chengfabiao
服务器端 配置web.xml 不需要写工程虚拟目录  只要直接写/servlet虚拟路径  例如：/chengfabiao 
</code></pre><hr>
<p>掌握Servlet程序编写</p>
<pre><code>通过路径 访问Servlet 程序
</code></pre><ul>
<li><p>Servlet 生命周期</p>
<p>  init<br>  service<br>  destroy </p>
</li>
</ul>
<p>学习init方法   init(ServletConfig)   通过ServletConfig 获得Servlet初始化参数</p>
<pre><code>1、创建一个Servlet
2、在web.xml 中 &lt;servlet&gt; 标签内 通过 &lt;init-param&gt; 标签 为Servlet配置初始化参数
        &lt;init-param&gt;
            &lt;param-name&gt;itcast&lt;/param-name&gt;
            &lt;param-value&gt;传智播客&lt;/param-value&gt;
        &lt;/init-param&gt;

3、在Servlet程序中通过ServletConfig对象 获得itcast对应数据 
    getInitParameter   通过name获得value
    getInitParameterNames  获得所有name 

  Servlet获取配置信息

    ServletConfig作用：

        1.获取servlet配置信息
        2.获取ServletContext对象 ServletContext对象代表整个应用，且一个应用应用只有一个ServletContext对象 作用：在一定范围之内使得多个Servlet共享数据

* 思考 ：如何在doGet 或 doPost 方法中 获得 Servlet初始化参数 
    1.将ServletConfig对象保存实例成员变量 
    2.GenericServlet 已经将ServletConfig 保存成员变量   在子类中通过 getServletConfig方法 获得 初始化参数

结论：子类Servlet不需要覆盖 init(ServletConfig) , 只需要通过GenericServlet中 getServletConfig() 获得ServletConfig对象 

应用：在init-param 指定配置文件位置和名称，配置Servlet随服务器启动创建 load-on-startup  

* ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得   每个Servlet程序都对应一个ServletConfig对象 

ServletContext 是Servlet上下文对象 
    每一个工程 对会创建 单独ServletContext对象，这个对象代表当前web工程 
    操作ServletContext 必须通过ServletConfig 获得对象 
</code></pre><p>应用：<br>    1、 获得整个web应用初始化参数<br>    2、 实现全局数据共享<br>    3、 实现服务器端转发功能<br>    4、 读取web工程资源文件</p>
<pre><code>1、获取WEB应用的初始化参数 和 ServletConfig 对象不同 
* ServletConfig对象 配置参数，只对配置Servlet有效，如果配置参数，所有Servlet都可以访问 通过ServletContext
    &lt;context-param&gt;

2、通过ServletContext 在多个Servlet间 共享数据 
    在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1 
    在CountServlet 初始化过程中，向ServletContext 保存访问次数   0    ServletContext  setAttribute 

      每次访问次数 +1  数据存放ServletContext中  所有Servlet都可以获得该数据

    * 在ServletContext中保存数据，所有Servlet都可以访问 

3、通过ServletContext 完成服务器程序转发 
    什么是转发？ 转发和重定向区别 ？
    getRequestDispatcher(java.lang.String path)   完成转发

    使用转发还是重定向？   转发性能好于重定向，请求次数好 

    统计字母次数
    request.getParameter(&quot;content&quot;) 获得form 提交内容 content 就是 textarea name属性

4、利用ServletContext对象读取资源文件

    使用java application 读取文件，读取当前工程下所有文件    使用相对路径读取文件
    使用Servlet读取文件 只能读取WebRoot下所有文件    必须使用绝对磁盘路径读取文件 

    通过站点根目录绝对路径 获得磁盘绝对路径   getServletContext().getRealPath(“/WEB-INF/info.txt”)

    * 因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，通过Class类对象读取 该目录下文件 
    String filename3 = c.getResource(&quot;/a1.txt&quot;).getFile();    / 代表 /WEB-INF/classes 

结论：在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx     getServletContext().getRealPath(&quot;/xxx&quot;);  /代表WebRoot 
      如果读取文件 恰好位于 WEB-INF/classes   通过 类名.class.getResource(&quot;/文件名&quot;).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes 


    缺省Servlet 功能：处理其他Servlet都不处理请求 
    tomcat/conf/web.xml  org.apache.catalina.servlets.DefaultServlet 作为缺省Servlet 
</code></pre><p>总结：<br>    1、编写Servlet HelloServlet<br>    2、修改Servlet模板<br>    3、Servlet生命周期 理论重点掌握<br>    4、Servlet url三种写法 完全、目录、扩展名<br>    5、路径问题：绝对路径      案例 九九乘法表<br>        将web.xml 配置路径复制到网页 在路径前 /工程名<br>    6、ServletConfig 和ServletContext 读取初始化参数区别 ？<br>    7、ServletContext数据共享案例      统计访问次数<br>    8、ServletContext转发案例   统计字母出现次数<br>    9、读取web工程中资源文件    绝对路径<br>        在web工程中，必须将 文件路径转换绝对磁盘路径 c:\xxx e:\xxx\xxx    getServletContext().getRealPath(“/xxx”);  /代表WebRoot<br>        如果读取文件 恰好位于 WEB-INF/classes    通过 类名.class.getResource(“/文件名”).getFile(); 获得绝对磁盘路径  / 代表 /WEB-INF/classes<br>    10、缺省Servlet 了解功能将静态资源数据内容读取写给客户端 </p>
<hr>
<h4 id="Servlet-基本训练"><a href="#Servlet-基本训练" class="headerlink" title="Servlet 基本训练"></a>Servlet 基本训练</h4><pre><code>1.在Servlet中实现请求转发

    在Servlet中实现页面转发，使用的是RequestDispatcher对象的 forward（）方法。可以在Servlet中通过 forward（）方法将当前的请求转发到其他web组件（Servlet、JSP、HTML）。

2.在Servlet中处理表单提交的数据

    Java Web的核心组件Servlet的主要功能就是处理客户端的表单请求数据，然后再Servlet中首先对这些数据进行验证，然后可能会封装到JavaBean。
    接下来调用数据库的业务逻辑方法将数据保存或者进行其他操作，最后Servlet控制将响应结果返回到客户端。

    注意：在实际开发中，Servlet处理完表单数据之后，通常会根据表单数据更新数据库，最后再由Servlet进行控制转发

3.在Servlet中实现页面重定向

    实现页面重定向主要应用在HttpServletResponse对象的sendRedirect()方法

4.动态生成HTML文档

5.在Servlet中向客户端写cookie信息
</code></pre><hr>
<p>HttpServletResponse HttpServletRequest(关键：了解HTTP协议)</p>
<pre><code>Web服务器(TOMCAT)收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。
所以既然response/request对象代表请求和响应，那么获取客户端提交过来的数据只需要找request对象就可以，然后向容器输出数据，只需要找response对象就可以了。
</code></pre><p>1.HttpServletResponse(该对象代表服务器的响应 此对象中封装了向客户端发送数据、发送响应头、发送响应状态码的方法)</p>
<pre><code>1.响应行 setStatus(int sc);//设置相应状态码 HTTP/1.1 200
2.相应头 setHeader(String name,String value);//设置响应头信息 
      请求重定向 sendRedirect(String location);

  浏览器使用的码表(告知)
    response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

  告知客户端不缓存
    response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
    response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
    response.setDataHeader(&quot;expires&quot;,0);
3.相应正文
    setCharacterEncoding(String charset);//告知服务器使用什么编码
    setContentType(String type);

扩展：response常见应用

    向客户端输出中文数据：response.getOutputStream().write(“中国”.getBytes()));//以默认编码发送数据

    注意：当浏览器中出现乱码，通过以下方法：response.setContentType(&quot;text/html;charset=UTF-8&quot;); 解决
    总结：程序以什么编码输出就需要告诉客户端以什么编码显示

    response细节：

        1.getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。
        2.getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。  会抛异常。
        3.Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 
        4.Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。 
</code></pre><p>2.HttpServletRequest(代表客户端的请求，当客户端通过HTTP协议访问服务器时，Http请求头中的所有信息都封装到这对象，开发人员通过此对象的方法获取客户的这些信息)</p>
<pre><code>1.请求行
  Get方式 URL链接：http://localhost:8080/day09/servlet/req1?username=zs  协议：http/1.1

    getMethod(); 获得请求方式
    getRequestURL();返回客户端发出请求时的完整URL。
    getRequestURI(); 返回请求行中的资源名部分。
    getContextPath(); 当前应用的虚拟目录 /day09_01_request
    getQueryString() ; 返回请求行中的参数部分。

2.请求消息头

  String getHeader(String name)  根据头名称得到头信息值
  Enumeration   getHeaderNames()  得到所有头信息name
  Enumeration   getHeaders(String name)  根据头名称得到相同名称头信息值

3.请求正文

获取表单数据相关的方法
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  getParameter(name) 根据表单中name属性的名，获取value属性的值方法 
  getParameterValues（String name）专业为复选框取取提供的方法
  getParameterNames() 得到表单提交的所有name的方法 
  getParameterMap 到表单提交的所有值的方法   //做框架用，非常实用
  getInputStream  以字节流的方式得到所有表单数据

扩展：
    操作非表单数据相关的方法(request是一个域对象)
        void setAttribute(String name, Object value);
        Object getAttribute(String name);
        void removeAttribute(String name);

    请求转发相关方法

        //得到请求转发或请求包含的协助对象
        RequestDispatcher getRequestDispatcher(String path)
        forward(ServletRequest request, ServletResponse response) //转发的方法
        include(ServletRequest request, ServletResponse response) //请求包含

    请求编码相关方法

        //解决post方式编码
        request.setCharacterEncoding(&quot;UTF-8&quot;); //告诉服务器客户端什么编码,只能处理post请求方式

        //解决get方式编码
        String name = new String(name.getBytes(“iso-8859-1”),”UTF-8”);
</code></pre><hr>
<p>一、什么Servlet？</p>
<pre><code>servlet 是运行在 Web 服务器中的小型 Java 程序（即：服务器端的小应用程序）。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。
</code></pre><p>1.1、编写一个servlet程序：<br>a、写一个java类，实现servlet接口</p>
<pre><code>public class ServletDemo implements Servlet{
    //接收用户请求，并作出响应
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        response.getWriter().write(&quot;hello ServletDemo&quot;);
    }
}
</code></pre><p>b、修改web.xml文件，给servlet提供一个可访问的URI地址</p>
<pre><code>&lt;!--创建Servlet实例--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servletDemo的实现类&lt;/servlet-class&gt;
&lt;/sevlet&gt;

&lt;!--给servlet提供(映射)一个可以访问的URI地址--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>c、部署应用到tomcat服务器</p>
<p>d、测试：<a href="http://locahost:8080/day08_servlet/demo1" target="_blank" rel="noopener">http://locahost:8080/day08_servlet/demo1</a></p>
<p>二、执行过程</p>
<pre><code>1.首先在浏览器输入地址，然后地址转到Tomcat找到servlet应用
2.然后在servlet应用中找到相应的访问的demo
3.在找到对应的demo之后实例化后调用初始化方法
4.然后再次调用service方法
5.最后将信息响应给客户端并调用distory方法
</code></pre><p>三、Servlet生命周期（重要）<br>    实例化–&gt;初始化–&gt;服务-&gt;销毁<br>出生：（实例化–&gt;初始化）第一次访问Servlet就出生（默认情况下）<br>活着：（服务）应用活着，servlet就活着<br>死亡：（销毁）应用卸载了servlet就销毁。</p>
<pre><code>//默认第一次请求，创建Servlet实例，当应用存在那么实例就存在，应用卸载，相应的实例就销毁
public class ServletDemo implements Servlet{
    //生命周期的方法：实例化对象
    //第一次被访问时调用
    public ServletDemo(){
        System.out.println(&quot;ServletDemo被调用&quot;);
    }
    //生命周期的方法：初始化方法
    //第一次被访问时调用
    public void init(ServletConfig config) throws ServletException{
        System.out.println(&quot;init方法被调用&quot;);
    }
    //生命周期方法：服务方法
    //接受用户请求，并做出相应
    //每次请求都被调用
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;service方法被调用&quot;);
    }
    //生命周期的方法：销毁
    //当应用被卸载时调用
    public void destroy(){
        System.out.println(&quot;destroy被调用&quot;);
    }
}
</code></pre><p>小知识：<br>如何让servlet在服务器启动时就创建。</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servletDemo的实现类&lt;/servlet-class&gt;
    &lt;!--使得当前servlet在服务器启动时创建--&gt;
    &lt;load-on-startup&gt;2&lt;/load-no-startup&gt;
&lt;/sevlet&gt;
</code></pre><p>四、Servlet的三种创建方式<br>4.1、实现javax.servlet.Servlet接口（参见：编写一个servlet程序：）</p>
<p>4.2、继承javax.servet.GenericServlet类(适配器模式)</p>
<pre><code>public class ServletDemo extends GenericServlet{
    public void service(ServletRequest request,ServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;servletDemo&quot;);
    }
}
</code></pre><p>4.3、继承javax.servlet.http.HttpServlet类（模板方法设计模式）<br>(开发中常用方式)</p>
<pre><code>//不要重写父类的service方法
public class ServletDemo extends HttpServlet{
    protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{
        System.out.println(&quot;servletDemo doGet方法被调用&quot;);
    }
    protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{

    }
}
</code></pre><p>Servlet –&gt; GenericServlet –&gt; HttpServlet  (继承HttpServlet)<br>曾祖父     爷爷        爸爸     孙子</p>
<p>小技巧：使生成的servlet更清新一些<br>找到：MyEclipse\Common\plugins目录<br>把com.genuitec.eclipse.wizards_9.0.0.me201108091322.jar复制到上面目录<br>servet映射细节：<br>servet映射细节1：</p>
<pre><code>&lt;!--配置多个映射路径--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletDemo3&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ServletDemo3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>servet映射细节2: 通配符<em> 代表任意字符串<br>url-pattern: </em>.do  以<em>.字符串的请求都可以访问 注：不要加/<br>url-pattern: /</em>  任意字符串都可以访问<br>url-pattern： /action/* 以/action开头的请求都可以访问<br>匹配规则：<br>优先级：从高到低<br>绝对匹配–&gt;  /开头匹配 –&gt; 扩展名方式匹配</p>
<p>如果url-pattern的值是/，表示执行默认映射。所有资源都是servlet</p>
<p>五、Servlet的线程安全<br>单实例：每次访问多线程<br>解决线程安全问题的最佳办法，不要写全局变量，而写局部变量。</p>
<p>六、Servlet获取配置信息<br>ServletConfig的使用<br>作用1：可以获取servlet配置信息<br>方式1：</p>
<pre><code>private ServletConfig config;
//使用初始化方法回复到ServletConfig对象，此对象由服务器创建
public void init(ServletConfig config) throws ServletException{
    this.config = config;
}

public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{
    String value = config.getInitParameter(&quot;encoding&quot;);//根据配置文件中的名，得到值
    System.out.println(value);
}
</code></pre><p>方式2：</p>
<pre><code>//通过使用继承父类的方法得到ServletConfig对象
String value = this.getServletConfig().getInitParameter(&quot;encoding&quot;);
System.out.println(value);
</code></pre><p>方式3：</p>
<pre><code>String value = this.getInitParameter(&quot;encoding&quot;);
System.out.println(value);
</code></pre><p>作用2：可以获得ServletContext对象</p>
<p>七、ServletContext（重要）<br>ServletContext: 代表的是整个应用。一个应用只有一个ServletContext对象。单实例。<br>作用：<br>域对象：在一定范围内（当前应用），使多个Servlet共享数据。<br>常用方法：<br>void setAttribute(String name,object value);//向ServletContext对象的map中添加数据<br>Object getAttribute(String name);//从ServletContext对象的map中取数据<br>void rmoveAttribute(String name);//根据name去移除数据</p>
<p>获取全局配置信息：</p>
<p>修改web.xml文件：</p>
<pre><code>&lt;!--配置当前应用的全局信息--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>String getInitParameter(String name) //根据配置文件中的key得到value</p>
<pre><code>//获取全局配置信息
String encoding = sc.getInitParameter(&quot;encoding&quot;);
System.out.println(encoding);
</code></pre><p>获取资源路径：<br>String  getRealPath(String path);//根据资源名称得到资源的绝对路径.<br>可以得到当前应用任何位置的任何资源。</p>
<p>实现Servlet的转发。</p>
<p> RequestDispatcher  getRequestDispatcher(String path) ;//参数表示要跳转到哪去</p>
<hr>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h4 id="题目1-在Servlet中实现请求转发"><a href="#题目1-在Servlet中实现请求转发" class="headerlink" title="题目1 在Servlet中实现请求转发"></a>题目1 在Servlet中实现请求转发</h4><pre><code>1.index.jsp
&lt;form action=&quot;forward&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

   2.forwardServlet.java
   public class ForwardServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);//设置请求的字符编码格式
        String name = request.getParameter(&quot;name&quot;);    //获得请求表单中的用户名
        String pwd = request.getParameter(&quot;pwd&quot;);//获得请求表单的密码
        if ((name != null &amp;&amp; !name.equals(&quot;&quot;))&amp;&amp; (pwd != null &amp;&amp; !pwd.equals(&quot;&quot;))) {
            if (name.equals(&quot;zhaoyanliang&quot;) &amp;&amp; pwd.equals(&quot;123&quot;)) {
                request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request,response);    //使用RequestDispatcher对象将页面请求转发到success.jsp页
            } else {
                request.getRequestDispatcher(&quot;error.jsp&quot;).forward(request,response);
            }
        }else {

        }
    }
}

3.web.xml
&lt;servlet&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;cn.itcast.servlet.ForwardServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/forward&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><hr>
<h4 id="题目2-在Servlet中处理表单提交的数据"><a href="#题目2-在Servlet中处理表单提交的数据" class="headerlink" title="题目2 在Servlet中处理表单提交的数据"></a>题目2 在Servlet中处理表单提交的数据</h4><pre><code>1.index.jsp
&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;性别：&lt;/td&gt;
               &lt;td&gt;
                   &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; /&gt;男
                   &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女
               &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;年龄：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;Email：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;
                   &lt;input type=&quot;submit&quot; value=&quot;注 册&quot; /&gt;
                   &lt;input type=&quot;reset&quot; value=&quot;重 置&quot; /&gt;
               &lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.LoginServlet.java
public class LoginServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;GBK&quot;);            //设置请求的字符编码格式
        String name = request.getParameter(&quot;name&quot;);        //获得用户名
        String pwd = request.getParameter(&quot;pwd&quot;);        //获得密码
        String sex = request.getParameter(&quot;sex&quot;);        //获得性别
        String age = request.getParameter(&quot;age&quot;);        //获得年龄
        String email = request.getParameter(&quot;email&quot;);    //获得Email
        request.getRequestDispatcher(&quot;logininfo.jsp&quot;).forward(request, response);
    }
}

3.logininfo.jsp
&lt;table align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;用户名：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;name&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;密码：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;pwd&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;性别：&lt;/td&gt;
        &lt;td&gt;
            &lt;%=request.getParameter(&quot;sex&quot;)%&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;年龄：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;age&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Email：&lt;/td&gt;
        &lt;td&gt;&lt;%=request.getParameter(&quot;email&quot;)%&gt;&lt;/td&gt;
    &lt;/tr&gt;
   &lt;/table&gt;
</code></pre><hr>
<h4 id="题目3-在Servlet中实现页面重定向"><a href="#题目3-在Servlet中实现页面重定向" class="headerlink" title="题目3 在Servlet中实现页面重定向"></a>题目3 在Servlet中实现页面重定向</h4><pre><code>1.index.jsp
&lt;form action=&quot;redirect&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.RedirectServlet.java
public class RedirectServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);        //设置请求数据的字符编码格式
        String name = request.getParameter(&quot;name&quot;); //获得请求表单中的用户名
        String pwd = request.getParameter(&quot;pwd&quot;);    //获得请求表单中的密码
        if((name!=null&amp;&amp;!name.equals(&quot;&quot;))&amp;&amp;(pwd!=null&amp;&amp;!pwd.equals(&quot;&quot;))){
            if(name.equals(&quot;mr&quot;)&amp;&amp;pwd.equals(&quot;123&quot;)){
                //使用SendRedirect()方法将页面重定向到success.jsp
                response.sendRedirect(&quot;success.jsp&quot;);
            }else{
                //使用SendRedirect()方法将页面重定向到error.jsp
                response.sendRedirect(&quot;error.jsp&quot;);
            }
        }
    }
}
</code></pre><hr>
<h4 id="题目4-动态生成HTML文档"><a href="#题目4-动态生成HTML文档" class="headerlink" title="题目4 动态生成HTML文档"></a>题目4 动态生成HTML文档</h4><pre><code>public class ServletHTML extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        //设置响应的字符集格式为UTF-8
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        //设置响应正文的MIME类型
        response.setContentType(&quot;text/html&quot;);
        //返回一个PrintWriter对象，Servlet使用它来输出字符串形式的正文数据
        PrintWriter out = response.getWriter();
        //以下为输出的HTML正文数据
        out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;&quot;);
        out.println(&quot;&lt;HTML&gt;&quot;);
        out.println(&quot;&lt;HEAD&gt;&lt;TITLE&gt;动态生成HTML文档&lt;/TITLE&gt;&quot;);
        out.println(&quot;&lt;link rel=;stylesheet&apos; type=&apos;text/css&apos; href=&apos;css/style.css&apos;&gt;&quot;);
        out.println(&quot;&lt;/HEAD&gt;&quot;);
        out.println(&quot;&lt;BODY&gt;&quot;);
        out.println(&quot;&lt;table border=&apos;1&apos; align=&apos;center&apos;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&lt;td&gt;动态生成HTMl文档&lt;/td&gt;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&lt;td&gt;表格&lt;/td&gt;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;/BODY&gt;&quot;);
        out.println(&quot;&lt;/HTML&gt;&quot;);
        out.flush();
        out.close();
    }

}
</code></pre><hr>
<h4 id="题目5-在Servlet中向客户端写Cookie信息"><a href="#题目5-在Servlet中向客户端写Cookie信息" class="headerlink" title="题目5 在Servlet中向客户端写Cookie信息"></a>题目5 在Servlet中向客户端写Cookie信息</h4><pre><code>1.index.jsp
&lt;form action=&quot;cookieservlet&quot; method=&quot;post&quot;&gt;
       &lt;table align=&quot;center&quot;&gt;
           &lt;tr&gt;
               &lt;td&gt;用户名：&lt;/td&gt;
               &lt;td&gt;
               &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
               &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td&gt;密码：&lt;/td&gt;
               &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr&gt;
               &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; /&gt;&lt;/td&gt;
           &lt;/tr&gt;
       &lt;/table&gt;
   &lt;/form&gt;

2.CookieServlet.java
public class CookieServlet extends HttpServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);
        String name = request.getParameter(&quot;name&quot;);            // 获取用户名
        //创建一个Cookie对象，并将用户名保存到Cookie对象中
        Cookie nameCookie = new Cookie(&quot;userName&quot;, name);
        //设置Cookie过期之前的时间，单位为秒
        nameCookie.setMaxAge(60);
        //通过response的addCookie()方法将此Cookie对象保存到客户端浏览器的Cookie中
        response.addCookie(nameCookie);
        request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request, response);
    }
}

3.在index.jsp中读取所有客户端的Cookie，通过循环Cookie数组找到保存用户名的Cookie
&lt;%
      String userName=null;//用于保存从cookie中读取出的用户名
      Cookie cookieArr[] = request.getCookies();//获取客户端的所有Cookie
      if(cookieArr!=null&amp;&amp;cookieArr.length&gt;0){
          for(Cookie c:cookieArr){
              if(c.getName().equals(&quot;userName&quot;)){ //如果Cookie中有一个名为
                                                           userName的Cookie
                  userName =c.getValue();            //获得此cookie的值 
              }
          }
      }
%&gt;   

4.将获取到的用户名Cookie的值赋值给用户名文本框
&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&lt;%if(userName!=null){out.print(userName);}%&gt;&quot;/&gt;
</code></pre><blockquote>
<p>注意：在创建Cookie对象时，由于不可以直接将中文字符作为Cookie的值，因此在将中文字符保存到Cookie对象之前，应该使用java.net.URLEncoder类的encode()方法对中文字符进行编码。在获取该Cookie对象中的值时，需要使用java.net.URLDecoder类的decode()方法对已经编码过的字符进行解码，还原字符串的初始值。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/Java 核心技术36讲 重点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/Java 核心技术36讲 重点/" itemprop="url">Java核心技术36讲</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:38:11+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java核心技术36讲/" itemprop="url" rel="index">
                    <span itemprop="name">Java核心技术36讲</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  19,551
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  70
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h4 id="谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗"><a href="#谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗" class="headerlink" title="谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?"></a>谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?</h4><ul>
<li>一次编译、到处运行”说的是Java语言跨平台的特性,Java的跨平台特性与Java虚拟机的存在密不可分,可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK,安装 好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异,并不是说Java语言可以跨平台,而是在不同的平台都有可以让Java语言运行的环境而已,所以 才有了Java一次编译,到处运行这样的效果。</li>
<li>程序从源代码到运行的三个阶段:编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的:首先是将Java源代码转化成.CLASS文件字节码,这是第 一次编译。.class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码,这是是由JVM来执行的,即Java的第二次编译。</li>
<li>Java是解析运行吗? 不正确! Java源代码经过Javac编译成.class文件 .class文件经JVM解析或编译运行。</li>
</ul>
<h4 id="Exception和Error有什么区别"><a href="#Exception和Error有什么区别" class="headerlink" title="Exception和Error有什么区别?"></a>Exception和Error有什么区别?</h4><ul>
<li><code>Exception</code>和<code>Error</code>都是继承了<code>Throwable</code>类,在Java中只有<code>Throwable</code>类型的实例才可以被抛出(throw)或者捕获(catch),它是异常处理机制的基本组成类型。</li>
<li><code>Exception</code>是程序正常运行中,可以预料的意外情况,可能并且应该被捕获,进行相应处理。</li>
<li><code>Error</code>是指在正常情况下,不大可能出现的情况,绝大部分的Error都会导致程序(比如JVM自身)处于非正常的、不可恢复状态。既然是非正常情况,所以不便于也不需要捕获,常 见的比如<code>OutOfMemoryError</code>之类,都是<code>Error</code>的子类。</li>
<li><code>Exception</code>又分为<code>可检查(checked)</code>异常和<code>不检查(unchecked)</code>异常,可检查异常在源代码里必须显式地进行捕获处理,这是编译期检查的一部分</li>
<li>不检查异常就是所谓的运行时异常,类似 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>之类,通常是可以编码避免的逻辑错误,具体根据需要来判断是否需要捕 获,并不会在编译期强制要求。<br><img src="https://img-blog.csdnimg.cn/20190406111450760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""><blockquote>
<p><code>异常处理的基本原则</code>:<br>尽量不要捕获类似Exception这样的通用异常,而是应该捕获特定异常<br>不要生吞(swallow)异常。这是异常处理中要特别注意的事情,因为很可能会导致非常难以诊断的诡异情况。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="谈谈final、finally、-finalize有什么不同？"><a href="#谈谈final、finally、-finalize有什么不同？" class="headerlink" title="谈谈final、finally、 finalize有什么不同？"></a>谈谈final、finally、 finalize有什么不同？</h4><ul>
<li><p><code>final</code>可以用来修饰类、方法、变量,分别有不同的意义,<code>final</code>修饰的<code>class</code>代表不可以继承扩展,fnal的变量是不可以修改的,而fnal的方法也是不可以重写的(override)。</p>
</li>
<li><p><code>finally</code>则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</p>
</li>
<li><p><code>finalize</code>是基础类java.lang.Object的一个方法,它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。fnalize机制现在已经不推荐使用,并且在JDK 9开始被标记 为deprecated。</p>
</li>
</ul>
<blockquote>
<p>提示：final变量产生了某种程度的不可变效果，所以可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可<br>以省去一些防御性拷贝的必要。</p>
</blockquote>
<hr>
<h4 id="强引用、软引用、弱引用、幻象引用有什么区别"><a href="#强引用、软引用、弱引用、幻象引用有什么区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别?"></a>强引用、软引用、弱引用、幻象引用有什么区别?</h4><ul>
<li><code>强引用</code>:我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足,JVM宁愿抛出OutOfMemoryError运 行时错误(OOM),使程序异常终止,也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象,如果没有其他的引用关系,只要超过了引用的作用域或者显式 地将相应(强)引用赋值为 null,就是可以被垃圾收集的了,具体回收时机还是要看垃圾收集策略。</li>
</ul>
<ul>
<li><code>软引用</code>:软引用通过<code>SoftReference</code>类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时,才会去试图回收软引用指向的对象:即JVM 会确保在抛出 OutOfMemoryError 之前,清理软引用指向的对象。软引用可以和一个引用队列(ReferenceQueue)联合使用,如果软引用所引用的对象被垃圾回收器回收,Java虚拟机就会把这个软引用加入到与之关联的引用 队列中。后续,我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空,将返回一个null,否则该方法返回队列中前面的一个Reference对象</li>
</ul>
<ul>
<li><code>弱引用</code> 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中,一旦发现了具有弱引用的对象,不管当前内存空间足够与否,都会 回收它的内存。由于垃圾回收器是一个优先级很低的线程,因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列(ReferenceQueue)联合使用,如果弱引用所引用的对象被垃圾 回收,Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。弱应用同样可用于内存敏感的缓存。</li>
</ul>
<ul>
<li><code>幻象引用</code>,有时候也翻译成虚引用,你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被fnalize以后,做某些事情的机制。如果 一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 (ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时,如 果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中。</li>
</ul>
<hr>
<h4 id="String、StringBufer、StringBuilder有什么区别"><a href="#String、StringBufer、StringBuilder有什么区别" class="headerlink" title="String、StringBufer、StringBuilder有什么区别?"></a>String、StringBufer、StringBuilder有什么区别?</h4><ul>
<li><p><code>String</code>被声明成为fnal class,所有属性也都是fnal的。也由于它的不可 变性,类似拼接、裁剪字符串等动作,都会产生新的String对象。Java为了避免在一个系统中产生大量的String对象,引入了字符串常量池，创建一个字符串时,首先检查池中是否有值相同的字符串对 象,如果有则不需要创建直接从池中刚查找到的对象引用;如果没有则新建字符串对象,返回对象引用,并且将新创建的对象放入池中。但是,通过new方法创建的String对象是不检查字符串 池的,而是直接在堆区或栈区创建一个新的对象,也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。<code>String</code>提供了<code>inter</code>()方法。调用该方法时,如果常量池中包括了一个等于此String对象的字符串(<code>由equals方法确定</code>),则返回池中的字符串。否则,将此String对象添加到池中,并且 返回此池中对象的引用</p>
</li>
<li><p><code>StringBufer和StringBuilder</code>都实现了<code>AbstractStringBuilder</code>抽象类,拥有几乎一致对外提供的调用接口;其底层在内存中的存储方式与String相同,都是以一个有序的字符序列(char类型 的数组)进行存储,不同点是<code>StringBufer/StringBuilder</code>对象的<code>值是可以改变</code>的,并且值改变以后,对象引用不会发生改变;两者对象在构造过程中,首先按照默认大小申请一个字符数组,由 于会不断加入新数据,<code>当超过默认大小后</code>,会创建一个更大的数组,并将原先的数组内容复制过来,再丢弃旧的数组。因此,对于较大对象的扩容会涉及大量的内存复制操作,如果能够预先评估大小,可提升性能。</p>
</li>
<li><p>唯一需要注意的是:<code>StringBufer是线程安全</code>的,但是<code>StringBuilder</code>是<code>线程不安全</code>的。可参看Java标准类库的源代码,<code>StringBufer</code>类中方法定义前面都会有<code>synchronize</code>关键字。为 此,StringBufer的性能要远低于StringBuilder。</p>
</li>
</ul>
<h4 id="谈谈Java反射机制-动态代理是基于什么原理"><a href="#谈谈Java反射机制-动态代理是基于什么原理" class="headerlink" title="谈谈Java反射机制,动态代理是基于什么原理"></a>谈谈Java反射机制,动态代理是基于什么原理</h4><ul>
<li><p><code>反射机制</code>是Java语言提供的一种基础功能,赋予程序在运行时自省(introspect,官方用语)的能力。通过反射我们可以直接操作类或者对象,比如获取某个对象的类定义,获取类 声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。</p>
</li>
<li><p><code>动态代理</code>是一种方便运行时动态构建代理、动态处理代理方法调用的机制,很多场景都是利用类似机制做到的,比如用来包装RPC调用、面向切面的编程(AOP)。</p>
</li>
<li><p><code>JDK</code>动态代理:基于Java反射机制实现,必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。</p>
</li>
<li><p><code>cglib</code>动态代理:基于ASM机制实现,通过生成业务类的子类作为代理类。</p>
</li>
</ul>
<hr>
<h4 id="int和Integer有什么区别-谈谈Integer的值缓存范围。"><a href="#int和Integer有什么区别-谈谈Integer的值缓存范围。" class="headerlink" title="int和Integer有什么区别?谈谈Integer的值缓存范围。"></a>int和Integer有什么区别?谈谈Integer的值缓存范围。</h4><ul>
<li><p><code>int</code>是我们常说的整形数字,是Java的8个原始数据类型(Primitive Types,boolean、byte 、short、char、int、foat、double、long)之一。Java语言虽然号称一切都是对象, 但原始数据类型是例外。</p>
</li>
<li><p><code>Integer</code>是int对应的包装类,它有一个int类型的字段存储数据,并且提供了基本操作,比如数学运算、int和字符串之间转换等。在Java 5中,引入了自动装箱和自动拆箱功能 (boxing/unboxing),Java可以根据上下文,自动进行转换,极大地简化了相关编程。</p>
</li>
<li><p>Integer的值默认缓存 是-128到127之间。缓存上限值实际是可以根据需要调整的,JVM提供了参数设置: <code>-XX:AutoBoxCacheMax=N</code>。</p>
</li>
<li><p>不管是Integer还Boolean等,都被声明为“private fnal”,所以,它们同样是不可变类型!</p>
</li>
</ul>
<hr>
<h4 id="对比Vector、ArrayList、LinkedList有何区别"><a href="#对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="对比Vector、ArrayList、LinkedList有何区别?"></a>对比Vector、ArrayList、LinkedList有何区别?</h4><p>三者都实现集合框架中的List，所谓的有序集合。</p>
<ul>
<li><p><code>Vector</code>是线程安全的动态数组,。<code>Vector</code>内部是使用对象数组来保存数据,可以根据需要自动增加 容量,当数组已满时,会创建新的数组,并拷贝原有数组数据。Vector在扩容时会<code>提高1倍</code>。</p>
</li>
<li><p><code>ArrayList</code>是动态数组实现,不是线程安全的,性能要好很多。与Vector近似,ArrayList也是可以根据需要调整容量,不过两者的调整逻辑有所区 别。ArrayList扩容时是增加50%。</p>
</li>
<li><p><code>Vector和ArrayList作为动态数组</code>,其内部元素以数组形式顺序存储的,所以非常适合随机访问的场合。除了尾部插入和删除元素,往往性能会相对较差,比如我们在中间位置插 入一个元素,需要移动后续所有元素。</p>
</li>
<li><p><code>LinkedList</code>是Java提供的双向链表,它不需要像上面两种那样调整容量,也不是线程安全的。LinkedList进行节点插入、删除却要高效得多,但是随机访问性能则要比动态数组慢。</p>
</li>
</ul>
<blockquote>
<p>提示：在实际开发过程中，可以预先估计应用操作偏向于插入、删除，还是随机访问的多，可以进行针对性的选择。</p>
</blockquote>
<p>扩展：</p>
<blockquote>
<p><code>TreeSet</code> 支持自然顺序访问,但是添加、删除、包含等操作要相对低效(log(n)时间)。</p>
</blockquote>
<blockquote>
<p><code>HashSet</code>则是利用哈希算法,理想情况下,如果哈希散列正常,可以提供常数时间的添加、删除、包含等操作,但是它不保证有序。</p>
</blockquote>
<blockquote>
<p><code>LinkedHashSet</code>,内部构建了一个记录插入顺序的双向链表,因此提供了按照插入顺序遍历的能力,与此同时,也保证了常数时间的添加、删除、包含等操作,这些操作性能略 低于HashSet,因为需要维护链表的开销。</p>
</blockquote>
<blockquote>
<p>在遍历元素时,<code>HashSet</code>性能受自身容量影响,所以初始化时,除非有必要,不然不要将其背后的HashMap容量设置过大。而对于LinkedHashSet,由于其内部链表提供的方便,遍历性能只和元素多少有关系。</p>
</blockquote>
<blockquote>
<p><code>Java提供的默认排序算法</code>:<br>对于原始数据类型,目前使用的是所谓双轴快速排序,是一种改进的快速排序算法,早期版本是相对传统的快速排序<br>对于对象数据类型,目前则是使用TimSort,思想上也是一种归并和二分插入排序结合的优化排序算法</p>
</blockquote>
<hr>
<h4 id="对比Hashtable、HashMap、TreeMap-有什么不同"><a href="#对比Hashtable、HashMap、TreeMap-有什么不同" class="headerlink" title="对比Hashtable、HashMap、TreeMap 有什么不同?"></a>对比Hashtable、HashMap、TreeMap 有什么不同?</h4><ul>
<li><p><code>元素特性</code>：Hashtable 中的key、value都不能为null;HashMap中的key、value可以为null,很显然只能有一个key为null的键值对,但是允许有多个值为null的键值对;TreeMap是基于红黑树的一种提供顺序访问的Map,和HashMap不一样，它的get、put、<br>remove 之类操作都是 O（log(n)）的时间复杂度，TreeMap中当未实现 Comparator 接口时,key 不可以为null;当实现 Comparator 接口时,若未对null情况进行判断,则key不可以为null,反之亦然。</p>
</li>
<li><p><code>顺序特性</code>：HashTable 、HashMap具有无序特性。TreeMap 是利用红黑树来实现的(树中的每个节点的值,都会大于或等于它的左子树中的所有节点的值,并且小于或等于它的右子树中的所有节点的 值),实现了SortMap接口,能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap 来进行,默认为升序排序方式(深度优先搜索),可自定义实现Comparator接口 实现排序方式。</p>
</li>
<li><p><code>初始化与增长方式</code>：初始化时:Hashtable 在不指定容量的情况下的默认容量为11,且不要求底层数组的容量一定要为2的整数次幂;HashMap默认容量为16,且要求容量一定为2的整数次幂。 扩容时:Hashtable将容量变为原来的2倍加1;HashMap扩容将容量变为原来的2倍。</p>
</li>
<li><p><code>HashMap</code>基于哈希思想,实现对数据的读写。当我们将键值对传递给<code>put()</code>方法时,它调用<code>键对象的hashCode()</code>方法来计算<code>hashcode</code>,然后找到<code>bucket</code>位置来储存值对象。当获取对象时, 通过键对象的<code>equals()方法找到正确的键值对,然后返回值对象</code>。HashMap使用<code>链表来解决碰撞问题</code>,当发生碰撞了,对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时,它们会储存在同一个bucket位置的链表中,可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值 (TREEIFY_THRESHOLD, 8),链表就会被改造为树形结构(红黑树)。</p>
</li>
</ul>
<blockquote>
<p>提示：hashcode和equals的一些基本约定：1.equals相等，hashcode一定要相等。2.重写了hashCode也要重写equals。3.hashCode需要保持一致性，状态改变返回的哈希值仍然要一致。4.equals的对称、反射、传递等特性。</p>
</blockquote>
<blockquote>
<p>解决哈希冲突有哪些典型方法呢?<br><code>开放定址法</code>：当关键字key的哈希地址p=H(key)出现冲突时,以p为基础,产生另一个哈希地址p1,如果p1仍然冲突,再以p为基础,产生另一个哈希地址p2,…,直到找出一个不冲突的哈 希地址pi ,将相应元素存入其中。<br><code>再哈希法</code>：当哈希地址Hi=RH1(key)发生冲突时,再计算Hi=RH2(key)……,直到冲突不再产生。这种方法不易产生聚集,但增加了计算时间。<br><code>链地址法</code>：这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表,并将单链表的头指针存在哈希表的第i个单元中,因而查找、插入和删除主要在同义词链中进行。链地址法适用 于经常进行插入和删除的情况。</p>
</blockquote>
<hr>
<h4 id="如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？"><a href="#如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？" class="headerlink" title="如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？"></a>如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？</h4><p><strong>1.为什么需要 ConcurrentHashMap？</strong><br></p>
<p>Hashtable本身比较低效，因为其基本实现基本就是将 put、get、size等各种方法加上“synchronized”。简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。Hashtable或者同步包装版本都只是适合在非高度并发的场景下。</p>
<p><strong>2.ConcurrentHashMap分析</strong><br></p>
<p>早期 ConcurrentHashMap 其实现是基于：</p>
<pre><code>1.分离锁，即将内部进行分段，里面则是HashEntry的数组，和HashMap类似，哈希相同的条目也是以链表的形式存放。

2.HashEntry内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。
</code></pre><blockquote>
<p>注意：在进行并发操作的时候，核心利用分段设计，只需要锁定相应段就能够有效的避免类似 Hashtable 整体同步问题，提高性能。</p>
</blockquote>
<p>在进行并发写操作时：</p>
<pre><code>1.
</code></pre><hr>
<h4 id="Java有几种文件拷贝方式？哪一种最高效？"><a href="#Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="Java有几种文件拷贝方式？哪一种最高效？"></a>Java有几种文件拷贝方式？哪一种最高效？</h4><p>Java有多种比较典型的文件拷贝实现方式：</p>
<pre><code>1.利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作。

    public static void copyFileByStream(File source, File dest) throws IOException {
        try(InputStream is = new FileInputStream(source);
            OutputStream os = new FileOutputStream(dest);){

            byte[] buffer = new byte[1024];
            int length;
            while((length = is.read(buffer)) &gt; 0){
                os.write(buffer, o, length);
            }

        }
    }

2.利用java.nio类库提供的transferTo或者transferFrom方法实现

    public static void copyFileByChannel(File source, File dest) throws IOException {
        try (FileChannel sourceChannel = new FileInputStream(source).getChannel();
            FileChannel targetChannel = new FileOutputStream(dest).getChannel();){
                for (long count = sourceChannel.size() ;count&gt;0 ;) {
                    long transferred = sourceChannel.transferTo(sourceChannel.position(), count, targetChannel); 
                    sourceChcount -= transferred;
                }
            }
        }
</code></pre><blockquote>
<p>提示：Java标准类库也提供了几种Files.copy()的实现。对应Copy的效率，其实与操作系统和配置等情况有关，总体来说，NIO transferTo/From的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
</blockquote>
<p><strong>1.拷贝实现机制分析</strong><br></p>
<p>首先我们应该清楚用户态空间和内核态空间，这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权，用户态空间则是给普通应用和服务使用。</p>
<p>1.当使用输入输出流进行读写过程时，在实际上进行了多次的上下文切换。如：应用读取数据时，现在内核态将数据从磁盘读取到内核缓存，在切换到用户态将数据从内核缓存读取到用户缓存。（写入步骤相反）。所以这种方式会带来一定的额外开销，可能会降低IO效率。</p>
<p>2.基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。</p>
<blockquote>
<p>注意：transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。</p>
</blockquote>
<p><strong>2.Java IO/NIO源码结构</strong><br></p>
<p>Java标准库提供了文件拷贝方法（java.nio.file.Files.copy）。</p>
<pre><code>public static Path copy(Path source, Path target, CopyOption... options) throws IOException

public static long copy(InputStream in, Path target, CopyOption... options) throws IOException

public static long copy(Path source, OutputStream out) throws IOException
</code></pre><p>这里我们可以看出，copy不仅支持文件之间的操作。</p>
<p><strong>3.NIO Buffer</strong><br></p>
<p>Buffer是NIO操作数据的基本工具，Java为每种原始数据类型都提供了相应的Buffer实现。特别注意Direct Buffer等使用，因为其在垃圾收集方面的特殊性。</p>
<pre><code>Buffer的基本属性：

    1.capcity buffer的大小，即数组的长度
    2.postion 操作的数据的起始位置
    3.limit 操作的限额
    4.mark 记录上一次postion的位置，默认是0

Buffer的基本操作：

    1.我们创建了一个 ByteBuffer，准备放入数据，capcity 当然就是缓冲区大小，而 position 就是 0，limit 默认就是 capcity 的大小。
    2.当我们写入几个字节的数据时，position 就会跟着水涨船高，但是它不可能超过 limit 的大小。
    3.如果我们想把前面写入的数据读出来，需要调用 flip 方法，将 position 设置为 0，limit 设置为以前的 position 那里。

    ...
</code></pre><p><strong>4.Direct Buffer 和垃圾收集</strong><br></p>
<p><strong>5.跟踪和诊断 Direct Buffer 内存占用？</strong></p>
<hr>
<h4 id="Java提供了哪些IO方式-NIO如何实现多路复用"><a href="#Java提供了哪些IO方式-NIO如何实现多路复用" class="headerlink" title="Java提供了哪些IO方式? NIO如何实现多路复用?"></a>Java提供了哪些IO方式? NIO如何实现多路复用?</h4><ul>
<li><p><code>传统的java.io包,它基于流模型实现</code>,提供了我们最熟知的一些IO功能,比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。</p>
</li>
<li><p>很多时候,人们也把java.net下面提供的部分网络API,比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库,因为网络通信同样是IO行为。</p>
</li>
<li><p><code>在Java 1.4中引入了NIO框架(java.nio包)</code>,提供了Channel、Selector、Bufer等新的抽象,可以构建多路复用的、<code>同步非阻塞IO程序</code>,同时提供了更接近操作系统底层 的高性能数据操作方式。</p>
</li>
<li><p><code>在Java 7中,NIO有了进一步的改进,也就是NIO 2</code>,引入了异<code>步非阻塞IO方式</code>,也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制,可以简单 理解为,应用操作直接返回,而不会阻塞在那里,当后台处理完成,操作系统会通知相应线程进行后续工作。</p>
</li>
</ul>
<blockquote>
<p><code>NIO多路复用的局限性是什么呢?</code><br>由于nio实际上是<code>同步非阻塞io</code>,是一个线程在同步的进行事件处理,当一组事channel处理完毕以后,去检查有没有又可以处理的channel。这也就是同步+非阻塞。同步,指每个准备好 的channel处理是依次进行的,非阻塞,是指线程不会傻傻的等待读。只有当channel准备好后,才会进行。那么就会有这样一个问题,当每个channel所进行的都是耗时操作时,由于是同步操 作,就会积压很多channel任务,从而完成影响。那么就需要对nio进行类似负载均衡的操作,如用线程池去进行管理读写,将channel分给其他的线程去执行,这样既充分利用了每一个线程,又不至于都堆积在一个线程中,等待执行</p>
</blockquote>
<h4 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h4><ul>
<li><p><code>接口</code>是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员,同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。 Java标准类库中，定义了非常多的接口，比如java.util.List。</p>
</li>
<li><p><code>抽象类</code>是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可<br>以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。 Java标准库中，比如collection框架，很多通用<br>部分就被抽取成为抽象类，例如java.util.AbstractList。</p>
</li>
</ul>
<blockquote>
<p>进行面向对象编程，掌握基本的设计原则是必须的，最通用的部分，也就是所谓的<code>S.O.L.I.D</code>原则。</p>
</blockquote>
<blockquote>
<p><code>单一职责</code>类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>开关原则</code>设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>里氏替换</code>这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>接口分离</code>我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>依赖反转</code>实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝</p>
</blockquote>
<hr>
<h4 id="谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？"><a href="#谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？" class="headerlink" title="谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？"></a>谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？</h4><ul>
<li><p>设计模式可以分为创建型模式、结构型模式和行为型模式。</p>
</li>
<li><p><code>创建型模式</code>，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、 Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</p>
</li>
<li><p><code>结构型模式</code>，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</p>
</li>
<li><p><code>行为型模式</code>，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</p>
</li>
</ul>
<blockquote>
<ul>
<li><code>InputStream</code>是一个抽象类，标准类库中提供了FileInputStream、 ByteArrayInputStream等各种不同的子类，分别从不同角度对InputStream进行了功能扩展，这是典型的装饰器模式应用案例。识别装饰器模式，可以通过识别类设计特征来进行判断，也就是其类构造函数以相同的抽象类或者接口为输入参数</li>
</ul>
</blockquote>
<blockquote>
<p><code>创建型模式</code>尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的API设计实践。比如， JDK最新版本中 HTTP/2 Client API，下面这个创建HttpRequest的过程，就是典型的构建器模式（Builder），通常会被实现成fuent风格的API，也有人叫它方法链。使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</p>
</blockquote>
<blockquote>
<p><code>Spring等如何在API设计中使用设计模式</code></p>
</blockquote>
<blockquote>
<p>BeanFactory和ApplicationContext应用了工厂模式</p>
</blockquote>
<blockquote>
<p>在Bean的创建中， Spring也为不同scope定义的对象，提供了单例和原型等模式实现。</p>
</blockquote>
<blockquote>
<p>AOP领域则是使用了代理模式、装饰器模式、适配器模式等。</p>
</blockquote>
<blockquote>
<p>各种事件监听器，是观察者模式的典型应用。</p>
</blockquote>
<blockquote>
<p>类似JdbcTemplate等则是应用了模板模式。</p>
</blockquote>
<hr>
<h4 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h4><ul>
<li><p><code>synchronized</code>是Java内建的同步机制,它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>
</li>
<li><p><code>ReentrantLock</code>，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时， ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</p>
</li>
</ul>
<h4 id="synchronized底层如何实现？什么是锁的升级、降级？"><a href="#synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="synchronized底层如何实现？什么是锁的升级、降级？"></a>synchronized底层如何实现？什么是锁的升级、降级？</h4><ul>
<li><p><code>synchronized</code>代码块是由一对儿<code>monitorenter/monitorexit</code>指令实现的， Monitor对象是同步的基本实现单元。在Java 6之前， Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle） JDK中， JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
</li>
<li><p>所谓锁的升级、降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>
</li>
<li><p>当没有竞争出现时，<code>默认会使用偏斜锁</code>。 <code>JVM</code>会利用<code>CAS</code>操作，在对象头上的<code>Mark Word</code>部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
</li>
<li><p>如果有另外的线程试图锁定某个已经被偏斜过的对象， JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
</li>
</ul>
<blockquote>
<p><code>你知道“自旋锁”是做什么的吗？它的使用场景是什么？</code><br><code>自旋锁</code>:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br><code>适用场景</code>:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费<br><code>在单核CPU上，自旋锁是无用</code>，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行，<br>同时由于其他线程无法运行，所以当前线程无法释放锁。</p>
</blockquote>
<h4 id="一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。"><a href="#一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。"></a>一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。</h4><ul>
<li>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</li>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。 Thread.join()也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本</li>
</ul>
<h4 id="什么情况下Java程序会产生死锁-如何定位、修复"><a href="#什么情况下Java程序会产生死锁-如何定位、修复" class="headerlink" title="什么情况下Java程序会产生死锁?如何定位、修复?"></a>什么情况下Java程序会产生死锁?如何定位、修复?</h4><ul>
<li><code>死锁</code>是一种特定的程序状态,在实体之间,由于<code>循环依赖导致</code>彼此一直处于等待之中,没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生,存在资源独占的进程之间同样也可能出现死锁。通常来说,我们大多是聚焦在多线程场景中的死锁,指两个或多个线程之间,由于互<code>相持有对方需要的锁</code>,而永久处于阻塞的状态。<br><img src="https://img-blog.csdnimg.cn/20190408224832820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></li>
<li><code>定位死锁</code>最常见的方式就是利用<code>jstack</code>等工具<code>获取线程栈</code>,然后定位互相之间的依赖关系,进而找到死锁。如果是比较明显的死锁,往往jstack等就能直接定位,类似JConsole甚至 可以在图形界面进行有限的死锁检测。</li>
<li>使用Java提供的标准管理API,ThreadMXBean,其直接就提供 fndDeadlockedThreads﻿()方法用于定位死锁。但是要注意的是,对线程进行快照本身是一个相对重量级的操作,还是要慎重选择频度和时机。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMXBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line"></span><br><span class="line">        Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">                <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                    System.out.println(<span class="string">"Detected deadlock threads:"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                        System.out.println(threadInfo.getThreadName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService scheduler =Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 稍等5秒,然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        Test1  t=<span class="keyword">new</span> Test1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">        Object obj1=<span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":    obj1--------"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   obj2--------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"    t2  obj2--------"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   t2  obj1--------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如<code>何在编程中尽量预防死锁呢?</code><br>尽量避免使用多个锁,并且只有需要时才持有锁<br>如果必须使用多个锁,尽量设计好锁的获取顺序<br>使用带超时的方法,为程序带来更多可控性。<br><code>有时候并不是阻塞导致的死锁,只是某个线程进入了死循环,导致其他线程一直等待,这种问题如何诊断呢?</code><br>可以通过linux下top命令查看cpu使用率较高的java进程,进而用<code>top -Hp pid</code>查看该java进程下cpu使用率较高的线程。再用jstack命令查看线程具体调用情况,排查问题</p>
</blockquote>
<h4 id="Java并发包提供了哪些并发工具类？"><a href="#Java并发包提供了哪些并发工具类？" class="headerlink" title="Java并发包提供了哪些并发工具类？"></a>Java并发包提供了哪些并发工具类？</h4><ul>
<li>提供了比synchronized更加高级的各种同步结构，包括<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、 <code>Semaphore</code>等。CountDownLatch，允许一个或多个线程等待某些操作完成。CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。Semaphore， Java版本的信号量实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。</li>
<li>各种<code>线程安全的容器</code>，比如最常见的<code>ConcurrentHashMap</code>、有序的<code>ConcunrrentSkipListMap</code>，或者通过类似快照机制，实现线程安全的动态数组<code>CopyOnWriteArrayList</code>等。</li>
<li>各种<code>并发队列</code>实现，如各种<code>BlockedQueue</code>实现，比较典型的<code>ArrayBlockingQueue</code>、 <code>SynchorousQueue</code>或针对特定场景的<code>PriorityBlockingQueue</code>等。</li>
<li>强大的<code>Executor</code>框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<blockquote>
<p><code>你使用过类似CountDownLatch的同步结构解决实际问题吗？</code><br>一个页面有A,B,C三个网络请求，其中请求C需要请求A和请求B的返回数据作为参数，用过CountdownLatch解决。<br>需求是每个对象一个线程，分别在每个线程里计算各自的数据，最终等到所有线程计算完毕，我还需要将每个有共通的对象进行合并，所以用它很合适。</p>
</blockquote>
<h4 id="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h4><p><img src="https://img-blog.csdnimg.cn/20190409124720516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="线程安全队列一览"></p>
<ul>
<li><code>Concurrent</code>类型基于<code>lock-free</code>，在常见的多线程访问场景，一般可以提供较高吞吐量。而<code>LinkedBlockingQueue</code>内部则是<code>基于锁</code>，并提供了<code>BlockingQueue</code>的等待性方法。</li>
<li><code>ArrayBlockingQueue</code>是最典型的的有界队列，其内部以<code>fnal</code>的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建ArrayBlockingQueue时，都要指定容量</li>
<li><code>LinkedBlockingQueue</code>，容易被<code>误解为无边界</code>，但其实其行为和内部代码都是<code>基于有界的逻辑实现</code>的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为<code>Integer.MAX_VALUE</code>，成为了无界队列。</li>
<li><code>SynchronousQueue</code>，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。其内<code>部容量是0</code></li>
<li><code>PriorityBlockingQueue</code>是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响</li>
<li><code>DelayedQueue</code>和<code>LinkedTransferQueue</code>同样是<code>无边界的队列</code>。对于无边界的队列，有一个自然的结果，就是put操作永远也不会发生其他<code>BlockingQueue</code>的那种等待情况。</li>
</ul>
<blockquote>
<p><code>在日常的应用开发中，如何进行选择呢？</code><br>考虑应用场景中<code>对队列边界的要求</code>。 ArrayBlockingQueue是有明确的容量限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定， SynchronousQueue则干脆不能缓存任何元素。<br><code>从空间利用角度</code>，数组结构的ArrayBlockingQueue要比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。<br><code>通用场景中</code>， LinkedBlockingQueue的吞吐量一般优于ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。<br>ArrayBlockingQueue实现比较简单，性能更好预测，属于表现稳定的“选手”。<br>如果我们需要实现的是两个线程之间接力性（handof）的场景，你可能会选择CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</p>
</blockquote>
<h4 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h4><p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li><code>newCachedThreadPool()</code>，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用<code>SynchronousQueue</code>作为工作队列。</li>
<li><code>newFixedThreadPool(int nThreads)</code>，重用<code>指定数目</code>（nThreads）的线程，其背后使用的是<code>无界的工作队列</code>，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
<li><code>newSingleThreadExecutor()</code>，它的特点在于<code>工作线程数目被限制为1</code>，操作一个<code>无界的工作队列</code>，所以它保证了所有任务的都是被<code>顺序执行</code>，最多会有<code>一个任务处于活动状态</code>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li><code>newSingleThreadScheduledExecutor()</code>和<code>newScheduledThreadPool(int corePoolSize)</code>，创建的是<code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程</li>
<li><code>newWorkStealingPool(int parallelism)</code>，这是一个经常被人忽略的线程池， <code>Java 8才加入这个创建方法</code>，其内部会构建<code>ForkJoinPool</code>，利用<code>Work-Stealing算法</code>，并行地处理任务，不保证处理顺序。</li>
</ul>
<blockquote>
<p><code>ThreadPoolExecutor参数详解</code><br>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目。于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool会将其设置为nThreads，而对于newCachedThreadPool则是为0。<br>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数<br>keepAliveTime和TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。<br>workQueue，工作队列，必须是BlockingQueue。<br><code>线程池大小的选择策略：</code><br>如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源。如果线程太多，反倒可能导致大量<br>的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。<br>如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：<code>线程数 = CPU核数 × （1 + 平均等待时间/平均工作时间）</code></p>
</blockquote>
<hr>
<h3 id="深入理解Java虚拟机问题"><a href="#深入理解Java虚拟机问题" class="headerlink" title="深入理解Java虚拟机问题"></a>深入理解Java虚拟机问题</h3><h4 id="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h4><ul>
<li><p><code>AtomicIntger</code>是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于<code>CAS（compare-and-swap）</code>技术。</p>
</li>
<li><p>所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p>
</li>
<li><p>于CAS的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区。</p>
</li>
</ul>
<hr>
<h4 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h4><ul>
<li><p>一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里有非常详细的定义。</p>
</li>
<li><p><code>首先是加载阶段</code>（Loading），它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、 class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
</li>
<li><p><code>第二阶段是链接</code>（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入JVM运行的过程中。这里可进一步细分为三个步骤：</p>
</li>
</ul>
<blockquote>
<p><code>验证</code>: 这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息害JVM的运行，验证阶段有可能触发更多class的加载。</p>
</blockquote>
<blockquote>
<p><code>准备</code>，创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令</p>
</blockquote>
<blockquote>
<p><code>解析</code>，在这一步会将常量池中的<code>符号引用</code>替换为<code>直接引用</code>。在Java虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
</blockquote>
<ul>
<li><p><code>最后是初始化阶段</code>（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
</li>
<li><p>再来谈谈<code>双亲委派模型</code>，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。<br><img src="https://img-blog.csdnimg.cn/20190409151248407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="双亲委派模型"></p>
</li>
</ul>
<hr>
<h4 id="有哪些方法可以在运行时动态生成一个Java类？"><a href="#有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类？"></a>有哪些方法可以在运行时动态生成一个Java类？</h4><ul>
<li><p>我们可以从常见的Java类来源分析，通常的开发过程是，开发者编写Java代码，调用javac编译成class文件，然后通过类加载机制载入JVM，就成为应用运行时可以使用的Java类了。</p>
</li>
<li><p>有一种笨办法，直接用ProcessBuilder之类启动javac进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
</li>
<li><p>你可以考虑使用Java Compiler API，这是JDK提供的标准API，里面提供了与javac对等的编译器功能，具体请参考java.compiler相关文档。</p>
</li>
</ul>
<hr>
<h4 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？</h4><ul>
<li>通常可以把<code>JVM</code>内存区域分为下面几个方面，其中，有的区域是<code>以线程为单位</code>，而有的区域则是<code>整个JVM</code>进程唯一的。</li>
<li><code>程序计数器</code>：在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefned）。</li>
<li><code>Java虚拟机栈</code>：早期也叫<code>Java栈</code>。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧</code>（Stack Frame），对应着一次次的Java方法调用。前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作<code>当前帧</code>，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。 JVM直接对Java栈的操作只有两个，就是对栈帧的<code>压栈和出栈</code>。栈帧中存储着<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法正常退出</code>或者<code>异常退出</code>的定义等</li>
<li><code>堆（Heap）</code>，它是Java内存管理的核心区域，用来<code>放置Java对象实例</code>，几乎所有创建的Java<code>对象实例都是被直接分配在堆上</code>。堆被<code>所有的线程共享</code>，在虚拟机启动时，我们指定的<code>“Xmx”</code>之类参数就是用来指定最大堆空间等指标。堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是<code>新生代</code>、老<code>年代</code>的划分。</li>
<li><code>方法区（Method Area）</code>。这也是所有<code>线程共享的一块内存区域</code>，用于存储所谓的<code>元（Meta）数据</code>，例如<code>类结构信息</code>，以及对应的<code>运行时常量池</code>、<code>字段</code>、<code>方法代码</code>等。由于早期的Hotspot JVM实现，很多人习惯于将方法区称为永久代， Oracle JDK 8中将永久代移除，同时<code>增加了元数据区</code>（Metaspace）</li>
<li><code>运行时常量池</code>，这是<code>方法区的一部分</code>。如果仔细分析过反编译的类文件结构，你能看到<code>版本号</code>、<code>字段</code>、<code>方法</code>、<code>超类</code>、<code>接口</code>等各种信息，还有一项信息就是<code>常量池</code>。 Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</li>
<li><code>本地方法栈</code>（Native Method Stack）。它和Java虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409170529393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<hr>
<h4 id="Java对象是不是都创建在堆上的呢？"><a href="#Java对象是不是都创建在堆上的呢？" class="headerlink" title="Java对象是不是都创建在堆上的呢？"></a>Java对象是不是都创建在堆上的呢？</h4><ul>
<li>有一些观点，认为通过逃逸分析， JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择</li>
<li>目前很多书籍还是基于JDK 7以前的版本， JDK已经发生了很大变化， Intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是， Intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合对象实例都是分配在堆上。</li>
</ul>
<hr>
<h4 id="什么是OOM问题，它可能在哪些内存区域发生？"><a href="#什么是OOM问题，它可能在哪些内存区域发生？" class="headerlink" title="什么是OOM问题，它可能在哪些内存区域发生？"></a>什么是OOM问题，它可能在哪些内存区域发生？</h4><ul>
<li>OOM如果通俗点儿说，就是JVM内存不够用了， javadoc中对<code>OutOfMemoryError</code>的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。当然，也不是在任何情况下垃圾收集器都会被触发的。比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值， JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。</li>
</ul>
<blockquote>
<p>提示：从我前面分析的数据区的角度，除了程序计数器，其他区域都有可能会因为可能的空间不足发OutOfMemoryError，简单总结如下：</p>
</blockquote>
<ul>
<li><p><code>堆内存不足是最常见的OOM原因之一</code>，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪。例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小；或者出现JVM处理引用不及时，导致堆积起来，内存无法释放等。</p>
</li>
<li><p>而对于Java虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况， JVM实际会抛出StackOverFlowError；当然，如果JVM试图去扩展栈空间的的时候失败，则会抛出OutOfMemoryError。</p>
</li>
<li><p><code>对于老版本的Oracle JDK</code>，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（<code>如，常量池回收、卸载不再需要的类型</code>）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code>也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似Intern字符串缓存占用太多空间，也会导致<code>OOM</code>问题。对应的异常信息，会标记出来和永久代相关： “<code>java.lang.OutOfMemoryError: PermGen space</code>”。</p>
</li>
<li><p><code>随着元数据区的引入</code>，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了： “<code>java.lang.OutOfMemoryError: Metaspace</code>”。</p>
</li>
<li><p>直接内存不足，也会导致OOM。</p>
</li>
</ul>
<blockquote>
<p>面试问题：我在试图分配一个100M bytes大数组的时候发生了OOME，但是GC日志显示，明明堆上还有远不止100M的空间，你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p>
</blockquote>
<ul>
<li><p>从不同的垃圾收集器角度来看：首先，数组的分配是需要连续的内存空间的。所以对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。</p>
</li>
<li><p>对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。</p>
</li>
</ul>
<hr>
<h4 id="如何监控和诊断JVM堆内和堆外内存使用？"><a href="#如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用？"></a>如何监控和诊断JVM堆内和堆外内存使用？</h4><ul>
<li>可以使用综合性的图形化工具，如JConsole、 VisualVM（注意，从Oracle JDK 9开始， VisualVM已经不再包含在JDK安装包中）等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。</li>
</ul>
<blockquote>
<p>以JConsole为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。</p>
</blockquote>
<ul>
<li><p>也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。</p>
</li>
<li><p>或者，也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。</p>
</li>
<li><p>如果你使用的是Tomcat、 Weblogic等Java EE服务器，这些服务器同样提供了内存管理相关的功能。</p>
</li>
<li><p>另外，从某种程度上来说， GC日志等输出，同样包含着丰富的信息。</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">JConsole官方教程</a>。我这里特别推荐<a href="https://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html" target="_blank" rel="noopener">Java Mission Control（JMC）</a>，这是一个非常强大的工具，不仅仅能够使用JMX进行普通的管理、监控任务，还可以配合Java Flight Recorder（JFR）技术，以非常低的开销，收集和分析JVM底层的Profling和事件等信息。</p>
</li>
</ul>
<p><strong>堆内部是什么结构？</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190409174432758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""><br>你可以看到，按照通常的GC年代方式划分， Java堆内分为：</p>
<p><strong>新生代</strong></p>
<ul>
<li><p>新生代是大部分对象创建和销毁的区域，在通常的Java应用中，绝大部分对象生命周期都是很短暂的。其内部又分为Eden区域，作为对象初始分配的区域；两个Survivor，有时候也叫from、 to区域，被用来放置从Minor GC中保留下来的对象。</p>
</li>
<li><p>JVM会随意选取一个Survivor区域作为“to”，然后会在GC过程中进行区域间拷贝，也就是将Eden中存活下来的对象和from区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
</li>
<li><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分， Hotspot JVM还有一个概念叫做（TLAB）。这是JVM为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，TLAB仍然在堆上，它是分配在Eden区域内的。其内部结构比较直观易懂， start、 end就是起始地址， top（指针）则表示已经分配到哪里了。所以我们分配新对象， JVM就会移动top，当top和end相遇时，即表示该缓存已满， JVM会试图再从Eden里分配一块儿。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409174715206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>老年代</strong></p>
<ul>
<li>放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大， JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间， JVM就会直接分配到老年代。</li>
</ul>
<p><strong>永久代</strong></p>
<ul>
<li>这部分就是早期Hotspot JVM的方法区实现方式了，储存Java类元数据、常量池、Intern字符串缓存，在JDK 8之后就不存在永久代这块儿了。</li>
</ul>
<p><strong>利用JVM参数，直接影响堆和内部区域的大小</strong></p>
<ul>
<li><p>最大堆体积：<code>-Xmx value</code></p>
</li>
<li><p>初始的最小堆体积：<code>-Xms value</code></p>
</li>
<li><p>老年代和新生代的比例：<code>-XX:NewRatio=value</code>。默认情况下，这个数值是3，意味着老年代是新生代的3倍大；换句话说，新生代是堆大小的1/4。也可以不用比例的方式调整新生代的大小，直接<code>-XX:NewSize=value</code>参数，设定具体的内存大小数值。</p>
</li>
</ul>
<hr>
<h4 id="谈谈你的GC调优思路？"><a href="#谈谈你的GC调优思路？" class="headerlink" title="谈谈你的GC调优思路？"></a>谈谈你的GC调优思路？</h4><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p>
<p>基本的调优思路总结：</p>
<pre><code>1.理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。

2.掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。

3.这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。

4.通过分析确定具体调整的参数或者软硬件配置。

5.验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。
</code></pre><blockquote>
<p>提示：GC调优问题是JVM调优的一个基础，很多JVM调优需求，最终都落实在GC调优上或者与其相关。</p>
</blockquote>
<blockquote>
<p>扩展 (G1 GC)</p>
</blockquote>
<p><strong>1.了解一下 G1 GC 的内部结构和主要机制</strong><br></p>
<p>从内存角度我们知道，G1 GC存在这年代的概念，但是与前面介绍的内存结构不一样，其内部类似棋盘状的一个个region。</p>
<p>…</p>
<hr>
<h4 id="Java常见的垃圾收集器-GC-有哪些？"><a href="#Java常见的垃圾收集器-GC-有哪些？" class="headerlink" title="Java常见的垃圾收集器(GC)有哪些？"></a>Java常见的垃圾收集器(GC)有哪些？</h4><ul>
<li><p>1.<code>Serial GC</code>，它是最古老的垃圾收集器， “Serial”体现在其收集<code>工作是单线程</code>的，并且在进行垃圾收集过程中，会进入臭名昭著的<code>“Stop-The-World”</code>状态。当然，其<code>单线程设计</code>也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。</p>
</li>
<li><p>2.从年代的角度，通常将其老年代实现单独称作<code>Serial Old</code>，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC的对应JVM参数是：<code>-XX:+UseSerialGC</code>。</p>
</li>
<li><p>3.<code>ParNew GC</code>，很明显是个<code>新生代GC</code>实现，它实际<code>是Serial GC的多线程版本</code>，最常见的应用场景是配合老年代的CMS GC工作，下面是对应参数 <code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code>。</p>
</li>
<li><p>4.<code>CMS GC</code>，基于标记-清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是，CMS采用的<code>标记-清除算法</code>，存在着<code>内存碎片化</code>问题，所以难以避免在长时间运行等情况下发生<code>full GC</code>，导致恶劣的停顿。另外，既然强调了并发（Concurrent）， CMS会<code>占用更多CPU资源</code>，并和用户线程争抢。</p>
</li>
<li><p>5.<code>Parrallel GC</code>，在早期JDK 8等版本中，它是server模式JVM的默认GC选择,也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是<code>新生代和老年代GC都是并行进行</code>的，在常见的服务器环境中更加高效。开启选项是：<code>-XX:+UseParallelGC</code>。另外， Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标， JVM会自动进行适应性调整，例如下面参数：</p>
</li>
</ul>
<blockquote>
<p><code>-XX:MaxGCPauseMillis=value</code></p>
</blockquote>
<blockquote>
<p>-XX:GCTimeRatio=N         //GC时间和用户时间比例 = 1 / (N+1)</p>
</blockquote>
<blockquote>
<p><code>查看jdk垃圾收集器</code>：java -XX:+PrintCommandLineFlags -version  </p>
</blockquote>
<ul>
<li><p>6.<code>G1 GC</code>这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
<li><p>6.1 <code>G1 GC</code>仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个region。Region之间是复制算法，但整体上实际可看作是标记-整理（MarkCompact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候， G1的优势更加明显。</p>
</li>
<li><p>6.2 G1吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得你深入掌握。</p>
</li>
</ul>
<blockquote>
<p>扩展</p>
</blockquote>
<p><strong>1.垃圾收集的原理和基础概念</strong><br></p>
<p>1.自动垃圾收集的前提是清楚哪些内存可以被释放。这一点可以结合我前面对 Java 类加载和内存结构的分析，来思考一下。</p>
<pre><code>主要是两个方面：

    1.对象实例（最主要部分）：对象实例都是存储在堆上面的。

    2.方法区中的元数据等信息：如类型不再使用，卸载该Java类似乎很合理。
</code></pre><p>2.JVM提供的收集器很多，特征不一样，适用于不同的业务场景：</p>
<pre><code>Serial收集器：串行运行；作用于新生代；复制算法；响应速度优先；适用于单CPU环境下的client模式。

ParNew收集器：并行运行；作用于新生代；复制算法；响应速度优先；多CPU环境Server模式下与CMS配合使用。

Parallel Scavenge收集器：并行运行；作用于新生代；复制算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。

Serial Old收集器：串行运行；作用于老年代；标记-整理算法；响应速度优先；单CPU环境下的Client模式。

Parallel Old收集器：并行运行；作用于老年代；标记-整理算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。

CMS收集器：并发运行；作用于老年代；标记-清除算法；响应速度优先；适用于互联网或B/S业务。
</code></pre><hr>
<h4 id="如何判断一个对象是否可以回收？"><a href="#如何判断一个对象是否可以回收？" class="headerlink" title="如何判断一个对象是否可以回收？"></a>如何判断一个对象是否可以回收？</h4><p>主要是两种基本算法， 引用计数和可达性分析：</p>
<pre><code>1.`引用计数算法`，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收。Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。

2.`Java选择的可达性分析`，Java的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，这种类型的垃圾收集通常叫作追踪性垃圾收集。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 `GC Roots`，然后跟踪引用链条，如果一个对象和`GC Roots之间不可达`，也就是不存在引用链条，那么即可认为是可回收对象。 JVM会把虚拟机栈和本地方法栈中正在引用的`对象、静态属性引用的对象和常量，作为GC Roots`。
</code></pre><p>方法区元数据的回收比较复杂，还记得我对类加载器的分类吧，一般来说初始化类加载器加载的类型是不会进行类卸载（unload）的；而普通的类型的卸载，往往是要求相应自定义类加载器本身被回收，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会 OOM。在 8u40 以后的 JDK 中，下面参数已经是默认的：</p>
<pre><code>-XX:+ClassUnloadingWithConcurrentMark
</code></pre><hr>
<h4 id="常见的垃圾收集算法？"><a href="#常见的垃圾收集算法？" class="headerlink" title="常见的垃圾收集算法？"></a>常见的垃圾收集算法？</h4><ul>
<li><p><code>复制（Copying）算法</code>：将活着的对象复制到to区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于G1这种分拆成为大量regio GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。</p>
</li>
<li><p><code>标记-清除（Mark-Sweep）算法</code>，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受。</p>
</li>
<li><p><code>标记-整理（Mark-Compact）</code>，类似于标记-清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</p>
</li>
</ul>
<blockquote>
<p>提示：这些都只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>
</blockquote>
<hr>
<h4 id="在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？"><a href="#在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？" class="headerlink" title="在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？"></a>在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？</h4><p>这实际上取决于具体的GC方式，先来熟悉一下通常的垃圾收集流程，我画了一系列示意图，希望能有助于你理解清楚这个过程。</p>
<pre><code>1.Java应用不断创建对象，通常都是分配在Eden区域，当其空间占用达到一定阈值时，触发minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到JVM选择的Survivor区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字1”，这是为了表明对象的存活时间。
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190409183348554.png" alt=""></p>
<pre><code>2.经过一次`Minor GC`， Eden就会空闲下来，直到再次达到`Minor GC`触发条件，这时候，另外一个`Survivor`区域则会成为`to`区域，`Eden`区域的存活对象和`From`区域对象，都会被复制到`to`区域，并且存活的年龄计数会被加`1`。
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190409183455640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<pre><code>3.类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：`-XX:MaxTenuringThreshold=&lt;N&gt;`
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190409183559189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></p>
<pre><code>4.后面就是`老年代GC`，具体取决于选择的`GC`选项，对应不同的算法。通常我们把`老年代GC`叫作`Major GC，`将对整个`堆进行的清理`叫作`Full GC`，但是这个也没有那么绝对，因为不同的老年代GC算法其实表现差异很大，例如`CMS`。 `“concurrent”`就体现在清理工作是与工作线程一起并发运行的。
</code></pre><p><strong>JDK又增加了两种全新的GC方式，分别是：</strong></p>
<ul>
<li><p><code>Epsilon GC</code>，简单说就是个<code>不做垃圾收集的GC</code>，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断GC本身产生了多大的开销，这就是其典型应用场景。</p>
</li>
<li><p><code>ZGC</code>，这是Oracle开源出来的一个<code>超级GC</code>实现，具备令人惊讶的扩展能力，比如支持<code>T bytes级</code>别的堆大小，并且保证绝大部分情况下，<code>延迟都不会超过10 ms</code>。虽然目前还处于<code>实验阶段</code>，仅支持Linux 64位的平台，但其已经表现出的能力和潜力都非常令人期待。</p>
</li>
</ul>
<hr>
<h4 id="Java内存模型中的happen-before是什么？"><a href="#Java内存模型中的happen-before是什么？" class="headerlink" title="Java内存模型中的happen-before是什么？"></a>Java内存模型中的happen-before是什么？</h4><p>1.典型回答</p>
<p>Happen-before关系，是Java内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面。如：</p>
<ul>
<li><p>线程内执行的每个操作，都保证happen-before后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</p>
</li>
<li><p>对于volatile变量，对它的写操作，保证happen-before在随后对该变量的读取操作。</p>
</li>
<li><p>对于一个锁的解锁操作，保证happen-before加锁操作。</p>
</li>
<li><p>对象构建完成，保证happen-before于fnalizer的开始动作。</p>
</li>
<li><p>甚至是类似线程内部操作的完成，保证happen-before其他Thread.join()的线程等。</p>
</li>
<li><p>这些happen-before关系是存在着传递性的，如果满足a happen-before b和b happen-before c，那么a happen-before c也成立。</p>
</li>
<li><p>JMM内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种happen-before规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。</p>
</li>
</ul>
<blockquote>
<p><code>可从四个维度去理解JMM</code></p>
</blockquote>
<ul>
<li><p>从JVM运行时视角来看， JVM内存可分为JVM栈、本地方法栈、 PC计数器、方法区、堆；其中前三区是线程所私有的，后两者则是所有线程共有的</p>
</li>
<li><p>从JVM内存功能视角来看， JVM可分为堆内存、非堆内存与其他。其中堆内存对应于上述的堆区；非堆内存对应于上述的JVM栈、本地方法栈、 PC计数器、方法区；其他则对应于直接内存</p>
</li>
<li><p>从线程运行视角来看， JVM可分为主内存与线程工作内存。 Java内存模型规定了所有的变量都存储在主内存中；每个线程的工作内存保存了被该线程使用到的变量，这些变量是主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</p>
</li>
<li><p>从垃圾回收视角来看， JVM中的堆区=新生代+老年代。新生代主要用于存放新创建的对象与存活时长小的对象，新生代=E+S1+S2；老年代则用于存放存活时间长的对象</p>
</li>
</ul>
<h4 id="JVM优化Java代码时都做了什么"><a href="#JVM优化Java代码时都做了什么" class="headerlink" title="JVM优化Java代码时都做了什么?"></a>JVM优化Java代码时都做了什么?</h4><ul>
<li>JVM在对代码执行的优化可分为<code>运行时化</code>和<code>即时编译器优化</code>。<code>运行时优化主要是</code>解析执行和动态编译通用的一些机制,比如说锁机制(<code>如偏向锁</code>)、内存分配机制(<code>如TLAB</code>)。除此之外，还有一些专门优化器执行效率的，比如说模板解析器，内联缓存。</li>
<li>J<code>VM的即时编译器优化</code>是指将热点代码以方法为单位转换成机器码,直接运行在底层硬件之上。它采用了多种优化方式,包括静态编译器可以使用的如方法内联、逃逸分析,也􏰂包括基于程序运行<code>profle</code>的投机性优化，这个怎么理解了?比如我有一条<code>instanceof</code>指令,在编译之前的运行过程中,测试对像的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回<code>instanceof</code>的结果。如果出现了其他类,那么就抛弃这段编译后的机器码,并且切换回解析执行。</li>
</ul>
<h4 id="谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响"><a href="#谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响" class="headerlink" title="谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?"></a>谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?</h4><ul>
<li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用,但是在扩展性和可靠性等方面存在局限性。</li>
<li>基于Twitter 早期开源的Snowflake的实现,以及相关改动方案。<br><img src="https://img-blog.csdnimg.cn/20190409221903872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt=""></li>
<li>整体长度通常是64 (1 + 41 + 10+ 12 = 64)位,适合使用Java语言中的long类型来存储。</li>
<li>头部是1位的正负标识位。跟着的高位部分包含41位时间戳,通常使用<code>System.currentTimeMillis()</code></li>
<li>后面是<code>10位</code>的<code>WorkerID</code>,标准定义是5位数据中心 + 5位机器ID,组成了机器编􏱆号，以区分不同的集群节点。</li>
<li>最后的12位就是单位毫秒内可生成的序列号数目的理论极限。</li>
</ul>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">242</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.avantv.cn" target="_blank" title="AVANTV">
                      
                        <i class="fa fa-fw fa-user"></i>AVANTV</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">465.0k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
