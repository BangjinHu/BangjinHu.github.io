<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/site.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="BangjinHu'Blog" />





  <link rel="alternate" href="/atom.xml" title="BangjinHu's Blog" type="application/atom+xml" />






<meta name="description" content="微信公众号：iProgrammer_ing">
<meta property="og:type" content="website">
<meta property="og:title" content="BangjinHu&#39;s Blog">
<meta property="og:url" content="http://bangjinhu.github.io/page/15/index.html">
<meta property="og:site_name" content="BangjinHu&#39;s Blog">
<meta property="og:description" content="微信公众号：iProgrammer_ing">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BangjinHu&#39;s Blog">
<meta name="twitter:description" content="微信公众号：iProgrammer_ing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bangjinhu.github.io/page/15/"/>





  <title>BangjinHu's Blog</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/BangjinHu"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BangjinHu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">让优秀成为习惯，让知识成为信仰</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            本站搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第10章 Executor框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第10章 Executor框架/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:53:17+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,526
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h2><p>Java的线程既是工作单元，也是执行机制。所以在JDK 1.5 之后将工作单元和执行机制分离开，工作单元包括 Runnable 和 Callable ，执行机制由 Executor 框架提供。</p>
<p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<h3 id="10-1-Executor-框架简介"><a href="#10-1-Executor-框架简介" class="headerlink" title="10.1 Executor 框架简介"></a>10.1 Executor 框架简介</h3><h4 id="10-1-1-Executor-框架的两级调度模型"><a href="#10-1-1-Executor-框架的两级调度模型" class="headerlink" title="10.1.1 Executor 框架的两级调度模型"></a>10.1.1 Executor 框架的两级调度模型</h4><p>在上层，Java多线程程序通常将应用分解为若干个任务，然后使用用户级的调度器(Executor框架)将这些任务映射为固定数量的线程。</p>
<p>在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<h4 id="10-1-2-Executor-框架的结构和成员"><a href="#10-1-2-Executor-框架的结构和成员" class="headerlink" title="10.1.2 Executor 框架的结构和成员"></a>10.1.2 Executor 框架的结构和成员</h4><p><strong>1.Executor 框架的结构</strong><br></p>
<blockquote>
<p>注意：Executor框架由两个关键类实现了ExecutorService接口(ThreadPoolExecutor和ScheduledThreadPoolExecutor)。</p>
</blockquote>
<p>Executor 框架由3大部分组成：</p>
<pre><code>1.任务：包括被执行任务需要实现的接口（Runnable接口 | Callable接口）

2.任务的执行：包括任务执行机制的核心接口Executor，以及继承Executor的ExecutorService接口。

3.异步计算的结果：包括接口Future接口和实现Future接口的FutureTask类。
</code></pre><p>Executor框架包括的主要的类和接口：</p>
<pre><code>1.Executor接口：是Executor框架基础，将任务的提交与任务的执行分离开。

2.ThreadPoolExecutor线程池核心实现类：用来执行被提交的任务。

3.ScheduledThreadPoolExecutor实现类：在给定的延迟后运行命令，或者定期执行命令。

4.Future接口和实现Future接口的FutureTask类：代表异步计算的结果。

5.Runnable接口和Callable接口的实现类：可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行。
</code></pre><blockquote>
<p>任务执行过程：</p>
</blockquote>
<p>1.首先主线程创建实现 Runnable 或者 Callable 接口的任务对象。工具类Executor可将一个Runnable对象封装成一个Callable对象。<br></p>
<p>2.然后可以将Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runnable command))，或者可以将Runnable对象交给 ExecutorService执行(ExecutorService.submit(Runnable task))或ExecutorService.submit(Callable<t> task)。<br></t></p>
<p>3.最后主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel() 来取消任务执行。</p>
<p><strong>2.Executor框架成员</strong><br></p>
<p>1.ThreadPoolExecutor</p>
<p>ThreadPoolExecutor 通常使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor。</p>
<pre><code>1.FixedThreadPool

2.SingleThreadExecutor

3.CachedThreadPool
</code></pre><p>2.ScheduledThreadPoolExecutor</p>
<pre><code>1.ScheduledThreadPoolExecutor：适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。

2.SingleThreadScheduledExecutor：适用于需要单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景。
</code></pre><p>3.Future接口</p>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduleThreadPoolExecutor会向我们返回一个FutureTask对象。</p>
<p>4.Runnable接口和Callable接口</p>
<p>Runnable接口和Callable接口都可以被ThreadPoolExecutor | ScheduledThreadPoolExecutor 执行，它们之间的区别在于 Runnable 不会返回结果，而Callable可以返回结果。</p>
<h3 id="10-2-ThreadPoolExecutor详解"><a href="#10-2-ThreadPoolExecutor详解" class="headerlink" title="10.2 ThreadPoolExecutor详解"></a>10.2 ThreadPoolExecutor详解</h3><p>主要有是三种Executor：1.CachedThreadPool：一个任务创建一个线程。2.FixedThreadPool：所有任务只能使用固定大小的线程。3.SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
<h4 id="10-2-1-FixedThreadPool详解"><a href="#10-2-1-FixedThreadPool详解" class="headerlink" title="10.2.1 FixedThreadPool详解"></a>10.2.1 FixedThreadPool详解</h4><p>该线程池被称作可重用固定线程数线程池。</p>
<h4 id="10-2-2-SingleThreadExecutor详解"><a href="#10-2-2-SingleThreadExecutor详解" class="headerlink" title="10.2.2 SingleThreadExecutor详解"></a>10.2.2 SingleThreadExecutor详解</h4><p>该线程池是使用单个worker线程的Executor。</p>
<h4 id="10-2-3-CachedThreadPool详解"><a href="#10-2-3-CachedThreadPool详解" class="headerlink" title="10.2.3 CachedThreadPool详解"></a>10.2.3 CachedThreadPool详解</h4><p>该线程池是一个会根据需要创建新线程的线程池。</p>
<h3 id="10-3-ScheduledThreadPoolExecutor详解"><a href="#10-3-ScheduledThreadPoolExecutor详解" class="headerlink" title="10.3 ScheduledThreadPoolExecutor详解"></a>10.3 ScheduledThreadPoolExecutor详解</h3><p>ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutorz。其主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、灵活。Timer对应单个后台线程。</p>
<h4 id="10-3-1-ScheduledThreadPoolExecutor-的运行机制"><a href="#10-3-1-ScheduledThreadPoolExecutor-的运行机制" class="headerlink" title="10.3.1 ScheduledThreadPoolExecutor 的运行机制"></a>10.3.1 ScheduledThreadPoolExecutor 的运行机制</h4><h3 id="10-4-FutureTask详解"><a href="#10-4-FutureTask详解" class="headerlink" title="10.4 FutureTask详解"></a>10.4 FutureTask详解</h3><p>Future接口和实现了Future接口的FutureTask类，表示的是异步计算的结果。</p>
<h4 id="10-4-1-FutureTask简介"><a href="#10-4-1-FutureTask简介" class="headerlink" title="10.4.1 FutureTask简介"></a>10.4.1 FutureTask简介</h4><p>FutureTask除实现Future接口之外，还是Runnable接口。所以FutureTask可以交给Executor执行，也可以调用线程直接执行(FutureTask.run())。</p>
<p>FutureTask可以处于以下3中状态：</p>
<pre><code>1.未启动：

2.已启动：

3.已完成：
</code></pre><h4 id="10-4-2-FutureTask的使用"><a href="#10-4-2-FutureTask的使用" class="headerlink" title="10.4.2 FutureTask的使用"></a>10.4.2 FutureTask的使用</h4><p>可以将FutureTask交给Executor执行，或者通过ExecutorService.submit()方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel()方法。</p>
<h4 id="10-4-3-FutureTask的实现"><a href="#10-4-3-FutureTask的实现" class="headerlink" title="10.4.3 FutureTask的实现"></a>10.4.3 FutureTask的实现</h4><p>FutureTask的实现基于 AbstractQueuedSynchronizer（AQS）。</p>
<blockquote>
<p>提示：java.util.concurrent中很多阻塞类（ReentrantLock）都是基于AQS实现的。AQS 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：基于AQS实现的同步器包括：ReentrantLock | Semaphore | ReentrantReadWriteLock | CountDownLatch | FutureTask。</p>
</blockquote>
</blockquote>
<p>每一个AQS实现的同步器都会包含两种类型的操作：</p>
<pre><code>1.至少有一个acquire操作。该做操阻塞调用线程，直到AQS允许这个线程执行。

    FutureTask的acquire操作是：get()/get(long timeout, TimeUnit unit)方法调用

2.至少有一个release操作。该操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。

    FutureTask的release操作包括run()方法和cancel()方法
</code></pre><h3 id="10-5-Future-模式"><a href="#10-5-Future-模式" class="headerlink" title="10.5 Future 模式"></a>10.5 Future 模式</h3><p>Future模式是多线程开发中常见的一种设计模式，核心思想是异步调用。在调用的方法返回的结果很慢的时候，我们可以让它在后台慢慢执行，我们利用这段时间处理其它任务，在真正需要数据的场合再去尝试获得需要的数据。</p>
<h4 id="10-5-1-Future模式主要方法"><a href="#10-5-1-Future模式主要方法" class="headerlink" title="10.5.1 Future模式主要方法"></a>10.5.1 Future模式主要方法</h4><pre><code>1. boolean cancel(boolean mayInterruptIfRunning);//取消任务

2. boolean isCancelled();//是否已经取消

3. boolean isDone();//是否已经完成

4. V get() throws InterruptedException..;//取得返回对象

5. V get(long timeout, TimeUnit unit);//取得返回对象，可以设置超时时间
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第11章 Java并发编程实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第11章 Java并发编程实战/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:19:16+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,114
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<p>[TOC]</p>
<h2 id="第十一章-Java并发编程实战"><a href="#第十一章-Java并发编程实战" class="headerlink" title="第十一章 Java并发编程实战"></a>第十一章 Java并发编程实战</h2><h3 id="11-1-生产者和消费者模式"><a href="#11-1-生产者和消费者模式" class="headerlink" title="11.1 生产者和消费者模式"></a>11.1 生产者和消费者模式</h3><blockquote>
<p>提示：生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。</p>
</blockquote>
<p>生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列中取。所以这里的阻塞队列相当于一个缓冲区，平衡生产者和消费者的处理能力。</p>
<h3 id="11-2-ArrayBlockingQueue"><a href="#11-2-ArrayBlockingQueue" class="headerlink" title="11.2 ArrayBlockingQueue"></a>11.2 ArrayBlockingQueue</h3><h3 id="11-3-并发组件ConcurrentHashMap使用注意事项"><a href="#11-3-并发组件ConcurrentHashMap使用注意事项" class="headerlink" title="11.3 并发组件ConcurrentHashMap使用注意事项"></a>11.3 并发组件ConcurrentHashMap使用注意事项</h3><p>在ConcurrentHashMap中的方法map.putIfAbsent()方法添加新设备列表时，如果在key在map中不存在，则将key与对应的值放入map中。注意的是这个操作是原子性操作，放入后会返回null。</p>
<p>如果key在map中存在，则调用putIfAbsent()会返回key对应的value值。如果发现返回的value值不是null则将新的value值添加到返回的列表里面，从而问题得到解决。</p>
<blockquote>
<p>总结：put(K key, V value)方法判断，如果key已经存在，则使用value覆盖原来的值并返回原来的值。如果key不存在则将value放入并返回null。putIfAbsent(K key, V value)方法则是如果key已经存在则直接返回原来对应的值并不使用value覆盖，如果key不存在则放入value并返回null。另外需要注意的是，判断key是否存在和放入是原子操作。</p>
</blockquote>
<h3 id="11-4-SimpleDateFormat-是线程不安全的"><a href="#11-4-SimpleDateFormat-是线程不安全的" class="headerlink" title="11.4 SimpleDateFormat 是线程不安全的"></a>11.4 SimpleDateFormat 是线程不安全的</h3><p>SimpleDateFormat是Java提供的一个格式化和解析日期的工具类，但是它不是线程安全的。所以在多线程程序中共用一个SimpleDateFormat实例对日期进行解析或者格式化会导致程序出错。 </p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>由于多线程使用的是一个calendar对象，所以线程A执行程序之后，线程B再次执行可能是线程A清空的对象，从而导致程序错误。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><pre><code>1. 每次使用时候new一个SimpleDateFormat的实例，这样可以保证每个实例使用自己的Calendar实例。

    这样的过程由于没有其它的引用，需要回收，开销很大

2. 可使用synchronized进行同步

    这样的方式同样也意味着多个线程要竞争锁，在高并发场景下会导致系统响应性能下降。

3. ThreadLocal 这样每个线程只需要使用一个SimpleDateFormat实例
</code></pre><h3 id="11-5-使用Timer时需要注意的事情"><a href="#11-5-使用Timer时需要注意的事情" class="headerlink" title="11.5 使用Timer时需要注意的事情"></a>11.5 使用Timer时需要注意的事情</h3><p>当一个Timer运行多个TimerTask时，只要其中一个TimerTask在执行中向run()方法外抛出了异常，则其它任务也会自动终止。</p>
<h4 id="11-5-2-Timer实现原理分析"><a href="#11-5-2-Timer实现原理分析" class="headerlink" title="11.5.2 Timer实现原理分析"></a>11.5.2 Timer实现原理分析</h4><p>TaskQueue是一个由平衡二叉树堆实现的优先级队列，每个Timer对象内部有一个TaskQueue队列。</p>
<p>用户线程调用Timer的schedule()方法就是将TimerTask任务添加到TaskQueue队列。</p>
<p>在调用schedule()方法时，long delay参数表示任务延迟多少时间执行。</p>
<blockquote>
<p>注意：TimerThread是具体执行任务的线程，是从TaskQueue队列里面获取优先级最高的任务进行执行。只有执行完当前的任务才会从队列里面获取下一个任务，不管队列是否有任务已经到了设置的delay时间。一个Timer只有一个TimerThread线程，所以在Timer的内部实现是一个 多生产者-单消费者模型。</p>
</blockquote>
<p>其实如果需要Timer功能，使用ScheduleThreadPoolExecutor的schedule()是比较好的选择。如果在ScheduledThreadPoolExecutor中的一个任务抛出异常，其它任务不受影响。</p>
<blockquote>
<p>提示：ScheduledThreadPoolExecutor的其它任务不受抛出异常任务的影响，是因为在ScheduledThreadPoolExecutor中的ScheduledFutureTask任务中catch掉了异常。</p>
</blockquote>
<h3 id="11-6-使用ThreadLocal不当会导致内存泄漏"><a href="#11-6-使用ThreadLocal不当会导致内存泄漏" class="headerlink" title="11.6 使用ThreadLocal不当会导致内存泄漏"></a>11.6 使用ThreadLocal不当会导致内存泄漏</h3><p>ThreadLocal只是一个工具类，具体存放变量的是线程的threadLocals变量。</p>
<p>threadLocals变量是一个ThreadLocalMap类型变量，</p>
<h3 id="11-7-线程池使用FutureTask时需要注意的事情"><a href="#11-7-线程池使用FutureTask时需要注意的事情" class="headerlink" title="11.7 线程池使用FutureTask时需要注意的事情"></a>11.7 线程池使用FutureTask时需要注意的事情</h3><p>线程池在使用FutrueTask时如果将拒绝策略设置为 DiscardPolicy 和 DiscardOldestPolicy，并且在被拒绝的任务的Future对象上调用了无参get()方法，那么调用线程会一直被阻塞。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第12章 HandlerMapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第12章 HandlerMapping/" itemprop="url">HandlerMapping</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:18:40+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,331
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第12章-HandlerMapping"><a href="#第12章-HandlerMapping" class="headerlink" title="第12章 HandlerMapping"></a>第12章 HandlerMapping</h1><p>[TOC]</p>
<p>HandlerMapping的作用是通过request查找Handler和Interceptors。HandlerMapping包括继承AbstractUrlHandlerMapping和继承AbstractHandlerMapping，这两支都继承抽象类AbstractHandlerMapping。</p>
<h2 id="12-1-AbstractHandlerMapping"><a href="#12-1-AbstractHandlerMapping" class="headerlink" title="12.1 AbstractHandlerMapping"></a>12.1 AbstractHandlerMapping</h2><p>AbstractHandlerMapping是HandlerMapping抽象实现。其采用模板模式设计了HandlerMapping实现的整体结构。子类通过模板方法提供初始值或者具体算法即可。这种模式是：首先使用一个抽象实现采用模板模式进行整体设计，然后在子类通过实现模板方法具体实现业务。</p>
<p>HandlerMapping的作用是是通过request查找Handler和Interceptors。获取Handler的过程通过模板方法getHandlerInternal()交给子类。AbstractHandlerMapping中保存了所有的配置Interceptor，在获取Handler后会自己根据从request中获取的lookupPath将相应的Interceptor装配。子类也可以如此。</p>
<h4 id="12-1-1-创建AbstractHandlerMapping"><a href="#12-1-1-创建AbstractHandlerMapping" class="headerlink" title="12.1.1 创建AbstractHandlerMapping"></a>12.1.1 创建AbstractHandlerMapping</h4><p>AbstractHandlerMapping继承WebApplicationObjectSupport，初始化时会自动调用模板方法initApplicationContext()方法。AbstractHandlerMapping创建是在initApplicationContext()方法中。</p>
<pre><code>package org.springframework.web.servlet.handler;
public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport implements HandlerMapping, Ordered {
    // ...
 }

protected void initApplicationContext() throws BeansException {
    //该方法是模板方法，给子类提供一个添加或修改Interceptors的入口
    extendInterceptors(this.interceptors);

    //将SpringMVC容器和父容器中所有的MappedInterceptor类型的Bean添加到mappedInterceptors属性
    detectMappedInterceptors(this.mappedInterceptors);

    //该方法的作用是初始化Interceptor
    initInterceptors();
}

//提供给子类扩展拦截器(没有使用)
protected void extendInterceptors(List&lt;Object&gt; interceptors) {

    }

//扫描应用下的MappedInterceptor,并添加到mappedInterceptors
protected void detectMappedInterceptors(List&lt;MappedInterceptor&gt; mappedInterceptors) {
     mappedInterceptors.addAll(
             BeanFactoryUtils.beansOfTypeIncludingAncestors(
                     getApplicationContext(),MappedInterceptor.class, true, false).values());
 }

//归集MappedInterceptor,并适配HandlerInterceptor和WebRequestInterceptor
protected void initInterceptors() {
     if (!this.interceptors.isEmpty()) {
         for (int i = 0; i &lt; this.interceptors.size(); i++) {
             Object interceptor = this.interceptors.get(i);
             if (interceptor == null) {
                 throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);
             }
             if (interceptor instanceof MappedInterceptor) {
                 mappedInterceptors.add((MappedInterceptor) interceptor);
             }
             else {
                 adaptedInterceptors.add(adaptInterceptor(interceptor));
             }
         }
     }
 }

AbstractHandlerMapping的属性：

    // order赋了最大值,优先级是最小的
    private int order = Integer.MAX_VALUE;

    // 默认的Handler,这边使用的Obejct,子类实现的时候,使用HandlerMethod,HandlerExecutionChain等
    private Object defaultHandler;

    // url计算的辅助类
    private UrlPathHelper urlPathHelper = new UrlPathHelper();

    // 基于ant进行path匹配,解决如/books/{id}场景
    private PathMatcher pathMatcher = new AntPathMatcher();

    // 拦截器配置:两种配置方式 interceptors只用于配置
    // 1 HandlerMapping属性设置;
    // 2 extendInterceptors设置
    private final List&lt;Object&gt; interceptors = new ArrayList&lt;Object&gt;();

    // 从interceptors中解析得到,直接添加给全部handler
    private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;HandlerInterceptor&gt;();

    // 使用前需要跟url进行匹配,匹配通过才会使用。匹配成功后将其添加到getHandler的返回值HandlerExecutionChain中。
    private final List&lt;MappedInterceptor&gt; mappedInterceptors = new ArrayList&lt;MappedInterceptor&gt;();
</code></pre><blockquote>
<p>提示：WebApplicationObjectSupport用于提供上下文ApplicationContext和ServletContext。AbstractHandlerMapping的创建就是上面三个Interceptor的初始化。</p>
</blockquote>
<h4 id="12-1-2-AbstractHandlerMapping的使用"><a href="#12-1-2-AbstractHandlerMapping的使用" class="headerlink" title="12.1.2 AbstractHandlerMapping的使用"></a>12.1.2 AbstractHandlerMapping的使用</h4><p>HandlerMapping通过getHandler()方法获取处理器Handler和拦截器Interceptors。</p>
<pre><code>public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    //留给子类具体实现，子类主要做的事情
    Object handler = getHandlerInternal(request);

    //没有获取到则使用默认的Handler
    if (handler == null) {
        handler = getDefaultHandler();
    }
    if (handler == null) {
        return null;
    }
    // Bean name or resolved handler?
    if (handler instanceof String) {
        String handlerName = (String) handler;
        handler = getApplicationContext().getBean(handlerName);
    }
    return getHandlerExecutionChain(handler, request);
}

//这里预留getHandlerInternal(HttpServletRequest request)方法给子类实现
protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception;
</code></pre><p>然后封装拦截器到HandlerExecutionChain()，该方法用于添加拦截器。</p>
<pre><code>protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {

    //1.首先使用handler创建HandlerExecutionChain类型变量
    HandlerExecutionChain chain = 
    (handler instanceof HandlerExecutionChain) ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler);

    //adaptedInterceptors直接添加
    chain.addInterceptors(getAdaptedInterceptors());

    //mappedInterceptors需要根据url匹配通过后添加
    String lookupPath = urlPathHelper.getLookupPathForRequest(request);
    for (MappedInterceptor mappedInterceptor : mappedInterceptors) {
        if (mappedInterceptor.matches(lookupPath, pathMatcher)) {
            chain.addInterceptor(mappedInterceptor.getInterceptor());
        }
    }

    return chain;
}
</code></pre><h2 id="12-2-AbstractUrlHandlerMapping"><a href="#12-2-AbstractUrlHandlerMapping" class="headerlink" title="12.2 AbstractUrlHandlerMapping"></a>12.2 AbstractUrlHandlerMapping</h2><p>从名字可以看出是通过url进行匹配的。大致原理是将url与对应的handler保存到一个Map中，在getHandlerInternal()方法中使用url从Map中获取Handler，AbstractUrlHandlerMapping中实现了具体用url从Map中获取Handler的过程。</p>
<pre><code>@Override
protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
    // 根据request获取url
    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
    // 根据url查找handler
    Object handler = lookupHandler(lookupPath, request);
    if (handler == null) {
        // 如果没有匹配到handler需要查找默认的,下面需要将PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE缓存到request
        //临时变量，保存找到的原始Handler
        Object rawHandler = null;
        if (&quot;/&quot;.equals(lookupPath)) {
            rawHandler = getRootHandler();
        }
        if (rawHandler == null) {
            rawHandler = getDefaultHandler();
        }
        if (rawHandler != null) {
            //如果是String类型则到容器中查找具体的bean
            if (rawHandler instanceof String) {
                String handlerName = (String) rawHandler;
                rawHandler = getApplicationContext().getBean(handlerName);
            }
            // 预留的校验handler模板方法,没有使用
            validateHandler(rawHandler, request);
            // 添加expose属性到request的拦截器
            handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
        }
    }
    if (handler != null &amp;&amp; logger.isDebugEnabled()) {
        logger.debug(&quot;Mapping [&quot; + lookupPath + &quot;] to &quot; + handler);
    }
    else if (handler == null &amp;&amp; logger.isTraceEnabled()) {
        logger.trace(&quot;No handler mapping found for [&quot; + lookupPath + &quot;]&quot;);
    }
    return handler;
}
</code></pre><blockquote>
<p>提示：这里的lookupHandler()方法用于使用lookupPath从Map中查找Handler。buildPathExposiongHandler()方法用于给查找到的Handler注册两个拦截器PathExposingHandlerIntercptor和UriTemplateVariablesHandlerInterceptor。这两个是内部拦截器，主要作用是将与当前url实际匹配的pattern、匹配条件和url模板参数等设置到request的属性中。这样一来在后面的处理过程中就能够直接从request中获取。</p>
</blockquote>
<pre><code>protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
    // 直接根据url进行查找handler，直接从Map中获取
    Object handler = this.handlerMap.get(urlPath);
    if (handler != null) {
        // 如果是String类型直接从容器中获取
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        validateHandler(handler, request);
        return buildPathExposingHandler(handler, urlPath, urlPath, null);
    }
    // Pattern match? 通过表达式进行匹配具体通过AntPathMatcher实现,具体后面分析
    List&lt;String&gt; matchingPatterns = new ArrayList&lt;String&gt;();
    for (String registeredPattern : this.handlerMap.keySet()) {
        if (getPathMatcher().match(registeredPattern, urlPath)) {
            matchingPatterns.add(registeredPattern);
        }
    }
    String bestPatternMatch = null;
    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);
    if (!matchingPatterns.isEmpty()) {
        Collections.sort(matchingPatterns, patternComparator);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Matching patterns for request [&quot; + urlPath + &quot;] are &quot; + matchingPatterns);
        }
        // order序号最小的优先级最高
        bestPatternMatch = matchingPatterns.get(0);
    }
    if (bestPatternMatch != null) {
        handler = this.handlerMap.get(bestPatternMatch);
        // 如果是String类型则从容器中获取
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        validateHandler(handler, request);
        String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);

        //处理使用sort()方法排序之后，多个Pattern顺序相同，返回值为0的情况
        Map&lt;String, String&gt; uriTemplateVariables = new LinkedHashMap&lt;String, String&gt;();
        for (String matchingPattern : matchingPatterns) {
            if (patternComparator.compare(bestPatternMatch, matchingPattern) == 0) {
                Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);
                Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);
                uriTemplateVariables.putAll(decodedVars);
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;URI Template variables for request [&quot; + urlPath + &quot;] are &quot; + uriTemplateVariables);
        }
        return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);
    }
    // No handler found...
    return null;
}
</code></pre><h4 id="12-2-1-SimpleUrlHandlerMapping"><a href="#12-2-1-SimpleUrlHandlerMapping" class="headerlink" title="12.2.1 SimpleUrlHandlerMapping"></a>12.2.1 SimpleUrlHandlerMapping</h4><p>该类定义了一个Map变量(两个作用：1.方便配置。2.在注册前做一些预处理。如：确保所有的url都以””/“开头)，将所有的url和handler的对应关系放在里面，最后注册到父类的Map中。AbstractDetectingUrlHandlerMapping是将容器中所有bean拿出来，按照一定规则注册到父类的Map中。</p>
<p>SimpleUrlHandlerMapping在创建时重写父类的initApplicationContext()方法，调用registerHandlers()方法完成Handler注册。registerHandlers()方法调用AbstractHandlerMapping的registerHandler()方法将配置的urlMap注册到AbstractUrlHandlerMapping的Map中。</p>
<blockquote>
<p>总结：该类就是直接将配置的内容注册到AbstractUrlHandlerMapping中去。</p>
</blockquote>
<h4 id="12-2-2-AbstractDetectingUrlHandlerMapping"><a href="#12-2-2-AbstractDetectingUrlHandlerMapping" class="headerlink" title="12.2.2 AbstractDetectingUrlHandlerMapping"></a>12.2.2 AbstractDetectingUrlHandlerMapping</h4><p>该类也是通过重写initApplicationContext来注册Handler，在里面调用了detectHandler()方法。在detectHandlers()中根据配置的detectHand-lersInAncestorContexts参数从Springmvc容器或者Springmvc及其父容器中找到所有的bean的beanName，然后使用方法determineUrlsHandler()方法对每个beanName解析出对应的urls。</p>
<pre><code>@Override
public void initApplicationContext() throws ApplicationContextException {
    //进行初始化
    super.initApplicationContext();

    detectHandlers();
}

protected void detectHandlers() throws BeansException {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Looking for URL mappings in application context: &quot; + getApplicationContext());
    }

    //获取容器的所有bean的名字
    String[] beanNames = (this.detectHandlersInAncestorContexts ?
            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :
            getApplicationContext().getBeanNamesForType(Object.class));

    // 对每个beanName解析url，如果能解析到就注册到父类的Map中
    for (String beanName : beanNames) {

        //使用beanName解析url，是模板方法，子类具体实现
        String[] urls = determineUrlsForHandler(beanName);

        //如果能解析到url则注册到父类
        if (!ObjectUtils.isEmpty(urls)) {
            // 父类的registerHandler方法
            registerHandler(urls, beanName);
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Rejected bean name &apos;&quot; + beanName + &quot;&apos;: no URL paths identified&quot;);
            }
        }
    }
}

//预留的模板方法
protected abstract String[] determineUrlsForHandler(String beanName);
</code></pre><blockquote>
<p>提示：AbstractDetectingUrlHandlerMapping中有三个类：BeanNameUrlHandlerMapping | DefaultAnnotationHandlerMapping(@Deprecated 已被弃用) | AbstractControllerUrlHandlerMapping 。</p>
</blockquote>
<p><strong>1.BeanNameUrlHandlerMapping</strong><br><br>该类是检查beanName和alias是否是以”/“开头，如果是则将其作为url，里面只有一个determineUrlsForHandler()方法。</p>
<pre><code>/**
 * Checks name and aliases of the given bean for URLs, starting with &quot;/&quot;.
 */
@Override
protected String[] determineUrlsForHandler(String beanName) {
    List&lt;String&gt; urls = new ArrayList&lt;String&gt;();
    if (beanName.startsWith(&quot;/&quot;)) {
        urls.add(beanName);
    }
    String[] aliases = getApplicationContext().getAliases(beanName);
    for (String alias : aliases) {
        if (alias.startsWith(&quot;/&quot;)) {
            urls.add(alias);
        }
    }
    return StringUtils.toStringArray(urls);
}
</code></pre><p><strong>2.AbstractControllerUrlHandlerMapping</strong><br><br>该类是将实现了Controller接口或注释@Controller的bean作为Handler，同时可以设置excludedClasses和excludedPackages将不包含的bean或者不包含的包下的所有bean排除在外。这里的determineUrlsForHandler()方法主要负责将符合条件的Handler找出来。</p>
<pre><code>//determineUrlsForHandler()方法主要负责将符合条件的Handler找出来
@Override
protected String[] determineUrlsForHandler(String beanName) {
    Class beanClass = getApplicationContext().getType(beanName);
    if (isEligibleForMapping(beanName, beanClass)) {
        return buildUrlsForHandler(beanName, beanClass);
    }
    else {
        return null;
    }
}

//判断controller是否被排除在外(通过包package排除或类class排除)
protected boolean isEligibleForMapping(String beanName, Class beanClass) {
    if (beanClass == null) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Excluding controller bean &apos;&quot; + beanName + &quot;&apos; from class name mapping &quot; +
                    &quot;because its bean type could not be determined&quot;);
        }
        return false;
    }

    //排除excludedClasses里配置的类
    if (this.excludedClasses.contains(beanClass)) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Excluding controller bean &apos;&quot; + beanName + &quot;&apos; from class name mapping &quot; +
                    &quot;because its bean class is explicitly excluded: &quot; + beanClass.getName());
        }
        return false;
    }
    String beanClassName = beanClass.getName();

    //排除excludedPackages里配置的包下的类
    for (String packageName : this.excludedPackages) {
        if (beanClassName.startsWith(packageName)) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Excluding controller bean &apos;&quot; + beanName + &quot;&apos; from class name mapping &quot; +
                        &quot;because its bean class is defined in an excluded package: &quot; + beanClass.getName());
            }
            return false;
        }
    }

    //检查是否实现了Controller接口或注释了@Controller
    return isControllerType(beanClass);
}
</code></pre><p><strong>2.1 AbstractControllerUrlHandlerMapping 的实现类 ControllerBeanNameUrlHandlerMapping</strong><br><br>此类是根据beanName来生产url。</p>
<pre><code>@Override
protected String[] buildUrlsForHandler(String beanName, Class beanClass) {
    List&lt;String&gt; urls = new ArrayList&lt;String&gt;();
    urls.add(generatePathMapping(beanName));
    String[] aliases = getApplicationContext().getAliases(beanName);// 也获取配置的别名
    for (String alias : aliases) {
        urls.add(generatePathMapping(alias));
    }
    return StringUtils.toStringArray(urls);
}
</code></pre><p><strong>2.2 AbstractControllerUrlHandlerMapping 的实现类 ControllerClassNameUrlHandlerMapping</strong><br><br>此类是根据className来生产url。</p>
<pre><code>//对path添加前后缀,还有/
protected String generatePathMapping(String beanName) {
    String name = (beanName.startsWith(&quot;/&quot;) ? beanName : &quot;/&quot; + beanName);
    StringBuilder path = new StringBuilder();
    if (!name.startsWith(this.urlPrefix)) {
        path.append(this.urlPrefix);
    }
    path.append(name);
    if (!name.endsWith(this.urlSuffix)) {
        path.append(this.urlSuffix);
    }
    return path.toString();
}
</code></pre><blockquote>
<p>提示：ControllerClassNameUrlHandlerMapping直接委托给 generatePathMappings 实现。</p>
</blockquote>
<pre><code>@Override
protected String[] buildUrlsForHandler(String beanName, Class beanClass) {
    return generatePathMappings(beanClass);
}


protected String[] generatePathMappings(Class beanClass) {
    StringBuilder pathMapping = buildPathPrefix(beanClass);
    String className = ClassUtils.getShortName(beanClass);
    String path = (className.endsWith(CONTROLLER_SUFFIX) ?
            className.substring(0, className.lastIndexOf(CONTROLLER_SUFFIX)) : className);
    if (path.length() &gt; 0) {
        if (this.caseSensitive) {
            pathMapping.append(path.substring(0, 1).toLowerCase()).append(path.substring(1));
        }
        else {
            pathMapping.append(path.toLowerCase());
        }
    }
    if (isMultiActionControllerType(beanClass)) {
        return new String[] {pathMapping.toString(), pathMapping.toString() + &quot;/*&quot;};
    }
    else {
        return new String[] {pathMapping.toString() + &quot;*&quot;};
    }
}


private StringBuilder buildPathPrefix(Class beanClass) {
    StringBuilder pathMapping = new StringBuilder();
    if (this.pathPrefix != null) {
        pathMapping.append(this.pathPrefix);
        pathMapping.append(&quot;/&quot;);
    }
    else {
        pathMapping.append(&quot;/&quot;);
    }
    if (this.basePackage != null) {
        String packageName = ClassUtils.getPackageName(beanClass);
        if (packageName.startsWith(this.basePackage)) {
            String subPackage = packageName.substring(this.basePackage.length()).replace(&apos;.&apos;, &apos;/&apos;);
            pathMapping.append(this.caseSensitive ? subPackage : subPackage.toLowerCase());
            pathMapping.append(&quot;/&quot;);
        }
    }
    return pathMapping;
}


protected boolean isMultiActionControllerType(Class beanClass) {
    return this.predicate.isMultiActionControllerType(beanClass);
}
</code></pre><h2 id="12-3-AbstractHandlerMethodMapping"><a href="#12-3-AbstractHandlerMethodMapping" class="headerlink" title="12.3 AbstractHandlerMethodMapping"></a>12.3 AbstractHandlerMethodMapping</h2><p>AbstractHandlerMethodMapping系列只有是三个类：AbstractHandlerMethodMapping | RequestMappingInfoHandlerMapping | RequestMappingHandlerMapping。这一系列是将Method作为Handler来使用的。比如经常使用的@RequestMapping所注释的方法就是这种Handler，它专门有一个类型：HandlerMethod，即Method类型的Handler。</p>
<h4 id="12-3-1-创建AbstractHandlerMethodMapping"><a href="#12-3-1-创建AbstractHandlerMethodMapping" class="headerlink" title="12.3.1 创建AbstractHandlerMethodMapping"></a>12.3.1 创建AbstractHandlerMethodMapping</h4><p>该类的作用是定义整个算法流程。这里最重要的理解三个Map的含义：</p>
<pre><code>//该map的作用是保存着匹配条件(RequestCondition)和Handler Method的对应关系。
private final Map&lt;T,HandlerMethod&gt; handlerMethods = new LinkedHashMap&lt;T,HandlerMethod&gt;();

//该map的作用是保存着url与匹配条件的对应关系。
private final MultiValueMap&lt;String,T&gt; urlMap = new LinkedMultiValueMap&lt;String,T&gt;();

//该map的作用是保存着name与handlermathod的对应关系。
private final MultiValueMap&lt;String,HandlerMethod&gt; nameMap = new LinkedMultiValueMap&lt;String,HandlerMethod&gt;();
</code></pre><p>这里的AbstractHandlerMethodMapping实现了initialziingBean接口，所有Spring容器会自动调用其afterProperties方法和afterPropertiesSet又交给initHandlerMethods()方法完成初始化。</p>
<pre><code>protected void initHandlerMethods() {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());
    }
    String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?
            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :
            obtainApplicationContext().getBeanNamesForType(Object.class));

    for (String beanName : beanNames) {
        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
            Class&lt;?&gt; beanType = null;
            try {
                beanType = obtainApplicationContext().getType(beanName);
            }
            catch (Throwable ex) {
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Could not resolve target class for bean with name &apos;&quot; + beanName + &quot;&apos;&quot;, ex);
                }
            }
            if (beanType != null &amp;&amp; isHandler(beanType)) {
                detectHandlerMethods(beanName);
            }
        }
    }
    handlerMethodsInitialized(getHandlerMethods());
}
</code></pre><blockquote>
<p>提示：1.首先拿到容器里面的所有bean。2.然后根据一定的规则筛选出Handler。3.最后保存到Map中。这里的筛选方法是isHandler()方法，是一个模板方法。具体的筛选是在子类里，筛选的逻辑是检查类前是否有@Controller或者@RequestMapping注解。4.在detectHandlerMethods中，首先从传入的处理器中找到符合要求的方法，然后用registerHandlerMethod进行注册（也就是保存在Map中），从这里可以看出Spring其实是将处理请求的方法所在的类看作处理器，而不是处理请求的方法，不过许多地方需要将请求的方法作为处理器来理解。从handler里获取可以处理请求的method的方法使用。</p>
</blockquote>
<h4 id="12-3-1-续-AbstractHandlerMethodMapping-系列之用"><a href="#12-3-1-续-AbstractHandlerMethodMapping-系列之用" class="headerlink" title="12.3.1 续 AbstractHandlerMethodMapping 系列之用"></a>12.3.1 续 AbstractHandlerMethodMapping 系列之用</h4><p>这里的主要功能是通过 getHandlerInternal() 方法获取处理器。这里的 getHandlerInternal() 方法做三件事：1.根据request获取ookupPath(url)。2.使用lookupPath和request找handlerMethod。3.如果可以找到handlerMethod则调用它的createWithResolverBean()方法创建新的 HandlerMethod 并返回。这里的 createWithResolverBean() 方法是判断 handlerMethod 里的handler是否是String类型。如果是则改为将其作为 beanName从容器中所取到的bean，但是HandlerMethod中的属性是final类型，不能修改。</p>
<h4 id="12-3-2-RequestMappingInfoHandlerMapping"><a href="#12-3-2-RequestMappingInfoHandlerMapping" class="headerlink" title="12.3.2 RequestMappingInfoHandlerMapping"></a>12.3.2 RequestMappingInfoHandlerMapping</h4><p>提供匹配条件RequestMappingInfo的解析处理。</p>
<pre><code>/**
 * 获取url集合，即@RequestMapping中设置的value或path
 */
@Override
protected Set&lt;String&gt; getMappingPathPatterns(RequestMappingInfo info) {
    return info.getPatternsCondition().getPatterns();
}
</code></pre><h4 id="12-3-3-RequestMappingHandlerMapping"><a href="#12-3-3-RequestMappingHandlerMapping" class="headerlink" title="12.3.3 RequestMappingHandlerMapping"></a>12.3.3 RequestMappingHandlerMapping</h4><p>根据@RequestMapping注解生成RequestMappingInfo，同时提供isHandler()方法实现。</p>
<pre><code>/**
 * 使用方法和类型注解@RequestMapping创建RequestMappingInfo对象
 */
@Override
@Nullable
protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
    // 创建方法的RequestMappingInfo
    RequestMappingInfo info = createRequestMappingInfo(method);
    if (info != null) {
        // 创建类的RequestMappingInfo
        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);
        if (typeInfo != null) {
            // 将方法RequestMappingInfo和类RequestMappingInfo合并，比如Controller类上有@RequestMapping(&quot;/demo&quot;)，方法的@RequestMapping(&quot;/demo1&quot;)，结果为&quot;/demo/demo1&quot;
            info = typeInfo.combine(info);
        }
    }
    return info;
}

@Nullable
private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {
    // 获取RequestMapping注解
    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);
    RequestCondition&lt;?&gt; condition = (element instanceof Class ?
            getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));
    // 调用createRequestMappingInfo创建匹配条件对象
    return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);
}

/**
 * 构造匹配条件对象
 */
protected RequestMappingInfo createRequestMappingInfo(
        RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) {

    RequestMappingInfo.Builder builder = RequestMappingInfo
            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))
            .methods(requestMapping.method())
            .params(requestMapping.params())
            .headers(requestMapping.headers())
            .consumes(requestMapping.consumes())
            .produces(requestMapping.produces())
            .mappingName(requestMapping.name());
    if (customCondition != null) {
        builder.customCondition(customCondition);
    }
    return builder.options(this.config).build();
}
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第13章 HandlerAdapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第13章 HandlerAdapter/" itemprop="url">HandlerAdapter</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T10:18:12+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,171
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第13章-HandlerAdapter"><a href="#第13章-HandlerAdapter" class="headerlink" title="第13章 HandlerAdapter"></a>第13章 HandlerAdapter</h1><p>[TOC]</p>
<p>HandlerMapping通过request找到Handler，而HandlerAdapter是具体使用Handler来干活的。每个HandlerAdapter封装了一种Handler的具体使用方法。HandlerAdapter结构中有5个Adapter，其中只有RequestMappingHandlerAdapter有两层，而其它的只有一层，是直接实现HandlerAdapter接口。同时其中的有一个类已经弃用，所以只有4类Adapter，5个类。</p>
<blockquote>
<p>提示：在HandlerAdapter的接口中只有三个方法：1.判断是否支持传入Handler。2.使用Handler处理请求。3.获取资源的LastModified值。</p>
</blockquote>
<h2 id="13-1-RequestMappingHandlerAdapter"><a href="#13-1-RequestMappingHandlerAdapter" class="headerlink" title="13.1 RequestMappingHandlerAdapter"></a>13.1 RequestMappingHandlerAdapter</h2><p>RequestMappingHandlerAdapter适配器是与RequestMappingHandlerMapping配合使用的。</p>
<h4 id="13-1-1-AbstractHandlerMethodAdapter"><a href="#13-1-1-AbstractHandlerMethodAdapter" class="headerlink" title="13.1.1 AbstractHandlerMethodAdapter"></a>13.1.1 AbstractHandlerMethodAdapter</h4><p><strong>1.supports()方法</strong><br><br>AbstractHandlerMethodAdapter类实现了supports()方法，可以知道支持的Handler是HandlerMethod，同时附加了一个判断方法supportsInternal，这个方法由RequestMappingHandlerAdapter实现，其就是简单地返回true。</p>
<pre><code>@Override
public final boolean supports(Object handler) {
    // 判断当前handler是否为HandlerMethod类型，并且判断supportsInternal()方法返回值是否为true，
    // 这里supportsInternal()方法是提供给子类实现的一个方法，对于RequestMappingHandlerAdapter
    // 而言，其返回值始终是true，因为其只需要处理的handler是HandlerMethod类型的即可
    return (handler instanceof HandlerMethod 
            &amp;&amp; supportsInternal((HandlerMethod) handler));
}

@Override
protected boolean supportsInternal(HandlerMethod handlerMethod) {
    // 这里RequestMappingHandlerAdapter只是对supportsInternal()返回true，因为其只需要
    // 处理的handler类型是HandlerMethod类型即可
    return true;
}

@Override
protected boolean supportsInternal(HandlerMethod handlerMethod) {
    // 这里RequestMappingHandlerAdapter只是对supportsInternal()返回true，因为其只需要
    // 处理的handler类型是HandlerMethod类型即可
    return true;
}
</code></pre><p><strong>2.handle()方法</strong><br><br>在supports()方法判断了所处理的handler是HandlerMethod类型之后，RequestMappingHandlerAdapter将会调用handle()方法处理当前请求。AbstractHandlerMethodAdapter实现了handle方法，就是简单地调用了模板方法handleInternal，handleInternal方法由RequestMappingHandlerAdapter实现。</p>
<pre><code>public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {
    return handleInternal(request, response, (HandlerMethod) handler);
}

@Override
protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
    ModelAndView mav;
    checkRequest(request);

    // 判断当前是否需要支持在同一个session中只能线性地处理请求
    if (this.synchronizeOnSession) {
        // 获取当前请求的session对象
        HttpSession session = request.getSession(false);
        if (session != null) {
            // 为当前session生成一个唯一的可以用于锁定的key
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized (mutex) {
                // 对HandlerMethod进行参数等的适配处理，并调用目标handler
                mav = invokeHandlerMethod(request, response, handlerMethod);
            }
        } else {
            // 如果当前不存在session，则直接对HandlerMethod进行适配
            mav = invokeHandlerMethod(request, response, handlerMethod);
        }
    } else {
        // 如果当前不需要对session进行同步处理，则直接对HandlerMethod进行适配
        mav = invokeHandlerMethod(request, response, handlerMethod);
    }

    // 判断当前请求头中是否包含Cache-Control请求头，如果不包含，则对当前response进行处理，
    // 为其设置过期时间
    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {
        // 如果当前SessionAttribute中存在配置的attributes，则为其设置过期时间。
        // 这里SessionAttribute主要是通过@SessionAttribute注解生成的
        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);
        } else {
            // 如果当前不存在SessionAttributes，则判断当前是否存在Cache-Control设置，
            // 如果存在，则按照该设置进行response处理，如果不存在，则设置response中的
            // Cache的过期时间为-1，即立即失效
            prepareResponse(response);
        }
    }

    return mav;
}
</code></pre><blockquote>
<p>提示：上面的程序作了两部分处理：1.判断当前是否对session进行同步处理，如果需要则进行加锁处理，不需要则直接调用。2.判断请求头是否已经包含Cache-Control请求头，如果不包含则设置Cache立即失效。对HandlerMethod的具体请求是在invokeHandlerMethod()方法中进行的。</p>
</blockquote>
<pre><code>@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try {
        // 获取容器中全局配置的InitBinder和当前HandlerMethod所对应的Controller中
        // 配置的InitBinder，用于进行参数的绑定
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        // 获取容器中全局配置的ModelAttribute和当前当前HandlerMethod所对应的Controller
        // 中配置的ModelAttribute，这些配置的方法将会在目标方法调用之前进行调用
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

        // 将handlerMethod封装为一个ServletInvocableHandlerMethod对象，
        // 该对象用于对当前request的整体调用流程进行了封装
        ServletInvocableHandlerMethod invocableMethod =
            createInvocableHandlerMethod(handlerMethod);
        if (this.argumentResolvers != null) {
            // 设置当前容器中配置的所有ArgumentResolver
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        if (this.returnValueHandlers != null) {
            // 设置当前容器中配置的所有ReturnValueHandler
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }
        // 将前面创建的WebDataBinderFactory设置到ServletInvocableHandlerMethod中
        invocableMethod.setDataBinderFactory(binderFactory);
        // 设置ParameterNameDiscoverer，该对象将按照一定的规则获取当前参数的名称
        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);

        ModelAndViewContainer mavContainer = new ModelAndViewContainer();
        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
        // 这里initModel()方法主要作用是调用前面获取到的@ModelAttribute标注的方法，
        // 从而达到@ModelAttribute标注的方法能够在目标Handler调用之前调用的目的
        modelFactory.initModel(webRequest, mavContainer, invocableMethod);
        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

        // 获取当前的AsyncWebRequest，这里AsyncWebRequest的主要作用是用于判断目标
        // handler的返回值是否为WebAsyncTask或DefferredResult，如果是这两种中的一种，
        // 则说明当前请求的处理应该是异步的。所谓的异步，指的是当前请求会将Controller中
        // 封装的业务逻辑放到一个线程池中进行调用，待该调用有返回结果之后再返回到response中。
        // 这种处理的优点在于用于请求分发的线程能够解放出来，从而处理更多的请求，只有待目标任务
        // 完成之后才会回来将该异步任务的结果返回。
        AsyncWebRequest asyncWebRequest = WebAsyncUtils
            .createAsyncWebRequest(request, response);
        asyncWebRequest.setTimeout(this.asyncRequestTimeout);

        // 封装异步任务的线程池，request和interceptors到WebAsyncManager中
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.setTaskExecutor(this.taskExecutor);
        asyncManager.setAsyncWebRequest(asyncWebRequest);
        asyncManager.registerCallableInterceptors(this.callableInterceptors);
        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

        // 这里就是用于判断当前请求是否有异步任务结果的，如果存在，则对异步任务结果进行封装
        if (asyncManager.hasConcurrentResult()) {
            Object result = asyncManager.getConcurrentResult();
            mavContainer = (ModelAndViewContainer) 
                asyncManager.getConcurrentResultContext()[0];
            asyncManager.clearConcurrentResult();
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
            }
            // 封装异步任务的处理结果，虽然封装的是一个HandlerMethod，但只是Spring简单的封装
            // 的一个Callable对象，该对象中直接将调用结果返回了。这样封装的目的在于能够统一的
            // 进行右面的ServletInvocableHandlerMethod.invokeAndHandle()方法的调用
            invocableMethod = invocableMethod.wrapConcurrentResult(result);
        }

        // 对请求参数进行处理，调用目标HandlerMethod，并且将返回值封装为一个ModelAndView对象
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
        if (asyncManager.isConcurrentHandlingStarted()) {
            return null;
        }

        // 对封装的ModelAndView进行处理，主要是判断当前请求是否进行了重定向，如果进行了重定向，
        // 还会判断是否需要将FlashAttributes封装到新的请求中
        return getModelAndView(mavContainer, modelFactory, webRequest);
    } finally {
        // 调用request destruction callbacks和对SessionAttributes进行处理
        webRequest.requestCompleted();
    }
}
</code></pre><blockquote>
<p>提示：RequestMappingHandlerAdapter处理请求的主要流程：1.获取当前容器中使用@InitBinder注解注册的属性转换器。2.获取当前容器中使用@ModelAttribute标注但是没有使用@RequestMapping标注的方法，并且在调用目标方法之前调用这些方法。3.判断目标handler返回值是否使用了WebAsync Task或DefferredResult封装，如果封装了按照异步任务的方式执行。4.处理请求参数，调用目标方法和处理返回值。</p>
</blockquote>
<pre><code>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) 
        throws Exception {
    // 判断当前缓存中是否缓存了当前bean所需要装配的InitBinder方法，如果存在，则直接从缓存中取，
    // 如果不存在，则在当前bean中进行扫描获取
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = this.initBinderCache.get(handlerType);
    if (methods == null) {
        // 在当前bean中查找所有标注了@InitBinder注解的方法，这里INIT_BINDER_METHODS就是一个
        // 选择器，表示只获取使用@InitBinder标注的方法
        methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);
        this.initBinderCache.put(handlerType, methods);
    }

    // 这里initBinderAdviceCache是在RequestMappingHandlerAdapter初始化时同步初始化的，
    // 其内包含的方法有如下两个特点：①当前方法所在类使用@ControllerAdvice进行标注了；
    // ②当前方法使用@InitBinder进行了标注。也就是说其内保存的方法可以理解为是全局类型
    // 的参数绑定方法
    List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList&lt;&gt;();
    this.initBinderAdviceCache.forEach((clazz, methodSet) -&gt; {
        // 这里判断的是当前配置的全局类型的InitBinder是否能够应用于当前bean，
        // 判断的方式主要在@ControllerAdvice注解中进行了声明，包括通过包名，类所在的包，
        // 接口或者注解的形式限定的范围
        if (clazz.isApplicableToBeanType(handlerType)) {
            Object bean = clazz.resolveBean();
            for (Method method : methodSet) {
                initBinderMethods.add(createInitBinderMethod(bean, method));
            }
        }
    });

    // 这里是将当前HandlerMethod所在bean中的InitBinder添加到需要执行的initBinderMethods中。
    // 这里从添加的顺序可以看出，全局类型的InitBinder会在当前bean中的InitBinder之前执行
    for (Method method : methods) {
        Object bean = handlerMethod.getBean();
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }

    // 将需要执行的InitBinder封装到InitBinderDataBinderFactory中
    return createDataBinderFactory(initBinderMethods);
}
</code></pre><h4 id="13-1-2-RequestMappingHandlerAdapter"><a href="#13-1-2-RequestMappingHandlerAdapter" class="headerlink" title="13.1.2 RequestMappingHandlerAdapter"></a>13.1.2 RequestMappingHandlerAdapter</h4><p><strong>1.初始化过程</strong><br><br>RequestMappingHandlerAdapter实现了InitializingBean接口，所以它的初始化入口是afterPropertiesSet方法。也就是说 RequestMappingHandlerAdapter 的创建是在 afterPropertiesSet() 方法中实现的。</p>
<blockquote>
<p>提示：handler表示Spring处理具体请求的某个Controller方法，即HandlerAdapter表示将当前请求适配到某个Handler的处理器。RequestMappingHandlerAdapter是HandlerAdapter的一个具体实现，主要用于将某个请求适配给@RequestMapping类型的Handler处理。</p>
</blockquote>
<p><strong>2.HandlerMapping接口的声明</strong><br></p>
<pre><code>public interface HandlerAdapter {
    // 用于判断当前HandlerAdapter是否能够处理当前请求
    boolean supports(Object handler);

    // 如果当前HandlerAdapter能够用于适配当前请求，那么就会处理当前请求中
    // 诸如参数和返回值等信息，以便能够直接委托给具体的Handler处理
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, 
        Object handler) throws Exception;

    // 获取当前请求的最后更改时间，主要用于供给浏览器判断当前请求是否修改过，
    // 从而判断是否可以直接使用之前缓存的结果
    long getLastModified(HttpServletRequest request, Object handler);
}
</code></pre><blockquote>
<p>属性：1.argumentResolvers 用于给处理器方法和被@ModelAttribute注解的方法设置参数。2.initBinderArgumentResolvers 用于给被@InitBinder注解的方法设置参数。3.returnValueHandlers 用于将处理器返回值处理成ModelAndView类型。</p>
</blockquote>
<pre><code>  public void afterPropertiesSet() {

    //初始化注释了 @ControllerAdvice 的类的相关属性
    initControllerAdviceCache();

    if (this.argumentResolvers == null) {
        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();
        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.initBinderArgumentResolvers == null) {
        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();
        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.returnValueHandlers == null) {
        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();
        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
    }
}
</code></pre><h2 id="13-2-RequestMappingHandlerAdapter-自身结构"><a href="#13-2-RequestMappingHandlerAdapter-自身结构" class="headerlink" title="13.2 RequestMappingHandlerAdapter 自身结构"></a>13.2 RequestMappingHandlerAdapter 自身结构</h2><h4 id="13-2-1-创建RequestMappingHandlerAdapter"><a href="#13-2-1-创建RequestMappingHandlerAdapter" class="headerlink" title="13.2.1 创建RequestMappingHandlerAdapter"></a>13.2.1 创建RequestMappingHandlerAdapter</h4><p>创建 RequestMappingHandlerAdapter 是在 afterPropertiesSet()方法中实现，内容主要是初始化 argumentResolvers | initBinderArgumentResolvers | returnValueHandlers | @ControllerAdvice注释的类相关的modelAttributeAdviceCache | initBinderAdviceCache | responseBodyAdvice 六个属性。</p>
<pre><code>1.argumentResolvers 给处理器方法和注释了@ModelAttribute的方法设置参数
2.initBinderArgumentResolvers 给注释了@initBinder的方法设置参数
3.returnValueHandlers 将处理器的返回值处理成ModelAndView的类型
4.modelAttributeAdviceCache | initBinderAdviceCache 用于缓存 @ControllerAdvice注释的类里面的注释了@ModelAttribute 和 @InitBinder 的方法。
5.responseBodyAdvice 保存 ResponseBodyAdvice 接口，可以修改返回的 ResponseBody 的类。
</code></pre><blockquote>
<p>注意：这些属性都是复数形式，可以有多个，使用的时候根据顺序调用即可。所以初始化时的顺序很重要。</p>
</blockquote>
<h4 id="13-2-2-RequestMappingHandlerAdapter之用"><a href="#13-2-2-RequestMappingHandlerAdapter之用" class="headerlink" title="13.2.2 RequestMappingHandlerAdapter之用"></a>13.2.2 RequestMappingHandlerAdapter之用</h4><p>RequestMappingHandlerAdapter 的处理请求入口方法是handleInternal。</p>
<pre><code>protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    //1.判断Handler是否有 @SessionAttribute 注释的参数
    if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
        this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
    } else {
        this.checkAndPrepare(request, response, true);
    } 

    //看代码应该是从session中获取一些信息，然后初始化header等信息
    //这块就是根据需要是否进行同步操作
    if (this.synchronizeOnSession) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized(mutex) {
                return this.invokeHandleMethod(request, response, handlerMethod);
            }
        }
    }
    //正式进入执行环节
    return this.invokeHandleMethod(request, response, handlerMethod);
}
</code></pre><blockquote>
<p>提示：这里关键的方法就是：checkAndPrepare()方法和invokeHandleMethod()方法。</p>
</blockquote>
<h2 id="13-3-ModelAndViewContainer"><a href="#13-3-ModelAndViewContainer" class="headerlink" title="13.3 ModelAndViewContainer"></a>13.3 ModelAndViewContainer</h2><p>ModelAndViewContainer承担着整个请求过程中数据的传递工作。除了保存Model和View之外还有其它的功能。它里面包含的属性有：</p>
<pre><code>1.view 视图，Object类型
2.defaultModel：默认使用的Model
3.redirectModel：redirect类型的Model
4.sessionStatus：用于设置SessionAttribute使用完的标志
5.ignoreDefaultModelOnRedirect：如果为true则在处理器返回redirect视图时一定不使用defaultModel
6.redirectModelScenario：处理器返回redirect视图的标志
7.requestHandled：请求是否已经处理完成的标志
</code></pre><h2 id="13-4-SessionAttributesHandler-和-SessionAttributeStore"><a href="#13-4-SessionAttributesHandler-和-SessionAttributeStore" class="headerlink" title="13.4 SessionAttributesHandler 和 SessionAttributeStore"></a>13.4 SessionAttributesHandler 和 SessionAttributeStore</h2><p>SessionAttributesHandler 作为处理 @SessionAttributes注释的参数，其只做宏观的事情，如：哪个Handler都可以缓存哪些参数，某个参数在当前的SessionAttribute中是否存在等。具体的存储工作交给SessionAttributeStore做，</p>
<h2 id="13-5-ModelFactory"><a href="#13-5-ModelFactory" class="headerlink" title="13.5 ModelFactory"></a>13.5 ModelFactory</h2><p>ModelFactory是用来维护Model的。两个功能：1. 初始化Model。2.处理器执行后将Model中相应参数更新到SessionAttribute。</p>
<h3 id="13-5-1-初始化Model"><a href="#13-5-1-初始化Model" class="headerlink" title="13.5.1 初始化Model"></a>13.5.1 初始化Model</h3><h2 id="13-6-ServletInvocableHandlerMethod"><a href="#13-6-ServletInvocableHandlerMethod" class="headerlink" title="13.6 ServletInvocableHandlerMethod"></a>13.6 ServletInvocableHandlerMethod</h2><p>是一种HandlerMethod，只是增加了方法执行的功能，相应地增加了参数解析、返回值处理等功能。</p>
<h3 id="13-6-1-HandlerMethod"><a href="#13-6-1-HandlerMethod" class="headerlink" title="13.6.1 HandlerMethod"></a>13.6.1 HandlerMethod</h3><h2 id="13-7-HandlerMethodArgumentResolver"><a href="#13-7-HandlerMethodArgumentResolver" class="headerlink" title="13.7 HandlerMethodArgumentResolver"></a>13.7 HandlerMethodArgumentResolver</h2><p>是为处理器解析参数的，主要用在InvocableHandlerMethod中。每个Resolver对应一种类型的参数。</p>
<h2 id="13-8-HandlerMethodReturnValueHandler"><a href="#13-8-HandlerMethodReturnValueHandler" class="headerlink" title="13.8 HandlerMethodReturnValueHandler"></a>13.8 HandlerMethodReturnValueHandler</h2><p>该处理方法用在ServletInvocableHandlerMethod中，功能：1. 将相应参数添加到Model。2. 设置View。3. 如果请求已经处理完则设置ModelAndViewContainer的requestHandled为true。</p>
<p>### </p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第13章 Spring框架的设计理念与设计模式分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第13章 Spring框架的设计理念与设计模式分析/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:53:43+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,457
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h2 id="第13章-Spring框架的设计理念与设计模式分析"><a href="#第13章-Spring框架的设计理念与设计模式分析" class="headerlink" title="第13章 Spring框架的设计理念与设计模式分析"></a>第13章 Spring框架的设计理念与设计模式分析</h2><p>[TOC]</p>
<h3 id="13-1-Spring的骨骼架构"><a href="#13-1-Spring的骨骼架构" class="headerlink" title="13.1 Spring的骨骼架构"></a>13.1 Spring的骨骼架构</h3><p>Spring的核心组件只有三种：Core | Context | Bean。其构建起整个Spring骨骼架构，没有它们就不可能有AOP | Web等上层的特性功能。</p>
<h4 id="13-1-1-Spring的设计理念"><a href="#13-1-1-Spring的设计理念" class="headerlink" title="13.1.1 Spring的设计理念"></a>13.1.1 Spring的设计理念</h4><p>Spring解决非常关键的问题，它可以让我们将对象之间的依赖关系转而用配置文件来管理，也就是依赖注入机制。而这个注入关系由Ioc容器中管理。</p>
<p>我们知道Bean包装的是Object，而Object必然有数据，而Context要解决的是数据的生存问题，发现每个Bean之间的关系。所以Context是一个Bean关系的集合，这个关系集合又叫Ioc容器。Core就是发现、建立和维护每个Bean之间的关系所需要的一些列工具。</p>
<h3 id="13-2-核心组件"><a href="#13-2-核心组件" class="headerlink" title="13.2 核心组件"></a>13.2 核心组件</h3><h4 id="13-2-1-Bean组件"><a href="#13-2-1-Bean组件" class="headerlink" title="13.2.1 Bean组件"></a>13.2.1 Bean组件</h4><p>Spring Bean的创建是典型的工厂模式，它的顶级接口是BeanFactory。BeanFactory有三个子类：1. ListableFactory 2. HierarchicalBeanFactory 3. AutowireCapacleBeanFactory。但最终的默认实现类都是 DefaultListableBeanFactory。</p>
<p>定义这么多接口的原因是因为每个接口都有其使用的场合，其主要区分在Spring对象内部对象的转换和传递过程，将对象的数据访问做限制。</p>
<pre><code>1. ListableBeanFactory 表示Bean是可列表的

2. HierarchicalBeanFactory 表示这些Bean是有继承关系的

3. Autowire.. 表示Bean的自动装配规则
</code></pre><p>Bean的定义主要有BeanDefinition描述。Bean的完整描述了在Spring配置文件中定义<bean>节点中所有的信息，包括各种子节点。</bean></p>
<blockquote>
<p>提示：Bean的解析过程就是对Spring配置文件的解析。</p>
</blockquote>
<h4 id="13-2-2-Context组件"><a href="#13-2-2-Context组件" class="headerlink" title="13.2.2 Context组件"></a>13.2.2 Context组件</h4><p>Context在Spring的 org.springframework.context 包下面。ApplicationContext是Context的顶级父类，它除了标识一个应用环境的基本信息之外，还继承了5个接口。</p>
<p>ApplicationContext继承了BeanFactory，说明了Spring容器中运行的主体对象是Bean。另外ApplicationContext继承了ResourceFactory接口，可以访问任何外部资源。</p>
<p>ApplicationContext的子类包含两个方面：</p>
<pre><code>1. ConfigurableApplicationContext 表示该Context可修改，在构建Context用户可以动态添加和修改已有的配置信息，其下面有多个子类，最常使用可更新的Context（AbstractRefreshableApplicationContext类）。

2. WebApplicationContext 表示为Web准备的Context，可以直接访问到ServletContext。
</code></pre><p>总体来说Context必须完成以下几件事情：</p>
<pre><code>1. 标识一个应用环境

2. 利用BeanFactory创建Bean对象

3. 保存对象关系表

4. 能够捕获各种事件
</code></pre><h4 id="12-2-3-Core组件"><a href="#12-2-3-Core组件" class="headerlink" title="12.2.3 Core组件"></a>12.2.3 Core组件</h4><p>Core组件是Spring的核心组件，包含了很多关键类，一个重要的组成部分是定义了资源的访问方式。</p>
<h4 id="12-2-4-Ioc容器工作过程"><a href="#12-2-4-Ioc容器工作过程" class="headerlink" title="12.2.4 Ioc容器工作过程"></a>12.2.4 Ioc容器工作过程</h4><pre><code>1. 创建BeanFacoty工厂

    Ioc容器实际上是Context组件结合其它两个组件共同构建了一个Bean关系网。 


4. Ioc容器

    我们如果需要使用Spring必须要先构建Ioc容器，没有它Spring无法工作，ApplicationContext.xml就是Ioc容器默认配置文件，Spring的所有特性功能都是基于Ioc容器工作的。
</code></pre><h3 id="13-3-Spring中AOP"><a href="#13-3-Spring中AOP" class="headerlink" title="13.3 Spring中AOP"></a>13.3 Spring中AOP</h3><h4 id="13-3-1-动态代理"><a href="#13-3-1-动态代理" class="headerlink" title="13.3.1 动态代理"></a>13.3.1 动态代理</h4><p>AOP是基于动态代理实现的。在JDK的java.lang.reflect包下有个Proxy类，是构造代理类的入口。最后一个方法newproxyInstance是创建代理对象的方法。</p>
<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h);

1. ClassLoader 用于加载代理类的Loader类，通常这个Loader类和被代理的类是同一个Loader类。

2. interfaces 被代理的那些接口

3. InvocationHandler 用于执行除了被代理类接口中方法之外的用户定义的操作，是用户需要代理的最终目的。用户调用目标方法都被代理到InvocationHandler类中定义的唯一方法invoke()中。
</code></pre><h4 id="13-3-2-Spring-AOP的实现"><a href="#13-3-2-Spring-AOP的实现" class="headerlink" title="13.3.2 Spring AOP的实现"></a>13.3.2 Spring AOP的实现</h4><p>代理的目的是调用目标方法时可以转而执行InvocationHandler类的invoke()方法，所以如何在InvocationHandler类上做文章便是实现AOP的关键所在。</p>
<p>Spring如何完成代理：</p>
<pre><code>1. 代理类继承了FactoryBean的ProxyFactoryBean，FactoryBeab之所以特别就在于它可以让我们自定义对象的创建方法。

2. Spring在创建代理对象之后，在我们调用目标对象上的方法时，都会被代理到InvocationHandler类的invok()方法中执行。
</code></pre><h3 id="13-4-设计模式之代理模式"><a href="#13-4-设计模式之代理模式" class="headerlink" title="13.4 设计模式之代理模式"></a>13.4 设计模式之代理模式</h3><h4 id="13-4-1-代理模式原理"><a href="#13-4-1-代理模式原理" class="headerlink" title="13.4.1 代理模式原理"></a>13.4.1 代理模式原理</h4><p>代理模式就是给某一个对象创建一个代理对象，由这个代理对象控制对原对象的引用，而创建此代理对象后可以在调用原对象时增加一些额外的操作。</p>
<pre><code>1. Subject 抽象主题，它是代理对象的真实对象要实现的接口

2. ProxySubject 代理类，除了实现抽象主题定义的接口外，还必须持有所代理对象的引用

3. RealSubject 被代理的类，是目标对象
</code></pre><h3 id="13-5-设计模式之策略模式"><a href="#13-5-设计模式之策略模式" class="headerlink" title="13.5 设计模式之策略模式"></a>13.5 设计模式之策略模式</h3><h4 id="13-5-1-策略模式原理"><a href="#13-5-1-策略模式原理" class="headerlink" title="13.5.1 策略模式原理"></a>13.5.1 策略模式原理</h4><p>表示完成某个操作可能有多种方法，这些方法都可能被使用到，每个实现方法都当做一个实现策略，用户可以根据场景选择合适的策略。</p>
<pre><code>1. Context 不同策略的环境，可根据自身条件选择不同的策略实现类完成所要的操作。

2. Strategy 抽象策略，定义每个策略都要实现的策略方法

3. ConcreteStrategy 具体策略实现类，实现抽象策略中定义的策略方法
</code></pre><h4 id="13-5-2-Spring中策略模式的实现"><a href="#13-5-2-Spring中策略模式的实现" class="headerlink" title="13.5.2 Spring中策略模式的实现"></a>13.5.2 Spring中策略模式的实现</h4><p>Spring中有多个地方用到了策略模式。如：Bean定义对象的创建及代理对象的创建等。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第15章 RequestToViewNameTranslator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第15章 RequestToViewNameTranslator/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:53:59+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  330
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第15章-RequestToViewNameTranslator"><a href="#第15章-RequestToViewNameTranslator" class="headerlink" title="第15章 RequestToViewNameTranslator"></a>第15章 RequestToViewNameTranslator</h1><p>RequestToViewNameTranslator能够在处理器返回的view为空时使用其根据request获取viewName。SpringMVC提供的实现类只有：DefaultRequestToViewNameTranslator。</p>
<pre><code>    public class DefaultRequestToViewNameTranslator implements RequestToViewNameTranslator {
    private static final String SLASH = &quot;/&quot;;
    private String prefix = &quot;&quot;;
    private String suffix = &quot;&quot;;

    //该属性表示：如果其值与Slash不同则用于替换原来的分隔符Slash
    private String separator = &quot;/&quot;;

    //该属性表示：如果前面的字符为Slash是否将其去掉
    private boolean stripLeadingSlash = true;

    //该属性表示：如果最后一个字符为Slash是否将其去掉
    private boolean stripTrailingSlash = true;

    //该属性表示：是否需要去掉扩展名
    private boolean stripExtension = true;

    private UrlPathHelper urlPathHelper = new UrlPathHelper();

    //这里分别添加了前缀和后缀
    public String getViewName(HttpServletRequest request) {
        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
        return this.prefix + this.transformPath(lookupPath) + this.suffix;
    }
    //这里处理分隔符“，&quot;,“/&quot;
    @Nullable
    protected String transformPath(String lookupPath) {
        String path = lookupPath;
        if (this.stripLeadingSlash &amp;&amp; lookupPath.startsWith(&quot;/&quot;)) {
            path = lookupPath.substring(1);
        }

        if (this.stripTrailingSlash &amp;&amp; path.endsWith(&quot;/&quot;)) {
            path = path.substring(0, path.length() - 1);
        }

        if (this.stripExtension) {
            path = StringUtils.stripFilenameExtension(path);
        }

        if (!&quot;/&quot;.equals(this.separator)) {
            path = StringUtils.replace(path, &quot;/&quot;, this.separator);
        }

        return path;
    }
}
</code></pre><h4 id="UrlPathHelper属性参数"><a href="#UrlPathHelper属性参数" class="headerlink" title="UrlPathHelper属性参数"></a>UrlPathHelper属性参数</h4><pre><code>1.urlDecode：设置url是否需要编码，一般默认
2.removeSemicolonContent：设置是否删除url中与分号相关的内容
3.alwaysUseFullPath：设置是否总是使用完整路径
</code></pre><blockquote>
<p>提示：因为urlPathHelper是用于处理url的工具，所以参数一般默认即可。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第14章 ViewResolver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第14章 ViewResolver/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:53:52+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,482
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第14章-ViewResolver"><a href="#第14章-ViewResolver" class="headerlink" title="第14章 ViewResolver"></a>第14章 ViewResolver</h1><p>ViewResolver主要的作用是根据视图名和Locale解析出视图，解析过程主要做两件事：解析出使用的模板和视图的类型。SpringMVC中的ViewResolver主要分为四大类：1.AbstractCachingViewResolver | 2.BeanNameViewResolver | 3.ContentNegotiatingViewResolver | 4.ViewResolverComposite 。其中在后面的三个只有一个实现类。</p>
<pre><code>1.BeanNameViewResolver：通过beanName从SpringMVC容器中查找。
2.ViewResolverComposite：该类封装着多个ViewResolver的容器，解析视图时遍历封装着的ViewResolver具体解析。在ViewResolverComposite遍历成员解析视图的同时还给成员初始化。其中包括对实现了ApplicationContextAware接口的ViewResolver设置ApplicationContext、是给实现了ServletContextAware接口的ViewResolver设置ServletContext以及对实现了InitializingBean接口的ViewResolver调用afterPropertiesSet方法。

    public class ViewResolverComposite implements ViewResolver, Ordered, InitializingBean, ApplicationContextAware, ServletContextAware {
        private final List&lt;ViewResolver&gt; viewResolvers = new ArrayList();
        private int order = 2147483647;

        public ViewResolverComposite() {
        }

        public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {
            this.viewResolvers.clear();
            if (!CollectionUtils.isEmpty(viewResolvers)) {
                this.viewResolvers.addAll(viewResolvers);
            }

        }

        public List&lt;ViewResolver&gt; getViewResolvers() {
            return Collections.unmodifiableList(this.viewResolvers);
        }

        public void setOrder(int order) {
            this.order = order;
        }

        public int getOrder() {
            return this.order;
        }

        public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
            Iterator var2 = this.viewResolvers.iterator();

            while(var2.hasNext()) {
                ViewResolver viewResolver = (ViewResolver)var2.next();
                if (viewResolver instanceof ApplicationContextAware) {
                    ((ApplicationContextAware)viewResolver).setApplicationContext(applicationContext);
                }
            }

        }

        public void setServletContext(ServletContext servletContext) {
            Iterator var2 = this.viewResolvers.iterator();

            while(var2.hasNext()) {
                ViewResolver viewResolver = (ViewResolver)var2.next();
                if (viewResolver instanceof ServletContextAware) {
                    ((ServletContextAware)viewResolver).setServletContext(servletContext);
                }
            }

        }

        public void afterPropertiesSet() throws Exception {
            Iterator var1 = this.viewResolvers.iterator();

            while(var1.hasNext()) {
                ViewResolver viewResolver = (ViewResolver)var1.next();
                if (viewResolver instanceof InitializingBean) {
                    ((InitializingBean)viewResolver).afterPropertiesSet();
                }
            }

        }

        //主要是这个方法用来解析View的
        @Nullable
        public View resolveViewName(String viewName, Locale locale) throws Exception {
            Iterator var3 = this.viewResolvers.iterator();

            View view;
            do {
                if (!var3.hasNext()) {
                    return null;
                }

                ViewResolver viewResolver = (ViewResolver)var3.next();
                view = viewResolver.resolveViewName(viewName, locale);
            } while(view == null);

            return view;
        }
    }
</code></pre><blockquote>
<p>总结：这里它真正的解析过程就是最后一个方法 resolveViewName()。其它方法都是给所包含的ViewResolver做初始化。</p>
</blockquote>
<h2 id="14-1-ContentNegotiatingViewResolver"><a href="#14-1-ContentNegotiatingViewResolver" class="headerlink" title="14.1 ContentNegotiatingViewResolver"></a>14.1 ContentNegotiatingViewResolver</h2><p>该解析器的作用是在别的解析器解析的结果上增加了对MediaType(Content-Type 媒体类型)和后缀支持。对视图的解析不是其本身完成的，而是通过封装的ViewResolver来进行的。</p>
<blockquote>
<p>整个过程是：1.首先遍历所封装的ViewResolver具体视图，这里可能会解析出多个视图。2.然后使用request获取MediaType，可能也是多个结果。3.最后将这两个结果进行匹配查找出最优的视图。</p>
</blockquote>
<blockquote>
<p>属性ViewResolver的两种初始化方式：1.手动设置，不在Spring容器中，则会对它初始化。2.如果没有设置则自动获取Spring容器中除它自己外的所有ViewResolver并设置到ViewResolver中。</p>
</blockquote>
<h4 id="1-initServletContext"><a href="#1-initServletContext" class="headerlink" title="1.initServletContext"></a>1.initServletContext</h4><pre><code> protected void initServletContext(ServletContext servletContext) {
    //获取容器中所有的ViewResolver类型的bean，是整个spring容器，而不仅仅是springMVC获取的
    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
    ViewResolver viewResolver;

    //如果没有手动注册则将容器中找到的ViewResolver设置给ViewResolvers
    if (this.viewResolvers == null) {
        this.viewResolvers = new ArrayList(matchingBeans.size());
        Iterator var3 = matchingBeans.iterator();

        while(var3.hasNext()) {
            viewResolver = (ViewResolver)var3.next();
            if (this != viewResolver) {
                this.viewResolvers.add(viewResolver);
            }
        }
    } else {
         //如果是手动注册，但是容器中不存在，则进行初始化
        for(int i = 0; i &lt; this.viewResolvers.size(); ++i) {
            viewResolver = (ViewResolver)this.viewResolvers.get(i);
            if (!matchingBeans.contains(viewResolver)) {
                String name = viewResolver.getClass().getName() + i;
                this.obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(viewResolver, name);
            }
        }
    }

    if (this.viewResolvers.isEmpty()) {
        this.logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);
    }
    //按照Order属性进行排序
    AnnotationAwareOrderComparator.sort(this.viewResolvers);
    this.cnmFactoryBean.setServletContext(servletContext);
}
</code></pre><h4 id="2-resolveViewName-解析视图的方法"><a href="#2-resolveViewName-解析视图的方法" class="headerlink" title="2.resolveViewName 解析视图的方法"></a>2.resolveViewName 解析视图的方法</h4><pre><code>@Nullable
public View resolveViewName(String viewName, Locale locale) throws Exception {
    //使用RequestContextHolder获取RequestAttribute，进而获取request
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
    //通过request获取MediaType,用作需要满足的条件
    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) {
        //获取所有的候选视图，内部通过遍历封装的viewResolver来解析
        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
        //从多个候选视图中选出最好的一个
        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
        if (bestView != null) {
            return bestView;
        }
    }

    if (this.useNotAcceptableStatusCode) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);
        }

        return NOT_ACCEPTABLE_VIEW;
    } else {
        this.logger.debug(&quot;No acceptable view found; returning null&quot;);
        return null;
    }
}
</code></pre><blockquote>
<p>总结：这里整个过程是：1.首先使用request获取MediaType作为需要满足的条件。2.然后使用viewResolver解析出多个候选视图。3.最后将两者进行匹配找出最优视图。</p>
</blockquote>
<h4 id="3-getCandidateView-获取候选视图"><a href="#3-getCandidateView-获取候选视图" class="headerlink" title="3.getCandidateView() 获取候选视图"></a>3.getCandidateView() 获取候选视图</h4><blockquote>
<p>总结：获取候选视图逻辑：1.遍历viewResolver进行视图解析，同时将所有解析出的结果添加到候选视图。2.然后判断有没有设置默认视图，如果有责将其添加到候选视图。同时这里不仅使用逻辑视图进行解析，而且还使用了通过遍历requestedMediaTypes获取到所对应的后缀，然后添加到逻辑视图后面作为新的视图名进行解析。</p>
</blockquote>
<h4 id="4-getBestView-获取最优视图"><a href="#4-getBestView-获取最优视图" class="headerlink" title="4.getBestView() 获取最优视图"></a>4.getBestView() 获取最优视图</h4><pre><code>private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes, RequestAttributes attrs) {
    Iterator var4 = candidateViews.iterator();
    //判断候选视图中有没有redirect视图，如果有直接返回
    while(var4.hasNext()) {
        View candidateView = (View)var4.next();
        if (candidateView instanceof SmartView) {
            SmartView smartView = (SmartView)candidateView;
            if (smartView.isRedirectView()) {
                if (this.logger.isDebugEnabled()) {
                    this.logger.debug(&quot;Returning redirect view [&quot; + candidateView + &quot;]&quot;);
                }

                return candidateView;
            }
        }
    }

    var4 = requestedMediaTypes.iterator();

    while(var4.hasNext()) {
        MediaType mediaType = (MediaType)var4.next();
        Iterator var10 = candidateViews.iterator();

        while(var10.hasNext()) {
            View candidateView = (View)var10.next();
            if (StringUtils.hasText(candidateView.getContentType())) {
                //根据候选视图获取对应的MediaType
                MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());
                //判断当前MediaType是否支持从候选视图获取对应的MediaType,如text/*可以支持test/html,text/css,text/xml等所有的text类型
                if (mediaType.isCompatibleWith(candidateContentType)) {
                    if (this.logger.isDebugEnabled()) {
                        this.logger.debug(&quot;Returning [&quot; + candidateView + &quot;] based on requested media type &apos;&quot; + mediaType + &quot;&apos;&quot;);
                    }

                    attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, 0);
                    return candidateView;
                }
            }
        }
    }

    return null;
}
</code></pre><blockquote>
<p>总结：1.首先判断候选视图中有没有redirect视图，如果有则直接返回，否则同时遍历从request中获取的requestMediaTypes和解析出的候选逻辑视图candidateViews。2.然后根据候选视图获取对应的MediaType，同时使用当前的requestedMediaType对其进行判断，如果支持则将所有的requestedMediaType添加到request的Attribute中，以便在视图渲染过程中使用，并将当前视图返回。</p>
</blockquote>
<h2 id="14-2-AbstractCachingViewResolver-系列"><a href="#14-2-AbstractCachingViewResolver-系列" class="headerlink" title="14.2 AbstractCachingViewResolver 系列"></a>14.2 AbstractCachingViewResolver 系列</h2><h3 id="14-2-1-AbstractCachingViewResolver解析视图"><a href="#14-2-1-AbstractCachingViewResolver解析视图" class="headerlink" title="14.2.1 AbstractCachingViewResolver解析视图"></a>14.2.1 AbstractCachingViewResolver解析视图</h3><p>该解析器提供统一的缓存功能，当视图被解析过一次就缓存起来，直到缓存被删除前视图的解析都会自动从缓存中获取。它的直接继承有三个类：</p>
<pre><code>1.ResourceBundleViewResolver：通过使用properties属性配置文件解析视图。

2.XmlViewResolver：通过使用xml属性配置文件解析视图。

3.UrlBasedViewResolver：所有直接将逻辑视图作为url查找模板文件的ViewResolver的基类，这个类设置了统一的查找模板的规则，它的子类只需要确定渲染方式就可以确定视图类型，它的每一个子类都对应一种视图类型。
</code></pre><blockquote>
<p>提示：前两种解析器的原理：1.首先根据Locale将相应的配置文件初始化到BeanFactory。2.然后直接将逻辑视图作为beanName到factory里查找。两者的loadView程序一样。</p>
</blockquote>
<pre><code>protected View loadView(String viewName, Locale locale) throws BeansException {
    BeanFactory factory = initFactory();
    try{
        return factory.getBean(viewName, View.class);
    }catch(NoSuchBeanDefinitionException ex){
        return null;
    }
}
</code></pre><h4 id="1-AbstractCachingViewResolver解析视图过程"><a href="#1-AbstractCachingViewResolver解析视图过程" class="headerlink" title="1.AbstractCachingViewResolver解析视图过程"></a>1.AbstractCachingViewResolver解析视图过程</h4><pre><code>public View resolveViewName(String viewName, Locale locale) throws Exception {
    //是否有缓存
    if (!this.isCache()) {
        //实际创建视图
        return this.createView(viewName, locale);
    } else {
        Object cacheKey = this.getCacheKey(viewName, locale);
        //这里是通过concurrentHashMap的容器中获取的缓存
        View view = (View)this.viewAccessCache.get(cacheKey);
        if (view == null) {
            Map var5 = this.viewCreationCache;
            synchronized(this.viewCreationCache) {
                view = (View)this.viewCreationCache.get(cacheKey);
                if (view == null) {
                    //创建视图
                    view = this.createView(viewName, locale);
                    if (view == null &amp;&amp; this.cacheUnresolved) {
                        view = UNRESOLVED_VIEW;
                    }

                    if (view != null) {
                        //这里同时在创建视图后存入缓存中，这里放到两个容器中了
                        this.viewAccessCache.put(cacheKey, view);
                        this.viewCreationCache.put(cacheKey, view);
                        if (this.logger.isTraceEnabled()) {
                            this.logger.trace(&quot;Cached view [&quot; + cacheKey + &quot;]&quot;);
                        }
                    }
                }
            }
        }

        return view != UNRESOLVED_VIEW ? view : null;
    }
}

@Nullable
protected View createView(String viewName, Locale locale) throws Exception {
    return this.loadView(viewName, locale);
}
//这是一个模板方法由子类实现
@Nullable
protected abstract View loadView(String var1, Locale var2) throws Exception;
</code></pre><blockquote>
<p>总结：1.首先判断是否开启缓存功能，如果没有开启则直接调用createView()创建视图，否则检查是否已经存在缓存中。如果存在则直接获取返回，否则使用createView创建一个。2.然后保存到缓存中返回。</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示：在createView()方法内部直接调用了loadView()方法，loadView()方法是模板方法，留给子类实际创建视图，是子类解析视图的入口方法。</p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：该AbstractCachingViewResolver中有一个cacheLimit参数，是用来设置最大缓存数，设置为0表不启用缓存。设置为正数表示最多可以缓存视图的数量。</p>
</blockquote>
<h3 id="14-2-2-UrlBasedViewResolver"><a href="#14-2-2-UrlBasedViewResolver" class="headerlink" title="14.2.2 UrlBasedViewResolver"></a>14.2.2 UrlBasedViewResolver</h3><p>在该解析器中重写了父类的 getCacheKey | createView | loadView三个方法。</p>
<pre><code>1.getCacheKey()：该方法直接返回viewName 和原来父类的返回viewName+“_”+locale相比，子类覆盖而没有使用locale，说明这个UrlBasedViewResolver并没有使用Locale，只是用viewName。

2.createView()：该方法首先检查是否可以解析传入的逻辑视图，如果不可以则返回null，然后让别的ViewResolver解析，接着分别检查是不是redirect或者forward视图，如果是则返回相应的视图，如果不是则交给父类的createView，父类中又调用loadView。

    protected View createView(String viewName, Locale locale) throws Exception {
        //检查是否支持此逻辑视图，可以配置支持的模板
        if (!this.canHandle(viewName, locale)) {
            return null;
        } else {
            String forwardUrl;
            //检查是不是redirect视图
            if (viewName.startsWith(&quot;redirect:&quot;)) {
                forwardUrl = viewName.substring(&quot;redirect:&quot;.length());
                RedirectView view = new RedirectView(forwardUrl, this.isRedirectContextRelative(), this.isRedirectHttp10Compatible());
                String[] hosts = this.getRedirectHosts();
                if (hosts != null) {
                    view.setHosts(hosts);
                }

                return this.applyLifecycleMethods(viewName, view);
            //检查是不是forward视图
            } else if (viewName.startsWith(&quot;forward:&quot;)) {
                forwardUrl = viewName.substring(&quot;forward:&quot;.length());
                return new InternalResourceView(forwardUrl);
            } else {
                //如果都不是则调用父类的createView，也就会调用loadView()方法
                return super.createView(viewName, locale);
            }
        }
    }

3.检查是否支持传入的逻辑视图和传入的逻辑视图是redirect和forward视图的功能。这里使用canHandle()方法检查，它通过配置的viewName属性检查，这里如果没有配置则可以解析所有逻辑视图，如果已经配置则按照配置的模式检查。

    //canHandle()方法
    protected boolean canHandle(String viewName, Locale locale) {
        String[] viewNames = getViewNames();
        return (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));
    }

    //loadView()方法
    protected View loadView(String viewName, Locale locale) throws Exception {
        //1.创建view
        AbstractUrlBasedView view = buildView(viewName);

        //2.使用applyLifecycleMethods()方法对创建的view初始化
        View result = applyLifecycleMethods(viewName, view);

        //3.检查view对应的模板是否存在，如果存在则将初始化视图返回
        return (View.checkResource(locale) ? result : null);
    }

    private View applyLifecycleMethods(String viewName, AbstractView view) {
        return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName);
    }

4.buildView()方法，它的作用是具体创建View。

    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        //这里viewClass可以在子类通过setViewClass()方法重新设置viewClass类型。
        Class&lt;?&gt; viewClass = this.getViewClass();
        Assert.state(viewClass != null, &quot;No view class&quot;);

        AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(viewClass);

        //这里给viewName加上前缀和后缀，可以通过配置设置
        view.setUrl(this.getPrefix() + viewName + this.getSuffix());

        String contentType = this.getContentType();
        if (contentType != null) {
            //contentType不为空设置给view
            view.setContentType(contentType);
        }

        view.setRequestContextAttribute(this.getRequestContextAttribute());
        view.setAttributesMap(this.getAttributesMap());
        Boolean exposePathVariables = this.getExposePathVariables();
        if (exposePathVariables != null) {
            //这个表示让view使用PathVariables,可以在ViewResolver中设置，PathVariable就是处理器中@PathVariables注释的参数
            view.setExposePathVariables(exposePathVariables);
        }

        Boolean exposeContextBeansAsAttributes = this.getExposeContextBeansAsAttributes();
        if (exposeContextBeansAsAttributes != null) {
            //这个不为空的时候设置给view，表示让view使用容器中注册的bean，此参数可以在ViewResolver中配置
            view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
        }

        String[] exposedContextBeanNames = this.getExposedContextBeanNames();
        if (exposedContextBeanNames != null) {
            //这个不为空的时候设置给view，表示让view使用容器中注册的bean，此参数可以在ViewResolver中配置
            view.setExposedContextBeanNames(exposedContextBeanNames);
        }
        return view;
    }


    public void setViewClass(@Nullable Class&lt;?&gt; viewClass) {
        if (viewClass != null &amp;&amp; !this.requiredViewClass().isAssignableFrom(viewClass)) {
            throw new IllegalArgumentException(&quot;Given view class [&quot; + viewClass.getName() + &quot;] is not of type [&quot; + this.requiredViewClass().getName() + &quot;]&quot;);
        } else {
            this.viewClass = viewClass;
        }
    }

    @Nullable
    protected Class&lt;?&gt; getViewClass() {
        return this.viewClass;
    }

    protected Class&lt;?&gt; requiredViewClass() {
        return AbstractUrlBasedView.class;
    }
</code></pre><blockquote>
<p>总结：这里我们知道UrlBasedViewResolver的子类主要的三件事情：1.通过重写 requiredViewClass()方法修改必须符合的视图类型的值。2.使用setViewClass()方法设置所用的视图类型。3.给创建出来的视图设置一些属性。</p>
</blockquote>
<h3 id="14-2-3-InternalResourceViewResolver和FreeMarkerViewResolver"><a href="#14-2-3-InternalResourceViewResolver和FreeMarkerViewResolver" class="headerlink" title="14.2.3 InternalResourceViewResolver和FreeMarkerViewResolver"></a>14.2.3 InternalResourceViewResolver和FreeMarkerViewResolver</h3><p>InternalResourceViewResolver和FreeMarkerViewResolver两个解析器，前面的解析器是用来解析JSP的，后面的解析器是用来解析freemarker视图的。</p>
<h4 id="1-InternalResourceViewResolver"><a href="#1-InternalResourceViewResolver" class="headerlink" title="1.InternalResourceViewResolver"></a>1.InternalResourceViewResolver</h4><pre><code>public class InternalResourceViewResolver extends UrlBasedViewResolver {
    private static final boolean jstlPresent = ClassUtils.isPresent(&quot;javax.servlet.jsp.jstl.core.Config&quot;, InternalResourceViewResolver.class.getClassLoader());
    @Nullable
    private Boolean alwaysInclude;
    //这里如果类型是jstlPresent，viewClass会使用JstlView.class
    public InternalResourceViewResolver() {
        Class&lt;?&gt; viewClass = this.requiredViewClass();
        if (InternalResourceView.class == viewClass &amp;&amp; jstlPresent) {
            viewClass = JstlView.class;
        }

        this.setViewClass(viewClass);
    }

    public InternalResourceViewResolver(String prefix, String suffix) {
        this();
        this.setPrefix(prefix);
        this.setSuffix(suffix);
    }
    //返回的类型是InternalResourceView  
    protected Class&lt;?&gt; requiredViewClass() {
        return InternalResourceView.class;
    }

    public void setAlwaysInclude(boolean alwaysInclude) {
        this.alwaysInclude = alwaysInclude;
    }
    //新添加了alwaysInclude属性
    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        InternalResourceView view = (InternalResourceView)super.buildView(viewName);
        //这个表示是否在使用forward的情况下也强制使用include，默认是false，可以在注册解析器时配置
        if (this.alwaysInclude != null) {
            view.setAlwaysInclude(this.alwaysInclude);
        }
        //用于阻止循环调用，也就是请求处理完成后又转发回了原来使用的处理器的情况
        view.setPreventDispatchLoop(true);
        return view;
    }
}
</code></pre><h4 id="2-FreeMarkerViewResolver"><a href="#2-FreeMarkerViewResolver" class="headerlink" title="2.FreeMarkerViewResolver"></a>2.FreeMarkerViewResolver</h4><pre><code>public class AbstractTemplateViewResolver extends UrlBasedViewResolver {
    private boolean exposeRequestAttributes = false;
    private boolean allowRequestOverride = false;
    private boolean exposeSessionAttributes = false;
    private boolean allowSessionOverride = false;
    private boolean exposeSpringMacroHelpers = true; 
    //...setter和getter方法

   protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        AbstractTemplateView view = (AbstractTemplateView)super.buildView(viewName);
        //是否将requestAttributes暴露给view，默认为false
        view.setExposeRequestAttributes(this.exposeRequestAttributes);
        //当requestAttributes中存在Model中同名的参数，是否允许将Model中的值覆盖，默认false
        view.setAllowRequestOverride(this.allowRequestOverride);
        //是否将SessionAttribute暴露给view使用，默认是false
        view.setExposeSessionAttributes(this.exposeSessionAttributes);
        //当SessionAttributes中存在Model中同名的参数，是否使用requestAttributes的值将Model中的覆盖，默认false
        view.setAllowSessionOverride(this.allowSessionOverride);
        view.setExposeSpringMacroHelpers(this.exposeSpringMacroHelpers);
        return view;
    }
}

//在这里只需要覆盖requiredViewClass()方法就返回FreeMakerView类型
public class FreeMarkerViewResolver extends AbstractTemplateViewResolver {
    public FreeMarkerViewResolver() {
        this.setViewClass(this.requiredViewClass());
    }

    public FreeMarkerViewResolver(String prefix, String suffix) {
        this();
        this.setPrefix(prefix);
        this.setSuffix(suffix);
    }

    protected Class&lt;?&gt; requiredViewClass() {
        return FreeMarkerView.class;
    }
}
</code></pre><blockquote>
<p>总结：大部分实现类都是继承AbstractCachingViewResolver，它提供了对解析结果进行缓存的统一解决方法，它的子类中ResourceBundlerViewResolver和XmlViewResolver分别通过properties和xml配置文件进行解析。UrlBasedViewResolver将viewName添加前后缀用作url，它的子类只需要提供视图类型就可以了。解析视图的核心工作是查找模板文件和视图类型，而查找的主要参数只有viewName，这里有三种解析思路：</p>
</blockquote>
<pre><code>1.使用viewName查找模板文件：对应URLBasedViewResolver
2.使用viewName查找视图类型：对应BeanNameViewResolver
3.使用viewName同时查找视图类型和模板文件：对应ResourceBundlerViewResolver和XmlViewResolver
</code></pre>
          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第17章 MultipartResolver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第17章 MultipartResolver/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:54:12+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  330
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第17章-MultipartResolver"><a href="#第17章-MultipartResolver" class="headerlink" title="第17章 MultipartResolver"></a>第17章 MultipartResolver</h1><p>该组件有两个实现类：StandardServletMultipartResolver 和 CommonsMultipartResolver。前者使用Servlet3.0标准上传方式，后者使用Apache的commons-fileupload。</p>
<h2 id="StandardServletMultipartResolver"><a href="#StandardServletMultipartResolver" class="headerlink" title="StandardServletMultipartResolver"></a>StandardServletMultipartResolver</h2><p>该方法使用Servlet 3.0 标准的上传方式。在该方式下只需要调用request的getParts()方法就可以获取所有上传的文件。如果是单个的：request.getPart(fileName)。然后调用它到write(saveFileName)方法就能够将文件保存以saveFileName为文件名的文件。</p>
<p>该方法判断请求是否是上传请求：1.在isMultipart()方法中判断是否是post请求，如果是则再检查contentType是否是以”multipart/开头，如果是则判断该请求是上传请求。</p>
<h2 id="CommonsMultipartResolver"><a href="#CommonsMultipartResolver" class="headerlink" title="CommonsMultipartResolver"></a>CommonsMultipartResolver</h2><p>该方法使用commons-fileupload来完成具体的上传操作。在CommonsMultipartResolver中判断是否是上传请求：isMultipart()，这将交给commons-fileupload的ServletFileUpload类完成。</p>
<pre><code>public boolean isMultipart(HttpServletRequest request){
    return (request != null &amp;&amp; ServletFileUpload.isMultipartContent(request));
}
</code></pre><p>CommonsMultipartResolver中实际处理request的方法是：resolveMultipart()</p>
<pre><code>public MultipartHttpServletRequest resolveMultipart(final HttpServletRequest request) throws MultipartException{
    Assert.notNull(request, &quot;request不能为空&quot;);
    if(this.resolveLazily){
        return new DefaultMultipartHttpServletRequest(request){
            @Override
            protected void initializeMultipart(){
                ...
            }
        }
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MultipartResolver的作用是将上传请求包装成可以直接获取File的request。所以此重点是从request中解析出上传的文件并设置到相应的上传类型request中。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第16章 HandlerExceptionResolver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第16章 HandlerExceptionResolver/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:54:05+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,859
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第16章-HandlerExceptionResolver"><a href="#第16章-HandlerExceptionResolver" class="headerlink" title="第16章 HandlerExceptionResolver"></a>第16章 HandlerExceptionResolver</h1><p>HandlerExceptionResolver主要实现都继承与抽象类的AbstractHandlerExecutionResolver，它有五个子类，其中AnnotationMethodHandlerExceptionResolver已经被弃用。</p>
<pre><code>1.AbstractHandlerMethodExceptionResolver和其子类ExceptionHandlerExcpetionResolver一起完成 @ExceptionHandler 注释的方法进行异常解析的功能。

2.DefaultHandlerExceptionResolver按照不同类型分别对异常进行解析。

3.ResponseStatusExceptionResolver解析@ResponseStatus注释类型的异常。

4.SimpleMappingExceptionResolver：通过配置的异常类和view的对应关系解析异常。

5.HandlerExecutionResolverComposite作为一个容器使用，里面封装了别的Resolver。
</code></pre><blockquote>
<p>提示：异常解析的过程是：1.给ModelAndView设置相应的内容，设置response的相关属性。</p>
</blockquote>
<h2 id="16-1-AbstractHandlerExceptionResolver"><a href="#16-1-AbstractHandlerExceptionResolver" class="headerlink" title="16.1 AbstractHandlerExceptionResolver"></a>16.1 AbstractHandlerExceptionResolver</h2><p>该类是所有直接解析异常类的父类，在里面定义了通用的解析流程，并使用模板模式，子类只需要覆盖相应的方法即可。</p>
<pre><code>@Nullable
public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    //判断当前ExceptionResolver是否可以解析所传入处理器抛出的异常，这里可以指定只能处理指定的处理器抛出的异常。如果不可以返回null，交给下一个解析
    if (this.shouldApplyTo(request, handler)) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Resolving exception from handler [&quot; + handler + &quot;]: &quot; + ex);
        }
        //设置response
        this.prepareResponse(ex, response);
        //调用这个实际解析异常，这是模板方法交给子类实现
        ModelAndView result = this.doResolveException(request, response, handler, ex);
        if (result != null) {
            this.logException(ex, request);
        }

        return result;
    } else {
        return null;
    }
}

protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler{
    //这里的mappedHandlers用于配置处理器的集合，mappedHandlerClasses用于配置处理器类型的集合，如果设置了这两个属性的一个，那么ExceptionResolver就只能解析所设置的处理器抛出的异常    
    if (handler != null) {
        if (this.mappedHandlers != null &amp;&amp; this.mappedHandlers.contains(handler)) {
            return true;
        }

        if (this.mappedHandlerClasses != null) {
            Class[] var3 = this.mappedHandlerClasses;
            int var4 = var3.length;

            for(int var5 = 0; var5 &lt; var4; ++var5) {
                Class&lt;?&gt; handlerClass = var3[var5];
                if (handlerClass.isInstance(handler)) {
                    return true;
                }
            }
        }
    }

    return this.mappedHandlers == null &amp;&amp; this.mappedHandlerClasses == null;
}
</code></pre><h2 id="16-2-ExceptionHandlerExceptionResolver"><a href="#16-2-ExceptionHandlerExceptionResolver" class="headerlink" title="16.2 ExceptionHandlerExceptionResolver"></a>16.2 ExceptionHandlerExceptionResolver</h2><p>这个类继承AbstractHandlerMethodExceptionResolver，后者又继承于AbstractHandlerMethodExceptionResolver重写了shouldApplyTo方法，并且在处理请求的doResolverException方法中将实际处理请求的过程交给了模板方法doResolveHanlerMethodException。</p>
<blockquote>
<p>提示：AbstractHandlerMethodExceptionResolver作用相当于适配器。一般的处理器是类的形式，但HandlerMethod是将方法作为处理器使用，所以需要适配。1.首先在shouldApplyTo()中判断如果处理器是HandlerMethod类型则将处理器设置为其所在类，然后再交给父类判断。如果为空则直接交给父类判断。如果既不为空也不是HandlerMethod类型则返回false不处理。</p>
</blockquote>
<p>ExceptionHandlerExceptionResolver其实是一个简化版的RequestMappingHandlerAdapter，它的执行也是使用ServletInvocableHandlerMethod。1.首先根据handlerMethod和exception将其创建出来（找出所有注释了@ExceptionHandler的方法，然后根据其配置中的异常和需要解析的异常进行匹配）。2.然后设置argumentResolver和returnValueHandlers。3.接着调用其invokeAndHandle()方法执行处理。4.最后将处理结果封装成ModelAndView返回。</p>
<pre><code>@Nullable
protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) {
    //找到处理异常的方法
    ServletInvocableHandlerMethod exceptionHandlerMethod = this.getExceptionHandlerMethod(handlerMethod, exception);
    if (exceptionHandlerMethod == null) {
        return null;
    } else {
         //设置argumentResolvers和returnValueHandlers
        if (this.argumentResolvers != null) {
            exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }

        if (this.returnValueHandlers != null) {
            exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }

        ServletWebRequest webRequest = new ServletWebRequest(request, response);
        ModelAndViewContainer mavContainer = new ModelAndViewContainer();

        try {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&quot;Invoking @ExceptionHandler method: &quot; + exceptionHandlerMethod);
            }

            Throwable cause = exception.getCause();
            if (cause != null) {
                //执行解析异常
                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, new Object[]{exception, cause, handlerMethod});
            } else {
                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, new Object[]{exception, handlerMethod});
            }
        } catch (Throwable var12) {
            if (var12 != exception &amp;&amp; this.logger.isWarnEnabled()) {
                this.logger.warn(&quot;Failed to invoke @ExceptionHandler method: &quot; + exceptionHandlerMethod, var12);
            }

            return null;
        }

        if (mavContainer.isRequestHandled()) {
            return new ModelAndView();
        } else {
            //封装ModelAndView 
            ModelMap model = mavContainer.getModel();
            HttpStatus status = mavContainer.getStatus();
            ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);
            mav.setViewName(mavContainer.getViewName());
            if (!mavContainer.isViewReference()) {
                mav.setView((View)mavContainer.getView());
            }

            if (model instanceof RedirectAttributes) {
                Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes)model).getFlashAttributes();
                RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
            }

            return mav;
        }
    }
}
</code></pre><blockquote>
<p>注意：这里只是返回了ModelAndView，并没有对response进行设置。如果需要可以自行在异常处理器中设置。</p>
</blockquote>
<h2 id="16-3-DefaultHandlerExceptionResolver"><a href="#16-3-DefaultHandlerExceptionResolver" class="headerlink" title="## 16.3 DefaultHandlerExceptionResolver"></a>## 16.3 DefaultHandlerExceptionResolver</h2><p>该解析器的解析过程是根据异常类型的不同，使用不同的方法进行处理。</p>
<pre><code>@Nullable
protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    try {
        if (ex instanceof HttpRequestMethodNotSupportedException) {
            return this.handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException)ex, request, response, handler);
        }

        if (ex instanceof HttpMediaTypeNotSupportedException) {
            return this.handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException)ex, request, response, handler);
        }

        if (ex instanceof HttpMediaTypeNotAcceptableException) {
            return this.handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException)ex, request, response, handler);
        }

        if (ex instanceof MissingPathVariableException) {
            return this.handleMissingPathVariable((MissingPathVariableException)ex, request, response, handler);
        }

        if (ex instanceof MissingServletRequestParameterException) {
            return this.handleMissingServletRequestParameter((MissingServletRequestParameterException)ex, request, response, handler);
        }

        if (ex instanceof ServletRequestBindingException) {
            return this.handleServletRequestBindingException((ServletRequestBindingException)ex, request, response, handler);
        }

        if (ex instanceof ConversionNotSupportedException) {
            return this.handleConversionNotSupported((ConversionNotSupportedException)ex, request, response, handler);
        }

        if (ex instanceof TypeMismatchException) {
            return this.handleTypeMismatch((TypeMismatchException)ex, request, response, handler);
        }

        if (ex instanceof HttpMessageNotReadableException) {
            return this.handleHttpMessageNotReadable((HttpMessageNotReadableException)ex, request, response, handler);
        }

        if (ex instanceof HttpMessageNotWritableException) {
            return this.handleHttpMessageNotWritable((HttpMessageNotWritableException)ex, request, response, handler);
        }

        if (ex instanceof MethodArgumentNotValidException) {
            return this.handleMethodArgumentNotValidException((MethodArgumentNotValidException)ex, request, response, handler);
        }

        if (ex instanceof MissingServletRequestPartException) {
            return this.handleMissingServletRequestPartException((MissingServletRequestPartException)ex, request, response, handler);
        }

        if (ex instanceof BindException) {
            return this.handleBindException((BindException)ex, request, response, handler);
        }

        if (ex instanceof NoHandlerFoundException) {
            return this.handleNoHandlerFoundException((NoHandlerFoundException)ex, request, response, handler);
        }

        if (ex instanceof AsyncRequestTimeoutException) {
            return this.handleAsyncRequestTimeoutException((AsyncRequestTimeoutException)ex, request, response, handler);
        }
    } catch (Exception var6) {
        if (this.logger.isWarnEnabled()) {
            this.logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in exception&quot;, var6);
        }
    }

    return null;
}
</code></pre><blockquote>
<p>提示：具体的解析方法很简单，主要是设置response的相关属性。</p>
</blockquote>
<h4 id="没有找到处理器执行方法和request的Method类型不支持异常处理"><a href="#没有找到处理器执行方法和request的Method类型不支持异常处理" class="headerlink" title="没有找到处理器执行方法和request的Method类型不支持异常处理"></a>没有找到处理器执行方法和request的Method类型不支持异常处理</h4><h2 id="16-4-ResponseStatusExceptionResolver"><a href="#16-4-ResponseStatusExceptionResolver" class="headerlink" title="16.4 ResponseStatusExceptionResolver"></a>16.4 ResponseStatusExceptionResolver</h2><p>该解析器用来解析注视了@ResponseStatus的异常。</p>
<pre><code>protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    try {
        if (ex instanceof ResponseStatusException) {
            return this.resolveResponseStatusException((ResponseStatusException)ex, request, response, handler);
        }
        //找到@ResponseStatus注释
        ResponseStatus status = (ResponseStatus)AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);
        if (status != null) {
            //然后调用解析方法
            return this.resolveResponseStatus(status, request, response, handler, ex);
        }

        if (ex.getCause() instanceof Exception) {
            ex = (Exception)ex.getCause();
            return this.doResolveException(request, response, handler, ex);
        }
    } catch (Exception var6) {
        this.logger.warn(&quot;ResponseStatus handling resulted in exception&quot;, var6);
    }

    return null;
}

protected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {
    int statusCode = responseStatus.code().value();
    String reason = responseStatus.reason();
    return this.applyStatusAndReason(statusCode, reason, response);
}
</code></pre><h2 id="16-5-SimpleMappingExceptionResolver"><a href="#16-5-SimpleMappingExceptionResolver" class="headerlink" title="16.5 SimpleMappingExceptionResolver"></a>16.5 SimpleMappingExceptionResolver</h2><p>该解析器需要提前配置异常类和view的对应关系后才能使用。</p>
<pre><code>protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {
    //首先根据异常查找显示错误的逻辑视图
    String viewName = this.determineViewName(ex, request);

    if (viewName != null) {

        //检查是否配置了所找到的viewName对应的statusCode
        Integer statusCode = this.determineStatusCode(request, viewName);

        if (statusCode != null) {

            //设置response
            this.applyStatusCodeIfPossible(request, response, statusCode);
        }
        //将异常和解析出的viewName封装成ModelAndView并返回
        return this.getModelAndView(viewName, ex, request);
    } else {
        return null;
    }
}

@Nullable
protected String determineViewName(Exception ex, HttpServletRequest request) {
    String viewName = null;

    //如果异常在设置的excludeExceptions中包含则返回null
    if (this.excludedExceptions != null) {
        Class[] var4 = this.excludedExceptions;
        int var5 = var4.length;

        for(int var6 = 0; var6 &lt; var5; ++var6) {
            Class&lt;?&gt; excludedEx = var4[var6];
            if (excludedEx.equals(ex.getClass())) {
                return null;
            }
        }
    }

    //调用findMatchingViewName方法实际查找
    if (this.exceptionMappings != null) {
        viewName = this.findMatchingViewName(this.exceptionMappings, ex);
    }

    //如果没有找到viewName且配置了defaultErrorView，则采用默认视图
    if (viewName == null &amp;&amp; this.defaultErrorView != null) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Resolving to default view &apos;&quot; + this.defaultErrorView + &quot;&apos; for exception of type [&quot; + ex.getClass().getName() + &quot;]&quot;);
        }

        viewName = this.defaultErrorView;
    }

    return viewName;
}
</code></pre><blockquote>
<p>提示：这里首先检查异常是不是配置在excludedException中(excludedException用于配置不处理的异常)，如果是则返回null，否则调用findMatchingViewName实际查找viewName，如果没有找到且配置了defaultErrorView，则使用defaultErrorView。findMatchingViewName()方法从传入的参数就可以看出它是根据配置的exceptionMapping参数匹配当前异常的，不过并不是直接完全匹配，而是只要配置异常的字符在当前处理的异常或其父类中存在就可以了。</p>
</blockquote>
<pre><code>protected String findMatchingViewName(Properties exceptionMapping, Exception ex) {
    String viewName = null;
    String dominantMapping = null;
    int deepest = Integer.MAX_VALUE;
    ...
} 
</code></pre><blockquote>
<p>总结：<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a> 会自动将ExceptionHandlerExceptionResolver | DefaultHandlerExceptionResolver | ResponseStatusExceptionResolver配置到SpringMVC中，如果SimpleMappingExceptionResolver使用时需要配置，同时该异常只能处理请求处理过程抛出的异常，异常处理本身抛出的异常和视图解析过程中抛出的异常时不能做到的。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bangjinhu.github.io/undefined/第18章 LocaleResolver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bangjin-Hu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/site.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BangjinHu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/第18章 LocaleResolver/" itemprop="url">AOP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T09:22:26+08:00">
                2019-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-29T09:54:18+08:00">
                2020-03-29
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AOP/" itemprop="url" rel="index">
                    <span itemprop="name">AOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,927
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center"></blockquote>
<div class="note danger"><p>注意：所有文章除特别说明外，转载请注明出处.</p></div>
<h1 id="第18章-LocaleResolver"><a href="#第18章-LocaleResolver" class="headerlink" title="第18章 LocaleResolver"></a>第18章 LocaleResolver</h1><p>LocaleResolver的主要作用在于根据不同的用户区域展示不同的视图，通过设置系统的环境，根据运行环境使用不同的语言显示。用户的区域称为 Locale ，这一信息可以由前端直接获取。通过这一方式可以实现国际化的目的。如：针对美国用户提供一个视图，针对中国用户提供一个视图。而LocaleResolver的使用是实现对用户不同视图的切换。LocaleResolver的作用是使用request解析出Locale。在LocaleResolver的实现类中，AcceptHeaderLocaleResolver直接使用了Header里的acceptlanguage值，不能在程序里面修改。</p>
<h4 id="1-Spring针对LocaleResoler提供几种实现方式"><a href="#1-Spring针对LocaleResoler提供几种实现方式" class="headerlink" title="1.Spring针对LocaleResoler提供几种实现方式"></a>1.Spring针对LocaleResoler提供几种实现方式</h4><pre><code>1.FixedLocaleResolver 在声明该resolver时，需要指定一个默认的Locale，在进行Locale获取时，始终返回该Locale，并且调用其setLocale()方法也无法改变其Locale。

2.SessionLocaleResolver 其会将Locale信息存储在session中，如果用户想要修改Locale信息，可以通过修改session中对应属性的值即可。

3.CookieLocaleResolver 其读取Locale的方式是在session中通过Cookie来获取其指定的Locale的，如果修改了Cookie的值，页面视图也会同步切换。

4.AcceptHeaderLocaleResolver 其会通过用户请求中名称为Accept-Language的header来获取Locale信息，如果想要修改展示的视图，只需要修改该header信息即可。
</code></pre><blockquote>
<p>提示：在Spring4.x之后，LocaleResolver添加子接口 LocaleContextResolver 其中增加了获取和设置LocaleContext 的能力，并添加了抽象类 AbstractLocaleContextResolver，抽象类添加了对TimeZone(时区)的支持。</p>
</blockquote>
<blockquote>
<blockquote>
<p>注意：Spring虽然提供几个不同的获取Locale的方式，但是这些方式除 FixedLocaleResolver 以外，其它也都支持在浏览器地址栏添加Locale参数来切换Locale。而对于Locale的切换，Spring通过拦截器来实现，其提供一个LocaleChangeInterceptor，在该拦截器中的preHandler()方法中，Spring会读取浏览器参数中的locale参数，然后调用LocaleResolver.setLocale()方法实现对Locale的切换。</p>
</blockquote>
</blockquote>
<h3 id="2-LocaleResolver接口声明"><a href="#2-LocaleResolver接口声明" class="headerlink" title="2.LocaleResolver接口声明"></a>2.LocaleResolver接口声明</h3><pre><code>public interface LocaleResolver {
    // 根据request对象根据指定的方式获取一个Locale，如果没有获取到，则使用用户指定的默认的Locale
    Locale resolveLocale(HttpServletRequest request);

    // 用于实现Locale的切换。比如SessionLocaleResolver获取Locale的方式是从session中读取，但如果
    // 用户想要切换其展示的样式(由英文切换为中文)，那么这里的setLocale()方法就提供了这样一种可能
    void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, 
        @Nullable Locale locale);
}
</code></pre><h4 id="2-1-重写-resolveLocale-HttpServletRequest-request-方法"><a href="#2-1-重写-resolveLocale-HttpServletRequest-request-方法" class="headerlink" title="2.1 重写 resolveLocale(HttpServletRequest request)方法"></a>2.1 重写 resolveLocale(HttpServletRequest request)方法</h4><p>这里使用默认的解析器 AcceptHeaderLocaleResolver 继承 LocaleResolver 重写resolverLocale(HttpServletRequest request)方法，通过检查客户端发送请求中的Accept-Language头来确定客户端Locale（地区信息）。</p>
<pre><code>/**
 * 从当前的request中解析Locale
 */
@Override
public Locale resolveLocale(HttpServletRequest request) {
    // 获取默认设置，可在配置AcceptHeaderLocaleResolver Bean中设置defaultLocale属性
    Locale defaultLocale = getDefaultLocale();
    // 设置了默认值并且请求中没有Accept-Language头信息时，使用默认设置
    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) {
        return defaultLocale;
    }
    // 从当前请求中获取Locale
    Locale requestLocale = request.getLocale();
    // 从配置中获取支持的Locale集合，可在AcceptHeaderLocaleResolver Bean中设置supportedLocales属性
    List&lt;Locale&gt; supportedLocales = getSupportedLocales();
    // 未设置supportedLocales或者supportedLocales中包括请求Locale，则使用请求Locale
    if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) {
        return requestLocale;
    }
    // 找到设置的Locale集合中是否有请求的Locale
    Locale supportedLocale = findSupportedLocale(request, supportedLocales);
    if (supportedLocale != null) {
        return supportedLocale;
    }
    return (defaultLocale != null ? defaultLocale : requestLocale);
}

/**
 * 不支持程序设置Locale
 */
@Override
public void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale) {
    throw new UnsupportedOperationException(
            &quot;Cannot change HTTP accept header - use a different locale resolution strategy&quot;);
}
</code></pre><h4 id="2-2-在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver-bean"><a href="#2-2-在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver-bean" class="headerlink" title="2.2 在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver bean"></a>2.2 在SpringMVC配置文件中配置资源加载以及AcceptHeaderLocaleResolver bean</h4><pre><code>&lt;!-- 国际化资源文件 --&gt;
&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;
    &lt;!-- 如果资源文件放在classpath下，basename的value必须有classpath:前缀，否则报错：No message found under code... --&gt;
    &lt;property name=&quot;basename&quot; value=&quot;classpath:i18n/messages&quot; /&gt;
    &lt;!-- 如果在国际化资源文件中找不到对应代码的信息，就用这个代码作为名称返回  --&gt;
    &lt;property name=&quot;useCodeAsDefaultMessage&quot; value=&quot;true&quot; /&gt;
    &lt;!--&lt;property name=&quot;defaultEncoding&quot; value=&quot;ISO-8859-1&quot;/&gt;--&gt;
&lt;/bean&gt;
&lt;!-- LocaleResolver解析器 --&gt;
&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver&quot;&gt;
    &lt;property name=&quot;defaultLocale&quot; value=&quot;zh_CN&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="2-3-属性文件"><a href="#2-3-属性文件" class="headerlink" title="2.3 属性文件"></a>2.3 属性文件</h4><p><strong>2.3.1 messages_en.properties</strong><br></p>
<pre><code>message.locale = en
</code></pre><p><strong>2.3.2 messages_zh_CN.properties</strong><br></p>
<pre><code>message.locale=zh_CN
</code></pre><h4 id="2-4-Controller"><a href="#2-4-Controller" class="headerlink" title="2.4 Controller"></a>2.4 Controller</h4><pre><code>@GetMapping(value = &quot;/acceptHeaderLocaleResolver&quot; , produces = &quot;text/html;charset=UTF-8&quot;)
@ResponseBody
public String test(HttpServletRequest request) {
    String clientLocale = &quot;&quot;;
    Enumeration&lt;Locale&gt; enus =  request.getLocales();
    while (enus.hasMoreElements()){
        Locale locale = enus.nextElement();
        clientLocale += locale + &quot;,&quot;;
    }
    RequestContext requestContext = new RequestContext(request);
    String value = requestContext.getMessage(&quot;message.locale&quot;);
    return &quot;客户端支持的Locale有：&quot;+clientLocale+&quot; &lt;/br&gt;当前使用的Locale是：&quot; + requestContext.getLocale() + &quot; &lt;/br&gt;使用的资源Locale文件是：&quot; + value ;
}
</code></pre><hr>
<h4 id="3-CookieLocaleResolver解析器"><a href="#3-CookieLocaleResolver解析器" class="headerlink" title="3.CookieLocaleResolver解析器"></a>3.CookieLocaleResolver解析器</h4><p>CookieLocaleResolver解析器通过不同的Locale展示不同的视图。CookieLocaleResolver类的入口是：resolveLocaleContext(final HttpServletRequest request); SpringMVC接收到客户端请求之后会调用该方法。</p>
<pre><code>@Override
public LocaleContext resolveLocaleContext(final HttpServletRequest request) {
    // 解析Cookie信息
    parseLocaleCookieIfNecessary(request);
    // 返回Locale和TimeZone
    return new TimeZoneAwareLocaleContext() {
        @Override
        @Nullable
        public Locale getLocale() {
            return (Locale) request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME);
        }
        @Override
        @Nullable
        public TimeZone getTimeZone() {
            return (TimeZone) request.getAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME);
        }
    };
}

private void parseLocaleCookieIfNecessary(HttpServletRequest request) {
    // 第一次请求为null
    if (request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME) == null) {
        Locale locale = null; // 地区
        TimeZone timeZone = null; // 时区

        // 获取cookie的名称，取自Spring MVC配置，默认为：CookieLocaleResolver.DEFAULT_COOKIE_NAME
        String cookieName = getCookieName();
        if (cookieName != null) {
            // 根据名称获取当前请求中的Cookie（第一次访问为null）
            Cookie cookie = WebUtils.getCookie(request, cookieName);
            if (cookie != null) {
                // 以下主要是从客户端Cookie中解析出Locale
                String value = cookie.getValue();
                String localePart = value;
                String timeZonePart = null;
                int spaceIndex = localePart.indexOf(&apos; &apos;);
                if (spaceIndex != -1) {
                    localePart = value.substring(0, spaceIndex);
                    timeZonePart = value.substring(spaceIndex + 1);
                }
                try {
                    locale = (!&quot;-&quot;.equals(localePart) ? parseLocaleValue(localePart) : null);
                    if (timeZonePart != null) {
                        timeZone = StringUtils.parseTimeZoneString(timeZonePart);
                    }
                }
                catch (IllegalArgumentException ex) {
                    if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {
                        // Error dispatch: ignore locale/timezone parse exceptions
                        if (logger.isDebugEnabled()) {
                            logger.debug(&quot;Ignoring invalid locale cookie &apos;&quot; + cookieName +
                                    &quot;&apos; with value [&quot; + value + &quot;] due to error dispatch: &quot; + ex.getMessage());
                        }
                    }
                    else {
                        throw new IllegalStateException(&quot;Invalid locale cookie &apos;&quot; + cookieName +
                                &quot;&apos; with value [&quot; + value + &quot;]: &quot; + ex.getMessage());
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Parsed cookie value [&quot; + cookie.getValue() + &quot;] into locale &apos;&quot; + locale +
                            &quot;&apos;&quot; + (timeZone != null ? &quot; and time zone &apos;&quot; + timeZone.getID() + &quot;&apos;&quot; : &quot;&quot;));
                }
            }
        }
        // 把Locale设置到请求的Attribute区，客户端请求没有携带Cookie，取Spring MVC中配置的defaultLocale
        request.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,
                (locale != null ? locale : determineDefaultLocale(request)));
        request.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,
                (timeZone != null ? timeZone : determineDefaultTimeZone(request)));
    }
}

// 设置Locale
@Override
public void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale) {
    setLocaleContext(request, response, (locale != null ? new SimpleLocaleContext(locale) : null));
}

// 主要是把Locale信息写回客户端
@Override
public void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response,
        @Nullable LocaleContext localeContext) {

    Assert.notNull(response, &quot;HttpServletResponse is required for CookieLocaleResolver&quot;);

    Locale locale = null;
    TimeZone timeZone = null;
    if (localeContext != null) {
        locale = localeContext.getLocale();
        if (localeContext instanceof TimeZoneAwareLocaleContext) {
            timeZone = ((TimeZoneAwareLocaleContext) localeContext).getTimeZone();
        }
        addCookie(response,
                (locale != null ? toLocaleValue(locale) : &quot;-&quot;) + (timeZone != null ? &apos; &apos; + timeZone.getID() : &quot;&quot;));
    }
    else {
        removeCookie(response);
    }
    request.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,
            (locale != null ? locale : determineDefaultLocale(request)));
    request.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,
            (timeZone != null ? timeZone : determineDefaultTimeZone(request)));
}
</code></pre><p><strong>3.1 配置xml文件</strong><br></p>
<pre><code>&lt;context:component-scan base-package=&quot;mvc&quot;/&gt;
&lt;mvc:annotation-driven/&gt;

&lt;mvc:interceptors&gt;
    &lt;!--添加拦截器，用于对Locale的切换--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;/&gt;
    &lt;bean class=&quot;mvc.interceptor.MyHandlerInterceptor&quot;/&gt;
&lt;/mvc:interceptors&gt;

&lt;!--指定ViewResolver是ResourceBundleViewResolver是因为其支持通过不同的Locale进行不同的视图切换--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;/&gt;

&lt;!--指定LocaleResolver为CookieLocaleResolver--&gt;
&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;
    &lt;!--指定defaultlocal是zh_CN--&gt;
    &lt;property name=&quot;defaultLocale&quot; value=&quot;zh_CN&quot;/&gt;
&lt;/bean&gt;
</code></pre><p><strong>3.2 声明接口</strong><br></p>
<pre><code>@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
  @Autowired
  private UserService userService;

  @RequestMapping(value = &quot;/detail&quot;, method = RequestMethod.GET)
  public ModelAndView detail(@RequestParam(&quot;id&quot;) long id, @ModelAttribute(&quot;message&quot;) String message, Locale locale) {
    System.out.println(message);
    ModelAndView view = new ModelAndView(&quot;user&quot;);
    User user = userService.detail(id);
    view.addObject(&quot;user&quot;, user);
    view.addObject(&quot;locale&quot;, locale);
    return view;
  }
}
</code></pre><blockquote>
<p>提示：这里返回的视图是：user 并将Locale信息返回给前端。这里获取Locale数据的方式就只需要简单的声明一个类型为Locale的参数。</p>
</blockquote>
<p><strong>3.3 视图的展示</strong><br><br>由于需要根据不同的Locale展示不同的视图，我们在上面的接口中没有发现这样的路由。在实际中，这个路由是根据ResourceBundleViewResolver类实现的，在使用该ViewResolver时，其会到class路径下查找名称为views的Resource Bundle，同时通过用户指定的Locale，唯一定位到某个 Resource Bundle。 然后在该Resource Bundle 中查找指定的视图信息。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里我们的LocaleResolver的bean名称必须是 localeResolver，并且需要指定的 ViewResolver 辅以支持，否则切换的视图可能无法工作。</p>

          
        
      
    </div>
    
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/site.jpg"
                alt="Bangjin-Hu" />
            
              <p class="site-author-name" itemprop="name">Bangjin-Hu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">242</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BangjinHu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2315378346@qq.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/Aaron_P_L" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/aaron-5-60" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-heart-o"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.avantv.cn" target="_blank" title="AVANTV">
                      
                        <i class="fa fa-fw fa-user"></i>AVANTV</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://iProgramering.github.io" target="_blank" title="iProgramer_ing">
                      
                        <i class="fa fa-fw fa-user"></i>iProgramer_ing</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66

">
    </iframe>
</div>
        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bangjin-Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">465.0k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
